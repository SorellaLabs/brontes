{"expiry":1699581630,"data":[{"SourceCode":"// SPDX-License-Identifier: MIT\r\n// -------------------\r\n// Router Version: 4.1\r\n// -------------------\r\npragma solidity 0.8.13;\r\n\r\n// ERC20 Interface\r\ninterface iERC20 {\r\n    function balanceOf(address) external view returns (uint256);\r\n    function burn(uint) external;\r\n}\r\n// RUNE Interface\r\ninterface iRUNE {\r\n    function transferTo(address, uint) external returns (bool);\r\n}\r\n// ROUTER Interface\r\ninterface iROUTER {\r\n    function depositWithExpiry(address, address, uint, string calldata, uint) external;\r\n}\r\n\r\n// THORChain_Router is managed by THORChain Vaults\r\ncontract THORChain_Router {\r\n    address public RUNE;\r\n\r\n    struct Coin {\r\n        address asset;\r\n        uint amount;\r\n    }\r\n\r\n    // Vault allowance for each asset\r\n    mapping(address => mapping(address => uint)) private _vaultAllowance;\r\n\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n\r\n    // Emitted for all deposits, the memo distinguishes for swap, add, remove, donate etc\r\n    event Deposit(address indexed to, address indexed asset, uint amount, string memo);\r\n\r\n    // Emitted for all outgoing transfers, the vault dictates who sent it, memo used to track.\r\n    event TransferOut(address indexed vault, address indexed to, address asset, uint amount, string memo);\r\n\r\n    // Emitted for all outgoing transferAndCalls, the vault dictates who sent it, memo used to track.\r\n    event TransferOutAndCall(address indexed vault, address target, uint amount, address finalAsset, address to, uint256 amountOutMin, string memo);\r\n\r\n    // Changes the spend allowance between vaults\r\n    event TransferAllowance(address indexed oldVault, address indexed newVault, address asset, uint amount, string memo);\r\n\r\n    // Specifically used to batch send the entire vault assets\r\n    event VaultTransfer(address indexed oldVault, address indexed newVault, Coin[] coins, string memo);\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    constructor(address rune) {\r\n        RUNE = rune;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    // Deposit with Expiry (preferred)\r\n    function depositWithExpiry(address payable vault, address asset, uint amount, string memory memo, uint expiration) external payable {\r\n        require(block.timestamp < expiration, \"THORChain_Router: expired\");\r\n        deposit(vault, asset, amount, memo);\r\n    }\r\n\r\n    // Deposit an asset with a memo. ETH is forwarded, ERC-20 stays in ROUTER\r\n    function deposit(address payable vault, address asset, uint amount, string memory memo) public payable nonReentrant{\r\n        uint safeAmount;\r\n        if(asset == address(0)){\r\n            safeAmount = msg.value;\r\n            bool success = vault.send(safeAmount);\r\n            require(success);\r\n        } else {\r\n            require(msg.value == 0, \"THORChain_Router: unexpected eth\");  // protect user from accidentally locking up eth\r\n            if(asset == RUNE) {\r\n                safeAmount = amount;\r\n                iRUNE(RUNE).transferTo(address(this), amount);\r\n                iERC20(RUNE).burn(amount);\r\n            } else {\r\n                safeAmount = safeTransferFrom(asset, amount); // Transfer asset\r\n                _vaultAllowance[vault][asset] += safeAmount; // Credit to chosen vault\r\n            }\r\n        }\r\n        emit Deposit(vault, asset, safeAmount, memo);\r\n    }\r\n\r\n    //############################## ALLOWANCE TRANSFERS ##############################\r\n\r\n    // Use for \"moving\" assets between vaults (asgard<>ygg), as well \"churning\" to a new Asgard\r\n    function transferAllowance(address router, address newVault, address asset, uint amount, string memory memo) external nonReentrant {\r\n        if (router == address(this)){\r\n            _adjustAllowances(newVault, asset, amount);\r\n            emit TransferAllowance(msg.sender, newVault, asset, amount, memo);\r\n        } else {\r\n            _routerDeposit(router, newVault, asset, amount, memo);\r\n        }\r\n    }\r\n\r\n    //############################## ASSET TRANSFERS ##############################\r\n\r\n    // Any vault calls to transfer any asset to any recipient.\r\n    // Note: Contract recipients of ETH are only given 2300 Gas to complete execution.\r\n    function transferOut(address payable to, address asset, uint amount, string memory memo) public payable nonReentrant {\r\n        uint safeAmount;\r\n        if(asset == address(0)){\r\n            safeAmount = msg.value;\r\n            bool success = to.send(safeAmount); // Send ETH. \r\n            if (!success) {\r\n                payable(address(msg.sender)).transfer(safeAmount); // For failure, bounce back to vault & continue.\r\n            }\r\n        } else {\r\n            _vaultAllowance[msg.sender][asset] -= amount; // Reduce allowance\r\n            (bool success, bytes memory data) = asset.call(abi.encodeWithSignature(\"transfer(address,uint256)\" , to, amount));\r\n            require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n            safeAmount = amount;\r\n        }\r\n        emit TransferOut(msg.sender, to, asset, safeAmount, memo);\r\n    }\r\n\r\n    // Any vault calls to transferAndCall on a target contract that conforms with \"swapOut(address,address,uint256)\"\r\n    // Example Memo: \"~1b3:ETH.0xFinalToken:0xTo:\"\r\n    // Aggregator is matched to the last three digits of whitelisted aggregators\r\n    // FinalToken, To, amountOutMin come from originating memo\r\n    // Memo passed in here is the \"OUT:HASH\" type\r\n    function transferOutAndCall(address payable aggregator, address finalToken, address to, uint256 amountOutMin, string memory memo) public payable nonReentrant {\r\n        uint256 _safeAmount = msg.value;\r\n        (bool erc20Success, ) = aggregator.call{value:_safeAmount}(abi.encodeWithSignature(\"swapOut(address,address,uint256)\", finalToken, to, amountOutMin));\r\n        if (!erc20Success) {\r\n            bool ethSuccess = payable(to).send(_safeAmount); // If can't swap, just send the recipient the ETH\r\n            if (!ethSuccess) {\r\n                payable(address(msg.sender)).transfer(_safeAmount); // For failure, bounce back to vault & continue.\r\n            }\r\n        }\r\n        emit TransferOutAndCall(msg.sender, aggregator, _safeAmount, finalToken, to, amountOutMin, memo);\r\n    }\r\n\r\n\r\n    //############################## VAULT MANAGEMENT ##############################\r\n\r\n    // A vault can call to \"return\" all assets to an asgard, including ETH. \r\n    function returnVaultAssets(address router, address payable asgard, Coin[] memory coins, string memory memo) external payable nonReentrant {\r\n        if (router == address(this)){\r\n            for(uint i = 0; i < coins.length; i++){\r\n                _adjustAllowances(asgard, coins[i].asset, coins[i].amount);\r\n            }\r\n            emit VaultTransfer(msg.sender, asgard, coins, memo); // Does not include ETH.           \r\n        } else {\r\n            for(uint i = 0; i < coins.length; i++){\r\n                _routerDeposit(router, asgard, coins[i].asset, coins[i].amount, memo);\r\n            }\r\n        }\r\n        bool success = asgard.send(msg.value);\r\n        require(success);\r\n    }\r\n\r\n    //############################## HELPERS ##############################\r\n\r\n    function vaultAllowance(address vault, address token) public view returns(uint amount){\r\n        return _vaultAllowance[vault][token];\r\n    }\r\n\r\n    // Safe transferFrom in case asset charges transfer fees\r\n    function safeTransferFrom(address _asset, uint _amount) internal returns(uint amount) {\r\n        uint _startBal = iERC20(_asset).balanceOf(address(this));\r\n        (bool success, bytes memory data) = _asset.call(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), _amount));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n        return (iERC20(_asset).balanceOf(address(this)) - _startBal);\r\n    }\r\n\r\n    // Decrements and Increments Allowances between two vaults\r\n    function _adjustAllowances(address _newVault, address _asset, uint _amount) internal {\r\n        _vaultAllowance[msg.sender][_asset] -= _amount;\r\n        _vaultAllowance[_newVault][_asset] += _amount;\r\n    }\r\n\r\n    // Adjust allowance and forwards funds to new router, credits allowance to desired vault\r\n    function _routerDeposit(address _router, address _vault, address _asset, uint _amount, string memory _memo) internal {\r\n        _vaultAllowance[msg.sender][_asset] -= _amount;\r\n        (bool success,) = _asset.call(abi.encodeWithSignature(\"approve(address,uint256)\", _router, _amount)); // Approve to transfer\r\n        require(success);\r\n        iROUTER(_router).depositWithExpiry(_vault, _asset, _amount, _memo, type(uint).max); // Transfer by depositing\r\n    }\r\n}","ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rune\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldVault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newVault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"}],\"name\":\"TransferAllowance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"}],\"name\":\"TransferOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"finalAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"}],\"name\":\"TransferOutAndCall\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldVault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newVault\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct THORChain_Router.Coin[]\",\"name\":\"coins\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"}],\"name\":\"VaultTransfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"RUNE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"depositWithExpiry\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"asgard\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct THORChain_Router.Coin[]\",\"name\":\"coins\",\"type\":\"tuple[]\"},{\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"}],\"name\":\"returnVaultAssets\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"}],\"name\":\"transferAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"}],\"name\":\"transferOut\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"aggregator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"finalToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"memo\",\"type\":\"string\"}],\"name\":\"transferOutAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"vaultAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"THORChain_Router","CompilerVersion":"v0.8.13+commit.abaa5c0e","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x0000000000000000000000003155ba85d5f96b2d030a4966af206230e46849cb","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":0,"SwarmSource":"ipfs://2cfe991af8d38fa2ac1704297d010d8644417c5713ec84f255506fc12400514d"}]}