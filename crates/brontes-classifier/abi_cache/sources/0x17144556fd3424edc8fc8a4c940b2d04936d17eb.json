{"expiry":1699511920,"data":[{"SourceCode":{"language":"Solidity","sources":{"contracts/common/interfaces/IBurner.sol":{"content":"// SPDX-FileCopyrightText: 2023 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n// See contracts/COMPILERS.md\n// solhint-disable-next-line\npragma solidity >=0.4.24 <0.9.0;\n\ninterface IBurner {\n    /**\n     * Commit cover/non-cover burning requests and logs cover/non-cover shares amount just burnt.\n     *\n     * NB: The real burn enactment to be invoked after the call (via internal Lido._burnShares())\n     */\n    function commitSharesToBurn(uint256 _stETHSharesToBurn) external;\n\n    /**\n     * Request burn shares\n     */\n    function requestBurnShares(address _from, uint256 _sharesAmount) external;\n\n    /**\n      * Returns the current amount of shares locked on the contract to be burnt.\n      */\n    function getSharesRequestedToBurn() external view returns (uint256 coverShares, uint256 nonCoverShares);\n\n    /**\n      * Returns the total cover shares ever burnt.\n      */\n    function getCoverSharesBurnt() external view returns (uint256);\n\n    /**\n      * Returns the total non-cover shares ever burnt.\n      */\n    function getNonCoverSharesBurnt() external view returns (uint256);\n}\n"},"@aragon/os/contracts/common/IVaultRecoverable.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\ninterface IVaultRecoverable {\n    event RecoverToVault(address indexed vault, address indexed token, uint256 amount);\n\n    function transferToVault(address token) external;\n\n    function allowRecoverability(address token) external view returns (bool);\n    function getRecoveryVault() external view returns (address);\n}\n"},"@aragon/os/contracts/common/EtherTokenConstant.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\n// aragonOS and aragon-apps rely on address(0) to denote native ETH, in\n// contracts where both tokens and ETH are accepted\ncontract EtherTokenConstant {\n    address internal constant ETH = address(0);\n}\n"},"@aragon/os/contracts/common/SafeERC20.sol":{"content":"// Inspired by AdEx (https://github.com/AdExNetwork/adex-protocol-eth/blob/b9df617829661a7518ee10f4cb6c4108659dd6d5/contracts/libs/SafeERC20.sol)\n// and 0x (https://github.com/0xProject/0x-monorepo/blob/737d1dc54d72872e24abce5a1dbe1b66d35fa21a/contracts/protocol/contracts/protocol/AssetProxy/ERC20Proxy.sol#L143)\n\npragma solidity ^0.4.24;\n\nimport \"../lib/token/ERC20.sol\";\n\n\nlibrary SafeERC20 {\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\n    // https://github.com/ethereum/solidity/issues/3544\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\n\n    string private constant ERROR_TOKEN_BALANCE_REVERTED = \"SAFE_ERC_20_BALANCE_REVERTED\";\n    string private constant ERROR_TOKEN_ALLOWANCE_REVERTED = \"SAFE_ERC_20_ALLOWANCE_REVERTED\";\n\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\n        private\n        returns (bool)\n    {\n        bool ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            let success := call(\n                gas,                  // forward all gas\n                _addr,                // address\n                0,                    // no value\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                // Check number of bytes returned from last function call\n                switch returndatasize\n\n                // No bytes returned: assume success\n                case 0 {\n                    ret := 1\n                }\n\n                // 32 bytes returned: check if non-zero\n                case 0x20 {\n                    // Only return success if returned data was true\n                    // Already have output in ptr\n                    ret := eq(mload(ptr), 1)\n                }\n\n                // Not sure what was returned: don't mark as success\n                default { }\n            }\n        }\n        return ret;\n    }\n\n    function staticInvoke(address _addr, bytes memory _calldata)\n        private\n        view\n        returns (bool, uint256)\n    {\n        bool success;\n        uint256 ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            success := staticcall(\n                gas,                  // forward all gas\n                _addr,                // address\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                ret := mload(ptr)\n            }\n        }\n        return (success, ret);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferCallData = abi.encodeWithSelector(\n            TRANSFER_SELECTOR,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferFromCallData = abi.encodeWithSelector(\n            _token.transferFrom.selector,\n            _from,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferFromCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\n        bytes memory approveCallData = abi.encodeWithSelector(\n            _token.approve.selector,\n            _spender,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, approveCallData);\n    }\n\n    /**\n    * @dev Static call into ERC20.balanceOf().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticBalanceOf(ERC20 _token, address _owner) internal view returns (uint256) {\n        bytes memory balanceOfCallData = abi.encodeWithSelector(\n            _token.balanceOf.selector,\n            _owner\n        );\n\n        (bool success, uint256 tokenBalance) = staticInvoke(_token, balanceOfCallData);\n        require(success, ERROR_TOKEN_BALANCE_REVERTED);\n\n        return tokenBalance;\n    }\n\n    /**\n    * @dev Static call into ERC20.allowance().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticAllowance(ERC20 _token, address _owner, address _spender) internal view returns (uint256) {\n        bytes memory allowanceCallData = abi.encodeWithSelector(\n            _token.allowance.selector,\n            _owner,\n            _spender\n        );\n\n        (bool success, uint256 allowance) = staticInvoke(_token, allowanceCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return allowance;\n    }\n\n    /**\n    * @dev Static call into ERC20.totalSupply().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticTotalSupply(ERC20 _token) internal view returns (uint256) {\n        bytes memory totalSupplyCallData = abi.encodeWithSelector(_token.totalSupply.selector);\n\n        (bool success, uint256 totalSupply) = staticInvoke(_token, totalSupplyCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return totalSupply;\n    }\n}\n"},"@aragon/os/contracts/common/UnstructuredStorage.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\nlibrary UnstructuredStorage {\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\n        assembly { data := sload(position) }\n    }\n\n    function setStorageBool(bytes32 position, bool data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageAddress(bytes32 position, address data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageUint256(bytes32 position, uint256 data) internal {\n        assembly { sstore(position, data) }\n    }\n}\n"},"contracts/0.4.24/utils/Pausable.sol":{"content":"// SPDX-FileCopyrightText: 2023 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.4.24;\n\nimport \"@aragon/os/contracts/common/UnstructuredStorage.sol\";\n\n\ncontract Pausable {\n    using UnstructuredStorage for bytes32;\n\n    event Stopped();\n    event Resumed();\n\n    // keccak256(\"lido.Pausable.activeFlag\")\n    bytes32 internal constant ACTIVE_FLAG_POSITION =\n        0x644132c4ddd5bb6f0655d5fe2870dcec7870e6be4758890f366b83441f9fdece;\n\n    function _whenNotStopped() internal view {\n        require(ACTIVE_FLAG_POSITION.getStorageBool(), \"CONTRACT_IS_STOPPED\");\n    }\n\n    function _whenStopped() internal view {\n        require(!ACTIVE_FLAG_POSITION.getStorageBool(), \"CONTRACT_IS_ACTIVE\");\n    }\n\n    function isStopped() public view returns (bool) {\n        return !ACTIVE_FLAG_POSITION.getStorageBool();\n    }\n\n    function _stop() internal {\n        _whenNotStopped();\n\n        ACTIVE_FLAG_POSITION.setStorageBool(false);\n        emit Stopped();\n    }\n\n    function _resume() internal {\n        _whenStopped();\n\n        ACTIVE_FLAG_POSITION.setStorageBool(true);\n        emit Resumed();\n    }\n}\n"},"@aragon/os/contracts/common/VaultRecoverable.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"../lib/token/ERC20.sol\";\nimport \"./EtherTokenConstant.sol\";\nimport \"./IsContract.sol\";\nimport \"./IVaultRecoverable.sol\";\nimport \"./SafeERC20.sol\";\n\n\ncontract VaultRecoverable is IVaultRecoverable, EtherTokenConstant, IsContract {\n    using SafeERC20 for ERC20;\n\n    string private constant ERROR_DISALLOWED = \"RECOVER_DISALLOWED\";\n    string private constant ERROR_VAULT_NOT_CONTRACT = \"RECOVER_VAULT_NOT_CONTRACT\";\n    string private constant ERROR_TOKEN_TRANSFER_FAILED = \"RECOVER_TOKEN_TRANSFER_FAILED\";\n\n    /**\n     * @notice Send funds to recovery Vault. This contract should never receive funds,\n     *         but in case it does, this function allows one to recover them.\n     * @param _token Token balance to be sent to recovery vault.\n     */\n    function transferToVault(address _token) external {\n        require(allowRecoverability(_token), ERROR_DISALLOWED);\n        address vault = getRecoveryVault();\n        require(isContract(vault), ERROR_VAULT_NOT_CONTRACT);\n\n        uint256 balance;\n        if (_token == ETH) {\n            balance = address(this).balance;\n            vault.transfer(balance);\n        } else {\n            ERC20 token = ERC20(_token);\n            balance = token.staticBalanceOf(this);\n            require(token.safeTransfer(vault, balance), ERROR_TOKEN_TRANSFER_FAILED);\n        }\n\n        emit RecoverToVault(vault, _token, balance);\n    }\n\n    /**\n    * @dev By default deriving from AragonApp makes it recoverable\n    * @param token Token address that would be recovered\n    * @return bool whether the app allows the recovery\n    */\n    function allowRecoverability(address token) public view returns (bool) {\n        return true;\n    }\n\n    // Cast non-implemented interface to be public so we can use it internally\n    function getRecoveryVault() public view returns (address);\n}\n"},"@aragon/os/contracts/acl/ACLSyntaxSugar.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\ncontract ACLSyntaxSugar {\n    function arr() internal pure returns (uint256[]) {\n        return new uint256[](0);\n    }\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c, _d);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}\n\n\ncontract ACLHelpers {\n    function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 30));\n    }\n\n    function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 31));\n    }\n\n    function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\n        a = uint32(_x);\n        b = uint32(_x >> (8 * 4));\n        c = uint32(_x >> (8 * 8));\n    }\n}\n"},"@aragon/os/contracts/common/IsContract.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\ncontract IsContract {\n    /*\n    * NOTE: this should NEVER be used for authentication\n    * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\n    *\n    * This is only intended to be used as a sanity check that an address is actually a contract,\n    * RATHER THAN an address not being a contract.\n    */\n    function isContract(address _target) internal view returns (bool) {\n        if (_target == address(0)) {\n            return false;\n        }\n\n        uint256 size;\n        assembly { size := extcodesize(_target) }\n        return size > 0;\n    }\n}\n"},"contracts/common/lib/SignatureUtils.sol":{"content":"// SPDX-FileCopyrightText: 2023 Lido <info@lido.fi>\n// SPDX-License-Identifier: MIT\n\n/* See contracts/COMPILERS.md */\n// solhint-disable-next-line lido/fixed-compiler-version\npragma solidity >=0.4.24 <0.9.0;\n\nimport {ECDSA} from \"./ECDSA.sol\";\n\n\nlibrary SignatureUtils {\n    /**\n     * @dev The selector of the ERC1271's `isValidSignature(bytes32 hash, bytes signature)` function,\n     * serving at the same time as the magic value that the function should return upon success.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-1271.\n     *\n     * bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n     */\n    bytes4 internal constant ERC1271_IS_VALID_SIGNATURE_SELECTOR = 0x1626ba7e;\n\n    /**\n     * @dev Checks signature validity.\n     *\n     * If the signer address doesn't contain any code, assumes that the address is externally owned\n     * and the signature is a ECDSA signature generated using its private key. Otherwise, issues a\n     * static call to the signer address to check the signature validity using the ERC-1271 standard.\n     */\n    function isValidSignature(\n        address signer,\n        bytes32 msgHash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (bool) {\n        if (_hasCode(signer)) {\n            bytes memory sig = abi.encodePacked(r, s, v);\n            // Solidity <0.5 generates a regular CALL instruction even if the function being called\n            // is marked as `view`, and the only way to perform a STATICCALL is to use assembly\n            bytes memory data = abi.encodeWithSelector(ERC1271_IS_VALID_SIGNATURE_SELECTOR, msgHash, sig);\n            bytes32 retval;\n            /// @solidity memory-safe-assembly\n            assembly {\n                // allocate memory for storing the return value\n                let outDataOffset := mload(0x40)\n                mstore(0x40, add(outDataOffset, 32))\n                // issue a static call and load the result if the call succeeded\n                let success := staticcall(gas(), signer, add(data, 32), mload(data), outDataOffset, 32)\n                if and(eq(success, 1), eq(returndatasize(), 32)) {\n                    retval := mload(outDataOffset)\n                }\n            }\n            return retval == bytes32(ERC1271_IS_VALID_SIGNATURE_SELECTOR);\n        } else {\n            return ECDSA.recover(msgHash, v, r, s) == signer;\n        }\n    }\n\n    function _hasCode(address addr) internal view returns (bool) {\n        uint256 size;\n        /// @solidity memory-safe-assembly\n        assembly { size := extcodesize(addr) }\n        return size > 0;\n    }\n}\n"},"@aragon/os/contracts/lib/math/SafeMath.sol":{"content":"// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/d51e38758e1d985661534534d5c61e27bece5042/contracts/math/SafeMath.sol\n// Adapted to use pragma ^0.4.24 and satisfy our linter rules\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    string private constant ERROR_ADD_OVERFLOW = \"MATH_ADD_OVERFLOW\";\n    string private constant ERROR_SUB_UNDERFLOW = \"MATH_SUB_UNDERFLOW\";\n    string private constant ERROR_MUL_OVERFLOW = \"MATH_MUL_OVERFLOW\";\n    string private constant ERROR_DIV_ZERO = \"MATH_DIV_ZERO\";\n\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n\n        uint256 c = _a * _b;\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\n        uint256 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\n        uint256 c = _a - _b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two numbers, reverts on overflow.\n    */\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        uint256 c = _a + _b;\n        require(c >= _a, ERROR_ADD_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, ERROR_DIV_ZERO);\n        return a % b;\n    }\n}\n"},"@aragon/os/contracts/evmscript/IEVMScriptExecutor.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\ninterface IEVMScriptExecutor {\n    function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);\n    function executorType() external pure returns (bytes32);\n}\n"},"@aragon/os/contracts/evmscript/IEVMScriptRegistry.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"./IEVMScriptExecutor.sol\";\n\n\ncontract EVMScriptRegistryConstants {\n    /* Hardcoded constants to save gas\n    bytes32 internal constant EVMSCRIPT_REGISTRY_APP_ID = apmNamehash(\"evmreg\");\n    */\n    bytes32 internal constant EVMSCRIPT_REGISTRY_APP_ID = 0xddbcfd564f642ab5627cf68b9b7d374fb4f8a36e941a75d89c87998cef03bd61;\n}\n\n\ninterface IEVMScriptRegistry {\n    function addScriptExecutor(IEVMScriptExecutor executor) external returns (uint id);\n    function disableScriptExecutor(uint256 executorId) external;\n\n    // TODO: this should be external\n    // See https://github.com/ethereum/solidity/issues/4832\n    function getScriptExecutor(bytes script) public view returns (IEVMScriptExecutor);\n}\n"},"contracts/common/interfaces/ILidoLocator.sol":{"content":"// SPDX-FileCopyrightText: 2023 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n// See contracts/COMPILERS.md\n// solhint-disable-next-line\npragma solidity >=0.4.24 <0.9.0;\n\ninterface ILidoLocator {\n    function accountingOracle() external view returns(address);\n    function depositSecurityModule() external view returns(address);\n    function elRewardsVault() external view returns(address);\n    function legacyOracle() external view returns(address);\n    function lido() external view returns(address);\n    function oracleReportSanityChecker() external view returns(address);\n    function burner() external view returns(address);\n    function stakingRouter() external view returns(address);\n    function treasury() external view returns(address);\n    function validatorsExitBusOracle() external view returns(address);\n    function withdrawalQueue() external view returns(address);\n    function withdrawalVault() external view returns(address);\n    function postTokenRebaseReceiver() external view returns(address);\n    function oracleDaemonConfig() external view returns(address);\n    function coreComponents() external view returns(\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address stakingRouter,\n        address treasury,\n        address withdrawalQueue,\n        address withdrawalVault\n    );\n    function oracleReportComponentsForLido() external view returns(\n        address accountingOracle,\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address burner,\n        address withdrawalQueue,\n        address withdrawalVault,\n        address postTokenRebaseReceiver\n    );\n}\n"},"contracts/common/lib/Math256.sol":{"content":"// SPDX-FileCopyrightText: 2023 Lido <info@lido.fi>\n// SPDX-License-Identifier: MIT\n\n// Copied from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/0457042d93d9dfd760dbaa06a4d2f1216fdbe297/contracts/utils/math/Math.sol\n\n// See contracts/COMPILERS.md\n// solhint-disable-next-line\npragma solidity >=0.4.24 <0.9.0;\n\nlibrary Math256 {\n    /// @dev Returns the largest of two numbers.\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /// @dev Returns the smallest of two numbers.\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /// @dev Returns the largest of two numbers.\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /// @dev Returns the smallest of two numbers.\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /// @dev Returns the ceiling of the division of two numbers.\n    ///\n    /// This differs from standard division with `/` in that it rounds up instead\n    /// of rounding down.\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /// @dev Returns absolute difference of two numbers.\n    function absDiff(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n}\n"},"@aragon/os/contracts/apps/AppStorage.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"../common/UnstructuredStorage.sol\";\nimport \"../kernel/IKernel.sol\";\n\n\ncontract AppStorage {\n    using UnstructuredStorage for bytes32;\n\n    /* Hardcoded constants to save gas\n    bytes32 internal constant KERNEL_POSITION = keccak256(\"aragonOS.appStorage.kernel\");\n    bytes32 internal constant APP_ID_POSITION = keccak256(\"aragonOS.appStorage.appId\");\n    */\n    bytes32 internal constant KERNEL_POSITION = 0x4172f0f7d2289153072b0a6ca36959e0cbe2efc3afe50fc81636caa96338137b;\n    bytes32 internal constant APP_ID_POSITION = 0xd625496217aa6a3453eecb9c3489dc5a53e6c67b444329ea2b2cbc9ff547639b;\n\n    function kernel() public view returns (IKernel) {\n        return IKernel(KERNEL_POSITION.getStorageAddress());\n    }\n\n    function appId() public view returns (bytes32) {\n        return APP_ID_POSITION.getStorageBytes32();\n    }\n\n    function setKernel(IKernel _kernel) internal {\n        KERNEL_POSITION.setStorageAddress(address(_kernel));\n    }\n\n    function setAppId(bytes32 _appId) internal {\n        APP_ID_POSITION.setStorageBytes32(_appId);\n    }\n}\n"},"contracts/0.4.24/StETH.sol":{"content":"// SPDX-FileCopyrightText: 2023 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n/* See contracts/COMPILERS.md */\npragma solidity 0.4.24;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\";\nimport \"@aragon/os/contracts/common/UnstructuredStorage.sol\";\nimport \"@aragon/os/contracts/lib/math/SafeMath.sol\";\nimport \"./utils/Pausable.sol\";\n\n/**\n * @title Interest-bearing ERC20-like token for Lido Liquid Stacking protocol.\n *\n * This contract is abstract. To make the contract deployable override the\n * `_getTotalPooledEther` function. `Lido.sol` contract inherits StETH and defines\n * the `_getTotalPooledEther` function.\n *\n * StETH balances are dynamic and represent the holder's share in the total amount\n * of Ether controlled by the protocol. Account shares aren't normalized, so the\n * contract also stores the sum of all shares to calculate each account's token balance\n * which equals to:\n *\n *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n *\n * For example, assume that we have:\n *\n *   _getTotalPooledEther() -> 10 ETH\n *   sharesOf(user1) -> 100\n *   sharesOf(user2) -> 400\n *\n * Therefore:\n *\n *   balanceOf(user1) -> 2 tokens which corresponds 2 ETH\n *   balanceOf(user2) -> 8 tokens which corresponds 8 ETH\n *\n * Since balances of all token holders change when the amount of total pooled Ether\n * changes, this token cannot fully implement ERC20 standard: it only emits `Transfer`\n * events upon explicit transfer between holders. In contrast, when total amount of\n * pooled Ether increases, no `Transfer` events are generated: doing so would require\n * emitting an event for each token holder and thus running an unbounded loop.\n *\n * The token inherits from `Pausable` and uses `whenNotStopped` modifier for methods\n * which change `shares` or `allowances`. `_stop` and `_resume` functions are overridden\n * in `Lido.sol` and might be called by an account with the `PAUSE_ROLE` assigned by the\n * DAO. This is useful for emergency scenarios, e.g. a protocol bug, where one might want\n * to freeze all token transfers and approvals until the emergency is resolved.\n */\ncontract StETH is IERC20, Pausable {\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren't\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account's token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it's non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256(\"lido.StETH.totalShares\")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return \"Liquid staked Ether 2.0\";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return \"stETH\";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller's account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller's tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller's\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, \"ALLOWANCE_BELOW_ZERO\");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account's relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller's account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), \"APPROVE_FROM_ZERO_ADDR\");\n        require(_spender != address(0), \"APPROVE_TO_ZERO_ADDR\");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, \"ALLOWANCE_EXCEEDED\");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), \"TRANSFER_FROM_ZERO_ADDR\");\n        require(_recipient != address(0), \"TRANSFER_TO_ZERO_ADDR\");\n        require(_recipient != address(this), \"TRANSFER_TO_STETH_CONTRACT\");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, \"BALANCE_EXCEEDED\");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn't increase the token total supply.\n     *\n     * NB: The method doesn't check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), \"MINT_TO_ZERO_ADDR\");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we're not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn't change\n        // as the result. This is equivalent to performing a send from each other token holder's\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`'s holdings, decreasing the total amount of shares.\n     * @dev This doesn't decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), \"BURN_FROM_ZERO_ADDR\");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, \"BALANCE_EXCEEDED\");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we're not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn't change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We're emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}\n"},"@aragon/os/contracts/common/Uint256Helpers.sol":{"content":"pragma solidity ^0.4.24;\n\n\nlibrary Uint256Helpers {\n    uint256 private constant MAX_UINT64 = uint64(-1);\n\n    string private constant ERROR_NUMBER_TOO_BIG = \"UINT64_NUMBER_TOO_BIG\";\n\n    function toUint64(uint256 a) internal pure returns (uint64) {\n        require(a <= MAX_UINT64, ERROR_NUMBER_TOO_BIG);\n        return uint64(a);\n    }\n}\n"},"@aragon/os/contracts/common/Petrifiable.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"./Initializable.sol\";\n\n\ncontract Petrifiable is Initializable {\n    // Use block UINT256_MAX (which should be never) as the initializable date\n    uint256 internal constant PETRIFIED_BLOCK = uint256(-1);\n\n    function isPetrified() public view returns (bool) {\n        return getInitializationBlock() == PETRIFIED_BLOCK;\n    }\n\n    /**\n    * @dev Function to be called by top level contract to prevent being initialized.\n    *      Useful for freezing base contracts when they're used behind proxies.\n    */\n    function petrify() internal onlyInit {\n        initializedAt(PETRIFIED_BLOCK);\n    }\n}\n"},"contracts/common/interfaces/IEIP712StETH.sol":{"content":"// SPDX-FileCopyrightText: 2023 OpenZeppelin, Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n// See contracts/COMPILERS.md\n// solhint-disable-next-line\npragma solidity >=0.4.24 <0.9.0;\n\n/**\n * @dev Helper interface of EIP712 StETH-dedicated helper.\n *\n * Has an access to the CHAIN_ID opcode and relies on immutables internally\n * Both are unavailable for Solidity 0.4.24.\n */\ninterface IEIP712StETH {\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function domainSeparatorV4(address _stETH) external view returns (bytes32);\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function hashTypedDataV4(address _stETH, bytes32 _structHash) external view returns (bytes32);\n\n    /**\n     * @dev returns the fields and values that describe the domain separator\n     * used by stETH for EIP-712 signature.\n     */\n    function eip712Domain(address _stETH) external view returns (\n        string memory name,\n        string memory version,\n        uint256 chainId,\n        address verifyingContract\n    );\n}\n"},"@aragon/os/contracts/common/ReentrancyGuard.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"../common/UnstructuredStorage.sol\";\n\n\ncontract ReentrancyGuard {\n    using UnstructuredStorage for bytes32;\n\n    /* Hardcoded constants to save gas\n    bytes32 internal constant REENTRANCY_MUTEX_POSITION = keccak256(\"aragonOS.reentrancyGuard.mutex\");\n    */\n    bytes32 private constant REENTRANCY_MUTEX_POSITION = 0xe855346402235fdd185c890e68d2c4ecad599b88587635ee285bce2fda58dacb;\n\n    string private constant ERROR_REENTRANT = \"REENTRANCY_REENTRANT_CALL\";\n\n    modifier nonReentrant() {\n        // Ensure mutex is unlocked\n        require(!REENTRANCY_MUTEX_POSITION.getStorageBool(), ERROR_REENTRANT);\n\n        // Lock mutex before function call\n        REENTRANCY_MUTEX_POSITION.setStorageBool(true);\n\n        // Perform function call\n        _;\n\n        // Unlock mutex after function call\n        REENTRANCY_MUTEX_POSITION.setStorageBool(false);\n    }\n}\n"},"@aragon/os/contracts/common/TimeHelpers.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"./Uint256Helpers.sol\";\n\n\ncontract TimeHelpers {\n    using Uint256Helpers for uint256;\n\n    /**\n    * @dev Returns the current block number.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n    * @dev Returns the current block number, converted to uint64.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber64() internal view returns (uint64) {\n        return getBlockNumber().toUint64();\n    }\n\n    /**\n    * @dev Returns the current timestamp.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp() internal view returns (uint256) {\n        return block.timestamp; // solium-disable-line security/no-block-members\n    }\n\n    /**\n    * @dev Returns the current timestamp, converted to uint64.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp64() internal view returns (uint64) {\n        return getTimestamp().toUint64();\n    }\n}\n"},"contracts/0.4.24/lib/StakeLimitUtils.sol":{"content":"// SPDX-FileCopyrightText: 2023 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n/* See contracts/COMPILERS.md */\npragma solidity 0.4.24;\n\nimport \"@aragon/os/contracts/common/UnstructuredStorage.sol\";\n\n//\n// We need to pack four variables into the same 256bit-wide storage slot\n// to lower the costs per each staking request.\n//\n// As a result, slot's memory aligned as follows:\n//\n// MSB ------------------------------------------------------------------------------> LSB\n// 256____________160_________________________128_______________32_____________________ 0\n// |_______________|___________________________|________________|_______________________|\n// | maxStakeLimit | maxStakeLimitGrowthBlocks | prevStakeLimit | prevStakeBlockNumber  |\n// |<-- 96 bits -->|<---------- 32 bits ------>|<-- 96 bits --->|<----- 32 bits ------->|\n//\n//\n// NB: Internal representation conventions:\n//\n// - the `maxStakeLimitGrowthBlocks` field above represented as follows:\n// `maxStakeLimitGrowthBlocks` = `maxStakeLimit` / `stakeLimitIncreasePerBlock`\n//           32 bits                 96 bits               96 bits\n//\n//\n// - the \"staking paused\" state is encoded by `prevStakeBlockNumber` being zero,\n// - the \"staking unlimited\" state is encoded by `maxStakeLimit` being zero and `prevStakeBlockNumber` being non-zero.\n//\n\n/**\n* @notice Library for the internal structs definitions\n* @dev solidity <0.6 doesn't support top-level structs\n* using the library to have a proper namespace\n*/\nlibrary StakeLimitState {\n    /**\n      * @dev Internal representation struct (slot-wide)\n      */\n    struct Data {\n        uint32 prevStakeBlockNumber;      // block number of the previous stake submit\n        uint96 prevStakeLimit;            // limit value (<= `maxStakeLimit`) obtained on the previous stake submit\n        uint32 maxStakeLimitGrowthBlocks; // limit regeneration speed expressed in blocks\n        uint96 maxStakeLimit;             // maximum limit value\n    }\n}\n\nlibrary StakeLimitUnstructuredStorage {\n    using UnstructuredStorage for bytes32;\n\n    /// @dev Storage offset for `maxStakeLimit` (bits)\n    uint256 internal constant MAX_STAKE_LIMIT_OFFSET = 160;\n    /// @dev Storage offset for `maxStakeLimitGrowthBlocks` (bits)\n    uint256 internal constant MAX_STAKE_LIMIT_GROWTH_BLOCKS_OFFSET = 128;\n    /// @dev Storage offset for `prevStakeLimit` (bits)\n    uint256 internal constant PREV_STAKE_LIMIT_OFFSET = 32;\n    /// @dev Storage offset for `prevStakeBlockNumber` (bits)\n    uint256 internal constant PREV_STAKE_BLOCK_NUMBER_OFFSET = 0;\n\n    /**\n    * @dev Read stake limit state from the unstructured storage position\n    * @param _position storage offset\n    */\n    function getStorageStakeLimitStruct(bytes32 _position) internal view returns (StakeLimitState.Data memory stakeLimit) {\n        uint256 slotValue = _position.getStorageUint256();\n\n        stakeLimit.prevStakeBlockNumber = uint32(slotValue >> PREV_STAKE_BLOCK_NUMBER_OFFSET);\n        stakeLimit.prevStakeLimit = uint96(slotValue >> PREV_STAKE_LIMIT_OFFSET);\n        stakeLimit.maxStakeLimitGrowthBlocks = uint32(slotValue >> MAX_STAKE_LIMIT_GROWTH_BLOCKS_OFFSET);\n        stakeLimit.maxStakeLimit = uint96(slotValue >> MAX_STAKE_LIMIT_OFFSET);\n    }\n\n     /**\n    * @dev Write stake limit state to the unstructured storage position\n    * @param _position storage offset\n    * @param _data stake limit state structure instance\n    */\n    function setStorageStakeLimitStruct(bytes32 _position, StakeLimitState.Data memory _data) internal {\n        _position.setStorageUint256(\n            uint256(_data.prevStakeBlockNumber) << PREV_STAKE_BLOCK_NUMBER_OFFSET\n                | uint256(_data.prevStakeLimit) << PREV_STAKE_LIMIT_OFFSET\n                | uint256(_data.maxStakeLimitGrowthBlocks) << MAX_STAKE_LIMIT_GROWTH_BLOCKS_OFFSET\n                | uint256(_data.maxStakeLimit) << MAX_STAKE_LIMIT_OFFSET\n        );\n    }\n}\n\n/**\n* @notice Interface library with helper functions to deal with stake limit struct in a more high-level approach.\n*/\nlibrary StakeLimitUtils {\n    /**\n    * @notice Calculate stake limit for the current block.\n    * @dev using `_constGasMin` to make gas consumption independent of the current block number\n    */\n    function calculateCurrentStakeLimit(StakeLimitState.Data memory _data) internal view returns(uint256 limit) {\n        uint256 stakeLimitIncPerBlock;\n        if (_data.maxStakeLimitGrowthBlocks != 0) {\n            stakeLimitIncPerBlock = _data.maxStakeLimit / _data.maxStakeLimitGrowthBlocks;\n        }\n\n        uint256 blocksPassed = block.number - _data.prevStakeBlockNumber;\n        uint256 projectedLimit = _data.prevStakeLimit + blocksPassed * stakeLimitIncPerBlock;\n\n        limit = _constGasMin(\n            projectedLimit,\n            _data.maxStakeLimit\n        );\n    }\n\n    /**\n    * @notice check if staking is on pause\n    */\n    function isStakingPaused(StakeLimitState.Data memory _data) internal pure returns(bool) {\n        return _data.prevStakeBlockNumber == 0;\n    }\n\n    /**\n    * @notice check if staking limit is set (otherwise staking is unlimited)\n    */\n    function isStakingLimitSet(StakeLimitState.Data memory _data) internal pure returns(bool) {\n        return _data.maxStakeLimit != 0;\n    }\n\n    /**\n    * @notice update stake limit repr with the desired limits\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _maxStakeLimit stake limit max value\n    * @param _stakeLimitIncreasePerBlock stake limit increase (restoration) per block\n    */\n    function setStakingLimit(\n        StakeLimitState.Data memory _data,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) internal view returns (StakeLimitState.Data memory) {\n        require(_maxStakeLimit != 0, \"ZERO_MAX_STAKE_LIMIT\");\n        require(_maxStakeLimit <= uint96(-1), \"TOO_LARGE_MAX_STAKE_LIMIT\");\n        require(_maxStakeLimit >= _stakeLimitIncreasePerBlock, \"TOO_LARGE_LIMIT_INCREASE\");\n        require(\n            (_stakeLimitIncreasePerBlock == 0)\n            || (_maxStakeLimit / _stakeLimitIncreasePerBlock <= uint32(-1)),\n            \"TOO_SMALL_LIMIT_INCREASE\"\n        );\n\n        // reset prev stake limit to the new max stake limit if\n        if (\n            // staking was paused or\n            _data.prevStakeBlockNumber == 0 ||\n            // staking was unlimited or\n            _data.maxStakeLimit == 0 ||\n            // new maximum limit value is lower than the value obtained on the previous stake submit\n            _maxStakeLimit < _data.prevStakeLimit\n        ) {\n            _data.prevStakeLimit = uint96(_maxStakeLimit);\n        }\n        _data.maxStakeLimitGrowthBlocks =\n            _stakeLimitIncreasePerBlock != 0 ? uint32(_maxStakeLimit / _stakeLimitIncreasePerBlock) : 0;\n\n        _data.maxStakeLimit = uint96(_maxStakeLimit);\n\n        if (_data.prevStakeBlockNumber != 0) {\n            _data.prevStakeBlockNumber = uint32(block.number);\n        }\n\n        return _data;\n    }\n\n    /**\n    * @notice update stake limit repr to remove the limit\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    */\n    function removeStakingLimit(\n        StakeLimitState.Data memory _data\n    ) internal pure returns (StakeLimitState.Data memory) {\n        _data.maxStakeLimit = 0;\n\n        return _data;\n    }\n\n    /**\n    * @notice update stake limit repr after submitting user's eth\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _newPrevStakeLimit new value for the `prevStakeLimit` field\n    */\n    function updatePrevStakeLimit(\n        StakeLimitState.Data memory _data,\n        uint256 _newPrevStakeLimit\n    ) internal view returns (StakeLimitState.Data memory) {\n        assert(_newPrevStakeLimit <= uint96(-1));\n        assert(_data.prevStakeBlockNumber != 0);\n\n        _data.prevStakeLimit = uint96(_newPrevStakeLimit);\n        _data.prevStakeBlockNumber = uint32(block.number);\n\n        return _data;\n    }\n\n    /**\n    * @notice set stake limit pause state (on or off)\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _isPaused pause state flag\n    */\n    function setStakeLimitPauseState(\n        StakeLimitState.Data memory _data,\n        bool _isPaused\n    ) internal view returns (StakeLimitState.Data memory) {\n        _data.prevStakeBlockNumber = uint32(_isPaused ? 0 : block.number);\n\n        return _data;\n    }\n\n    /**\n     * @notice find a minimum of two numbers with a constant gas consumption\n     * @dev doesn't use branching logic inside\n     * @param _lhs left hand side value\n     * @param _rhs right hand side value\n     */\n    function _constGasMin(uint256 _lhs, uint256 _rhs) internal pure returns (uint256 min) {\n        uint256 lhsIsLess;\n        assembly {\n            lhsIsLess := lt(_lhs, _rhs) // lhsIsLess = (_lhs < _rhs) ? 1 : 0\n        }\n        min = (_lhs * lhsIsLess) + (_rhs * (1 - lhsIsLess));\n    }\n}\n"},"@aragon/os/contracts/evmscript/EVMScriptRunner.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"./IEVMScriptExecutor.sol\";\nimport \"./IEVMScriptRegistry.sol\";\n\nimport \"../apps/AppStorage.sol\";\nimport \"../kernel/KernelConstants.sol\";\nimport \"../common/Initializable.sol\";\n\n\ncontract EVMScriptRunner is AppStorage, Initializable, EVMScriptRegistryConstants, KernelNamespaceConstants {\n    string private constant ERROR_EXECUTOR_UNAVAILABLE = \"EVMRUN_EXECUTOR_UNAVAILABLE\";\n    string private constant ERROR_PROTECTED_STATE_MODIFIED = \"EVMRUN_PROTECTED_STATE_MODIFIED\";\n\n    /* This is manually crafted in assembly\n    string private constant ERROR_EXECUTOR_INVALID_RETURN = \"EVMRUN_EXECUTOR_INVALID_RETURN\";\n    */\n\n    event ScriptResult(address indexed executor, bytes script, bytes input, bytes returnData);\n\n    function getEVMScriptExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\n        return IEVMScriptExecutor(getEVMScriptRegistry().getScriptExecutor(_script));\n    }\n\n    function getEVMScriptRegistry() public view returns (IEVMScriptRegistry) {\n        address registryAddr = kernel().getApp(KERNEL_APP_ADDR_NAMESPACE, EVMSCRIPT_REGISTRY_APP_ID);\n        return IEVMScriptRegistry(registryAddr);\n    }\n\n    function runScript(bytes _script, bytes _input, address[] _blacklist)\n        internal\n        isInitialized\n        protectState\n        returns (bytes)\n    {\n        IEVMScriptExecutor executor = getEVMScriptExecutor(_script);\n        require(address(executor) != address(0), ERROR_EXECUTOR_UNAVAILABLE);\n\n        bytes4 sig = executor.execScript.selector;\n        bytes memory data = abi.encodeWithSelector(sig, _script, _input, _blacklist);\n\n        bytes memory output;\n        assembly {\n            let success := delegatecall(\n                gas,                // forward all gas\n                executor,           // address\n                add(data, 0x20),    // calldata start\n                mload(data),        // calldata length\n                0,                  // don't write output (we'll handle this ourselves)\n                0                   // don't write output\n            )\n\n            output := mload(0x40) // free mem ptr get\n\n            switch success\n            case 0 {\n                // If the call errored, forward its full error data\n                returndatacopy(output, 0, returndatasize)\n                revert(output, returndatasize)\n            }\n            default {\n                switch gt(returndatasize, 0x3f)\n                case 0 {\n                    // Need at least 0x40 bytes returned for properly ABI-encoded bytes values,\n                    // revert with \"EVMRUN_EXECUTOR_INVALID_RETURN\"\n                    // See remix: doing a `revert(\"EVMRUN_EXECUTOR_INVALID_RETURN\")` always results in\n                    // this memory layout\n                    mstore(output, 0x08c379a000000000000000000000000000000000000000000000000000000000)         // error identifier\n                    mstore(add(output, 0x04), 0x0000000000000000000000000000000000000000000000000000000000000020) // starting offset\n                    mstore(add(output, 0x24), 0x000000000000000000000000000000000000000000000000000000000000001e) // reason length\n                    mstore(add(output, 0x44), 0x45564d52554e5f4558454355544f525f494e56414c49445f52455455524e0000) // reason\n\n                    revert(output, 100) // 100 = 4 + 3 * 32 (error identifier + 3 words for the ABI encoded error)\n                }\n                default {\n                    // Copy result\n                    //\n                    // Needs to perform an ABI decode for the expected `bytes` return type of\n                    // `executor.execScript()` as solidity will automatically ABI encode the returned bytes as:\n                    //    [ position of the first dynamic length return value = 0x20 (32 bytes) ]\n                    //    [ output length (32 bytes) ]\n                    //    [ output content (N bytes) ]\n                    //\n                    // Perform the ABI decode by ignoring the first 32 bytes of the return data\n                    let copysize := sub(returndatasize, 0x20)\n                    returndatacopy(output, 0x20, copysize)\n\n                    mstore(0x40, add(output, copysize)) // free mem ptr set\n                }\n            }\n        }\n\n        emit ScriptResult(address(executor), _script, _input, output);\n\n        return output;\n    }\n\n    modifier protectState {\n        address preKernel = address(kernel());\n        bytes32 preAppId = appId();\n        _; // exec\n        require(address(kernel()) == preKernel, ERROR_PROTECTED_STATE_MODIFIED);\n        require(appId() == preAppId, ERROR_PROTECTED_STATE_MODIFIED);\n    }\n}\n"},"@aragon/os/contracts/kernel/IKernel.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"../acl/IACL.sol\";\nimport \"../common/IVaultRecoverable.sol\";\n\n\ninterface IKernelEvents {\n    event SetApp(bytes32 indexed namespace, bytes32 indexed appId, address app);\n}\n\n\n// This should be an interface, but interfaces can't inherit yet :(\ncontract IKernel is IKernelEvents, IVaultRecoverable {\n    function acl() public view returns (IACL);\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n\n    function setApp(bytes32 namespace, bytes32 appId, address app) public;\n    function getApp(bytes32 namespace, bytes32 appId) public view returns (address);\n}\n"},"contracts/0.4.24/Lido.sol":{"content":"// SPDX-FileCopyrightText: 2023 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n/* See contracts/COMPILERS.md */\npragma solidity 0.4.24;\n\nimport \"@aragon/os/contracts/apps/AragonApp.sol\";\nimport \"@aragon/os/contracts/lib/math/SafeMath.sol\";\n\nimport \"../common/interfaces/ILidoLocator.sol\";\nimport \"../common/interfaces/IBurner.sol\";\n\nimport \"./lib/StakeLimitUtils.sol\";\nimport \"../common/lib/Math256.sol\";\n\nimport \"./StETHPermit.sol\";\n\nimport \"./utils/Versioned.sol\";\n\ninterface IPostTokenRebaseReceiver {\n    function handlePostTokenRebase(\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        uint256 _preTotalShares,\n        uint256 _preTotalEther,\n        uint256 _postTotalShares,\n        uint256 _postTotalEther,\n        uint256 _sharesMintedAsFees\n    ) external;\n}\n\ninterface IOracleReportSanityChecker {\n    function checkAccountingOracleReport(\n        uint256 _timeElapsed,\n        uint256 _preCLBalance,\n        uint256 _postCLBalance,\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        uint256 _preCLValidators,\n        uint256 _postCLValidators\n    ) external view;\n\n    function smoothenTokenRebase(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _preCLBalance,\n        uint256 _postCLBalance,\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        uint256 _etherToLockForWithdrawals,\n        uint256 _newSharesToBurnForWithdrawals\n    ) external view returns (\n        uint256 withdrawals,\n        uint256 elRewards,\n        uint256 simulatedSharesToBurn,\n        uint256 sharesToBurn\n    );\n\n    function checkWithdrawalQueueOracleReport(\n        uint256 _lastFinalizableRequestId,\n        uint256 _reportTimestamp\n    ) external view;\n\n    function checkSimulatedShareRate(\n        uint256 _postTotalPooledEther,\n        uint256 _postTotalShares,\n        uint256 _etherLockedOnWithdrawalQueue,\n        uint256 _sharesBurntDueToWithdrawals,\n        uint256 _simulatedShareRate\n    ) external view;\n}\n\ninterface ILidoExecutionLayerRewardsVault {\n    function withdrawRewards(uint256 _maxAmount) external returns (uint256 amount);\n}\n\ninterface IWithdrawalVault {\n    function withdrawWithdrawals(uint256 _amount) external;\n}\n\ninterface IStakingRouter {\n    function deposit(\n        uint256 _depositsCount,\n        uint256 _stakingModuleId,\n        bytes _depositCalldata\n    ) external payable;\n\n    function getStakingRewardsDistribution()\n        external\n        view\n        returns (\n            address[] memory recipients,\n            uint256[] memory stakingModuleIds,\n            uint96[] memory stakingModuleFees,\n            uint96 totalFee,\n            uint256 precisionPoints\n        );\n\n    function getWithdrawalCredentials() external view returns (bytes32);\n\n    function reportRewardsMinted(uint256[] _stakingModuleIds, uint256[] _totalShares) external;\n\n    function getTotalFeeE4Precision() external view returns (uint16 totalFee);\n\n    function getStakingFeeAggregateDistributionE4Precision() external view returns (\n        uint16 modulesFee, uint16 treasuryFee\n    );\n\n    function getStakingModuleMaxDepositsCount(uint256 _stakingModuleId, uint256 _maxDepositsValue)\n        external\n        view\n        returns (uint256);\n\n    function TOTAL_BASIS_POINTS() external view returns (uint256);\n}\n\ninterface IWithdrawalQueue {\n    function prefinalize(uint256[] _batches, uint256 _maxShareRate)\n        external\n        view\n        returns (uint256 ethToLock, uint256 sharesToBurn);\n\n    function finalize(uint256 _lastIdToFinalize, uint256 _maxShareRate) external payable;\n\n    function isPaused() external view returns (bool);\n\n    function unfinalizedStETH() external view returns (uint256);\n\n    function isBunkerModeActive() external view returns (bool);\n}\n\n/**\n* @title Liquid staking pool implementation\n*\n* Lido is an Ethereum liquid staking protocol solving the problem of frozen staked ether on Consensus Layer\n* being unavailable for transfers and DeFi on Execution Layer.\n*\n* Since balances of all token holders change when the amount of total pooled Ether\n* changes, this token cannot fully implement ERC20 standard: it only emits `Transfer`\n* events upon explicit transfer between holders. In contrast, when Lido oracle reports\n* rewards, no Transfer events are generated: doing so would require emitting an event\n* for each token holder and thus running an unbounded loop.\n*\n* ---\n* NB: Order of inheritance must preserve the structured storage layout of the previous versions.\n*\n* @dev Lido is derived from `StETHPermit` that has a structured storage:\n* SLOT 0: mapping (address => uint256) private shares (`StETH`)\n* SLOT 1: mapping (address => mapping (address => uint256)) private allowances (`StETH`)\n* SLOT 2: mapping(address => uint256) internal noncesByAddress (`StETHPermit`)\n*\n* `Versioned` and `AragonApp` both don't have the pre-allocated structured storage.\n*/\ncontract Lido is Versioned, StETHPermit, AragonApp {\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256(\"PAUSE_ROLE\");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256(\"RESUME_ROLE\");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256(\"STAKING_PAUSE_ROLE\")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256(\"STAKING_CONTROL_ROLE\")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256(\"UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE\")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256(\"lido.Lido.lidoLocator\")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256(\"lido.Lido.stakeLimit\");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256(\"lido.Lido.bufferedEther\");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256(\"lido.Lido.depositedValidators\");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // \"beacon\" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256(\"lido.Lido.beaconBalance\");\n    /// @dev number of Lido's validators available in the Consensus Layer state\n    // \"beacon\" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256(\"lido.Lido.beaconValidators\");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256(\"lido.Lido.totalELRewardsCollected\");\n\n    // Staking was paused (don't accept user's ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user's ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user's submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract's balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version \"2\"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value \"1\" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), \"NOT_INITIALIZED\");\n\n        require(_lidoLocator != address(0), \"LIDO_LOCATOR_ZERO_ADDRESS\");\n        require(_eip712StETH != address(0), \"EIP712_STETH_ZERO_ADDRESS\");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, \"INITIAL_HOLDER_EXISTS\");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), \"NOT_INITIALIZED\");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     * ▲ Stake limit\n     * │.....  .....   ........ ...            ....     ... Stake limit = max\n     * │      .       .        .   .   .      .    . . .\n     * │     .       .              . .  . . .      . .\n     * │            .                .  . . .\n     * │──────────────────────────────────────────────────> Time\n     * │     ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it's paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, \"NON_EMPTY_DATA\");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert(\"NOT_SUPPORTED\");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract's balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol's pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), \"APP_AUTH_DSM_FAILED\");\n        require(canDeposit(), \"CAN_NOT_DEPOSIT\");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can't deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, \"REPORTED_MORE_DEPOSITED\");\n        require(_postClValidators >= _preClValidators, \"REPORTED_LESS_VALIDATORS\");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Don’t mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, \"ZERO_DEPOSIT\");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), \"STAKING_PAUSED\");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, \"STAKE_LIMIT\");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, \"WRONG_RECIPIENTS_INPUT\");\n        require(ret.moduleIds.length == ret.modulesFees.length, \"WRONG_MODULE_IDS_INPUT\");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), \"APP_AUTH_FAILED\");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome 'stack too deep' issue.\n     *\n     * The method updates the protocol's accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, \"APP_AUTH_FAILED\");\n        require(_reportedData.reportTimestamp <= block.timestamp, \"INVALID_REPORT_TIMESTAMP\");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract's balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract's balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract's balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}\n"},"@aragon/os/contracts/common/Autopetrified.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"./Petrifiable.sol\";\n\n\ncontract Autopetrified is Petrifiable {\n    constructor() public {\n        // Immediately petrify base (non-proxy) instances of inherited contracts on deploy.\n        // This renders them uninitializable (and unusable without a proxy).\n        petrify();\n    }\n}\n"},"@aragon/os/contracts/apps/AragonApp.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"./AppStorage.sol\";\nimport \"../acl/ACLSyntaxSugar.sol\";\nimport \"../common/Autopetrified.sol\";\nimport \"../common/ConversionHelpers.sol\";\nimport \"../common/ReentrancyGuard.sol\";\nimport \"../common/VaultRecoverable.sol\";\nimport \"../evmscript/EVMScriptRunner.sol\";\n\n\n// Contracts inheriting from AragonApp are, by default, immediately petrified upon deployment so\n// that they can never be initialized.\n// Unless overriden, this behaviour enforces those contracts to be usable only behind an AppProxy.\n// ReentrancyGuard, EVMScriptRunner, and ACLSyntaxSugar are not directly used by this contract, but\n// are included so that they are automatically usable by subclassing contracts\ncontract AragonApp is AppStorage, Autopetrified, VaultRecoverable, ReentrancyGuard, EVMScriptRunner, ACLSyntaxSugar {\n    string private constant ERROR_AUTH_FAILED = \"APP_AUTH_FAILED\";\n\n    modifier auth(bytes32 _role) {\n        require(canPerform(msg.sender, _role, new uint256[](0)), ERROR_AUTH_FAILED);\n        _;\n    }\n\n    modifier authP(bytes32 _role, uint256[] _params) {\n        require(canPerform(msg.sender, _role, _params), ERROR_AUTH_FAILED);\n        _;\n    }\n\n    /**\n    * @dev Check whether an action can be performed by a sender for a particular role on this app\n    * @param _sender Sender of the call\n    * @param _role Role on this app\n    * @param _params Permission params for the role\n    * @return Boolean indicating whether the sender has the permissions to perform the action.\n    *         Always returns false if the app hasn't been initialized yet.\n    */\n    function canPerform(address _sender, bytes32 _role, uint256[] _params) public view returns (bool) {\n        if (!hasInitialized()) {\n            return false;\n        }\n\n        IKernel linkedKernel = kernel();\n        if (address(linkedKernel) == address(0)) {\n            return false;\n        }\n\n        return linkedKernel.hasPermission(\n            _sender,\n            address(this),\n            _role,\n            ConversionHelpers.dangerouslyCastUintArrayToBytes(_params)\n        );\n    }\n\n    /**\n    * @dev Get the recovery vault for the app\n    * @return Recovery vault address for the app\n    */\n    function getRecoveryVault() public view returns (address) {\n        // Funds recovery via a vault is only available when used with a kernel\n        return kernel().getRecoveryVault(); // if kernel is not set, it will revert\n    }\n}\n"},"@aragon/os/contracts/common/Initializable.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\nimport \"./TimeHelpers.sol\";\nimport \"./UnstructuredStorage.sol\";\n\n\ncontract Initializable is TimeHelpers {\n    using UnstructuredStorage for bytes32;\n\n    // keccak256(\"aragonOS.initializable.initializationBlock\")\n    bytes32 internal constant INITIALIZATION_BLOCK_POSITION = 0xebb05b386a8d34882b8711d156f463690983dc47815980fb82aeeff1aa43579e;\n\n    string private constant ERROR_ALREADY_INITIALIZED = \"INIT_ALREADY_INITIALIZED\";\n    string private constant ERROR_NOT_INITIALIZED = \"INIT_NOT_INITIALIZED\";\n\n    modifier onlyInit {\n        require(getInitializationBlock() == 0, ERROR_ALREADY_INITIALIZED);\n        _;\n    }\n\n    modifier isInitialized {\n        require(hasInitialized(), ERROR_NOT_INITIALIZED);\n        _;\n    }\n\n    /**\n    * @return Block number in which the contract was initialized\n    */\n    function getInitializationBlock() public view returns (uint256) {\n        return INITIALIZATION_BLOCK_POSITION.getStorageUint256();\n    }\n\n    /**\n    * @return Whether the contract has been initialized by the time of the current block\n    */\n    function hasInitialized() public view returns (bool) {\n        uint256 initializationBlock = getInitializationBlock();\n        return initializationBlock != 0 && getBlockNumber() >= initializationBlock;\n    }\n\n    /**\n    * @dev Function to be called by top level contract after initialization has finished.\n    */\n    function initialized() internal onlyInit {\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(getBlockNumber());\n    }\n\n    /**\n    * @dev Function to be called by top level contract after initialization to enable the contract\n    *      at a future block number rather than immediately.\n    */\n    function initializedAt(uint256 _blockNumber) internal onlyInit {\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(_blockNumber);\n    }\n}\n"},"@aragon/os/contracts/acl/IACL.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\ninterface IACL {\n    function initialize(address permissionsCreator) external;\n\n    // TODO: this should be external\n    // See https://github.com/ethereum/solidity/issues/4832\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n}\n"},"contracts/common/lib/ECDSA.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// Extracted from:\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/cryptography/ECDSA.sol#L53\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/541e821/contracts/utils/cryptography/ECDSA.sol#L112\n\n/* See contracts/COMPILERS.md */\n// solhint-disable-next-line\npragma solidity >=0.4.24 <0.9.0;\n\n\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`).\n     * This address can then be used for verification purposes.\n     * Receives the `v`, `r` and `s` signature fields separately.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address)\n    {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Overload of `recover` that receives the `r` and `vs` short-signature fields separately.\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return recover(hash, v, r, s);\n    }\n}\n"},"@aragon/os/contracts/lib/token/ERC20.sol":{"content":"// See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a9f910d34f0ab33a1ae5e714f69f9596a02b4d91/contracts/token/ERC20/ERC20.sol\n\npragma solidity ^0.4.24;\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 {\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address _who) public view returns (uint256);\n\n    function allowance(address _owner, address _spender)\n        public view returns (uint256);\n\n    function transfer(address _to, uint256 _value) public returns (bool);\n\n    function approve(address _spender, uint256 _value)\n        public returns (bool);\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"},"@aragon/os/contracts/common/ConversionHelpers.sol":{"content":"pragma solidity ^0.4.24;\n\n\nlibrary ConversionHelpers {\n    string private constant ERROR_IMPROPER_LENGTH = \"CONVERSION_IMPROPER_LENGTH\";\n\n    function dangerouslyCastUintArrayToBytes(uint256[] memory _input) internal pure returns (bytes memory output) {\n        // Force cast the uint256[] into a bytes array, by overwriting its length\n        // Note that the bytes array doesn't need to be initialized as we immediately overwrite it\n        // with the input and a new length. The input becomes invalid from this point forward.\n        uint256 byteLength = _input.length * 32;\n        assembly {\n            output := _input\n            mstore(output, byteLength)\n        }\n    }\n\n    function dangerouslyCastBytesToUintArray(bytes memory _input) internal pure returns (uint256[] memory output) {\n        // Force cast the bytes array into a uint256[], by overwriting its length\n        // Note that the uint256[] doesn't need to be initialized as we immediately overwrite it\n        // with the input and a new length. The input becomes invalid from this point forward.\n        uint256 intsLength = _input.length / 32;\n        require(_input.length == intsLength * 32, ERROR_IMPROPER_LENGTH);\n\n        assembly {\n            output := _input\n            mstore(output, intsLength)\n        }\n    }\n}\n"},"@aragon/os/contracts/kernel/KernelConstants.sol":{"content":"/*\n * SPDX-License-Identifier:    MIT\n */\n\npragma solidity ^0.4.24;\n\n\ncontract KernelAppIds {\n    /* Hardcoded constants to save gas\n    bytes32 internal constant KERNEL_CORE_APP_ID = apmNamehash(\"kernel\");\n    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = apmNamehash(\"acl\");\n    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = apmNamehash(\"vault\");\n    */\n    bytes32 internal constant KERNEL_CORE_APP_ID = 0x3b4bf6bf3ad5000ecf0f989d5befde585c6860fea3e574a4fab4c49d1c177d9c;\n    bytes32 internal constant KERNEL_DEFAULT_ACL_APP_ID = 0xe3262375f45a6e2026b7e7b18c2b807434f2508fe1a2a3dfb493c7df8f4aad6a;\n    bytes32 internal constant KERNEL_DEFAULT_VAULT_APP_ID = 0x7e852e0fcfce6551c13800f1e7476f982525c2b5277ba14b24339c68416336d1;\n}\n\n\ncontract KernelNamespaceConstants {\n    /* Hardcoded constants to save gas\n    bytes32 internal constant KERNEL_CORE_NAMESPACE = keccak256(\"core\");\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = keccak256(\"base\");\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = keccak256(\"app\");\n    */\n    bytes32 internal constant KERNEL_CORE_NAMESPACE = 0xc681a85306374a5ab27f0bbc385296a54bcd314a1948b6cf61c4ea1bc44bb9f8;\n    bytes32 internal constant KERNEL_APP_BASES_NAMESPACE = 0xf1f3eb40f5bc1ad1344716ced8b8a0431d840b5783aea1fd01786bc26f35ac0f;\n    bytes32 internal constant KERNEL_APP_ADDR_NAMESPACE = 0xd6f028ca0e8edb4a8c9757ca4fdccab25fa1e0317da1188108f7d2dee14902fb;\n}\n"},"contracts/0.4.24/utils/Versioned.sol":{"content":"// SPDX-FileCopyrightText: 2023 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.4.24;\n\nimport \"@aragon/os/contracts/common/UnstructuredStorage.sol\";\n\n/**\n * @title Adapted code of /contracts/0.8.9/utils/Versioned.sol\n *\n * This contract contains only core part of original Versioned.sol\n * to reduce contract size\n */\ncontract Versioned {\n    using UnstructuredStorage for bytes32;\n\n    event ContractVersionSet(uint256 version);\n\n    /// @dev Storage slot: uint256 version\n    /// Version of the initialized contract storage.\n    /// The version stored in CONTRACT_VERSION_POSITION equals to:\n    /// - 0 right after the deployment, before an initializer is invoked (and only at that moment);\n    /// - N after calling initialize(), where N is the initially deployed contract version;\n    /// - N after upgrading contract by calling finalizeUpgrade_vN().\n    bytes32 internal constant CONTRACT_VERSION_POSITION =\n        0x4dd0f6662ba1d6b081f08b350f5e9a6a7b15cf586926ba66f753594928fa64a6; // keccak256(\"lido.Versioned.contractVersion\");\n\n    uint256 internal constant PETRIFIED_VERSION_MARK = uint256(-1);\n\n    constructor() public {\n        // lock version in the implementation's storage to prevent initialization\n        CONTRACT_VERSION_POSITION.setStorageUint256(PETRIFIED_VERSION_MARK);\n    }\n\n    /// @notice Returns the current contract version.\n    function getContractVersion() public view returns (uint256) {\n        return CONTRACT_VERSION_POSITION.getStorageUint256();\n    }\n\n    function _checkContractVersion(uint256 version) internal view {\n        require(version == getContractVersion(), \"UNEXPECTED_CONTRACT_VERSION\");\n    }\n\n    function _setContractVersion(uint256 version) internal {\n        CONTRACT_VERSION_POSITION.setStorageUint256(version);\n        emit ContractVersionSet(version);\n    }\n}\n"},"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol":{"content":"pragma solidity ^0.4.24;\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 {\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address who) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n    external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function approve(address spender, uint256 value)\n    external returns (bool);\n\n  function transferFrom(address from, address to, uint256 value)\n    external returns (bool);\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n"},"contracts/0.4.24/StETHPermit.sol":{"content":"// SPDX-FileCopyrightText: 2023 OpenZeppelin, Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n\n/* See contracts/COMPILERS.md */\npragma solidity 0.4.24;\n\nimport {UnstructuredStorage} from \"@aragon/os/contracts/common/UnstructuredStorage.sol\";\n\nimport {SignatureUtils} from \"../common/lib/SignatureUtils.sol\";\nimport {IEIP712StETH} from \"../common/interfaces/IEIP712StETH.sol\";\n\nimport {StETH} from \"./StETH.sol\";\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC2612 {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     */\n    function permit(\n        address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\n\ncontract StETHPermit is IERC2612, StETH {\n    using UnstructuredStorage for bytes32;\n\n    /**\n     * @dev Service event for initialization\n     */\n    event EIP712StETHInitialized(address eip712StETH);\n\n    /**\n     * @dev Nonces for ERC-2612 (Permit)\n     */\n    mapping(address => uint256) internal noncesByAddress;\n\n    /**\n     * @dev Storage position used for the EIP712 message utils contract\n     *\n     * keccak256(\"lido.StETHPermit.eip712StETH\")\n     */\n    bytes32 internal constant EIP712_STETH_POSITION =\n        0x42b2d95e1ce15ce63bf9a8d9f6312cf44b23415c977ffa3b884333422af8941c;\n\n    /**\n     * @dev Typehash constant for ERC-2612 (Permit)\n     *\n     * keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n     */\n    bytes32 internal constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     */\n    function permit(\n        address _owner, address _spender, uint256 _value, uint256 _deadline, uint8 _v, bytes32 _r, bytes32 _s\n    ) external {\n        require(block.timestamp <= _deadline, \"DEADLINE_EXPIRED\");\n\n        bytes32 structHash = keccak256(\n            abi.encode(PERMIT_TYPEHASH, _owner, _spender, _value, _useNonce(_owner), _deadline)\n        );\n\n        bytes32 hash = IEIP712StETH(getEIP712StETH()).hashTypedDataV4(address(this), structHash);\n\n        require(SignatureUtils.isValidSignature(_owner, hash, _v, _r, _s), \"INVALID_SIGNATURE\");\n        _approve(_owner, _spender, _value);\n    }\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256) {\n        return noncesByAddress[owner];\n    }\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return IEIP712StETH(getEIP712StETH()).domainSeparatorV4(address(this));\n    }\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     *\n     * NB: compairing to the full-fledged ERC-5267 version:\n     * - `salt` and `extensions` are unused\n     * - `flags` is hex\"0f\" or 01111b\n     *\n     * @dev using shortened returns to reduce a bytecode size\n     */\n    function eip712Domain() external view returns (\n        string memory name,\n        string memory version,\n        uint256 chainId,\n        address verifyingContract\n    ) {\n        return IEIP712StETH(getEIP712StETH()).eip712Domain(address(this));\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     */\n    function _useNonce(address _owner) internal returns (uint256 current) {\n        current = noncesByAddress[_owner];\n        noncesByAddress[_owner] = current.add(1);\n    }\n\n    /**\n     * @dev Initialize EIP712 message utils contract for stETH\n     */\n    function _initializeEIP712StETH(address _eip712StETH) internal {\n        require(_eip712StETH != address(0), \"ZERO_EIP712STETH\");\n        require(getEIP712StETH() == address(0), \"EIP712STETH_ALREADY_SET\");\n\n        EIP712_STETH_POSITION.setStorageAddress(_eip712StETH);\n\n        emit EIP712StETHInitialized(_eip712StETH);\n    }\n\n    /**\n     * @dev Get EIP712 message utils contract\n     */\n    function getEIP712StETH() public view returns (address) {\n        return EIP712_STETH_POSITION.getStorageAddress();\n    }\n}\n"}},"settings":{"evmVersion":"constantinople","libraries":{},"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}}},"ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasInitialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STAKING_CONTROL_ROLE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ethAmount\",\"type\":\"uint256\"}],\"name\":\"getSharesByPooledEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStakingPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_script\",\"type\":\"bytes\"}],\"name\":\"getEVMScriptExecutor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxStakeLimit\",\"type\":\"uint256\"},{\"name\":\"_stakeLimitIncreasePerBlock\",\"type\":\"uint256\"}],\"name\":\"setStakingLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RESUME_ROLE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lidoLocator\",\"type\":\"address\"},{\"name\":\"_eip712StETH\",\"type\":\"address\"}],\"name\":\"finalizeUpgrade_v2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRecoveryVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalPooledEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDepositedValidators\",\"type\":\"uint256\"}],\"name\":\"unsafeChangeDepositedValidators\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PAUSE_ROLE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTreasury\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBufferedEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lidoLocator\",\"type\":\"address\"},{\"name\":\"_eip712StETH\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"receiveELRewards\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getWithdrawalCredentials\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentStakeLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStakeLimitFullInfo\",\"outputs\":[{\"name\":\"isStakingPaused\",\"type\":\"bool\"},{\"name\":\"isStakingLimitSet\",\"type\":\"bool\"},{\"name\":\"currentStakeLimit\",\"type\":\"uint256\"},{\"name\":\"maxStakeLimit\",\"type\":\"uint256\"},{\"name\":\"maxStakeLimitGrowthBlocks\",\"type\":\"uint256\"},{\"name\":\"prevStakeLimit\",\"type\":\"uint256\"},{\"name\":\"prevStakeBlockNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_sharesAmount\",\"type\":\"uint256\"}],\"name\":\"transferSharesFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resumeStaking\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFeeDistribution\",\"outputs\":[{\"name\":\"treasuryFeeBasisPoints\",\"type\":\"uint16\"},{\"name\":\"insuranceFeeBasisPoints\",\"type\":\"uint16\"},{\"name\":\"operatorsFeeBasisPoints\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"receiveWithdrawals\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sharesAmount\",\"type\":\"uint256\"}],\"name\":\"getPooledEthByShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"allowRecoverability\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"appId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eip712Domain\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"version\",\"type\":\"string\"},{\"name\":\"chainId\",\"type\":\"uint256\"},{\"name\":\"verifyingContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInitializationBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_sharesAmount\",\"type\":\"uint256\"}],\"name\":\"transferShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEIP712StETH\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferToVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"bytes32\"},{\"name\":\"_params\",\"type\":\"uint256[]\"}],\"name\":\"canPerform\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"submit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEVMScriptRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxDepositsCount\",\"type\":\"uint256\"},{\"name\":\"_stakingModuleId\",\"type\":\"uint256\"},{\"name\":\"_depositCalldata\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBeaconStat\",\"outputs\":[{\"name\":\"depositedValidators\",\"type\":\"uint256\"},{\"name\":\"beaconValidators\",\"type\":\"uint256\"},{\"name\":\"beaconBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeStakingLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reportTimestamp\",\"type\":\"uint256\"},{\"name\":\"_timeElapsed\",\"type\":\"uint256\"},{\"name\":\"_clValidators\",\"type\":\"uint256\"},{\"name\":\"_clBalance\",\"type\":\"uint256\"},{\"name\":\"_withdrawalVaultBalance\",\"type\":\"uint256\"},{\"name\":\"_elRewardsVaultBalance\",\"type\":\"uint256\"},{\"name\":\"_sharesRequestedToBurn\",\"type\":\"uint256\"},{\"name\":\"_withdrawalFinalizationBatches\",\"type\":\"uint256[]\"},{\"name\":\"_simulatedShareRate\",\"type\":\"uint256\"}],\"name\":\"handleOracleReport\",\"outputs\":[{\"name\":\"postRebaseAmounts\",\"type\":\"uint256[4]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFee\",\"outputs\":[{\"name\":\"totalFee\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kernel\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_deadline\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPetrified\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLidoLocator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canDeposit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STAKING_PAUSE_ROLE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDepositableEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"sharesOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseStaking\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalELRewardsCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"StakingPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"StakingResumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"maxStakeLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stakeLimitIncreasePerBlock\",\"type\":\"uint256\"}],\"name\":\"StakingLimitSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"StakingLimitRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"reportTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"preCLValidators\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"postCLValidators\",\"type\":\"uint256\"}],\"name\":\"CLValidatorsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"depositedValidators\",\"type\":\"uint256\"}],\"name\":\"DepositedValidatorsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"reportTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"preCLBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"postCLBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"withdrawalsWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"executionLayerRewardsWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"postBufferedEther\",\"type\":\"uint256\"}],\"name\":\"ETHDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"reportTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeElapsed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"preTotalShares\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"preTotalEther\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"postTotalShares\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"postTotalEther\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sharesMintedAsFees\",\"type\":\"uint256\"}],\"name\":\"TokenRebased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"lidoLocator\",\"type\":\"address\"}],\"name\":\"LidoLocatorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ELRewardsReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawalsReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"Submitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unbuffered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"script\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"input\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"returnData\",\"type\":\"bytes\"}],\"name\":\"ScriptResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RecoverToVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"eip712StETH\",\"type\":\"address\"}],\"name\":\"EIP712StETHInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sharesValue\",\"type\":\"uint256\"}],\"name\":\"TransferShares\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"preRebaseTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"postRebaseTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sharesAmount\",\"type\":\"uint256\"}],\"name\":\"SharesBurnt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Stopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Resumed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"ContractVersionSet\",\"type\":\"event\"}]","ContractName":"Lido","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x","EVMVersion":"constantinople","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}