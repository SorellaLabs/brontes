{"expiry":1699579529,"data":[{"SourceCode":{"language":"Solidity","sources":{"contracts/interfaces/ISettlement.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@1inch/limit-order-protocol-contract/contracts/interfaces/IInteractionNotificationReceiver.sol\";\nimport \"./IFeeBankCharger.sol\";\n\ninterface ISettlement is IInteractionNotificationReceiver, IFeeBankCharger {\n    function settleOrders(bytes calldata order) external;\n}\n"},"contracts/libraries/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ntype Address is uint256;\n\nlibrary AddressLib {\n    function get(Address a) internal pure returns (address) {\n        return address(uint160(Address.unwrap(a)));\n    }\n\n    function getFlag(Address a, uint256 flag) internal pure returns (bool) {\n        return Address.unwrap(a) & flag != 0;\n    }\n\n    function getUint32(Address a, uint256 offset) internal pure returns (uint32) {\n        return uint32(Address.unwrap(a) >> offset);\n    }\n\n    function getUint64(Address a, uint256 offset) internal pure returns (uint64) {\n        return uint64(Address.unwrap(a) >> offset);\n    }\n}\n"},"contracts/libraries/OrderSuffix.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@1inch/limit-order-protocol-contract/contracts/OrderLib.sol\";\nimport \"./OrderSaltParser.sol\";\nimport \"./TakingFee.sol\";\n\n// Placed in the end of the order interactions data\n// Last byte contains flags and lengths, can have up to 15 resolvers and 7 points\nlibrary OrderSuffix {\n    using OrderSaltParser for uint256;\n\n    // `Order.interactions` suffix structure:\n    // M*(1 + 3 bytes)  - auction points coefficients with seconds delays\n    // N*(4 + 20 bytes) - resolver with corresponding time limit\n    // 4 bytes          - public time limit\n    // 32 bytes         - taking fee (optional if flags has _HAS_TAKING_FEE_FLAG)\n    // 1 bytes          - flags\n\n    uint256 private constant _HAS_TAKING_FEE_FLAG = 0x80;\n    uint256 private constant _RESOLVERS_LENGTH_MASK = 0x78;\n    uint256 private constant _RESOLVERS_LENGTH_BIT_SHIFT = 3;\n    uint256 private constant _POINTS_LENGTH_MASK = 0x07;\n    uint256 private constant _POINTS_LENGTH_BIT_SHIFT = 0;\n\n    uint256 private constant _TAKING_FEE_BYTES_SIZE = 32;\n\n    uint256 private constant _PUBLIC_TIME_LIMIT_BYTES_SIZE = 4;\n    uint256 private constant _PUBLIC_TIME_LIMIT_BIT_SHIFT = 224; // 256 - _PUBLIC_TIME_LIMIT_BYTES_SIZE * 8\n\n    uint256 private constant _AUCTION_POINT_DELAY_BYTES_SIZE = 2;\n    uint256 private constant _AUCTION_POINT_BUMP_BYTES_SIZE = 3;\n    uint256 private constant _AUCTION_POINT_BYTES_SIZE = 5; // _AUCTION_POINT_DELAY_BYTES_SIZE + _AUCTION_POINT_BUMP_BYTES_SIZE;\n    uint256 private constant _AUCTION_POINT_DELAY_BIT_SHIFT = 240; // 256 - _AUCTION_POINT_DELAY_BYTES_SIZE * 8;\n    uint256 private constant _AUCTION_POINT_BUMP_BIT_SHIFT = 232; // 256 - _AUCTION_POINT_BUMP_BYTES_SIZE * 8;\n\n    uint256 private constant _RESOLVER_TIME_LIMIT_BYTES_SIZE = 4;\n    uint256 private constant _RESOLVER_ADDRESS_BYTES_SIZE = 20;\n    uint256 private constant _RESOLVER_BYTES_SIZE = 24; // _RESOLVER_TIME_LIMIT_BYTES_SIZE + _RESOLVER_ADDRESS_BYTES_SIZE;\n    uint256 private constant _RESOLVER_TIME_LIMIT_BIT_SHIFT = 224; // 256 - _RESOLVER_TIME_LIMIT_BYTES_SIZE * 8;\n    uint256 private constant _RESOLVER_ADDRESS_BIT_SHIFT = 96; // 256 - _RESOLVER_ADDRESS_BYTES_SIZE * 8;\n\n    function takingFee(OrderLib.Order calldata order) internal pure returns (TakingFee.Data ret) {\n        bytes calldata interactions = order.interactions;\n        assembly {\n            let ptr := sub(add(interactions.offset, interactions.length), 1)\n            if and(_HAS_TAKING_FEE_FLAG, byte(0, calldataload(ptr))) {\n                ret := calldataload(sub(ptr, _TAKING_FEE_BYTES_SIZE))\n            }\n        }\n    }\n\n    function checkResolver(OrderLib.Order calldata order, address resolver) internal view returns (bool valid) {\n        bytes calldata interactions = order.interactions;\n        assembly {\n            let ptr := sub(add(interactions.offset, interactions.length), 1)\n            let flags := byte(0, calldataload(ptr))\n            ptr := sub(ptr, _PUBLIC_TIME_LIMIT_BYTES_SIZE)\n            if and(flags, _HAS_TAKING_FEE_FLAG) {\n                ptr := sub(ptr, _TAKING_FEE_BYTES_SIZE)\n            }\n\n            let resolversCount := shr(_RESOLVERS_LENGTH_BIT_SHIFT, and(flags, _RESOLVERS_LENGTH_MASK))\n\n            // Check public time limit\n            let publicLimit := shr(_PUBLIC_TIME_LIMIT_BIT_SHIFT, calldataload(ptr))\n            valid := gt(timestamp(), publicLimit)\n\n            // Check resolvers and corresponding time limits\n            if not(valid) {\n                for { let end := sub(ptr, mul(_RESOLVER_BYTES_SIZE, resolversCount)) } gt(ptr, end) { } {\n                    ptr := sub(ptr, _RESOLVER_ADDRESS_BYTES_SIZE)\n                    let account := shr(_RESOLVER_ADDRESS_BIT_SHIFT, calldataload(ptr))\n                    ptr := sub(ptr, _RESOLVER_TIME_LIMIT_BYTES_SIZE)\n                    let limit := shr(_RESOLVER_TIME_LIMIT_BIT_SHIFT, calldataload(ptr))\n                    if eq(account, resolver) {\n                        valid := iszero(lt(timestamp(), limit))\n                        break\n                    }\n                }\n            }\n        }\n    }\n\n    function rateBump(OrderLib.Order calldata order) internal view returns (uint256 bump) {\n        uint256 startBump = order.salt.getInitialRateBump();\n        uint256 cumulativeTime = order.salt.getStartTime();\n        uint256 lastTime = cumulativeTime + order.salt.getDuration();\n        if (block.timestamp <= cumulativeTime) {\n            return startBump;\n        } else if (block.timestamp >= lastTime) {\n            return 0;\n        }\n\n        bytes calldata interactions = order.interactions;\n        assembly {\n            function linearInterpolation(t1, t2, v1, v2, t) -> v {\n                v := div(\n                    add(mul(sub(t, t1), v2), mul(sub(t2, t), v1)),\n                    sub(t2, t1)\n                )\n            }\n\n            let ptr := sub(add(interactions.offset, interactions.length), 1)\n\n            // move ptr to the last point\n            let pointsCount\n            {  // stack too deep\n                let flags := byte(0, calldataload(ptr))\n                let resolversCount := shr(_RESOLVERS_LENGTH_BIT_SHIFT, and(flags, _RESOLVERS_LENGTH_MASK))\n                pointsCount := and(flags, _POINTS_LENGTH_MASK)\n                if and(flags, _HAS_TAKING_FEE_FLAG) {\n                    ptr := sub(ptr, _TAKING_FEE_BYTES_SIZE)\n                }\n                ptr := sub(ptr, add(mul(_RESOLVER_BYTES_SIZE, resolversCount), _PUBLIC_TIME_LIMIT_BYTES_SIZE)) // 24 byte for each wl entry + 4 bytes for public time limit\n            }\n\n            // Check points sequentially\n            let prevCoefficient := startBump\n            let prevCumulativeTime := cumulativeTime\n            for { let end := sub(ptr, mul(_AUCTION_POINT_BYTES_SIZE, pointsCount)) } gt(ptr, end) { } {\n                ptr := sub(ptr, _AUCTION_POINT_BUMP_BYTES_SIZE)\n                let coefficient := shr(_AUCTION_POINT_BUMP_BIT_SHIFT, calldataload(ptr))\n                ptr := sub(ptr, _AUCTION_POINT_DELAY_BYTES_SIZE)\n                let delay := shr(_AUCTION_POINT_DELAY_BIT_SHIFT, calldataload(ptr))\n                cumulativeTime := add(cumulativeTime, delay)\n                if gt(cumulativeTime, timestamp()) {\n                    // prevCumulativeTime <passed> time <elapsed> cumulativeTime\n                    // prevCoefficient    <passed>  X   <elapsed> coefficient\n                    bump := linearInterpolation(\n                        prevCumulativeTime,\n                        cumulativeTime,\n                        prevCoefficient,\n                        coefficient,\n                        timestamp()\n                    )\n                    break\n                }\n                prevCumulativeTime := cumulativeTime\n                prevCoefficient := coefficient\n            }\n\n            if iszero(bump) {\n                bump := linearInterpolation(\n                    prevCumulativeTime,\n                    lastTime,\n                    prevCoefficient,\n                    0,\n                    timestamp()\n                )\n            }\n        }\n    }\n}\n"},"contracts/Settlement.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@1inch/limit-order-protocol-contract/contracts/interfaces/IOrderMixin.sol\";\nimport \"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\";\nimport \"./interfaces/ISettlement.sol\";\nimport \"./interfaces/IResolver.sol\";\nimport \"./libraries/DynamicSuffix.sol\";\nimport \"./libraries/OrderSaltParser.sol\";\nimport \"./libraries/OrderSuffix.sol\";\nimport \"./FeeBankCharger.sol\";\n\ncontract Settlement is ISettlement, FeeBankCharger {\n    using SafeERC20 for IERC20;\n    using OrderSaltParser for uint256;\n    using DynamicSuffix for bytes;\n    using AddressLib for Address;\n    using OrderSuffix for OrderLib.Order;\n    using TakingFee for TakingFee.Data;\n\n    error AccessDenied();\n    error IncorrectCalldataParams();\n    error FailedExternalCall();\n    error ResolverIsNotWhitelisted();\n    error WrongInteractionTarget();\n\n    bytes1 private constant _FINALIZE_INTERACTION = 0x01;\n    uint256 private constant _ORDER_FEE_BASE_POINTS = 1e15;\n    uint256 private constant _BASE_POINTS = 10_000_000; // 100%\n\n    IOrderMixin private immutable _limitOrderProtocol;\n\n    modifier onlyThis(address account) {\n        if (account != address(this)) revert AccessDenied();\n        _;\n    }\n\n    modifier onlyLimitOrderProtocol {\n        if (msg.sender != address(_limitOrderProtocol)) revert AccessDenied();\n        _;\n    }\n\n    constructor(IOrderMixin limitOrderProtocol, IERC20 token)\n        FeeBankCharger(token)\n    {\n        _limitOrderProtocol = limitOrderProtocol;\n    }\n\n    function settleOrders(bytes calldata data) external {\n        _settleOrder(data, msg.sender, 0, new bytes(0));\n    }\n\n    function fillOrderInteraction(\n        address taker,\n        uint256, /* makingAmount */\n        uint256 takingAmount,\n        bytes calldata interactiveData\n    ) external onlyThis(taker) onlyLimitOrderProtocol returns (uint256 result) {\n        (DynamicSuffix.Data calldata suffix, bytes calldata tokensAndAmounts, bytes calldata interaction) = interactiveData.decodeSuffix();\n        IERC20 token = IERC20(suffix.token.get());\n        result = takingAmount * (_BASE_POINTS + suffix.rateBump) / _BASE_POINTS;\n        uint256 takingFee = result * suffix.takingFee.ratio() / TakingFee._TAKING_FEE_BASE;\n\n        bytes memory allTokensAndAmounts = new bytes(tokensAndAmounts.length + 0x40);\n        assembly {\n            let ptr := add(allTokensAndAmounts, 0x20)\n            calldatacopy(ptr, tokensAndAmounts.offset, tokensAndAmounts.length)\n            ptr := add(ptr, tokensAndAmounts.length)\n            mstore(ptr, token)\n            mstore(add(ptr, 0x20), add(result, takingFee))\n        }\n\n        if (interactiveData[0] == _FINALIZE_INTERACTION) {\n            _chargeFee(suffix.resolver.get(), suffix.totalFee);\n            address target = address(bytes20(interaction));\n            bytes calldata data = interaction[20:];\n            IResolver(target).resolveOrders(suffix.resolver.get(), allTokensAndAmounts, data);\n        } else {\n            _settleOrder(\n                interaction,\n                suffix.resolver.get(),\n                suffix.totalFee,\n                allTokensAndAmounts\n            );\n        }\n\n        if (takingFee > 0) {\n            token.safeTransfer(suffix.takingFee.receiver(), takingFee);\n        }\n        token.forceApprove(address(_limitOrderProtocol), result);\n    }\n\n    bytes4 private constant _FILL_ORDER_TO_SELECTOR = 0xe5d7bde6; // IOrderMixin.fillOrderTo.selector\n    bytes4 private constant _WRONG_INTERACTION_TARGET_SELECTOR = 0x5b34bf89; // WrongInteractionTarget.selector\n\n    function _settleOrder(bytes calldata data, address resolver, uint256 totalFee, bytes memory tokensAndAmounts) private {\n        OrderLib.Order calldata order;\n        assembly {\n            order := add(data.offset, calldataload(data.offset))\n        }\n        if (!order.checkResolver(resolver)) revert ResolverIsNotWhitelisted();\n        TakingFee.Data takingFeeData = order.takingFee();\n        totalFee += order.salt.getFee() * _ORDER_FEE_BASE_POINTS;\n\n        uint256 rateBump = order.rateBump();\n        uint256 suffixLength = DynamicSuffix._STATIC_DATA_SIZE + tokensAndAmounts.length + 0x20;\n        IOrderMixin limitOrderProtocol = _limitOrderProtocol;\n\n        assembly {\n            function memcpy(dst, src, len) {\n                pop(staticcall(gas(), 0x4, src, len, dst, len))\n            }\n\n            let interactionLengthOffset := calldataload(add(data.offset, 0x40))\n            let interactionOffset := add(interactionLengthOffset, 0x20)\n            let interactionLength := calldataload(add(data.offset, interactionLengthOffset))\n\n            { // stack too deep\n                let target := shr(96, calldataload(add(data.offset, interactionOffset)))\n                if or(lt(interactionLength, 20), iszero(eq(target, address()))) {\n                    mstore(0, _WRONG_INTERACTION_TARGET_SELECTOR)\n                    revert(0, 4)\n                }\n            }\n\n            // Copy calldata and patch interaction.length\n            let ptr := mload(0x40)\n            mstore(ptr, _FILL_ORDER_TO_SELECTOR)\n            calldatacopy(add(ptr, 4), data.offset, data.length)\n            mstore(add(add(ptr, interactionLengthOffset), 4), add(interactionLength, suffixLength))\n\n            {  // stack too deep\n                // Append suffix fields\n                let offset := add(add(ptr, interactionOffset), interactionLength)\n                mstore(add(offset, 0x04), totalFee)\n                mstore(add(offset, 0x24), resolver)\n                mstore(add(offset, 0x44), calldataload(add(order, 0x40)))  // takerAsset\n                mstore(add(offset, 0x64), rateBump)\n                mstore(add(offset, 0x84), takingFeeData)\n                let tokensAndAmountsLength := mload(tokensAndAmounts)\n                memcpy(add(offset, 0xa4), add(tokensAndAmounts, 0x20), tokensAndAmountsLength)\n                mstore(add(offset, add(0xa4, tokensAndAmountsLength)), tokensAndAmountsLength)\n            }\n\n            // Call fillOrderTo\n            if iszero(call(gas(), limitOrderProtocol, 0, ptr, add(add(4, suffixLength), data.length), ptr, 0)) {\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n        }\n    }\n}\n"},"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"../interfaces/IDaiLikePermit.sol\";\nimport \"../libraries/RevertReasonForwarder.sol\";\n\n/// @title Implements efficient safe methods for ERC20 interface.\nlibrary SafeERC20 {\n    error SafeTransferFailed();\n    error SafeTransferFromFailed();\n    error ForceApproveFailed();\n    error SafeIncreaseAllowanceFailed();\n    error SafeDecreaseAllowanceFailed();\n    error SafePermitBadLength();\n\n    /// @dev Ensures method do not revert or return boolean `true`, admits call to non-smart-contract.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bytes4 selector = token.transferFrom.selector;\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), from)\n            mstore(add(data, 0x24), to)\n            mstore(add(data, 0x44), amount)\n            success := call(gas(), token, 0, data, 100, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n        if (!success) revert SafeTransferFromFailed();\n    }\n\n    /// @dev Ensures method do not revert or return boolean `true`, admits call to non-smart-contract.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        if (!_makeCall(token, token.transfer.selector, to, value)) {\n            revert SafeTransferFailed();\n        }\n    }\n\n    /// @dev If `approve(from, to, amount)` fails, try to `approve(from, to, 0)` before retry.\n    function forceApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        if (!_makeCall(token, token.approve.selector, spender, value)) {\n            if (\n                !_makeCall(token, token.approve.selector, spender, 0) ||\n                !_makeCall(token, token.approve.selector, spender, value)\n            ) {\n                revert ForceApproveFailed();\n            }\n        }\n    }\n\n    /// @dev Allowance increase with safe math check.\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (value > type(uint256).max - allowance) revert SafeIncreaseAllowanceFailed();\n        forceApprove(token, spender, allowance + value);\n    }\n\n    /// @dev Allowance decrease with safe math check.\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 allowance = token.allowance(address(this), spender);\n        if (value > allowance) revert SafeDecreaseAllowanceFailed();\n        forceApprove(token, spender, allowance - value);\n    }\n\n    /// @dev Calls either ERC20 or Dai `permit` for `token`, if unsuccessful forwards revert from external call.\n    function safePermit(IERC20 token, bytes calldata permit) internal {\n        if (!tryPermit(token, permit)) RevertReasonForwarder.reRevert();\n    }\n\n    function tryPermit(IERC20 token, bytes calldata permit) internal returns(bool) {\n        if (permit.length == 32 * 7) {\n            return _makeCalldataCall(token, IERC20Permit.permit.selector, permit);\n        }\n        if (permit.length == 32 * 8) {\n            return _makeCalldataCall(token, IDaiLikePermit.permit.selector, permit);\n        }\n        revert SafePermitBadLength();\n    }\n\n    function _makeCall(\n        IERC20 token,\n        bytes4 selector,\n        address to,\n        uint256 amount\n    ) private returns (bool success) {\n        /// @solidity memory-safe-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            mstore(add(data, 0x04), to)\n            mstore(add(data, 0x24), amount)\n            success := call(gas(), token, 0, data, 0x44, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n    }\n\n    function _makeCalldataCall(\n        IERC20 token,\n        bytes4 selector,\n        bytes calldata args\n    ) private returns (bool success) {\n        /// @solidity memory-safe-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            let len := add(4, args.length)\n            let data := mload(0x40)\n\n            mstore(data, selector)\n            calldatacopy(add(data, 0x04), args.offset, args.length)\n            success := call(gas(), token, 0, data, len, 0x0, 0x20)\n            if success {\n                switch returndatasize()\n                case 0 {\n                    success := gt(extcodesize(token), 0)\n                }\n                default {\n                    success := and(gt(returndatasize(), 31), eq(mload(0), 1))\n                }\n            }\n        }\n    }\n}\n"},"contracts/libraries/OrderSaltParser.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title Library for parsing parameters from salt.\nlibrary OrderSaltParser {\n    uint256 private constant _TIME_START_MASK        = 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000; // prettier-ignore\n    uint256 private constant _DURATION_MASK          = 0x00000000FFFFFF00000000000000000000000000000000000000000000000000; // prettier-ignore\n    uint256 private constant _INITIAL_RATE_BUMP_MASK = 0x00000000000000FFFFFF00000000000000000000000000000000000000000000; // prettier-ignore\n    uint256 private constant _FEE_MASK               = 0x00000000000000000000FFFFFFFF000000000000000000000000000000000000; // prettier-ignore\n    uint256 private constant _SALT_MASK              = 0x0000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore\n\n    uint256 private constant _TIME_START_SHIFT = 224; // orderTimeMask 224-255\n    uint256 private constant _DURATION_SHIFT = 200; // durationMask 200-223\n    uint256 private constant _INITIAL_RATE_BUMP_SHIFT = 176; // initialRateMask 176-200\n    uint256 private constant _FEE_SHIFT = 144; // orderFee 144-175\n\n    function getStartTime(uint256 salt) internal pure returns (uint256) {\n        return (salt & _TIME_START_MASK) >> _TIME_START_SHIFT;\n    }\n\n    function getDuration(uint256 salt) internal pure returns (uint256) {\n        return (salt & _DURATION_MASK) >> _DURATION_SHIFT;\n    }\n\n    function getInitialRateBump(uint256 salt) internal pure returns (uint256) {\n        return (salt & _INITIAL_RATE_BUMP_MASK) >> _INITIAL_RATE_BUMP_SHIFT;\n    }\n\n    function getFee(uint256 salt) internal pure returns (uint256) {\n        return (salt & _FEE_MASK) >> _FEE_SHIFT;\n    }\n\n    function getSalt(uint256 salt) internal pure returns (uint256) {\n        return salt & _SALT_MASK;\n    }\n}\n"},"contracts/libraries/TakingFee.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary TakingFee {\n    type Data is uint256;\n\n    uint256 internal constant _TAKING_FEE_BASE = 1e9;\n    uint256 private constant _TAKING_FEE_RATIO_OFFSET = 160;\n\n    function init(address receiver_, uint256 ratio_) internal pure returns (Data) {\n        if (ratio_ == 0) {\n            return Data.wrap(uint160(receiver_));\n        }\n        return Data.wrap(uint160(receiver_) | (ratio_ << _TAKING_FEE_RATIO_OFFSET));\n    }\n\n    function enabled(Data self) internal pure returns (bool) {\n        return ratio(self) != 0;\n    }\n\n    function ratio(Data self) internal pure returns (uint256) {\n        return uint32(Data.unwrap(self) >> _TAKING_FEE_RATIO_OFFSET);\n    }\n\n    function receiver(Data self) internal pure returns (address) {\n        return address(uint160(Data.unwrap(self)));\n    }\n}\n"},"@1inch/solidity-utils/contracts/interfaces/IDaiLikePermit.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v1;\n\ninterface IDaiLikePermit {\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"},"@openzeppelin/contracts/interfaces/IERC1271.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"},"contracts/interfaces/IResolver.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../libraries/DynamicSuffix.sol\";\n\ninterface IResolver {\n    function resolveOrders(address resolver, bytes calldata tokensAndAmounts, bytes calldata data) external;\n}\n"},"contracts/FeeBankCharger.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./interfaces/IFeeBankCharger.sol\";\nimport \"./FeeBank.sol\";\n\ncontract FeeBankCharger is IFeeBankCharger {\n    error OnlyFeeBankAccess();\n    error NotEnoughCredit();\n\n    IFeeBank public immutable feeBank;\n    mapping(address => uint256) private _creditAllowance;\n\n    modifier onlyFeeBank() {\n        if (msg.sender != address(feeBank)) revert OnlyFeeBankAccess();\n        _;\n    }\n\n    constructor(IERC20 token) {\n        feeBank = new FeeBank(this, token, msg.sender);\n    }\n\n    function availableCredit(address account) external view returns (uint256) {\n        return _creditAllowance[account];\n    }\n\n    function increaseAvailableCredit(address account, uint256 amount) external onlyFeeBank returns (uint256 allowance) {\n        allowance = _creditAllowance[account];\n        allowance += amount;\n        _creditAllowance[account] = allowance;\n    }\n\n    function decreaseAvailableCredit(address account, uint256 amount) external onlyFeeBank returns (uint256 allowance) {\n        allowance = _creditAllowance[account];\n        allowance -= amount;\n        _creditAllowance[account] = allowance;\n    }\n\n    function _chargeFee(address account, uint256 fee) internal {\n        if (fee > 0) {\n            uint256 currentAllowance = _creditAllowance[account];\n            if (currentAllowance < fee) revert NotEnoughCredit();\n            unchecked {\n                _creditAllowance[account] = currentAllowance - fee;\n            }\n        }\n    }\n}\n"},"contracts/libraries/DynamicSuffix.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./Address.sol\";\nimport \"./TakingFee.sol\";\n\n// layout of dynamic suffix is as follows:\n// 0x00 - 0x19: totalFee\n// 0x20 - 0x39: resolver\n// 0x40 - 0x59: token\n// 0x60 - 0x79: rateBump\n// 0x80 - 0x99: takingFee\n// 0xa0 - 0x..: tokensAndAmounts bytes\n// 0x.. - 0x..: tokensAndAmounts length in bytes\nlibrary DynamicSuffix {\n    struct Data {\n        uint256 totalFee;\n        Address resolver;\n        Address token;\n        uint256 rateBump;\n        TakingFee.Data takingFee;\n    }\n\n    uint256 internal constant _STATIC_DATA_SIZE = 0xa0;\n\n    function decodeSuffix(bytes calldata cd) internal pure returns(Data calldata suffix, bytes calldata tokensAndAmounts, bytes calldata interaction) {\n        assembly {\n            let lengthOffset := sub(add(cd.offset, cd.length), 0x20)\n            tokensAndAmounts.length := calldataload(lengthOffset)\n            tokensAndAmounts.offset := sub(lengthOffset, tokensAndAmounts.length)\n            suffix := sub(tokensAndAmounts.offset, _STATIC_DATA_SIZE)\n            interaction.offset := add(cd.offset, 1)\n            interaction.length := sub(suffix, interaction.offset)\n        }\n    }\n}\n"},"@openzeppelin/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"@1inch/limit-order-protocol-contract/contracts/interfaces/IInteractionNotificationReceiver.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\npragma abicoder v1;\n\n/**\n * @title Interface for interactor which acts after `taker -> maker` transfers.\n * @notice The order filling steps are `preInteraction` =>` Transfer \"maker -> taker\"` => **`Interaction`** => `Transfer \"taker -> maker\"` => `postInteraction`\n */\ninterface IInteractionNotificationReceiver {\n    /**\n     * @notice Callback method that gets called after all funds transfers\n     * @param taker Taker address (tx sender)\n     * @param makingAmount Actual making amount\n     * @param takingAmount Actual taking amount\n     * @param interactionData Interaction calldata\n     * @return offeredTakingAmount Suggested amount. Order is filled with this amount if maker or taker getter functions are not defined.\n     */\n    function fillOrderInteraction(\n        address taker,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        bytes memory interactionData\n    ) external returns(uint256 offeredTakingAmount);\n}\n"},"@1inch/solidity-utils/contracts/libraries/ECDSA.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v1;\n\nimport \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\n\nlibrary ECDSA {\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n    // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n    //\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n    // these malleable signatures as well.\n    uint256 private constant _S_BOUNDARY = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0 + 1;\n    uint256 private constant _COMPACT_S_MASK = 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    uint256 private constant _COMPACT_V_SHIFT = 255;\n\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (address signer) {\n        /// @solidity memory-safe-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            if lt(s, _S_BOUNDARY) {\n                let ptr := mload(0x40)\n\n                mstore(ptr, hash)\n                mstore(add(ptr, 0x20), v)\n                mstore(add(ptr, 0x40), r)\n                mstore(add(ptr, 0x60), s)\n                mstore(0, 0)\n                pop(staticcall(gas(), 0x1, ptr, 0x80, 0, 0x20))\n                signer := mload(0)\n            }\n        }\n    }\n\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal view returns (address signer) {\n        /// @solidity memory-safe-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            let s := and(vs, _COMPACT_S_MASK)\n            if lt(s, _S_BOUNDARY) {\n                let ptr := mload(0x40)\n\n                mstore(ptr, hash)\n                mstore(add(ptr, 0x20), add(27, shr(_COMPACT_V_SHIFT, vs)))\n                mstore(add(ptr, 0x40), r)\n                mstore(add(ptr, 0x60), s)\n                mstore(0, 0)\n                pop(staticcall(gas(), 0x1, ptr, 0x80, 0, 0x20))\n                signer := mload(0)\n            }\n        }\n    }\n\n    /// @dev WARNING!!!\n    /// There is a known signature malleability issue with two representations of signatures!\n    /// Even though this function is able to verify both standard 65-byte and compact 64-byte EIP-2098 signatures\n    /// one should never use raw signatures for any kind of invalidation logic in their code.\n    /// As the standard and compact representations are interchangeable any invalidation logic that relies on\n    /// signature uniqueness will get rekt.\n    /// More info: https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-4h98-2769-gh6h\n    function recover(bytes32 hash, bytes calldata signature) internal view returns (address signer) {\n        /// @solidity memory-safe-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            // memory[ptr:ptr+0x80] = (hash, v, r, s)\n            switch signature.length\n            case 65 {\n                // memory[ptr+0x20:ptr+0x80] = (v, r, s)\n                mstore(add(ptr, 0x20), byte(0, calldataload(add(signature.offset, 0x40))))\n                calldatacopy(add(ptr, 0x40), signature.offset, 0x40)\n            }\n            case 64 {\n                // memory[ptr+0x20:ptr+0x80] = (v, r, s)\n                let vs := calldataload(add(signature.offset, 0x20))\n                mstore(add(ptr, 0x20), add(27, shr(_COMPACT_V_SHIFT, vs)))\n                calldatacopy(add(ptr, 0x40), signature.offset, 0x20)\n                mstore(add(ptr, 0x60), and(vs, _COMPACT_S_MASK))\n            }\n            default {\n                ptr := 0\n            }\n\n            if ptr {\n                if lt(mload(add(ptr, 0x60)), _S_BOUNDARY) {\n                    // memory[ptr:ptr+0x20] = (hash)\n                    mstore(ptr, hash)\n\n                    mstore(0, 0)\n                    pop(staticcall(gas(), 0x1, ptr, 0x80, 0, 0x20))\n                    signer := mload(0)\n                }\n            }\n        }\n    }\n\n    function recoverOrIsValidSignature(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        if (signer == address(0)) return false;\n        if ((signature.length == 64 || signature.length == 65) && recover(hash, signature) == signer) {\n            return true;\n        }\n        return isValidSignature(signer, hash, signature);\n    }\n\n    function recoverOrIsValidSignature(\n        address signer,\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (bool success) {\n        if (signer == address(0)) return false;\n        if (recover(hash, v, r, s) == signer) {\n            return true;\n        }\n        return isValidSignature(signer, hash, v, r, s);\n    }\n\n    function recoverOrIsValidSignature(\n        address signer,\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal view returns (bool success) {\n        if (signer == address(0)) return false;\n        if (recover(hash, r, vs) == signer) {\n            return true;\n        }\n        return isValidSignature(signer, hash, r, vs);\n    }\n\n    function recoverOrIsValidSignature65(\n        address signer,\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal view returns (bool success) {\n        if (signer == address(0)) return false;\n        if (recover(hash, r, vs) == signer) {\n            return true;\n        }\n        return isValidSignature65(signer, hash, r, vs);\n    }\n\n    function isValidSignature(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view returns (bool success) {\n        // (bool success, bytes memory data) = signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature));\n        // return success && data.length >= 4 && abi.decode(data, (bytes4)) == IERC1271.isValidSignature.selector;\n        bytes4 selector = IERC1271.isValidSignature.selector;\n        /// @solidity memory-safe-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            mstore(ptr, selector)\n            mstore(add(ptr, 0x04), hash)\n            mstore(add(ptr, 0x24), 0x40)\n            mstore(add(ptr, 0x44), signature.length)\n            calldatacopy(add(ptr, 0x64), signature.offset, signature.length)\n            if staticcall(gas(), signer, ptr, add(0x64, signature.length), 0, 0x20) {\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\n            }\n        }\n    }\n\n    function isValidSignature(\n        address signer,\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (bool success) {\n        bytes4 selector = IERC1271.isValidSignature.selector;\n        /// @solidity memory-safe-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            mstore(ptr, selector)\n            mstore(add(ptr, 0x04), hash)\n            mstore(add(ptr, 0x24), 0x40)\n            mstore(add(ptr, 0x44), 65)\n            mstore(add(ptr, 0x64), r)\n            mstore(add(ptr, 0x84), s)\n            mstore8(add(ptr, 0xa4), v)\n            if staticcall(gas(), signer, ptr, 0xa5, 0, 0x20) {\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\n            }\n        }\n    }\n\n    function isValidSignature(\n        address signer,\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal view returns (bool success) {\n        // (bool success, bytes memory data) = signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, abi.encodePacked(r, vs)));\n        // return success && data.length >= 4 && abi.decode(data, (bytes4)) == IERC1271.isValidSignature.selector;\n        bytes4 selector = IERC1271.isValidSignature.selector;\n        /// @solidity memory-safe-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            mstore(ptr, selector)\n            mstore(add(ptr, 0x04), hash)\n            mstore(add(ptr, 0x24), 0x40)\n            mstore(add(ptr, 0x44), 64)\n            mstore(add(ptr, 0x64), r)\n            mstore(add(ptr, 0x84), vs)\n            if staticcall(gas(), signer, ptr, 0xa4, 0, 0x20) {\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\n            }\n        }\n    }\n\n    function isValidSignature65(\n        address signer,\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal view returns (bool success) {\n        // (bool success, bytes memory data) = signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, abi.encodePacked(r, vs & ~uint256(1 << 255), uint8(vs >> 255))));\n        // return success && data.length >= 4 && abi.decode(data, (bytes4)) == IERC1271.isValidSignature.selector;\n        bytes4 selector = IERC1271.isValidSignature.selector;\n        /// @solidity memory-safe-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            mstore(ptr, selector)\n            mstore(add(ptr, 0x04), hash)\n            mstore(add(ptr, 0x24), 0x40)\n            mstore(add(ptr, 0x44), 65)\n            mstore(add(ptr, 0x64), r)\n            mstore(add(ptr, 0x84), and(vs, _COMPACT_S_MASK))\n            mstore8(add(ptr, 0xa4), add(27, shr(_COMPACT_V_SHIFT, vs)))\n            if staticcall(gas(), signer, ptr, 0xa5, 0, 0x20) {\n                success := and(eq(selector, mload(0)), eq(returndatasize(), 0x20))\n            }\n        }\n    }\n\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 res) {\n        // 32 is the length in bytes of hash, enforced by the type signature above\n        // return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n        /// @solidity memory-safe-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            mstore(0, 0x19457468657265756d205369676e6564204d6573736167653a0a333200000000) // \"\\x19Ethereum Signed Message:\\n32\"\n            mstore(28, hash)\n            res := keccak256(0, 60)\n        }\n    }\n\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 res) {\n        // return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        /// @solidity memory-safe-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n            mstore(ptr, 0x1901000000000000000000000000000000000000000000000000000000000000) // \"\\x19\\x01\"\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            res := keccak256(ptr, 66)\n        }\n    }\n}\n"},"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"},"@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"@1inch/solidity-utils/contracts/libraries/RevertReasonForwarder.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma abicoder v1;\n\n/// @title Revert reason forwarder.\nlibrary RevertReasonForwarder {\n    /// @dev Forwards latest externall call revert.\n    function reRevert() internal pure {\n        // bubble up revert reason from latest external call\n        /// @solidity memory-safe-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n            returndatacopy(ptr, 0, returndatasize())\n            revert(ptr, returndatasize())\n        }\n    }\n}\n"},"contracts/FeeBank.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@1inch/solidity-utils/contracts/libraries/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/IFeeBankCharger.sol\";\nimport \"./interfaces/IFeeBank.sol\";\n\n/// @title Contract with fee mechanism for solvers to pay for using the system\ncontract FeeBank is IFeeBank, Ownable {\n    using SafeERC20 for IERC20;\n\n    IERC20 private immutable _token;\n    IFeeBankCharger private immutable _charger;\n\n    mapping(address => uint256) private _accountDeposits;\n\n    constructor(IFeeBankCharger charger, IERC20 inch, address owner) {\n        _charger = charger;\n        _token = inch;\n        transferOwnership(owner);\n    }\n\n    function availableCredit(address account) external view returns (uint256) {\n        return _charger.availableCredit(account);\n    }\n\n    /**\n     * @notice Increment sender's availableCredit in Settlement contract.\n     * @param amount The amount of 1INCH sender pay for incresing.\n     * @return totalAvailableCredit The total sender's availableCredit after deposit.\n     */\n    function deposit(uint256 amount) external returns (uint256 totalAvailableCredit) {\n        return _depositFor(msg.sender, amount);\n    }\n\n    /**\n     * @notice Increases account's availableCredit in Settlement contract.\n     * @param account The account whose availableCredit is increased by the sender.\n     * @param amount The amount of 1INCH sender pay for incresing.\n     * @return totalAvailableCredit The total account's availableCredit after deposit.\n     */\n    function depositFor(address account, uint256 amount) external returns (uint256 totalAvailableCredit) {\n        return _depositFor(account, amount);\n    }\n\n    /**\n     * @notice See {deposit}. This method uses permit for deposit without prior approves.\n     * @param amount The amount of 1INCH sender pay for incresing.\n     * @param permit The data with sender's permission via token.\n     * @return totalAvailableCredit The total sender's availableCredit after deposit.\n     */\n    function depositWithPermit(uint256 amount, bytes calldata permit) external returns (uint256 totalAvailableCredit) {\n        return depositForWithPermit(msg.sender, amount, permit);\n    }\n\n    /**\n     * @notice See {depositFor} and {depositWithPermit}.\n     */\n    function depositForWithPermit(\n        address account,\n        uint256 amount,\n        bytes calldata permit\n    ) public returns (uint256 totalAvailableCredit) {\n        _token.safePermit(permit);\n        return _depositFor(account, amount);\n    }\n\n    /**\n     * @notice Returns unspent availableCredit.\n     * @param amount The amount of 1INCH sender returns.\n     * @return totalAvailableCredit The total sender's availableCredit after withdrawal.\n     */\n    function withdraw(uint256 amount) external returns (uint256 totalAvailableCredit) {\n        return _withdrawTo(msg.sender, amount);\n    }\n\n    /**\n     * @notice Returns unspent availableCredit to specific account.\n     * @param account The account which get withdrawaled tokens.\n     * @param amount The amount of withdrawaled tokens.\n     * @return totalAvailableCredit The total sender's availableCredit after withdrawal.\n     */\n    function withdrawTo(address account, uint256 amount) external returns (uint256 totalAvailableCredit) {\n        return _withdrawTo(account, amount);\n    }\n\n    /**\n     * @notice Admin method returns commissions spent by users.\n     * @param accounts Accounts whose commissions are being withdrawn.\n     * @return totalAccountFees The total amount of accounts commissions.\n     */\n    function gatherFees(address[] memory accounts) external onlyOwner returns (uint256 totalAccountFees) {\n        uint256 accountsLength = accounts.length;\n        for (uint256 i = 0; i < accountsLength; ++i) {\n            address account = accounts[i];\n            uint256 accountDeposit = _accountDeposits[account];\n            uint256 availableCredit_ = _charger.availableCredit(account);\n            _accountDeposits[account] = availableCredit_;\n            totalAccountFees += accountDeposit - availableCredit_;\n        }\n        _token.safeTransfer(msg.sender, totalAccountFees);\n    }\n\n    function _depositFor(address account, uint256 amount) internal returns (uint256 totalAvailableCredit) {\n        _token.safeTransferFrom(msg.sender, address(this), amount);\n        _accountDeposits[account] += amount;\n        totalAvailableCredit = _charger.increaseAvailableCredit(account, amount);\n    }\n\n    function _withdrawTo(address account, uint256 amount) internal returns (uint256 totalAvailableCredit) {\n        totalAvailableCredit = _charger.decreaseAvailableCredit(msg.sender, amount);\n        _accountDeposits[msg.sender] -= amount;\n        _token.safeTransfer(account, amount);\n    }\n}\n"},"@1inch/limit-order-protocol-contract/contracts/interfaces/IOrderMixin.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../OrderLib.sol\";\n\ninterface IOrderMixin {\n    /**\n     * @notice Returns unfilled amount for order. Throws if order does not exist\n     * @param orderHash Order's hash. Can be obtained by the `hashOrder` function\n     * @return amount Unfilled amount\n     */\n    function remaining(bytes32 orderHash) external view returns(uint256 amount);\n\n    /**\n     * @notice Returns unfilled amount for order\n     * @param orderHash Order's hash. Can be obtained by the `hashOrder` function\n     * @return rawAmount Unfilled amount of order plus one if order exists. Otherwise 0\n     */\n    function remainingRaw(bytes32 orderHash) external view returns(uint256 rawAmount);\n\n    /**\n     * @notice Same as `remainingRaw` but for multiple orders\n     * @param orderHashes Array of hashes\n     * @return rawAmounts Array of amounts for each order plus one if order exists or 0 otherwise\n     */\n    function remainingsRaw(bytes32[] memory orderHashes) external view returns(uint256[] memory rawAmounts);\n\n    /**\n     * @notice Checks order predicate\n     * @param order Order to check predicate for\n     * @return result Predicate evaluation result. True if predicate allows to fill the order, false otherwise\n     */\n    function checkPredicate(OrderLib.Order calldata order) external view returns(bool result);\n\n    /**\n     * @notice Returns order hash according to EIP712 standard\n     * @param order Order to get hash for\n     * @return orderHash Hash of the order\n     */\n    function hashOrder(OrderLib.Order calldata order) external view returns(bytes32 orderHash);\n\n    /**\n     * @notice Delegates execution to custom implementation. Could be used to validate if `transferFrom` works properly\n     * @dev The function always reverts and returns the simulation results in revert data.\n     * @param target Addresses that will be delegated\n     * @param data Data that will be passed to delegatee\n     */\n    function simulate(address target, bytes calldata data) external;\n\n    /**\n     * @notice Cancels order.\n     * @dev Order is cancelled by setting remaining amount to _ORDER_FILLED value\n     * @param order Order quote to cancel\n     * @return orderRemaining Unfilled amount of order before cancellation\n     * @return orderHash Hash of the filled order\n     */\n    function cancelOrder(OrderLib.Order calldata order) external returns(uint256 orderRemaining, bytes32 orderHash);\n\n    /**\n     * @notice Fills an order. If one doesn't exist (first fill) it will be created using order.makerAssetData\n     * @param order Order quote to fill\n     * @param signature Signature to confirm quote ownership\n     * @param interaction A call data for InteractiveNotificationReceiver. Taker may execute interaction after getting maker assets and before sending taker assets.\n     * @param makingAmount Making amount\n     * @param takingAmount Taking amount\n     * @param skipPermitAndThresholdAmount Specifies maximum allowed takingAmount when takingAmount is zero, otherwise specifies minimum allowed makingAmount. Top-most bit specifies whether taker wants to skip maker's permit.\n     * @return actualMakingAmount Actual amount transferred from maker to taker\n     * @return actualTakingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     */\n    function fillOrder(\n        OrderLib.Order calldata order,\n        bytes calldata signature,\n        bytes calldata interaction,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 skipPermitAndThresholdAmount\n    ) external payable returns(uint256 actualMakingAmount, uint256 actualTakingAmount, bytes32 orderHash);\n\n    /**\n     * @notice Same as `fillOrderTo` but calls permit first,\n     * allowing to approve token spending and make a swap in one transaction.\n     * Also allows to specify funds destination instead of `msg.sender`\n     * @dev See tests for examples\n     * @param order Order quote to fill\n     * @param signature Signature to confirm quote ownership\n     * @param interaction A call data for InteractiveNotificationReceiver. Taker may execute interaction after getting maker assets and before sending taker assets.\n     * @param makingAmount Making amount\n     * @param takingAmount Taking amount\n     * @param skipPermitAndThresholdAmount Specifies maximum allowed takingAmount when takingAmount is zero, otherwise specifies minimum allowed makingAmount. Top-most bit specifies whether taker wants to skip maker's permit.\n     * @param target Address that will receive swap funds\n     * @param permit Should consist of abiencoded token address and encoded `IERC20Permit.permit` call.\n     * @return actualMakingAmount Actual amount transferred from maker to taker\n     * @return actualTakingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     */\n    function fillOrderToWithPermit(\n        OrderLib.Order calldata order,\n        bytes calldata signature,\n        bytes calldata interaction,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 skipPermitAndThresholdAmount,\n        address target,\n        bytes calldata permit\n    ) external returns(uint256 actualMakingAmount, uint256 actualTakingAmount, bytes32 orderHash);\n\n    /**\n     * @notice Same as `fillOrder` but allows to specify funds destination instead of `msg.sender`\n     * @param order_ Order quote to fill\n     * @param signature Signature to confirm quote ownership\n     * @param interaction A call data for InteractiveNotificationReceiver. Taker may execute interaction after getting maker assets and before sending taker assets.\n     * @param makingAmount Making amount\n     * @param takingAmount Taking amount\n     * @param skipPermitAndThresholdAmount Specifies maximum allowed takingAmount when takingAmount is zero, otherwise specifies minimum allowed makingAmount. Top-most bit specifies whether taker wants to skip maker's permit.\n     * @param target Address that will receive swap funds\n     * @return actualMakingAmount Actual amount transferred from maker to taker\n     * @return actualTakingAmount Actual amount transferred from taker to maker\n     * @return orderHash Hash of the filled order\n     */\n    function fillOrderTo(\n        OrderLib.Order calldata order_,\n        bytes calldata signature,\n        bytes calldata interaction,\n        uint256 makingAmount,\n        uint256 takingAmount,\n        uint256 skipPermitAndThresholdAmount,\n        address target\n    ) external payable returns(uint256 actualMakingAmount, uint256 actualTakingAmount, bytes32 orderHash);\n}\n"},"@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"},"contracts/interfaces/IFeeBank.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IFeeBank {\n    function deposit(uint256 amount) external returns (uint256 totalAvailableCredit);\n}\n"},"@1inch/limit-order-protocol-contract/contracts/OrderLib.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@1inch/solidity-utils/contracts/libraries/ECDSA.sol\";\n\nlibrary OrderLib {\n    struct Order {\n        uint256 salt;\n        address makerAsset;\n        address takerAsset;\n        address maker;\n        address receiver;\n        address allowedSender;  // equals to Zero address on public orders\n        uint256 makingAmount;\n        uint256 takingAmount;\n        uint256 offsets;\n        // bytes makerAssetData;\n        // bytes takerAssetData;\n        // bytes getMakingAmount; // this.staticcall(abi.encodePacked(bytes, swapTakerAmount)) => (swapMakerAmount)\n        // bytes getTakingAmount; // this.staticcall(abi.encodePacked(bytes, swapMakerAmount)) => (swapTakerAmount)\n        // bytes predicate;       // this.staticcall(bytes) => (bool)\n        // bytes permit;          // On first fill: permit.1.call(abi.encodePacked(permit.selector, permit.2))\n        // bytes preInteraction;\n        // bytes postInteraction;\n        bytes interactions; // concat(makerAssetData, takerAssetData, getMakingAmount, getTakingAmount, predicate, permit, preIntercation, postInteraction)\n    }\n\n    bytes32 constant internal _LIMIT_ORDER_TYPEHASH = keccak256(\n        \"Order(\"\n            \"uint256 salt,\"\n            \"address makerAsset,\"\n            \"address takerAsset,\"\n            \"address maker,\"\n            \"address receiver,\"\n            \"address allowedSender,\"\n            \"uint256 makingAmount,\"\n            \"uint256 takingAmount,\"\n            \"uint256 offsets,\"\n            \"bytes interactions\"\n        \")\"\n    );\n\n    enum DynamicField {\n        MakerAssetData,\n        TakerAssetData,\n        GetMakingAmount,\n        GetTakingAmount,\n        Predicate,\n        Permit,\n        PreInteraction,\n        PostInteraction\n    }\n\n    function getterIsFrozen(bytes calldata getter) internal pure returns(bool) {\n        return getter.length == 1 && getter[0] == \"x\";\n    }\n\n    function _get(Order calldata order, DynamicField field) private pure returns(bytes calldata) {\n        uint256 bitShift = uint256(field) << 5; // field * 32\n        return order.interactions[\n            uint32((order.offsets << 32) >> bitShift):\n            uint32(order.offsets >> bitShift)\n        ];\n    }\n\n    function makerAssetData(Order calldata order) internal pure returns(bytes calldata) {\n        return _get(order, DynamicField.MakerAssetData);\n    }\n\n    function takerAssetData(Order calldata order) internal pure returns(bytes calldata) {\n        return _get(order, DynamicField.TakerAssetData);\n    }\n\n    function getMakingAmount(Order calldata order) internal pure returns(bytes calldata) {\n        return _get(order, DynamicField.GetMakingAmount);\n    }\n\n    function getTakingAmount(Order calldata order) internal pure returns(bytes calldata) {\n        return _get(order, DynamicField.GetTakingAmount);\n    }\n\n    function predicate(Order calldata order) internal pure returns(bytes calldata) {\n        return _get(order, DynamicField.Predicate);\n    }\n\n    function permit(Order calldata order) internal pure returns(bytes calldata) {\n        return _get(order, DynamicField.Permit);\n    }\n\n    function preInteraction(Order calldata order) internal pure returns(bytes calldata) {\n        return _get(order, DynamicField.PreInteraction);\n    }\n\n    function postInteraction(Order calldata order) internal pure returns(bytes calldata) {\n        return _get(order, DynamicField.PostInteraction);\n    }\n\n    function hash(Order calldata order, bytes32 domainSeparator) internal pure returns(bytes32 result) {\n        bytes calldata interactions = order.interactions;\n        bytes32 typehash = _LIMIT_ORDER_TYPEHASH;\n        /// @solidity memory-safe-assembly\n        assembly { // solhint-disable-line no-inline-assembly\n            let ptr := mload(0x40)\n\n            // keccak256(abi.encode(_LIMIT_ORDER_TYPEHASH, orderWithoutInteractions, keccak256(order.interactions)));\n            calldatacopy(ptr, interactions.offset, interactions.length)\n            mstore(add(ptr, 0x140), keccak256(ptr, interactions.length))\n            calldatacopy(add(ptr, 0x20), order, 0x120)\n            mstore(ptr, typehash)\n            result := keccak256(ptr, 0x160)\n        }\n        result = ECDSA.toTypedDataHash(domainSeparator, result);\n    }\n}\n"},"contracts/interfaces/IFeeBankCharger.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IFeeBankCharger {\n    function availableCredit(address account) external view returns (uint256);\n    function increaseAvailableCredit(address account, uint256 amount) external returns (uint256 allowance);\n    function decreaseAvailableCredit(address account, uint256 amount) external returns (uint256 allowance);\n}\n"}},"settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":1000000},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}}},"ABI":"[{\"inputs\":[{\"internalType\":\"contract IOrderMixin\",\"name\":\"limitOrderProtocol\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessDenied\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedExternalCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ForceApproveFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectCalldataParams\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughCredit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyFeeBankAccess\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ResolverIsNotWhitelisted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongInteractionTarget\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"availableCredit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"decreaseAvailableCredit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBank\",\"outputs\":[{\"internalType\":\"contract IFeeBank\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"takingAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"interactiveData\",\"type\":\"bytes\"}],\"name\":\"fillOrderInteraction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"increaseAvailableCredit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"settleOrders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Settlement","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":1,"Runs":1000000,"ConstructorArguments":"0x0000000000000000000000001111111254eeb25477b68fb85ed929f73a960582000000000000000000000000111111111117dc0aa78b770fa6a738034120c302","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}