{"expiry":1699512416,"data":[{"SourceCode":"# @version 0.3.1\r\n# (c) Curve.Fi, 2021\r\n# Pool for two crypto assets\r\n\r\n# Universal implementation which can use both ETH and ERC20s\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\ninterface Factory:\r\n    def admin() -> address: view\r\n    def fee_receiver() -> address: view\r\n\r\ninterface CurveToken:\r\n    def totalSupply() -> uint256: view\r\n    def mint(_to: address, _value: uint256) -> bool: nonpayable\r\n    def mint_relative(_to: address, frac: uint256) -> uint256: nonpayable\r\n    def burnFrom(_to: address, _value: uint256) -> bool: nonpayable\r\n\r\ninterface WETH:\r\n    def deposit(): payable\r\n    def withdraw(_amount: uint256): nonpayable\r\n\r\n\r\n# Events\r\nevent TokenExchange:\r\n    buyer: indexed(address)\r\n    sold_id: uint256\r\n    tokens_sold: uint256\r\n    bought_id: uint256\r\n    tokens_bought: uint256\r\n\r\nevent AddLiquidity:\r\n    provider: indexed(address)\r\n    token_amounts: uint256[N_COINS]\r\n    fee: uint256\r\n    token_supply: uint256\r\n\r\nevent RemoveLiquidity:\r\n    provider: indexed(address)\r\n    token_amounts: uint256[N_COINS]\r\n    token_supply: uint256\r\n\r\nevent RemoveLiquidityOne:\r\n    provider: indexed(address)\r\n    token_amount: uint256\r\n    coin_index: uint256\r\n    coin_amount: uint256\r\n\r\nevent CommitNewParameters:\r\n    deadline: indexed(uint256)\r\n    admin_fee: uint256\r\n    mid_fee: uint256\r\n    out_fee: uint256\r\n    fee_gamma: uint256\r\n    allowed_extra_profit: uint256\r\n    adjustment_step: uint256\r\n    ma_half_time: uint256\r\n\r\nevent NewParameters:\r\n    admin_fee: uint256\r\n    mid_fee: uint256\r\n    out_fee: uint256\r\n    fee_gamma: uint256\r\n    allowed_extra_profit: uint256\r\n    adjustment_step: uint256\r\n    ma_half_time: uint256\r\n\r\nevent RampAgamma:\r\n    initial_A: uint256\r\n    future_A: uint256\r\n    initial_gamma: uint256\r\n    future_gamma: uint256\r\n    initial_time: uint256\r\n    future_time: uint256\r\n\r\nevent StopRampA:\r\n    current_A: uint256\r\n    current_gamma: uint256\r\n    time: uint256\r\n\r\nevent ClaimAdminFee:\r\n    admin: indexed(address)\r\n    tokens: uint256\r\n\r\n\r\nADMIN_ACTIONS_DELAY: constant(uint256) = 3 * 86400\r\nMIN_RAMP_TIME: constant(uint256) = 86400\r\n\r\nMAX_ADMIN_FEE: constant(uint256) = 10 * 10 ** 9\r\nMIN_FEE: constant(uint256) = 5 * 10 ** 5  # 0.5 bps\r\nMAX_FEE: constant(uint256) = 10 * 10 ** 9\r\nMAX_A_CHANGE: constant(uint256) = 10\r\nNOISE_FEE: constant(uint256) = 10**5  # 0.1 bps\r\n\r\nMIN_GAMMA: constant(uint256) = 10**10\r\nMAX_GAMMA: constant(uint256) = 2 * 10**16\r\n\r\nMIN_A: constant(uint256) = N_COINS**N_COINS * A_MULTIPLIER / 10\r\nMAX_A: constant(uint256) = N_COINS**N_COINS * A_MULTIPLIER * 100000\r\n\r\nEXP_PRECISION: constant(uint256) = 10**10\r\n\r\nN_COINS: constant(int128) = 2\r\nPRECISION: constant(uint256) = 10 ** 18  # The precision to convert to\r\nA_MULTIPLIER: constant(uint256) = 10000\r\n\r\n\r\n# Implementation can be changed by changing this constant\r\nWETH20: immutable(address)\r\n\r\n\r\ntoken: public(address)\r\ncoins: public(address[N_COINS])\r\n\r\nprice_scale: public(uint256)   # Internal price scale\r\n_price_oracle: uint256  # Price target given by MA\r\n\r\nlast_prices: public(uint256)\r\nlast_prices_timestamp: public(uint256)\r\n\r\ninitial_A_gamma: public(uint256)\r\nfuture_A_gamma: public(uint256)\r\ninitial_A_gamma_time: public(uint256)\r\nfuture_A_gamma_time: public(uint256)\r\n\r\nallowed_extra_profit: public(uint256)  # 2 * 10**12 - recommended value\r\nfuture_allowed_extra_profit: public(uint256)\r\n\r\nfee_gamma: public(uint256)\r\nfuture_fee_gamma: public(uint256)\r\n\r\nadjustment_step: public(uint256)\r\nfuture_adjustment_step: public(uint256)\r\n\r\nma_half_time: public(uint256)\r\nfuture_ma_half_time: public(uint256)\r\n\r\nmid_fee: public(uint256)\r\nout_fee: public(uint256)\r\nadmin_fee: public(uint256)\r\nfuture_mid_fee: public(uint256)\r\nfuture_out_fee: public(uint256)\r\nfuture_admin_fee: public(uint256)\r\n\r\nbalances: public(uint256[N_COINS])\r\nD: public(uint256)\r\n\r\nfactory: public(address)\r\n\r\nxcp_profit: public(uint256)\r\nxcp_profit_a: public(uint256)  # Full profit at last claim of admin fees\r\nvirtual_price: public(uint256)  # Cached (fast to read) virtual price also used internally\r\nnot_adjusted: bool\r\n\r\nadmin_actions_deadline: public(uint256)\r\n\r\n# This must be changed for different N_COINS\r\n# For example:\r\n# N_COINS = 3 -> 1  (10**18 -> 10**18)\r\n# N_COINS = 4 -> 10**8  (10**18 -> 10**10)\r\n# PRICE_PRECISION_MUL: constant(uint256) = 1\r\nPRECISIONS: uint256  # packed\r\n\r\n\r\n@external\r\ndef __init__(_weth: address):\r\n    WETH20 = _weth\r\n    self.mid_fee = 22022022\r\n\r\n\r\n@payable\r\n@external\r\ndef __default__():\r\n    pass\r\n\r\n\r\n# Internal Functions\r\n\r\n@internal\r\n@view\r\ndef _get_precisions() -> uint256[2]:\r\n    p0: uint256 = self.PRECISIONS\r\n    p1: uint256 = 10 ** shift(p0, -8)\r\n    p0 = 10 ** bitwise_and(p0, 255)\r\n    return [p0, p1]\r\n\r\n\r\n@internal\r\n@view\r\ndef xp() -> uint256[N_COINS]:\r\n    precisions: uint256[2] = self._get_precisions()\r\n    return [self.balances[0] * precisions[0],\r\n            self.balances[1] * precisions[1] * self.price_scale / PRECISION]\r\n\r\n\r\n@view\r\n@internal\r\ndef _A_gamma() -> uint256[2]:\r\n    t1: uint256 = self.future_A_gamma_time\r\n\r\n    A_gamma_1: uint256 = self.future_A_gamma\r\n    gamma1: uint256 = bitwise_and(A_gamma_1, 2**128-1)\r\n    A1: uint256 = shift(A_gamma_1, -128)\r\n\r\n    if block.timestamp < t1:\r\n        # handle ramping up and down of A\r\n        A_gamma_0: uint256 = self.initial_A_gamma\r\n        t0: uint256 = self.initial_A_gamma_time\r\n\r\n        # Less readable but more compact way of writing and converting to uint256\r\n        # gamma0: uint256 = bitwise_and(A_gamma_0, 2**128-1)\r\n        # A0: uint256 = shift(A_gamma_0, -128)\r\n        # A1 = A0 + (A1 - A0) * (block.timestamp - t0) / (t1 - t0)\r\n        # gamma1 = gamma0 + (gamma1 - gamma0) * (block.timestamp - t0) / (t1 - t0)\r\n\r\n        t1 -= t0\r\n        t0 = block.timestamp - t0\r\n        t2: uint256 = t1 - t0\r\n\r\n        A1 = (shift(A_gamma_0, -128) * t2 + A1 * t0) / t1\r\n        gamma1 = (bitwise_and(A_gamma_0, 2**128-1) * t2 + gamma1 * t0) / t1\r\n\r\n    return [A1, gamma1]\r\n\r\n\r\n@internal\r\n@view\r\ndef _fee(xp: uint256[N_COINS]) -> uint256:\r\n    \"\"\"\r\n    f = fee_gamma / (fee_gamma + (1 - K))\r\n    where\r\n    K = prod(x) / (sum(x) / N)**N\r\n    (all normalized to 1e18)\r\n    \"\"\"\r\n    fee_gamma: uint256 = self.fee_gamma\r\n    f: uint256 = xp[0] + xp[1]  # sum\r\n    f = fee_gamma * 10**18 / (\r\n        fee_gamma + 10**18 - (10**18 * N_COINS**N_COINS) * xp[0] / f * xp[1] / f\r\n    )\r\n    return (self.mid_fee * f + self.out_fee * (10**18 - f)) / 10**18\r\n\r\n\r\n### Math functions\r\n@internal\r\n@pure\r\ndef geometric_mean(unsorted_x: uint256[N_COINS], sort: bool) -> uint256:\r\n    \"\"\"\r\n    (x[0] * x[1] * ...) ** (1/N)\r\n    \"\"\"\r\n    x: uint256[N_COINS] = unsorted_x\r\n    if sort and x[0] < x[1]:\r\n        x = [unsorted_x[1], unsorted_x[0]]\r\n    D: uint256 = x[0]\r\n    diff: uint256 = 0\r\n    for i in range(255):\r\n        D_prev: uint256 = D\r\n        # tmp: uint256 = 10**18\r\n        # for _x in x:\r\n        #     tmp = tmp * _x / D\r\n        # D = D * ((N_COINS - 1) * 10**18 + tmp) / (N_COINS * 10**18)\r\n        # line below makes it for 2 coins\r\n        D = (D + x[0] * x[1] / D) / N_COINS\r\n        if D > D_prev:\r\n            diff = D - D_prev\r\n        else:\r\n            diff = D_prev - D\r\n        if diff <= 1 or diff * 10**18 < D:\r\n            return D\r\n    raise \"Did not converge\"\r\n\r\n\r\n@internal\r\n@view\r\ndef newton_D(ANN: uint256, gamma: uint256, x_unsorted: uint256[N_COINS]) -> uint256:\r\n    \"\"\"\r\n    Finding the invariant using Newton method.\r\n    ANN is higher by the factor A_MULTIPLIER\r\n    ANN is already A * N**N\r\n\r\n    Currently uses 60k gas\r\n    \"\"\"\r\n    # Safety checks\r\n    assert ANN > MIN_A - 1 and ANN < MAX_A + 1  # dev: unsafe values A\r\n    assert gamma > MIN_GAMMA - 1 and gamma < MAX_GAMMA + 1  # dev: unsafe values gamma\r\n\r\n    # Initial value of invariant D is that for constant-product invariant\r\n    x: uint256[N_COINS] = x_unsorted\r\n    if x[0] < x[1]:\r\n        x = [x_unsorted[1], x_unsorted[0]]\r\n\r\n    assert x[0] > 10**9 - 1 and x[0] < 10**15 * 10**18 + 1  # dev: unsafe values x[0]\r\n    assert x[1] * 10**18 / x[0] > 10**14-1  # dev: unsafe values x[i] (input)\r\n\r\n    D: uint256 = N_COINS * self.geometric_mean(x, False)\r\n    S: uint256 = x[0] + x[1]\r\n\r\n    for i in range(255):\r\n        D_prev: uint256 = D\r\n\r\n        # K0: uint256 = 10**18\r\n        # for _x in x:\r\n        #     K0 = K0 * _x * N_COINS / D\r\n        # collapsed for 2 coins\r\n        K0: uint256 = (10**18 * N_COINS**2) * x[0] / D * x[1] / D\r\n\r\n        _g1k0: uint256 = gamma + 10**18\r\n        if _g1k0 > K0:\r\n            _g1k0 = _g1k0 - K0 + 1\r\n        else:\r\n            _g1k0 = K0 - _g1k0 + 1\r\n\r\n        # D / (A * N**N) * _g1k0**2 / gamma**2\r\n        mul1: uint256 = 10**18 * D / gamma * _g1k0 / gamma * _g1k0 * A_MULTIPLIER / ANN\r\n\r\n        # 2*N*K0 / _g1k0\r\n        mul2: uint256 = (2 * 10**18) * N_COINS * K0 / _g1k0\r\n\r\n        neg_fprime: uint256 = (S + S * mul2 / 10**18) + mul1 * N_COINS / K0 - mul2 * D / 10**18\r\n\r\n        # D -= f / fprime\r\n        D_plus: uint256 = D * (neg_fprime + S) / neg_fprime\r\n        D_minus: uint256 = D*D / neg_fprime\r\n        if 10**18 > K0:\r\n            D_minus += D * (mul1 / neg_fprime) / 10**18 * (10**18 - K0) / K0\r\n        else:\r\n            D_minus -= D * (mul1 / neg_fprime) / 10**18 * (K0 - 10**18) / K0\r\n\r\n        if D_plus > D_minus:\r\n            D = D_plus - D_minus\r\n        else:\r\n            D = (D_minus - D_plus) / 2\r\n\r\n        diff: uint256 = 0\r\n        if D > D_prev:\r\n            diff = D - D_prev\r\n        else:\r\n            diff = D_prev - D\r\n        if diff * 10**14 < max(10**16, D):  # Could reduce precision for gas efficiency here\r\n            # Test that we are safe with the next newton_y\r\n            for _x in x:\r\n                frac: uint256 = _x * 10**18 / D\r\n                assert (frac > 10**16 - 1) and (frac < 10**20 + 1)  # dev: unsafe values x[i]\r\n            return D\r\n\r\n    raise \"Did not converge\"\r\n\r\n\r\n@internal\r\n@pure\r\ndef newton_y(ANN: uint256, gamma: uint256, x: uint256[N_COINS], D: uint256, i: uint256) -> uint256:\r\n    \"\"\"\r\n    Calculating x[i] given other balances x[0..N_COINS-1] and invariant D\r\n    ANN = A * N**N\r\n    \"\"\"\r\n    # Safety checks\r\n    assert ANN > MIN_A - 1 and ANN < MAX_A + 1  # dev: unsafe values A\r\n    assert gamma > MIN_GAMMA - 1 and gamma < MAX_GAMMA + 1  # dev: unsafe values gamma\r\n    assert D > 10**17 - 1 and D < 10**15 * 10**18 + 1 # dev: unsafe values D\r\n\r\n    x_j: uint256 = x[1 - i]\r\n    y: uint256 = D**2 / (x_j * N_COINS**2)\r\n    K0_i: uint256 = (10**18 * N_COINS) * x_j / D\r\n    # S_i = x_j\r\n\r\n    # frac = x_j * 1e18 / D => frac = K0_i / N_COINS\r\n    assert (K0_i > 10**16*N_COINS - 1) and (K0_i < 10**20*N_COINS + 1)  # dev: unsafe values x[i]\r\n\r\n    # x_sorted: uint256[N_COINS] = x\r\n    # x_sorted[i] = 0\r\n    # x_sorted = self.sort(x_sorted)  # From high to low\r\n    # x[not i] instead of x_sorted since x_soted has only 1 element\r\n\r\n    convergence_limit: uint256 = max(max(x_j / 10**14, D / 10**14), 100)\r\n\r\n    for j in range(255):\r\n        y_prev: uint256 = y\r\n\r\n        K0: uint256 = K0_i * y * N_COINS / D\r\n        S: uint256 = x_j + y\r\n\r\n        _g1k0: uint256 = gamma + 10**18\r\n        if _g1k0 > K0:\r\n            _g1k0 = _g1k0 - K0 + 1\r\n        else:\r\n            _g1k0 = K0 - _g1k0 + 1\r\n\r\n        # D / (A * N**N) * _g1k0**2 / gamma**2\r\n        mul1: uint256 = 10**18 * D / gamma * _g1k0 / gamma * _g1k0 * A_MULTIPLIER / ANN\r\n\r\n        # 2*K0 / _g1k0\r\n        mul2: uint256 = 10**18 + (2 * 10**18) * K0 / _g1k0\r\n\r\n        yfprime: uint256 = 10**18 * y + S * mul2 + mul1\r\n        _dyfprime: uint256 = D * mul2\r\n        if yfprime < _dyfprime:\r\n            y = y_prev / 2\r\n            continue\r\n        else:\r\n            yfprime -= _dyfprime\r\n        fprime: uint256 = yfprime / y\r\n\r\n        # y -= f / f_prime;  y = (y * fprime - f) / fprime\r\n        # y = (yfprime + 10**18 * D - 10**18 * S) // fprime + mul1 // fprime * (10**18 - K0) // K0\r\n        y_minus: uint256 = mul1 / fprime\r\n        y_plus: uint256 = (yfprime + 10**18 * D) / fprime + y_minus * 10**18 / K0\r\n        y_minus += 10**18 * S / fprime\r\n\r\n        if y_plus < y_minus:\r\n            y = y_prev / 2\r\n        else:\r\n            y = y_plus - y_minus\r\n\r\n        diff: uint256 = 0\r\n        if y > y_prev:\r\n            diff = y - y_prev\r\n        else:\r\n            diff = y_prev - y\r\n        if diff < max(convergence_limit, y / 10**14):\r\n            frac: uint256 = y * 10**18 / D\r\n            assert (frac > 10**16 - 1) and (frac < 10**20 + 1)  # dev: unsafe value for y\r\n            return y\r\n\r\n    raise \"Did not converge\"\r\n\r\n\r\n@internal\r\n@pure\r\ndef halfpow(power: uint256) -> uint256:\r\n    \"\"\"\r\n    1e18 * 0.5 ** (power/1e18)\r\n\r\n    Inspired by: https://github.com/balancer-labs/balancer-core/blob/master/contracts/BNum.sol#L128\r\n    \"\"\"\r\n    intpow: uint256 = power / 10**18\r\n    otherpow: uint256 = power - intpow * 10**18\r\n    if intpow > 59:\r\n        return 0\r\n    result: uint256 = 10**18 / (2**intpow)\r\n    if otherpow == 0:\r\n        return result\r\n\r\n    term: uint256 = 10**18\r\n    x: uint256 = 5 * 10**17\r\n    S: uint256 = 10**18\r\n    neg: bool = False\r\n\r\n    for i in range(1, 256):\r\n        K: uint256 = i * 10**18\r\n        c: uint256 = K - 10**18\r\n        if otherpow > c:\r\n            c = otherpow - c\r\n            neg = not neg\r\n        else:\r\n            c -= otherpow\r\n        term = term * (c * x / 10**18) / K\r\n        if neg:\r\n            S -= term\r\n        else:\r\n            S += term\r\n        if term < EXP_PRECISION:\r\n            return result * S / 10**18\r\n\r\n    raise \"Did not converge\"\r\n### end of Math functions\r\n\r\n\r\n@internal\r\n@view\r\ndef get_xcp(D: uint256) -> uint256:\r\n    x: uint256[N_COINS] = [D / N_COINS, D * PRECISION / (self.price_scale * N_COINS)]\r\n    return self.geometric_mean(x, True)\r\n\r\n\r\n@internal\r\ndef _claim_admin_fees():\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n\r\n    xcp_profit: uint256 = self.xcp_profit\r\n    xcp_profit_a: uint256 = self.xcp_profit_a\r\n\r\n    # Gulp here\r\n    for i in range(N_COINS):\r\n        coin: address = self.coins[i]\r\n        if coin == WETH20:\r\n            self.balances[i] = self.balance\r\n        else:\r\n            self.balances[i] = ERC20(coin).balanceOf(self)\r\n\r\n    vprice: uint256 = self.virtual_price\r\n\r\n    if xcp_profit > xcp_profit_a:\r\n        fees: uint256 = (xcp_profit - xcp_profit_a) * self.admin_fee / (2 * 10**10)\r\n        if fees > 0:\r\n            receiver: address = Factory(self.factory).fee_receiver()\r\n            if receiver != ZERO_ADDRESS:\r\n                frac: uint256 = vprice * 10**18 / (vprice - fees) - 10**18\r\n                claimed: uint256 = CurveToken(self.token).mint_relative(receiver, frac)\r\n                xcp_profit -= fees*2\r\n                self.xcp_profit = xcp_profit\r\n                log ClaimAdminFee(receiver, claimed)\r\n\r\n    total_supply: uint256 = CurveToken(self.token).totalSupply()\r\n\r\n    # Recalculate D b/c we gulped\r\n    D: uint256 = self.newton_D(A_gamma[0], A_gamma[1], self.xp())\r\n    self.D = D\r\n\r\n    self.virtual_price = 10**18 * self.get_xcp(D) / total_supply\r\n\r\n    if xcp_profit > xcp_profit_a:\r\n        self.xcp_profit_a = xcp_profit\r\n\r\n\r\n@internal\r\n@view\r\ndef internal_price_oracle() -> uint256:\r\n    price_oracle: uint256 = self._price_oracle\r\n    last_prices_timestamp: uint256 = self.last_prices_timestamp\r\n\r\n    if last_prices_timestamp < block.timestamp:\r\n        ma_half_time: uint256 = self.ma_half_time\r\n        last_prices: uint256 = self.last_prices\r\n        alpha: uint256 = self.halfpow((block.timestamp - last_prices_timestamp) * 10**18 / ma_half_time)\r\n        return (last_prices * (10**18 - alpha) + price_oracle * alpha) / 10**18\r\n\r\n    else:\r\n        return price_oracle\r\n\r\n\r\n@internal\r\ndef tweak_price(A_gamma: uint256[2],_xp: uint256[N_COINS], p_i: uint256, new_D: uint256):\r\n    price_oracle: uint256 = self._price_oracle\r\n    last_prices: uint256 = self.last_prices\r\n    price_scale: uint256 = self.price_scale\r\n    last_prices_timestamp: uint256 = self.last_prices_timestamp\r\n    p_new: uint256 = 0\r\n\r\n    if last_prices_timestamp < block.timestamp:\r\n        # MA update required\r\n        ma_half_time: uint256 = self.ma_half_time\r\n        alpha: uint256 = self.halfpow((block.timestamp - last_prices_timestamp) * 10**18 / ma_half_time)\r\n        price_oracle = (last_prices * (10**18 - alpha) + price_oracle * alpha) / 10**18\r\n        self._price_oracle = price_oracle\r\n        self.last_prices_timestamp = block.timestamp\r\n\r\n    D_unadjusted: uint256 = new_D  # Withdrawal methods know new D already\r\n    if new_D == 0:\r\n        # We will need this a few times (35k gas)\r\n        D_unadjusted = self.newton_D(A_gamma[0], A_gamma[1], _xp)\r\n\r\n    if p_i > 0:\r\n        last_prices = p_i\r\n\r\n    else:\r\n        # calculate real prices\r\n        __xp: uint256[N_COINS] = _xp\r\n        dx_price: uint256 = __xp[0] / 10**6\r\n        __xp[0] += dx_price\r\n        last_prices = price_scale * dx_price / (_xp[1] - self.newton_y(A_gamma[0], A_gamma[1], __xp, D_unadjusted, 1))\r\n\r\n    self.last_prices = last_prices\r\n\r\n    total_supply: uint256 = CurveToken(self.token).totalSupply()\r\n    old_xcp_profit: uint256 = self.xcp_profit\r\n    old_virtual_price: uint256 = self.virtual_price\r\n\r\n    # Update profit numbers without price adjustment first\r\n    xp: uint256[N_COINS] = [D_unadjusted / N_COINS, D_unadjusted * PRECISION / (N_COINS * price_scale)]\r\n    xcp_profit: uint256 = 10**18\r\n    virtual_price: uint256 = 10**18\r\n\r\n    if old_virtual_price > 0:\r\n        xcp: uint256 = self.geometric_mean(xp, True)\r\n        virtual_price = 10**18 * xcp / total_supply\r\n        xcp_profit = old_xcp_profit * virtual_price / old_virtual_price\r\n\r\n        t: uint256 = self.future_A_gamma_time\r\n        if virtual_price < old_virtual_price and t == 0:\r\n            raise \"Loss\"\r\n        if t == 1:\r\n            self.future_A_gamma_time = 0\r\n\r\n    self.xcp_profit = xcp_profit\r\n\r\n    norm: uint256 = price_oracle * 10**18 / price_scale\r\n    if norm > 10**18:\r\n        norm -= 10**18\r\n    else:\r\n        norm = 10**18 - norm\r\n    adjustment_step: uint256 = max(self.adjustment_step, norm / 5)\r\n\r\n    needs_adjustment: bool = self.not_adjusted\r\n    # if not needs_adjustment and (virtual_price-10**18 > (xcp_profit-10**18)/2 + self.allowed_extra_profit):\r\n    # (re-arrange for gas efficiency)\r\n    if not needs_adjustment and (virtual_price * 2 - 10**18 > xcp_profit + 2*self.allowed_extra_profit) and (norm > adjustment_step) and (old_virtual_price > 0):\r\n        needs_adjustment = True\r\n        self.not_adjusted = True\r\n\r\n    if needs_adjustment:\r\n        if norm > adjustment_step and old_virtual_price > 0:\r\n            p_new = (price_scale * (norm - adjustment_step) + adjustment_step * price_oracle) / norm\r\n\r\n            # Calculate balances*prices\r\n            xp = [_xp[0], _xp[1] * p_new / price_scale]\r\n\r\n            # Calculate \"extended constant product\" invariant xCP and virtual price\r\n            D: uint256 = self.newton_D(A_gamma[0], A_gamma[1], xp)\r\n            xp = [D / N_COINS, D * PRECISION / (N_COINS * p_new)]\r\n            # We reuse old_virtual_price here but it's not old anymore\r\n            old_virtual_price = 10**18 * self.geometric_mean(xp, True) / total_supply\r\n\r\n            # Proceed if we've got enough profit\r\n            # if (old_virtual_price > 10**18) and (2 * (old_virtual_price - 10**18) > xcp_profit - 10**18):\r\n            if (old_virtual_price > 10**18) and (2 * old_virtual_price - 10**18 > xcp_profit):\r\n                self.price_scale = p_new\r\n                self.D = D\r\n                self.virtual_price = old_virtual_price\r\n\r\n                return\r\n\r\n            else:\r\n                self.not_adjusted = False\r\n\r\n                # Can instead do another flag variable if we want to save bytespace\r\n                self.D = D_unadjusted\r\n                self.virtual_price = virtual_price\r\n                self._claim_admin_fees()\r\n\r\n                return\r\n\r\n    # If we are here, the price_scale adjustment did not happen\r\n    # Still need to update the profit counter and D\r\n    self.D = D_unadjusted\r\n    self.virtual_price = virtual_price\r\n\r\n    # norm appeared < adjustment_step after\r\n    if needs_adjustment:\r\n        self.not_adjusted = False\r\n        self._claim_admin_fees()\r\n\r\n\r\n@internal\r\ndef _exchange(sender: address, mvalue: uint256, i: uint256, j: uint256, dx: uint256, min_dy: uint256,\r\n              use_eth: bool, receiver: address, callbacker: address, callback_sig: bytes32) -> uint256:\r\n    assert i != j  # dev: coin index out of range\r\n    assert i < N_COINS  # dev: coin index out of range\r\n    assert j < N_COINS  # dev: coin index out of range\r\n    assert dx > 0  # dev: do not exchange 0 coins\r\n\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n    xp: uint256[N_COINS] = self.balances\r\n    p: uint256 = 0\r\n    dy: uint256 = 0\r\n\r\n    in_coin: address = self.coins[i]\r\n    out_coin: address = self.coins[j]\r\n\r\n    y: uint256 = xp[j]\r\n    x0: uint256 = xp[i]\r\n    xp[i] = x0 + dx\r\n    self.balances[i] = xp[i]\r\n\r\n    price_scale: uint256 = self.price_scale\r\n    precisions: uint256[2] = self._get_precisions()\r\n\r\n    xp = [xp[0] * precisions[0], xp[1] * price_scale * precisions[1] / PRECISION]\r\n\r\n    prec_i: uint256 = precisions[0]\r\n    prec_j: uint256 = precisions[1]\r\n    if i == 1:\r\n        prec_i = precisions[1]\r\n        prec_j = precisions[0]\r\n\r\n    # In case ramp is happening\r\n    t: uint256 = self.future_A_gamma_time\r\n    if t > 0:\r\n        x0 *= prec_i\r\n        if i > 0:\r\n            x0 = x0 * price_scale / PRECISION\r\n        x1: uint256 = xp[i]  # Back up old value in xp\r\n        xp[i] = x0\r\n        self.D = self.newton_D(A_gamma[0], A_gamma[1], xp)\r\n        xp[i] = x1  # And restore\r\n        if block.timestamp >= t:\r\n            self.future_A_gamma_time = 1\r\n\r\n    dy = xp[j] - self.newton_y(A_gamma[0], A_gamma[1], xp, self.D, j)\r\n    # Not defining new \"y\" here to have less variables / make subsequent calls cheaper\r\n    xp[j] -= dy\r\n    dy -= 1\r\n\r\n    if j > 0:\r\n        dy = dy * PRECISION / price_scale\r\n    dy /= prec_j\r\n\r\n    dy -= self._fee(xp) * dy / 10**10\r\n    assert dy >= min_dy, \"Slippage\"\r\n    y -= dy\r\n\r\n    self.balances[j] = y\r\n\r\n    # Do transfers in and out together\r\n    # XXX coin vs ETH\r\n    if use_eth and in_coin == WETH20:\r\n        assert mvalue == dx  # dev: incorrect eth amount\r\n    else:\r\n        assert mvalue == 0  # dev: nonzero eth amount\r\n        if callback_sig == EMPTY_BYTES32:\r\n            response: Bytes[32] = raw_call(\r\n                in_coin,\r\n                _abi_encode(\r\n                    sender, self, dx, method_id=method_id(\"transferFrom(address,address,uint256)\")\r\n                ),\r\n                max_outsize=32,\r\n            )\r\n            if len(response) != 0:\r\n                assert convert(response, bool)  # dev: failed transfer\r\n        else:\r\n            b: uint256 = ERC20(in_coin).balanceOf(self)\r\n            raw_call(\r\n                callbacker,\r\n                concat(slice(callback_sig, 0, 4), _abi_encode(sender, receiver, in_coin, dx, dy))\r\n            )\r\n            assert ERC20(in_coin).balanceOf(self) - b == dx  # dev: callback didn't give us coins\r\n        if in_coin == WETH20:\r\n            WETH(WETH20).withdraw(dx)\r\n\r\n    if use_eth and out_coin == WETH20:\r\n        raw_call(receiver, b\"\", value=dy)\r\n    else:\r\n        if out_coin == WETH20:\r\n            WETH(WETH20).deposit(value=dy)\r\n        response: Bytes[32] = raw_call(\r\n            out_coin,\r\n            _abi_encode(receiver, dy, method_id=method_id(\"transfer(address,uint256)\")),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n    y *= prec_j\r\n    if j > 0:\r\n        y = y * price_scale / PRECISION\r\n    xp[j] = y\r\n\r\n    # Calculate price\r\n    if dx > 10**5 and dy > 10**5:\r\n        _dx: uint256 = dx * prec_i\r\n        _dy: uint256 = dy * prec_j\r\n        if i == 0:\r\n            p = _dx * 10**18 / _dy\r\n        else:  # j == 0\r\n            p = _dy * 10**18 / _dx\r\n\r\n    self.tweak_price(A_gamma, xp, p, 0)\r\n\r\n    log TokenExchange(sender, i, dx, j, dy)\r\n\r\n    return dy\r\n\r\n\r\n@view\r\n@internal\r\ndef _calc_token_fee(amounts: uint256[N_COINS], xp: uint256[N_COINS]) -> uint256:\r\n    # fee = sum(amounts_i - avg(amounts)) * fee' / sum(amounts)\r\n    fee: uint256 = self._fee(xp) * N_COINS / (4 * (N_COINS-1))\r\n    S: uint256 = 0\r\n    for _x in amounts:\r\n        S += _x\r\n    avg: uint256 = S / N_COINS\r\n    Sdiff: uint256 = 0\r\n    for _x in amounts:\r\n        if _x > avg:\r\n            Sdiff += _x - avg\r\n        else:\r\n            Sdiff += avg - _x\r\n    return fee * Sdiff / S + NOISE_FEE\r\n\r\n\r\n@internal\r\n@view\r\ndef _calc_withdraw_one_coin(A_gamma: uint256[2], token_amount: uint256, i: uint256, update_D: bool,\r\n                            calc_price: bool) -> (uint256, uint256, uint256, uint256[N_COINS]):\r\n    token_supply: uint256 = CurveToken(self.token).totalSupply()\r\n    assert token_amount <= token_supply  # dev: token amount more than supply\r\n    assert i < N_COINS  # dev: coin out of range\r\n\r\n    xx: uint256[N_COINS] = self.balances\r\n    D0: uint256 = 0\r\n    precisions: uint256[2] = self._get_precisions()\r\n\r\n    price_scale_i: uint256 = self.price_scale * precisions[1]\r\n    xp: uint256[N_COINS] = [xx[0] * precisions[0], xx[1] * price_scale_i / PRECISION]\r\n    if i == 0:\r\n        price_scale_i = PRECISION * precisions[0]\r\n\r\n    if update_D:\r\n        D0 = self.newton_D(A_gamma[0], A_gamma[1], xp)\r\n    else:\r\n        D0 = self.D\r\n\r\n    D: uint256 = D0\r\n\r\n    # Charge the fee on D, not on y, e.g. reducing invariant LESS than charging the user\r\n    fee: uint256 = self._fee(xp)\r\n    dD: uint256 = token_amount * D / token_supply\r\n    D -= (dD - (fee * dD / (2 * 10**10) + 1))\r\n    y: uint256 = self.newton_y(A_gamma[0], A_gamma[1], xp, D, i)\r\n    dy: uint256 = (xp[i] - y) * PRECISION / price_scale_i\r\n    xp[i] = y\r\n\r\n    # Price calc\r\n    p: uint256 = 0\r\n    if calc_price and dy > 10**5 and token_amount > 10**5:\r\n        # p_i = dD / D0 * sum'(p_k * x_k) / (dy - dD / D0 * y0)\r\n        S: uint256 = 0\r\n        precision: uint256 = precisions[0]\r\n        if i == 1:\r\n            S = xx[0] * precisions[0]\r\n            precision = precisions[1]\r\n        else:\r\n            S = xx[1] * precisions[1]\r\n        S = S * dD / D0\r\n        p = S * PRECISION / (dy * precision - dD * xx[i] * precision / D0)\r\n        if i == 0:\r\n            p = (10**18)**2 / p\r\n\r\n    return dy, p, D, xp\r\n\r\n\r\n@internal\r\n@pure\r\ndef sqrt_int(x: uint256) -> uint256:\r\n    \"\"\"\r\n    Originating from: https://github.com/vyperlang/vyper/issues/1266\r\n    \"\"\"\r\n\r\n    if x == 0:\r\n        return 0\r\n\r\n    z: uint256 = (x + 10**18) / 2\r\n    y: uint256 = x\r\n\r\n    for i in range(256):\r\n        if z == y:\r\n            return y\r\n        y = z\r\n        z = (x * 10**18 / z + z) / 2\r\n\r\n    raise \"Did not converge\"\r\n\r\n\r\n# External Functions\r\n\r\n\r\n@payable\r\n@external\r\n@nonreentrant('lock')\r\ndef exchange(i: uint256, j: uint256, dx: uint256, min_dy: uint256,\r\n             use_eth: bool = False, receiver: address = msg.sender) -> uint256:\r\n    \"\"\"\r\n    Exchange using WETH by default\r\n    \"\"\"\r\n    return self._exchange(msg.sender, msg.value, i, j, dx, min_dy, use_eth, receiver, ZERO_ADDRESS, EMPTY_BYTES32)\r\n\r\n\r\n@payable\r\n@external\r\n@nonreentrant('lock')\r\ndef exchange_underlying(i: uint256, j: uint256, dx: uint256, min_dy: uint256,\r\n                        receiver: address = msg.sender) -> uint256:\r\n    \"\"\"\r\n    Exchange using ETH\r\n    \"\"\"\r\n    return self._exchange(msg.sender, msg.value, i, j, dx, min_dy, True, receiver, ZERO_ADDRESS, EMPTY_BYTES32)\r\n\r\n\r\n@payable\r\n@external\r\n@nonreentrant('lock')\r\ndef exchange_extended(i: uint256, j: uint256, dx: uint256, min_dy: uint256,\r\n                      use_eth: bool, sender: address, receiver: address, cb: bytes32) -> uint256:\r\n    assert cb != EMPTY_BYTES32  # dev: No callback specified\r\n    return self._exchange(sender, msg.value, i, j, dx, min_dy, use_eth, receiver, msg.sender, cb)\r\n\r\n\r\n@payable\r\n@external\r\n@nonreentrant('lock')\r\ndef add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256,\r\n                  use_eth: bool = False, receiver: address = msg.sender) -> uint256:\r\n    assert amounts[0] > 0 or amounts[1] > 0  # dev: no coins to add\r\n\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n\r\n    xp: uint256[N_COINS] = self.balances\r\n    amountsp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    xx: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    d_token: uint256 = 0\r\n    d_token_fee: uint256 = 0\r\n    old_D: uint256 = 0\r\n\r\n    xp_old: uint256[N_COINS] = xp\r\n\r\n    for i in range(N_COINS):\r\n        bal: uint256 = xp[i] + amounts[i]\r\n        xp[i] = bal\r\n        self.balances[i] = bal\r\n    xx = xp\r\n\r\n    precisions: uint256[2] = self._get_precisions()\r\n\r\n    price_scale: uint256 = self.price_scale * precisions[1]\r\n    xp = [xp[0] * precisions[0], xp[1] * price_scale / PRECISION]\r\n    xp_old = [xp_old[0] * precisions[0], xp_old[1] * price_scale / PRECISION]\r\n\r\n    if not use_eth:\r\n        assert msg.value == 0  # dev: nonzero eth amount\r\n\r\n    for i in range(N_COINS):\r\n        coin: address = self.coins[i]\r\n        if use_eth and coin == WETH20:\r\n            assert msg.value == amounts[i]  # dev: incorrect eth amount\r\n        if amounts[i] > 0:\r\n            if (not use_eth) or (coin != WETH20):\r\n                response: Bytes[32] = raw_call(\r\n                    coin,\r\n                    _abi_encode(\r\n                        msg.sender,\r\n                        self,\r\n                        amounts[i],\r\n                        method_id=method_id(\"transferFrom(address,address,uint256)\"),\r\n                    ),\r\n                    max_outsize=32,\r\n                )\r\n                if len(response) != 0:\r\n                    assert convert(response, bool)  # dev: failed transfer\r\n                if coin == WETH20:\r\n                    WETH(WETH20).withdraw(amounts[i])\r\n            amountsp[i] = xp[i] - xp_old[i]\r\n\r\n    t: uint256 = self.future_A_gamma_time\r\n    if t > 0:\r\n        old_D = self.newton_D(A_gamma[0], A_gamma[1], xp_old)\r\n        if block.timestamp >= t:\r\n            self.future_A_gamma_time = 1\r\n    else:\r\n        old_D = self.D\r\n\r\n    D: uint256 = self.newton_D(A_gamma[0], A_gamma[1], xp)\r\n\r\n    lp_token: address = self.token\r\n    token_supply: uint256 = CurveToken(lp_token).totalSupply()\r\n    if old_D > 0:\r\n        d_token = token_supply * D / old_D - token_supply\r\n    else:\r\n        d_token = self.get_xcp(D)  # making initial virtual price equal to 1\r\n    assert d_token > 0  # dev: nothing minted\r\n\r\n    if old_D > 0:\r\n        d_token_fee = self._calc_token_fee(amountsp, xp) * d_token / 10**10 + 1\r\n        d_token -= d_token_fee\r\n        token_supply += d_token\r\n        CurveToken(lp_token).mint(receiver, d_token)\r\n\r\n        # Calculate price\r\n        # p_i * (dx_i - dtoken / token_supply * xx_i) = sum{k!=i}(p_k * (dtoken / token_supply * xx_k - dx_k))\r\n        # Simplified for 2 coins\r\n        p: uint256 = 0\r\n        if d_token > 10**5:\r\n            if amounts[0] == 0 or amounts[1] == 0:\r\n                S: uint256 = 0\r\n                precision: uint256 = 0\r\n                ix: uint256 = 0\r\n                if amounts[0] == 0:\r\n                    S = xx[0] * precisions[0]\r\n                    precision = precisions[1]\r\n                    ix = 1\r\n                else:\r\n                    S = xx[1] * precisions[1]\r\n                    precision = precisions[0]\r\n                S = S * d_token / token_supply\r\n                p = S * PRECISION / (amounts[ix] * precision - d_token * xx[ix] * precision / token_supply)\r\n                if ix == 0:\r\n                    p = (10**18)**2 / p\r\n\r\n        self.tweak_price(A_gamma, xp, p, D)\r\n\r\n    else:\r\n        self.D = D\r\n        self.virtual_price = 10**18\r\n        self.xcp_profit = 10**18\r\n        CurveToken(lp_token).mint(receiver, d_token)\r\n\r\n    assert d_token >= min_mint_amount, \"Slippage\"\r\n\r\n    log AddLiquidity(receiver, amounts, d_token_fee, token_supply)\r\n\r\n    return d_token\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS],\r\n                     use_eth: bool = False, receiver: address = msg.sender):\r\n    \"\"\"\r\n    This withdrawal method is very safe, does no complex math\r\n    \"\"\"\r\n    lp_token: address = self.token\r\n    total_supply: uint256 = CurveToken(lp_token).totalSupply()\r\n    CurveToken(lp_token).burnFrom(msg.sender, _amount)\r\n    balances: uint256[N_COINS] = self.balances\r\n    amount: uint256 = _amount - 1  # Make rounding errors favoring other LPs a tiny bit\r\n\r\n    for i in range(N_COINS):\r\n        d_balance: uint256 = balances[i] * amount / total_supply\r\n        assert d_balance >= min_amounts[i]\r\n        self.balances[i] = balances[i] - d_balance\r\n        balances[i] = d_balance  # now it's the amounts going out\r\n        coin: address = self.coins[i]\r\n        if use_eth and coin == WETH20:\r\n            raw_call(receiver, b\"\", value=d_balance)\r\n        else:\r\n            if coin == WETH20:\r\n                WETH(WETH20).deposit(value=d_balance)\r\n            response: Bytes[32] = raw_call(\r\n                coin,\r\n                _abi_encode(receiver, d_balance, method_id=method_id(\"transfer(address,uint256)\")),\r\n                max_outsize=32,\r\n            )\r\n            if len(response) != 0:\r\n                assert convert(response, bool)\r\n\r\n    D: uint256 = self.D\r\n    self.D = D - D * amount / total_supply\r\n\r\n    log RemoveLiquidity(msg.sender, balances, total_supply - _amount)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_liquidity_one_coin(token_amount: uint256, i: uint256, min_amount: uint256,\r\n                              use_eth: bool = False, receiver: address = msg.sender) -> uint256:\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n\r\n    dy: uint256 = 0\r\n    D: uint256 = 0\r\n    p: uint256 = 0\r\n    xp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    future_A_gamma_time: uint256 = self.future_A_gamma_time\r\n    dy, p, D, xp = self._calc_withdraw_one_coin(A_gamma, token_amount, i, (future_A_gamma_time > 0), True)\r\n    assert dy >= min_amount, \"Slippage\"\r\n\r\n    if block.timestamp >= future_A_gamma_time:\r\n        self.future_A_gamma_time = 1\r\n\r\n    self.balances[i] -= dy\r\n    CurveToken(self.token).burnFrom(msg.sender, token_amount)\r\n\r\n    coin: address = self.coins[i]\r\n    if use_eth and coin == WETH20:\r\n        raw_call(receiver, b\"\", value=dy)\r\n    else:\r\n        if coin == WETH20:\r\n            WETH(WETH20).deposit(value=dy)\r\n        response: Bytes[32] = raw_call(\r\n            coin,\r\n            _abi_encode(receiver, dy, method_id=method_id(\"transfer(address,uint256)\")),\r\n            max_outsize=32,\r\n        )\r\n        if len(response) != 0:\r\n            assert convert(response, bool)\r\n\r\n    self.tweak_price(A_gamma, xp, p, D)\r\n\r\n    log RemoveLiquidityOne(msg.sender, token_amount, i, dy)\r\n\r\n    return dy\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef claim_admin_fees():\r\n    self._claim_admin_fees()\r\n\r\n\r\n# Admin parameters\r\n@external\r\ndef ramp_A_gamma(future_A: uint256, future_gamma: uint256, future_time: uint256):\r\n    assert msg.sender == Factory(self.factory).admin()  # dev: only owner\r\n    assert block.timestamp > self.initial_A_gamma_time + (MIN_RAMP_TIME-1)\r\n    assert future_time > block.timestamp + (MIN_RAMP_TIME-1)  # dev: insufficient time\r\n\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n    initial_A_gamma: uint256 = shift(A_gamma[0], 128)\r\n    initial_A_gamma = bitwise_or(initial_A_gamma, A_gamma[1])\r\n\r\n    assert future_A > MIN_A-1\r\n    assert future_A < MAX_A+1\r\n    assert future_gamma > MIN_GAMMA-1\r\n    assert future_gamma < MAX_GAMMA+1\r\n\r\n    ratio: uint256 = 10**18 * future_A / A_gamma[0]\r\n    assert ratio < 10**18 * MAX_A_CHANGE + 1\r\n    assert ratio > 10**18 / MAX_A_CHANGE - 1\r\n\r\n    ratio = 10**18 * future_gamma / A_gamma[1]\r\n    assert ratio < 10**18 * MAX_A_CHANGE + 1\r\n    assert ratio > 10**18 / MAX_A_CHANGE - 1\r\n\r\n    self.initial_A_gamma = initial_A_gamma\r\n    self.initial_A_gamma_time = block.timestamp\r\n\r\n    future_A_gamma: uint256 = shift(future_A, 128)\r\n    future_A_gamma = bitwise_or(future_A_gamma, future_gamma)\r\n    self.future_A_gamma_time = future_time\r\n    self.future_A_gamma = future_A_gamma\r\n\r\n    log RampAgamma(A_gamma[0], future_A, A_gamma[1], future_gamma, block.timestamp, future_time)\r\n\r\n\r\n@external\r\ndef stop_ramp_A_gamma():\r\n    assert msg.sender == Factory(self.factory).admin()  # dev: only owner\r\n\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n    current_A_gamma: uint256 = shift(A_gamma[0], 128)\r\n    current_A_gamma = bitwise_or(current_A_gamma, A_gamma[1])\r\n    self.initial_A_gamma = current_A_gamma\r\n    self.future_A_gamma = current_A_gamma\r\n    self.initial_A_gamma_time = block.timestamp\r\n    self.future_A_gamma_time = block.timestamp\r\n    # now (block.timestamp < t1) is always False, so we return saved A\r\n\r\n    log StopRampA(A_gamma[0], A_gamma[1], block.timestamp)\r\n\r\n\r\n@external\r\ndef commit_new_parameters(\r\n    _new_mid_fee: uint256,\r\n    _new_out_fee: uint256,\r\n    _new_admin_fee: uint256,\r\n    _new_fee_gamma: uint256,\r\n    _new_allowed_extra_profit: uint256,\r\n    _new_adjustment_step: uint256,\r\n    _new_ma_half_time: uint256,\r\n    ):\r\n    assert msg.sender == Factory(self.factory).admin()  # dev: only owner\r\n    assert self.admin_actions_deadline == 0  # dev: active action\r\n\r\n    new_mid_fee: uint256 = _new_mid_fee\r\n    new_out_fee: uint256 = _new_out_fee\r\n    new_admin_fee: uint256 = _new_admin_fee\r\n    new_fee_gamma: uint256 = _new_fee_gamma\r\n    new_allowed_extra_profit: uint256 = _new_allowed_extra_profit\r\n    new_adjustment_step: uint256 = _new_adjustment_step\r\n    new_ma_half_time: uint256 = _new_ma_half_time\r\n\r\n    # Fees\r\n    if new_out_fee < MAX_FEE+1:\r\n        assert new_out_fee > MIN_FEE-1  # dev: fee is out of range\r\n    else:\r\n        new_out_fee = self.out_fee\r\n    if new_mid_fee > MAX_FEE:\r\n        new_mid_fee = self.mid_fee\r\n    assert new_mid_fee <= new_out_fee  # dev: mid-fee is too high\r\n    if new_admin_fee > MAX_ADMIN_FEE:\r\n        new_admin_fee = self.admin_fee\r\n\r\n    # AMM parameters\r\n    if new_fee_gamma < 10**18:\r\n        assert new_fee_gamma > 0  # dev: fee_gamma out of range [1 .. 10**18]\r\n    else:\r\n        new_fee_gamma = self.fee_gamma\r\n    if new_allowed_extra_profit > 10**18:\r\n        new_allowed_extra_profit = self.allowed_extra_profit\r\n    if new_adjustment_step > 10**18:\r\n        new_adjustment_step = self.adjustment_step\r\n\r\n    # MA\r\n    if new_ma_half_time < 7*86400:\r\n        assert new_ma_half_time > 0  # dev: MA time should be longer than 1 second\r\n    else:\r\n        new_ma_half_time = self.ma_half_time\r\n\r\n    _deadline: uint256 = block.timestamp + ADMIN_ACTIONS_DELAY\r\n    self.admin_actions_deadline = _deadline\r\n\r\n    self.future_admin_fee = new_admin_fee\r\n    self.future_mid_fee = new_mid_fee\r\n    self.future_out_fee = new_out_fee\r\n    self.future_fee_gamma = new_fee_gamma\r\n    self.future_allowed_extra_profit = new_allowed_extra_profit\r\n    self.future_adjustment_step = new_adjustment_step\r\n    self.future_ma_half_time = new_ma_half_time\r\n\r\n    log CommitNewParameters(_deadline, new_admin_fee, new_mid_fee, new_out_fee,\r\n                            new_fee_gamma,\r\n                            new_allowed_extra_profit, new_adjustment_step,\r\n                            new_ma_half_time)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef apply_new_parameters():\r\n    assert msg.sender == Factory(self.factory).admin()  # dev: only owner\r\n    assert block.timestamp >= self.admin_actions_deadline  # dev: insufficient time\r\n    assert self.admin_actions_deadline != 0  # dev: no active action\r\n\r\n    self.admin_actions_deadline = 0\r\n\r\n    admin_fee: uint256 = self.future_admin_fee\r\n    if self.admin_fee != admin_fee:\r\n        self._claim_admin_fees()\r\n        self.admin_fee = admin_fee\r\n\r\n    mid_fee: uint256 = self.future_mid_fee\r\n    self.mid_fee = mid_fee\r\n    out_fee: uint256 = self.future_out_fee\r\n    self.out_fee = out_fee\r\n    fee_gamma: uint256 = self.future_fee_gamma\r\n    self.fee_gamma = fee_gamma\r\n    allowed_extra_profit: uint256 = self.future_allowed_extra_profit\r\n    self.allowed_extra_profit = allowed_extra_profit\r\n    adjustment_step: uint256 = self.future_adjustment_step\r\n    self.adjustment_step = adjustment_step\r\n    ma_half_time: uint256 = self.future_ma_half_time\r\n    self.ma_half_time = ma_half_time\r\n\r\n    log NewParameters(admin_fee, mid_fee, out_fee,\r\n                      fee_gamma,\r\n                      allowed_extra_profit, adjustment_step,\r\n                      ma_half_time)\r\n\r\n\r\n@external\r\ndef revert_new_parameters():\r\n    assert msg.sender == Factory(self.factory).admin()  # dev: only owner\r\n\r\n    self.admin_actions_deadline = 0\r\n\r\n\r\n# View Methods\r\n\r\n\r\n@external\r\n@view\r\ndef get_dy(i: uint256, j: uint256, dx: uint256) -> uint256:\r\n    assert i != j  # dev: same input and output coin\r\n    assert i < N_COINS  # dev: coin index out of range\r\n    assert j < N_COINS  # dev: coin index out of range\r\n\r\n    precisions: uint256[2] = self._get_precisions()\r\n\r\n    price_scale: uint256 = self.price_scale * precisions[1]\r\n    xp: uint256[N_COINS] = self.balances\r\n\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n    D: uint256 = self.D\r\n    if self.future_A_gamma_time > 0:\r\n        D = self.newton_D(A_gamma[0], A_gamma[1], self.xp())\r\n\r\n    xp[i] += dx\r\n    xp = [xp[0] * precisions[0], xp[1] * price_scale / PRECISION]\r\n\r\n    y: uint256 = self.newton_y(A_gamma[0], A_gamma[1], xp, D, j)\r\n    dy: uint256 = xp[j] - y - 1\r\n    xp[j] = y\r\n    if j > 0:\r\n        dy = dy * PRECISION / price_scale\r\n    else:\r\n        dy /= precisions[0]\r\n    dy -= self._fee(xp) * dy / 10**10\r\n\r\n    return dy\r\n\r\n\r\n@view\r\n@external\r\ndef calc_token_amount(amounts: uint256[N_COINS]) -> uint256:\r\n    token_supply: uint256 = CurveToken(self.token).totalSupply()\r\n    precisions: uint256[2] = self._get_precisions()\r\n    price_scale: uint256 = self.price_scale * precisions[1]\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n    xp: uint256[N_COINS] = self.xp()\r\n    amountsp: uint256[N_COINS] = [\r\n        amounts[0] * precisions[0],\r\n        amounts[1] * price_scale / PRECISION]\r\n    D0: uint256 = self.D\r\n    if self.future_A_gamma_time > 0:\r\n        D0 = self.newton_D(A_gamma[0], A_gamma[1], xp)\r\n    xp[0] += amountsp[0]\r\n    xp[1] += amountsp[1]\r\n    D: uint256 = self.newton_D(A_gamma[0], A_gamma[1], xp)\r\n    d_token: uint256 = token_supply * D / D0 - token_supply\r\n    d_token -= self._calc_token_fee(amountsp, xp) * d_token / 10**10 + 1\r\n    return d_token\r\n\r\n\r\n@view\r\n@external\r\ndef calc_withdraw_one_coin(token_amount: uint256, i: uint256) -> uint256:\r\n    return self._calc_withdraw_one_coin(self._A_gamma(), token_amount, i, True, False)[0]\r\n\r\n\r\n@external\r\n@view\r\ndef lp_price() -> uint256:\r\n    \"\"\"\r\n    Approximate LP token price\r\n    \"\"\"\r\n    return 2 * self.virtual_price * self.sqrt_int(self.internal_price_oracle()) / 10**18\r\n\r\n\r\n@view\r\n@external\r\ndef A() -> uint256:\r\n    return self._A_gamma()[0]\r\n\r\n\r\n@view\r\n@external\r\ndef gamma() -> uint256:\r\n    return self._A_gamma()[1]\r\n\r\n\r\n@external\r\n@view\r\ndef fee() -> uint256:\r\n    return self._fee(self.xp())\r\n\r\n\r\n@external\r\n@view\r\ndef get_virtual_price() -> uint256:\r\n    return 10**18 * self.get_xcp(self.D) / CurveToken(self.token).totalSupply()\r\n\r\n\r\n@external\r\n@view\r\ndef price_oracle() -> uint256:\r\n    return self.internal_price_oracle()\r\n\r\n\r\n# Initializer\r\n\r\n\r\n@external\r\ndef initialize(\r\n    A: uint256,\r\n    gamma: uint256,\r\n    mid_fee: uint256,\r\n    out_fee: uint256,\r\n    allowed_extra_profit: uint256,\r\n    fee_gamma: uint256,\r\n    adjustment_step: uint256,\r\n    admin_fee: uint256,\r\n    ma_half_time: uint256,\r\n    initial_price: uint256,\r\n    _token: address,\r\n    _coins: address[N_COINS],\r\n    _precisions: uint256,\r\n):\r\n    assert self.mid_fee == 0  # dev: check that we call it from factory\r\n\r\n    self.factory = msg.sender\r\n\r\n    # Pack A and gamma:\r\n    # shifted A + gamma\r\n    A_gamma: uint256 = shift(A, 128)\r\n    A_gamma = bitwise_or(A_gamma, gamma)\r\n    self.initial_A_gamma = A_gamma\r\n    self.future_A_gamma = A_gamma\r\n\r\n    self.mid_fee = mid_fee\r\n    self.out_fee = out_fee\r\n    self.allowed_extra_profit = allowed_extra_profit\r\n    self.fee_gamma = fee_gamma\r\n    self.adjustment_step = adjustment_step\r\n    self.admin_fee = admin_fee\r\n\r\n    self.price_scale = initial_price\r\n    self._price_oracle = initial_price\r\n    self.last_prices = initial_price\r\n    self.last_prices_timestamp = block.timestamp\r\n    self.ma_half_time = ma_half_time\r\n\r\n    self.xcp_profit_a = 10**18\r\n\r\n    self.token = _token\r\n    self.coins = _coins\r\n    self.PRECISIONS = _precisions","ABI":"[{\"name\":\"TokenExchange\",\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\",\"indexed\":true},{\"name\":\"sold_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"tokens_sold\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"bought_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"tokens_bought\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AddLiquidity\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amounts\",\"type\":\"uint256[2]\",\"indexed\":false},{\"name\":\"fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"token_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidity\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amounts\",\"type\":\"uint256[2]\",\"indexed\":false},{\"name\":\"token_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidityOne\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"coin_index\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"coin_amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"CommitNewParameters\",\"inputs\":[{\"name\":\"deadline\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"admin_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"mid_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"out_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"fee_gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"allowed_extra_profit\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"adjustment_step\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"ma_half_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewParameters\",\"inputs\":[{\"name\":\"admin_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"mid_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"out_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"fee_gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"allowed_extra_profit\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"adjustment_step\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"ma_half_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RampAgamma\",\"inputs\":[{\"name\":\"initial_A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"future_A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"initial_gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"future_gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"initial_time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"future_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"StopRampA\",\"inputs\":[{\"name\":\"current_A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"current_gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ClaimAdminFee\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":true},{\"name\":\"tokens\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_weth\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"min_dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"min_dy\",\"type\":\"uint256\"},{\"name\":\"use_eth\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"min_dy\",\"type\":\"uint256\"},{\"name\":\"use_eth\",\"type\":\"bool\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange_underlying\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"min_dy\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange_underlying\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"min_dy\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange_extended\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"min_dy\",\"type\":\"uint256\"},{\"name\":\"use_eth\",\"type\":\"bool\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"cb\",\"type\":\"bytes32\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[2]\"},{\"name\":\"min_mint_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[2]\"},{\"name\":\"min_mint_amount\",\"type\":\"uint256\"},{\"name\":\"use_eth\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[2]\"},{\"name\":\"min_mint_amount\",\"type\":\"uint256\"},{\"name\":\"use_eth\",\"type\":\"bool\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"min_amounts\",\"type\":\"uint256[2]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"min_amounts\",\"type\":\"uint256[2]\"},{\"name\":\"use_eth\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"min_amounts\",\"type\":\"uint256[2]\"},{\"name\":\"use_eth\",\"type\":\"bool\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"min_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"min_amount\",\"type\":\"uint256\"},{\"name\":\"use_eth\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"min_amount\",\"type\":\"uint256\"},{\"name\":\"use_eth\",\"type\":\"bool\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_admin_fees\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"ramp_A_gamma\",\"inputs\":[{\"name\":\"future_A\",\"type\":\"uint256\"},{\"name\":\"future_gamma\",\"type\":\"uint256\"},{\"name\":\"future_time\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"stop_ramp_A_gamma\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_new_parameters\",\"inputs\":[{\"name\":\"_new_mid_fee\",\"type\":\"uint256\"},{\"name\":\"_new_out_fee\",\"type\":\"uint256\"},{\"name\":\"_new_admin_fee\",\"type\":\"uint256\"},{\"name\":\"_new_fee_gamma\",\"type\":\"uint256\"},{\"name\":\"_new_allowed_extra_profit\",\"type\":\"uint256\"},{\"name\":\"_new_adjustment_step\",\"type\":\"uint256\"},{\"name\":\"_new_ma_half_time\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply_new_parameters\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"revert_new_parameters\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dy\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_token_amount\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[2]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_withdraw_one_coin\",\"inputs\":[{\"name\":\"token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lp_price\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"A\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gamma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_virtual_price\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"price_oracle\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"initialize\",\"inputs\":[{\"name\":\"A\",\"type\":\"uint256\"},{\"name\":\"gamma\",\"type\":\"uint256\"},{\"name\":\"mid_fee\",\"type\":\"uint256\"},{\"name\":\"out_fee\",\"type\":\"uint256\"},{\"name\":\"allowed_extra_profit\",\"type\":\"uint256\"},{\"name\":\"fee_gamma\",\"type\":\"uint256\"},{\"name\":\"adjustment_step\",\"type\":\"uint256\"},{\"name\":\"admin_fee\",\"type\":\"uint256\"},{\"name\":\"ma_half_time\",\"type\":\"uint256\"},{\"name\":\"initial_price\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_coins\",\"type\":\"address[2]\"},{\"name\":\"_precisions\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"coins\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"price_scale\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_prices\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_prices_timestamp\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"initial_A_gamma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_A_gamma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"initial_A_gamma_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_A_gamma_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowed_extra_profit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_allowed_extra_profit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee_gamma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_fee_gamma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"adjustment_step\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_adjustment_step\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"ma_half_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_ma_half_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"mid_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"out_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_mid_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_out_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_admin_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balances\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"D\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"factory\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"xcp_profit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"xcp_profit_a\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"virtual_price\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin_actions_deadline\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.3.1","OptimizationUsed":0,"Runs":0,"ConstructorArguments":"0x000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":0,"SwarmSource":""}]}