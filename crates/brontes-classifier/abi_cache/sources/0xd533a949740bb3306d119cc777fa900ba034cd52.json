{"expiry":1699579189,"data":[{"SourceCode":"# @version 0.2.4\r\n\"\"\"\r\n@title Curve DAO Token\r\n@author Curve Finance\r\n@license MIT\r\n@notice ERC20 with piecewise-linear mining supply.\r\n@dev Based on the ERC-20 token standard as defined at\r\n     https://eips.ethereum.org/EIPS/eip-20\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\nimplements: ERC20\r\n\r\n\r\nevent Transfer:\r\n    _from: indexed(address)\r\n    _to: indexed(address)\r\n    _value: uint256\r\n\r\nevent Approval:\r\n    _owner: indexed(address)\r\n    _spender: indexed(address)\r\n    _value: uint256\r\n\r\nevent UpdateMiningParameters:\r\n    time: uint256\r\n    rate: uint256\r\n    supply: uint256\r\n\r\nevent SetMinter:\r\n    minter: address\r\n\r\nevent SetAdmin:\r\n    admin: address\r\n\r\n\r\nname: public(String[64])\r\nsymbol: public(String[32])\r\ndecimals: public(uint256)\r\n\r\nbalanceOf: public(HashMap[address, uint256])\r\nallowances: HashMap[address, HashMap[address, uint256]]\r\ntotal_supply: uint256\r\n\r\nminter: public(address)\r\nadmin: public(address)\r\n\r\n# General constants\r\nYEAR: constant(uint256) = 86400 * 365\r\n\r\n# Allocation:\r\n# =========\r\n# * shareholders - 30%\r\n# * emplyees - 3%\r\n# * DAO-controlled reserve - 5%\r\n# * Early users - 5%\r\n# == 43% ==\r\n# left for inflation: 57%\r\n\r\n# Supply parameters\r\nINITIAL_SUPPLY: constant(uint256) = 1_303_030_303\r\nINITIAL_RATE: constant(uint256) = 274_815_283 * 10 ** 18 / YEAR  # leading to 43% premine\r\nRATE_REDUCTION_TIME: constant(uint256) = YEAR\r\nRATE_REDUCTION_COEFFICIENT: constant(uint256) = 1189207115002721024  # 2 ** (1/4) * 1e18\r\nRATE_DENOMINATOR: constant(uint256) = 10 ** 18\r\nINFLATION_DELAY: constant(uint256) = 86400\r\n\r\n# Supply variables\r\nmining_epoch: public(int128)\r\nstart_epoch_time: public(uint256)\r\nrate: public(uint256)\r\n\r\nstart_epoch_supply: uint256\r\n\r\n\r\n@external\r\ndef __init__(_name: String[64], _symbol: String[32], _decimals: uint256):\r\n    \"\"\"\r\n    @notice Contract constructor\r\n    @param _name Token full name\r\n    @param _symbol Token symbol\r\n    @param _decimals Number of decimals for token\r\n    \"\"\"\r\n    init_supply: uint256 = INITIAL_SUPPLY * 10 ** _decimals\r\n    self.name = _name\r\n    self.symbol = _symbol\r\n    self.decimals = _decimals\r\n    self.balanceOf[msg.sender] = init_supply\r\n    self.total_supply = init_supply\r\n    self.admin = msg.sender\r\n    log Transfer(ZERO_ADDRESS, msg.sender, init_supply)\r\n\r\n    self.start_epoch_time = block.timestamp + INFLATION_DELAY - RATE_REDUCTION_TIME\r\n    self.mining_epoch = -1\r\n    self.rate = 0\r\n    self.start_epoch_supply = init_supply\r\n\r\n\r\n@internal\r\ndef _update_mining_parameters():\r\n    \"\"\"\r\n    @dev Update mining rate and supply at the start of the epoch\r\n         Any modifying mining call must also call this\r\n    \"\"\"\r\n    _rate: uint256 = self.rate\r\n    _start_epoch_supply: uint256 = self.start_epoch_supply\r\n\r\n    self.start_epoch_time += RATE_REDUCTION_TIME\r\n    self.mining_epoch += 1\r\n\r\n    if _rate == 0:\r\n        _rate = INITIAL_RATE\r\n    else:\r\n        _start_epoch_supply += _rate * RATE_REDUCTION_TIME\r\n        self.start_epoch_supply = _start_epoch_supply\r\n        _rate = _rate * RATE_DENOMINATOR / RATE_REDUCTION_COEFFICIENT\r\n\r\n    self.rate = _rate\r\n\r\n    log UpdateMiningParameters(block.timestamp, _rate, _start_epoch_supply)\r\n\r\n\r\n@external\r\ndef update_mining_parameters():\r\n    \"\"\"\r\n    @notice Update mining rate and supply at the start of the epoch\r\n    @dev Callable by any address, but only once per epoch\r\n         Total supply becomes slightly larger if this function is called late\r\n    \"\"\"\r\n    assert block.timestamp >= self.start_epoch_time + RATE_REDUCTION_TIME  # dev: too soon!\r\n    self._update_mining_parameters()\r\n\r\n\r\n@external\r\ndef start_epoch_time_write() -> uint256:\r\n    \"\"\"\r\n    @notice Get timestamp of the current mining epoch start\r\n            while simultaneously updating mining parameters\r\n    @return Timestamp of the epoch\r\n    \"\"\"\r\n    _start_epoch_time: uint256 = self.start_epoch_time\r\n    if block.timestamp >= _start_epoch_time + RATE_REDUCTION_TIME:\r\n        self._update_mining_parameters()\r\n        return self.start_epoch_time\r\n    else:\r\n        return _start_epoch_time\r\n\r\n\r\n@external\r\ndef future_epoch_time_write() -> uint256:\r\n    \"\"\"\r\n    @notice Get timestamp of the next mining epoch start\r\n            while simultaneously updating mining parameters\r\n    @return Timestamp of the next epoch\r\n    \"\"\"\r\n    _start_epoch_time: uint256 = self.start_epoch_time\r\n    if block.timestamp >= _start_epoch_time + RATE_REDUCTION_TIME:\r\n        self._update_mining_parameters()\r\n        return self.start_epoch_time + RATE_REDUCTION_TIME\r\n    else:\r\n        return _start_epoch_time + RATE_REDUCTION_TIME\r\n\r\n\r\n@internal\r\n@view\r\ndef _available_supply() -> uint256:\r\n    return self.start_epoch_supply + (block.timestamp - self.start_epoch_time) * self.rate\r\n\r\n\r\n@external\r\n@view\r\ndef available_supply() -> uint256:\r\n    \"\"\"\r\n    @notice Current number of tokens in existence (claimed or unclaimed)\r\n    \"\"\"\r\n    return self._available_supply()\r\n\r\n\r\n@external\r\n@view\r\ndef mintable_in_timeframe(start: uint256, end: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice How much supply is mintable from start timestamp till end timestamp\r\n    @param start Start of the time interval (timestamp)\r\n    @param end End of the time interval (timestamp)\r\n    @return Tokens mintable from `start` till `end`\r\n    \"\"\"\r\n    assert start <= end  # dev: start > end\r\n    to_mint: uint256 = 0\r\n    current_epoch_time: uint256 = self.start_epoch_time\r\n    current_rate: uint256 = self.rate\r\n\r\n    # Special case if end is in future (not yet minted) epoch\r\n    if end > current_epoch_time + RATE_REDUCTION_TIME:\r\n        current_epoch_time += RATE_REDUCTION_TIME\r\n        current_rate = current_rate * RATE_DENOMINATOR / RATE_REDUCTION_COEFFICIENT\r\n\r\n    assert end <= current_epoch_time + RATE_REDUCTION_TIME  # dev: too far in future\r\n\r\n    for i in range(999):  # Curve will not work in 1000 years. Darn!\r\n        if end >= current_epoch_time:\r\n            current_end: uint256 = end\r\n            if current_end > current_epoch_time + RATE_REDUCTION_TIME:\r\n                current_end = current_epoch_time + RATE_REDUCTION_TIME\r\n\r\n            current_start: uint256 = start\r\n            if current_start >= current_epoch_time + RATE_REDUCTION_TIME:\r\n                break  # We should never get here but what if...\r\n            elif current_start < current_epoch_time:\r\n                current_start = current_epoch_time\r\n\r\n            to_mint += current_rate * (current_end - current_start)\r\n\r\n            if start >= current_epoch_time:\r\n                break\r\n\r\n        current_epoch_time -= RATE_REDUCTION_TIME\r\n        current_rate = current_rate * RATE_REDUCTION_COEFFICIENT / RATE_DENOMINATOR  # double-division with rounding made rate a bit less => good\r\n        assert current_rate <= INITIAL_RATE  # This should never happen\r\n\r\n    return to_mint\r\n\r\n\r\n@external\r\ndef set_minter(_minter: address):\r\n    \"\"\"\r\n    @notice Set the minter address\r\n    @dev Only callable once, when minter has not yet been set\r\n    @param _minter Address of the minter\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    assert self.minter == ZERO_ADDRESS  # dev: can set the minter only once, at creation\r\n    self.minter = _minter\r\n    log SetMinter(_minter)\r\n\r\n\r\n@external\r\ndef set_admin(_admin: address):\r\n    \"\"\"\r\n    @notice Set the new admin.\r\n    @dev After all is set up, admin only can change the token name\r\n    @param _admin New admin address\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    self.admin = _admin\r\n    log SetAdmin(_admin)\r\n\r\n\r\n@external\r\n@view\r\ndef totalSupply() -> uint256:\r\n    \"\"\"\r\n    @notice Total number of tokens in existence.\r\n    \"\"\"\r\n    return self.total_supply\r\n\r\n\r\n@external\r\n@view\r\ndef allowance(_owner : address, _spender : address) -> uint256:\r\n    \"\"\"\r\n    @notice Check the amount of tokens that an owner allowed to a spender\r\n    @param _owner The address which owns the funds\r\n    @param _spender The address which will spend the funds\r\n    @return uint256 specifying the amount of tokens still available for the spender\r\n    \"\"\"\r\n    return self.allowances[_owner][_spender]\r\n\r\n\r\n@external\r\ndef transfer(_to : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @notice Transfer `_value` tokens from `msg.sender` to `_to`\r\n    @dev Vyper does not allow underflows, so the subtraction in\r\n         this function will revert on an insufficient balance\r\n    @param _to The address to transfer to\r\n    @param _value The amount to be transferred\r\n    @return bool success\r\n    \"\"\"\r\n    assert _to != ZERO_ADDRESS  # dev: transfers to 0x0 are not allowed\r\n    self.balanceOf[msg.sender] -= _value\r\n    self.balanceOf[_to] += _value\r\n    log Transfer(msg.sender, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef transferFrom(_from : address, _to : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n     @notice Transfer `_value` tokens from `_from` to `_to`\r\n     @param _from address The address which you want to send tokens from\r\n     @param _to address The address which you want to transfer to\r\n     @param _value uint256 the amount of tokens to be transferred\r\n     @return bool success\r\n    \"\"\"\r\n    assert _to != ZERO_ADDRESS  # dev: transfers to 0x0 are not allowed\r\n    # NOTE: vyper does not allow underflows\r\n    #       so the following subtraction would revert on insufficient balance\r\n    self.balanceOf[_from] -= _value\r\n    self.balanceOf[_to] += _value\r\n    self.allowances[_from][msg.sender] -= _value\r\n    log Transfer(_from, _to, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef approve(_spender : address, _value : uint256) -> bool:\r\n    \"\"\"\r\n    @notice Approve `_spender` to transfer `_value` tokens on behalf of `msg.sender`\r\n    @dev Approval may only be from zero -> nonzero or from nonzero -> zero in order\r\n        to mitigate the potential race condition described here:\r\n        https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    @param _spender The address which will spend the funds\r\n    @param _value The amount of tokens to be spent\r\n    @return bool success\r\n    \"\"\"\r\n    assert _value == 0 or self.allowances[msg.sender][_spender] == 0\r\n    self.allowances[msg.sender][_spender] = _value\r\n    log Approval(msg.sender, _spender, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef mint(_to: address, _value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Mint `_value` tokens and assign them to `_to`\r\n    @dev Emits a Transfer event originating from 0x00\r\n    @param _to The account that will receive the created tokens\r\n    @param _value The amount that will be created\r\n    @return bool success\r\n    \"\"\"\r\n    assert msg.sender == self.minter  # dev: minter only\r\n    assert _to != ZERO_ADDRESS  # dev: zero address\r\n\r\n    if block.timestamp >= self.start_epoch_time + RATE_REDUCTION_TIME:\r\n        self._update_mining_parameters()\r\n\r\n    _total_supply: uint256 = self.total_supply + _value\r\n    assert _total_supply <= self._available_supply()  # dev: exceeds allowable mint amount\r\n    self.total_supply = _total_supply\r\n\r\n    self.balanceOf[_to] += _value\r\n    log Transfer(ZERO_ADDRESS, _to, _value)\r\n\r\n    return True\r\n\r\n\r\n@external\r\ndef burn(_value: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Burn `_value` tokens belonging to `msg.sender`\r\n    @dev Emits a Transfer event with a destination of 0x00\r\n    @param _value The amount that will be burned\r\n    @return bool success\r\n    \"\"\"\r\n    self.balanceOf[msg.sender] -= _value\r\n    self.total_supply -= _value\r\n\r\n    log Transfer(msg.sender, ZERO_ADDRESS, _value)\r\n    return True\r\n\r\n\r\n@external\r\ndef set_name(_name: String[64], _symbol: String[32]):\r\n    \"\"\"\r\n    @notice Change the token name and symbol to `_name` and `_symbol`\r\n    @dev Only callable by the admin account\r\n    @param _name New token name\r\n    @param _symbol New token symbol\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"Only admin is allowed to change name\"\r\n    self.name = _name\r\n    self.symbol = _symbol","ABI":"[{\"name\":\"Transfer\",\"inputs\":[{\"type\":\"address\",\"name\":\"_from\",\"indexed\":true},{\"type\":\"address\",\"name\":\"_to\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"_value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"type\":\"address\",\"name\":\"_owner\",\"indexed\":true},{\"type\":\"address\",\"name\":\"_spender\",\"indexed\":true},{\"type\":\"uint256\",\"name\":\"_value\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateMiningParameters\",\"inputs\":[{\"type\":\"uint256\",\"name\":\"time\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"rate\",\"indexed\":false},{\"type\":\"uint256\",\"name\":\"supply\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetMinter\",\"inputs\":[{\"type\":\"address\",\"name\":\"minter\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"SetAdmin\",\"inputs\":[{\"type\":\"address\",\"name\":\"admin\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_name\"},{\"type\":\"string\",\"name\":\"_symbol\"},{\"type\":\"uint256\",\"name\":\"_decimals\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"name\":\"update_mining_parameters\",\"outputs\":[],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":148748},{\"name\":\"start_epoch_time_write\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":149603},{\"name\":\"future_epoch_time_write\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":149806},{\"name\":\"available_supply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":4018},{\"name\":\"mintable_in_timeframe\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"start\"},{\"type\":\"uint256\",\"name\":\"end\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":2216141},{\"name\":\"set_minter\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_minter\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":38698},{\"name\":\"set_admin\",\"outputs\":[],\"inputs\":[{\"type\":\"address\",\"name\":\"_admin\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":37837},{\"name\":\"totalSupply\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1421},{\"name\":\"allowance\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_owner\"},{\"type\":\"address\",\"name\":\"_spender\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1759},{\"name\":\"transfer\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":75139},{\"name\":\"transferFrom\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_from\"},{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":111433},{\"name\":\"approve\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_spender\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":39288},{\"name\":\"mint\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"_to\"},{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":228030},{\"name\":\"burn\",\"outputs\":[{\"type\":\"bool\",\"name\":\"\"}],\"inputs\":[{\"type\":\"uint256\",\"name\":\"_value\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":74999},{\"name\":\"set_name\",\"outputs\":[],\"inputs\":[{\"type\":\"string\",\"name\":\"_name\"},{\"type\":\"string\",\"name\":\"_symbol\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"gas\":178270},{\"name\":\"name\",\"outputs\":[{\"type\":\"string\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":8063},{\"name\":\"symbol\",\"outputs\":[{\"type\":\"string\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":7116},{\"name\":\"decimals\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1721},{\"name\":\"balanceOf\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[{\"type\":\"address\",\"name\":\"arg0\"}],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1905},{\"name\":\"minter\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1781},{\"name\":\"admin\",\"outputs\":[{\"type\":\"address\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1811},{\"name\":\"mining_epoch\",\"outputs\":[{\"type\":\"int128\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1841},{\"name\":\"start_epoch_time\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1871},{\"name\":\"rate\",\"outputs\":[{\"type\":\"uint256\",\"name\":\"\"}],\"inputs\":[],\"stateMutability\":\"view\",\"type\":\"function\",\"gas\":1901}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.4","OptimizationUsed":0,"Runs":0,"ConstructorArguments":"0x000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000f43757276652044414f20546f6b656e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034352560000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":0,"SwarmSource":""}]}