{"expiry":1699581631,"data":[{"SourceCode":{"language":"Solidity","sources":{"cache/solpp-generated-contracts/common/interfaces/IAllowList.sol":{"content":"pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n\n\ninterface IAllowList {\n    /*//////////////////////////////////////////////////////////////\n                            EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Access mode of target contract is changed\n    event UpdateAccessMode(address indexed target, AccessMode previousMode, AccessMode newMode);\n\n    /// @notice Permission to call is changed\n    event UpdateCallPermission(address indexed caller, address indexed target, bytes4 indexed functionSig, bool status);\n\n    /// @notice Type of access to a specific contract includes three different modes\n    /// @param Closed No one has access to the contract\n    /// @param SpecialAccessOnly Any address with granted special access can interact with a contract (see `hasSpecialAccessToCall`)\n    /// @param Public Everyone can interact with a contract\n    enum AccessMode {\n        Closed,\n        SpecialAccessOnly,\n        Public\n    }\n\n    /// @dev A struct that contains deposit limit data of a token\n    /// @param depositLimitation Whether any deposit limitation is placed or not\n    /// @param depositCap The maximum amount that can be deposited.\n    struct Deposit {\n        bool depositLimitation;\n        uint256 depositCap;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    function getAccessMode(address _target) external view returns (AccessMode);\n\n    function hasSpecialAccessToCall(\n        address _caller,\n        address _target,\n        bytes4 _functionSig\n    ) external view returns (bool);\n\n    function canCall(\n        address _caller,\n        address _target,\n        bytes4 _functionSig\n    ) external view returns (bool);\n\n    function getTokenDepositLimitData(address _l1Token) external view returns (Deposit memory);\n\n    /*//////////////////////////////////////////////////////////////\n                           ALLOW LIST LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setBatchAccessMode(address[] calldata _targets, AccessMode[] calldata _accessMode) external;\n\n    function setAccessMode(address _target, AccessMode _accessMode) external;\n\n    function setBatchPermissionToCall(\n        address[] calldata _callers,\n        address[] calldata _targets,\n        bytes4[] calldata _functionSigs,\n        bool[] calldata _enables\n    ) external;\n\n    function setPermissionToCall(\n        address _caller,\n        address _target,\n        bytes4 _functionSig,\n        bool _enable\n    ) external;\n\n    /*//////////////////////////////////////////////////////////////\n                           DEPOSIT LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setDepositLimit(\n        address _l1Token,\n        bool _depositLimitation,\n        uint256 _depositCap\n    ) external;\n}\n"},"@openzeppelin/contracts/access/Ownable2Step.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() external {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}\n"},"@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"cache/solpp-generated-contracts/common/AllowList.sol":{"content":"pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\n\nimport \"./interfaces/IAllowList.sol\";\nimport \"./libraries/UncheckedMath.sol\";\n\n/// @author Matter Labs\n/// @notice The smart contract that stores the permissions to call the function on different contracts.\n/// @dev The contract is fully controlled by the owner, that can grant and revoke any permissions at any time.\n/// @dev The permission list has three different modes:\n/// - Closed. The contract can NOT be called by anyone.\n/// - SpecialAccessOnly. Only some contract functions can be called by specifically granted addresses.\n/// - Public. Access list to call any function from the target contract by any caller\ncontract AllowList is IAllowList, Ownable2Step {\n    using UncheckedMath for uint256;\n\n    /// @notice The Access mode by which it is decided whether the caller has access\n    mapping(address => AccessMode) public getAccessMode;\n\n    /// @notice The mapping that stores permissions to call the function on the target address by the caller\n    /// @dev caller => target => function signature => permission to call target function for the given caller address\n    mapping(address => mapping(address => mapping(bytes4 => bool))) public hasSpecialAccessToCall;\n\n    /// @dev The mapping L1 token address => struct Deposit\n    mapping(address => Deposit) public tokenDeposit;\n\n    constructor(address _initialOwner) {\n        _transferOwnership(_initialOwner);\n    }\n\n    /// @return Whether the caller can call the specific function on the target contract\n    /// @param _caller The caller address, who is granted access\n    /// @param _target The address of the smart contract which is called\n    /// @param _functionSig The function signature (selector), access to which need to check\n    function canCall(\n        address _caller,\n        address _target,\n        bytes4 _functionSig\n    ) external view returns (bool) {\n        AccessMode accessMode = getAccessMode[_target];\n        return\n            accessMode == AccessMode.Public ||\n            (accessMode == AccessMode.SpecialAccessOnly && hasSpecialAccessToCall[_caller][_target][_functionSig]);\n    }\n\n    /// @notice Set the permission mode to call the target contract\n    /// @param _target The address of the smart contract, of which access to the call is to be changed\n    /// @param _accessMode Whether no one, any or only some addresses can call the target contract\n    function setAccessMode(address _target, AccessMode _accessMode) external onlyOwner {\n        _setAccessMode(_target, _accessMode);\n    }\n\n    /// @notice Set many permission modes to call the target contracts\n    /// @dev Analogous to function `setAccessMode` but performs a batch of changes\n    /// @param _targets The array of smart contract addresses, of which access to the call is to be changed\n    /// @param _accessModes The array of new permission modes, whether no one, any or only some addresses can call the target contract\n    function setBatchAccessMode(address[] calldata _targets, AccessMode[] calldata _accessModes) external onlyOwner {\n        uint256 targetsLength = _targets.length;\n        require(targetsLength == _accessModes.length, \"yg\"); // The size of arrays should be equal\n\n        for (uint256 i = 0; i < targetsLength; i = i.uncheckedInc()) {\n            _setAccessMode(_targets[i], _accessModes[i]);\n        }\n    }\n\n    /// @dev Changes access mode and emit the event if the access was changed\n    function _setAccessMode(address _target, AccessMode _accessMode) internal {\n        AccessMode accessMode = getAccessMode[_target];\n\n        if (accessMode != _accessMode) {\n            getAccessMode[_target] = _accessMode;\n            emit UpdateAccessMode(_target, accessMode, _accessMode);\n        }\n    }\n\n    /// @notice Set many permissions to call the function on the contract to the specified caller address\n    /// @param _callers The array of caller addresses, who are granted access\n    /// @param _targets The array of smart contract addresses, of which access to the call are to be changed\n    /// @param _functionSigs The array of function signatures (selectors), access to which need to be changed\n    /// @param _enables The array of boolean flags, whether enable or disable the function access to the corresponding target address\n    function setBatchPermissionToCall(\n        address[] calldata _callers,\n        address[] calldata _targets,\n        bytes4[] calldata _functionSigs,\n        bool[] calldata _enables\n    ) external onlyOwner {\n        uint256 callersLength = _callers.length;\n\n        // The size of arrays should be equal\n        require(callersLength == _targets.length, \"yw\");\n        require(callersLength == _functionSigs.length, \"yx\");\n        require(callersLength == _enables.length, \"yy\");\n\n        for (uint256 i = 0; i < callersLength; i = i.uncheckedInc()) {\n            _setPermissionToCall(_callers[i], _targets[i], _functionSigs[i], _enables[i]);\n        }\n    }\n\n    /// @notice Set the permission to call the function on the contract to the specified caller address\n    /// @param _caller The caller address, who is granted access\n    /// @param _target The address of the smart contract, of which access to the call is to be changed\n    /// @param _functionSig The function signature (selector), access to which need to be changed\n    /// @param _enable Whether enable or disable the permission\n    function setPermissionToCall(\n        address _caller,\n        address _target,\n        bytes4 _functionSig,\n        bool _enable\n    ) external onlyOwner {\n        _setPermissionToCall(_caller, _target, _functionSig, _enable);\n    }\n\n    /// @dev Changes permission to call and emits the event if the permission was changed\n    function _setPermissionToCall(\n        address _caller,\n        address _target,\n        bytes4 _functionSig,\n        bool _enable\n    ) internal {\n        bool currentPermission = hasSpecialAccessToCall[_caller][_target][_functionSig];\n\n        if (currentPermission != _enable) {\n            hasSpecialAccessToCall[_caller][_target][_functionSig] = _enable;\n            emit UpdateCallPermission(_caller, _target, _functionSig, _enable);\n        }\n    }\n\n    /// @dev Set deposit limit data for a token\n    /// @param _l1Token The address of L1 token\n    /// @param _depositLimitation deposit limitation is active or not\n    /// @param _depositCap The maximum amount that can be deposited.\n    function setDepositLimit(\n        address _l1Token,\n        bool _depositLimitation,\n        uint256 _depositCap\n    ) external onlyOwner {\n        tokenDeposit[_l1Token].depositLimitation = _depositLimitation;\n        tokenDeposit[_l1Token].depositCap = _depositCap;\n    }\n\n    /// @dev Get deposit limit data of a token\n    /// @param _l1Token The address of L1 token\n    function getTokenDepositLimitData(address _l1Token) external view returns (Deposit memory) {\n        return tokenDeposit[_l1Token];\n    }\n}\n"},"cache/solpp-generated-contracts/common/libraries/UncheckedMath.sol":{"content":"pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n\n\nlibrary UncheckedMath {\n    function uncheckedInc(uint256 _number) internal pure returns (uint256) {\n        unchecked {\n            return _number + 1;\n        }\n    }\n\n    function uncheckedAdd(uint256 _lhs, uint256 _rhs) internal pure returns (uint256) {\n        unchecked {\n            return _lhs + _rhs;\n        }\n    }\n}\n"},"@openzeppelin/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"}},"settings":{"libraries":{},"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}}},"ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initialOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum IAllowList.AccessMode\",\"name\":\"previousMode\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"enum IAllowList.AccessMode\",\"name\":\"newMode\",\"type\":\"uint8\"}],\"name\":\"UpdateAccessMode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"functionSig\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"UpdateCallPermission\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"_functionSig\",\"type\":\"bytes4\"}],\"name\":\"canCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getAccessMode\",\"outputs\":[{\"internalType\":\"enum IAllowList.AccessMode\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_l1Token\",\"type\":\"address\"}],\"name\":\"getTokenDepositLimitData\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"depositLimitation\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"depositCap\",\"type\":\"uint256\"}],\"internalType\":\"struct IAllowList.Deposit\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"hasSpecialAccessToCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"enum IAllowList.AccessMode\",\"name\":\"_accessMode\",\"type\":\"uint8\"}],\"name\":\"setAccessMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_targets\",\"type\":\"address[]\"},{\"internalType\":\"enum IAllowList.AccessMode[]\",\"name\":\"_accessModes\",\"type\":\"uint8[]\"}],\"name\":\"setBatchAccessMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_callers\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_targets\",\"type\":\"address[]\"},{\"internalType\":\"bytes4[]\",\"name\":\"_functionSigs\",\"type\":\"bytes4[]\"},{\"internalType\":\"bool[]\",\"name\":\"_enables\",\"type\":\"bool[]\"}],\"name\":\"setBatchPermissionToCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_l1Token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_depositLimitation\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_depositCap\",\"type\":\"uint256\"}],\"name\":\"setDepositLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"_functionSig\",\"type\":\"bytes4\"},{\"internalType\":\"bool\",\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"setPermissionToCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenDeposit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"depositLimitation\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"depositCap\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AllowList","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x0000000000000000000000004e4943346848c4867f81dfb37c4ca9c5715a7828","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}