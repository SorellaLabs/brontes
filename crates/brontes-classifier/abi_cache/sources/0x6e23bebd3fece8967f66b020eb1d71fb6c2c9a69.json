{"expiry":1699514900,"data":[{"SourceCode":{"language":"Solidity","sources":{"contracts/interfaces/pool/IPoolEvents.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IPoolEvents {\n  /// @notice Emitted only once per pool when #initialize is first called\n  /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n  /// @param sqrtP The initial price of the pool\n  /// @param tick The initial tick of the pool\n  event Initialize(uint160 sqrtP, int24 tick);\n\n  /// @notice Emitted when liquidity is minted for a given position\n  /// @dev transfers reinvestment tokens for any collected fees earned by the position\n  /// @param sender address that minted the liquidity\n  /// @param owner address of owner of the position\n  /// @param tickLower position's lower tick\n  /// @param tickUpper position's upper tick\n  /// @param qty liquidity minted to the position range\n  /// @param qty0 token0 quantity needed to mint the liquidity\n  /// @param qty1 token1 quantity needed to mint the liquidity\n  event Mint(\n    address sender,\n    address indexed owner,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 qty,\n    uint256 qty0,\n    uint256 qty1\n  );\n\n  /// @notice Emitted when a position's liquidity is removed\n  /// @dev transfers reinvestment tokens for any collected fees earned by the position\n  /// @param owner address of owner of the position\n  /// @param tickLower position's lower tick\n  /// @param tickUpper position's upper tick\n  /// @param qty liquidity removed\n  /// @param qty0 token0 quantity withdrawn from removal of liquidity\n  /// @param qty1 token1 quantity withdrawn from removal of liquidity\n  event Burn(\n    address indexed owner,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 qty,\n    uint256 qty0,\n    uint256 qty1\n  );\n\n  /// @notice Emitted when reinvestment tokens are burnt\n  /// @param owner address which burnt the reinvestment tokens\n  /// @param qty reinvestment token quantity burnt\n  /// @param qty0 token0 quantity sent to owner for burning reinvestment tokens\n  /// @param qty1 token1 quantity sent to owner for burning reinvestment tokens\n  event BurnRTokens(address indexed owner, uint256 qty, uint256 qty0, uint256 qty1);\n\n  /// @notice Emitted for swaps by the pool between token0 and token1\n  /// @param sender Address that initiated the swap call, and that received the callback\n  /// @param recipient Address that received the swap output\n  /// @param deltaQty0 Change in pool's token0 balance\n  /// @param deltaQty1 Change in pool's token1 balance\n  /// @param sqrtP Pool's sqrt price after the swap\n  /// @param liquidity Pool's liquidity after the swap\n  /// @param currentTick Log base 1.0001 of pool's price after the swap\n  event Swap(\n    address indexed sender,\n    address indexed recipient,\n    int256 deltaQty0,\n    int256 deltaQty1,\n    uint160 sqrtP,\n    uint128 liquidity,\n    int24 currentTick\n  );\n\n  /// @notice Emitted by the pool for any flash loans of token0/token1\n  /// @param sender The address that initiated the flash loan, and that received the callback\n  /// @param recipient The address that received the flash loan quantities\n  /// @param qty0 token0 quantity loaned to the recipient\n  /// @param qty1 token1 quantity loaned to the recipient\n  /// @param paid0 token0 quantity paid for the flash, which can exceed qty0 + fee\n  /// @param paid1 token1 quantity paid for the flash, which can exceed qty0 + fee\n  event Flash(\n    address indexed sender,\n    address indexed recipient,\n    uint256 qty0,\n    uint256 qty1,\n    uint256 paid0,\n    uint256 paid1\n  );\n}\n"},"@openzeppelin/contracts/proxy/Clones.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"},"contracts/libraries/QuadMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nlibrary QuadMath {\n  // our equation is ax^2 - 2bx + c = 0, where a, b and c > 0\n  // the qudratic formula to obtain the smaller root is (2b - sqrt((2*b)^2 - 4ac)) / 2a\n  // which can be simplified to (b - sqrt(b^2 - ac)) / a\n  function getSmallerRootOfQuadEqn(\n    uint256 a,\n    uint256 b,\n    uint256 c\n  ) internal pure returns (uint256 smallerRoot) {\n    smallerRoot = (b - sqrt(b * b - a * c)) / a;\n  }\n\n  // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n  function sqrt(uint256 y) internal pure returns (uint256 z) {\n    unchecked {\n      if (y > 3) {\n        z = y;\n        uint256 x = y / 2 + 1;\n        while (x < z) {\n          z = x;\n          x = (y / x + x) / 2;\n        }\n      } else if (y != 0) {\n        z = 1;\n      }\n    }\n  }\n}\n"},"@openzeppelin/contracts/utils/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"contracts/PoolStorage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport {Clones} from '@openzeppelin/contracts/proxy/Clones.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {Linkedlist} from './libraries/Linkedlist.sol';\nimport {TickMath} from './libraries/TickMath.sol';\nimport {MathConstants as C} from './libraries/MathConstants.sol';\nimport {IPoolOracle} from './interfaces/oracle/IPoolOracle.sol';\n\nimport {IFactory} from './interfaces/IFactory.sol';\nimport {IPoolStorage} from './interfaces/pool/IPoolStorage.sol';\n\nabstract contract PoolStorage is IPoolStorage {\n  using Clones for address;\n  using Linkedlist for mapping(int24 => Linkedlist.Data);\n\n  address internal constant LIQUIDITY_LOCKUP_ADDRESS = 0xD444422222222222222222222222222222222222;\n\n  struct PoolData {\n    uint160 sqrtP;\n    int24 nearestCurrentTick;\n    int24 currentTick;\n    bool locked;\n    uint128 baseL;\n    uint128 reinvestL;\n    uint128 reinvestLLast;\n    uint256 feeGrowthGlobal;\n    uint128 secondsPerLiquidityGlobal;\n    uint32 secondsPerLiquidityUpdateTime;\n  }\n\n  // data stored for each initialized individual tick\n  struct TickData {\n    // gross liquidity of all positions in tick\n    uint128 liquidityGross;\n    // liquidity quantity to be added | removed when tick is crossed up | down\n    int128 liquidityNet;\n    // fee growth per unit of liquidity on the other side of this tick (relative to current tick)\n    // only has relative meaning, not absolute — the value depends on when the tick is initialized\n    uint256 feeGrowthOutside;\n    // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n    // only has relative meaning, not absolute — the value depends on when the tick is initialized\n    uint128 secondsPerLiquidityOutside;\n  }\n\n  // data stored for each user's position\n  struct Position {\n    // the amount of liquidity owned by this position\n    uint128 liquidity;\n    // fee growth per unit of liquidity as of the last update to liquidity\n    uint256 feeGrowthInsideLast;\n  }\n\n  struct CumulativesData {\n    uint256 feeGrowth;\n    uint128 secondsPerLiquidity;\n  }\n\n  /// see IPoolStorage for explanations of the immutables below\n  IFactory public immutable override factory;\n  IERC20 public immutable override token0;\n  IERC20 public immutable override token1;\n  IPoolOracle public immutable override poolOracle;\n  uint128 public immutable override maxTickLiquidity;\n  uint24 public immutable override swapFeeUnits;\n  int24 public immutable override tickDistance;\n\n  mapping(int24 => TickData) public override ticks;\n  mapping(int24 => Linkedlist.Data) public override initializedTicks;\n\n  mapping(bytes32 => Position) internal positions;\n\n  PoolData internal poolData;\n\n  /// @dev Mutually exclusive reentrancy protection into the pool from/to a method.\n  /// Also prevents entrance to pool actions prior to initalization\n  modifier lock() {\n    require(poolData.locked == false, 'locked');\n    poolData.locked = true;\n    _;\n    poolData.locked = false;\n  }\n\n  constructor() {\n    // fetch data from factory constructor\n    (\n      address _factory,\n      address _poolOracle,\n      address _token0,\n      address _token1,\n      uint24 _swapFeeUnits,\n      int24 _tickDistance\n    ) = IFactory(msg.sender).parameters();\n    factory = IFactory(_factory);\n    poolOracle = IPoolOracle(_poolOracle);\n    token0 = IERC20(_token0);\n    token1 = IERC20(_token1);\n    swapFeeUnits = _swapFeeUnits;\n    tickDistance = _tickDistance;\n\n    maxTickLiquidity = type(uint128).max / TickMath.getMaxNumberTicks(_tickDistance);\n    poolData.locked = true; // set pool to locked state\n  }\n\n  function _initPoolStorage(uint160 initialSqrtP, int24 initialTick) internal {\n    poolData.baseL = 0;\n    poolData.reinvestL = C.MIN_LIQUIDITY;\n    poolData.reinvestLLast = C.MIN_LIQUIDITY;\n\n    poolData.sqrtP = initialSqrtP;\n    poolData.currentTick = initialTick;\n    poolData.nearestCurrentTick = TickMath.MIN_TICK;\n\n    initializedTicks.init(TickMath.MIN_TICK, TickMath.MAX_TICK);\n\n    poolOracle.initializeOracle(_blockTimestamp());\n\n    poolData.locked = false; // unlock the pool\n  }\n\n  function getPositions(\n    address owner,\n    int24 tickLower,\n    int24 tickUpper\n  ) external view override returns (uint128 liquidity, uint256 feeGrowthInsideLast) {\n    bytes32 key = _positionKey(owner, tickLower, tickUpper);\n    return (positions[key].liquidity, positions[key].feeGrowthInsideLast);\n  }\n\n  /// @inheritdoc IPoolStorage\n  function getPoolState()\n    external\n    view\n    override\n    returns (\n      uint160 sqrtP,\n      int24 currentTick,\n      int24 nearestCurrentTick,\n      bool locked\n    )\n  {\n    sqrtP = poolData.sqrtP;\n    currentTick = poolData.currentTick;\n    nearestCurrentTick = poolData.nearestCurrentTick;\n    locked = poolData.locked;\n  }\n\n  /// @inheritdoc IPoolStorage\n  function getLiquidityState()\n    external\n    view\n    override\n    returns (\n      uint128 baseL,\n      uint128 reinvestL,\n      uint128 reinvestLLast\n    )\n  {\n    baseL = poolData.baseL;\n    reinvestL = poolData.reinvestL;\n    reinvestLLast = poolData.reinvestLLast;\n  }\n\n  function getFeeGrowthGlobal() external view override returns (uint256) {\n    return poolData.feeGrowthGlobal;\n  }\n\n  function getSecondsPerLiquidityData()\n    external\n    view\n    override\n    returns (uint128 secondsPerLiquidityGlobal, uint32 lastUpdateTime)\n  {\n    secondsPerLiquidityGlobal = poolData.secondsPerLiquidityGlobal;\n    lastUpdateTime = poolData.secondsPerLiquidityUpdateTime;\n  }\n\n  function getSecondsPerLiquidityInside(int24 tickLower, int24 tickUpper)\n    external\n    view\n    override\n    returns (uint128 secondsPerLiquidityInside)\n  {\n    require(tickLower <= tickUpper, 'bad tick range');\n    int24 currentTick = poolData.currentTick;\n    uint128 secondsPerLiquidityGlobal = poolData.secondsPerLiquidityGlobal;\n    uint32 lastUpdateTime = poolData.secondsPerLiquidityUpdateTime;\n\n    uint128 lowerValue = ticks[tickLower].secondsPerLiquidityOutside;\n    uint128 upperValue = ticks[tickUpper].secondsPerLiquidityOutside;\n\n    unchecked {\n      if (currentTick < tickLower) {\n        secondsPerLiquidityInside = lowerValue - upperValue;\n      } else if (currentTick >= tickUpper) {\n        secondsPerLiquidityInside = upperValue - lowerValue;\n      } else {\n        secondsPerLiquidityInside = secondsPerLiquidityGlobal - (lowerValue + upperValue);\n      }\n    }\n\n    // in the case where position is in range (tickLower <= _poolTick < tickUpper),\n    // need to add timeElapsed per liquidity\n    if (tickLower <= currentTick && currentTick < tickUpper) {\n      uint256 secondsElapsed = _blockTimestamp() - lastUpdateTime;\n      uint128 baseL = poolData.baseL;\n      if (secondsElapsed > 0 && baseL > 0) {\n        unchecked {\n          secondsPerLiquidityInside += uint128((secondsElapsed << 96) / baseL);\n        }\n      }\n    }\n  }\n\n  function _positionKey(\n    address owner,\n    int24 tickLower,\n    int24 tickUpper\n  ) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(owner, tickLower, tickUpper));\n  }\n\n  /// @dev For overriding in tests\n  function _blockTimestamp() internal view virtual returns (uint32) {\n    return uint32(block.timestamp);\n  }\n}\n"},"contracts/interfaces/IPool.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IPoolActions} from './pool/IPoolActions.sol';\nimport {IPoolEvents} from './pool/IPoolEvents.sol';\nimport {IPoolStorage} from './pool/IPoolStorage.sol';\n\ninterface IPool is IPoolActions, IPoolEvents, IPoolStorage {}\n"},"contracts/libraries/TickMath.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n  /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n  int24 internal constant MIN_TICK = -887272;\n  /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n  int24 internal constant MAX_TICK = -MIN_TICK;\n\n  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n  uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n  uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n  /// @notice Calculates sqrt(1.0001^tick) * 2^96\n  /// @dev Throws if |tick| > max tick\n  /// @param tick The input tick for the above formula\n  /// @return sqrtP A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n  /// at the given tick\n  function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtP) {\n    unchecked {\n      uint256 absTick = uint256(tick < 0 ? -int256(tick) : int256(tick));\n      require(absTick <= uint256(int256(MAX_TICK)), 'T');\n\n      // do bitwise comparison, if i-th bit is turned on,\n      // multiply ratio by hardcoded values of sqrt(1.0001^-(2^i)) * 2^128\n      // where 0 <= i <= 19\n      uint256 ratio = (absTick & 0x1 != 0)\n        ? 0xfffcb933bd6fad37aa2d162d1a594001\n        : 0x100000000000000000000000000000000;\n      if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n      if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n      if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n      if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n      if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n      if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n      if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n      if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n      if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n      if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n      if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n      if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n      if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n      if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n      if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n      if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n      if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n      if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n      if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n      // take reciprocal for positive tick values\n      if (tick > 0) ratio = type(uint256).max / ratio;\n\n      // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n      // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n      // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n      sqrtP = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n  }\n\n  /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n  /// @dev Throws in case sqrtP < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n  /// ever return.\n  /// @param sqrtP The sqrt ratio for which to compute the tick as a Q64.96\n  /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n  function getTickAtSqrtRatio(uint160 sqrtP) internal pure returns (int24 tick) {\n    // second inequality must be < because the price can never reach the price at the max tick\n    require(sqrtP >= MIN_SQRT_RATIO && sqrtP < MAX_SQRT_RATIO, 'R');\n    uint256 ratio = uint256(sqrtP) << 32;\n\n    uint256 r = ratio;\n    uint256 msb = 0;\n\n    unchecked {\n      assembly {\n        let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n        msb := or(msb, f)\n        r := shr(f, r)\n      }\n      assembly {\n        let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n        msb := or(msb, f)\n        r := shr(f, r)\n      }\n      assembly {\n        let f := shl(5, gt(r, 0xFFFFFFFF))\n        msb := or(msb, f)\n        r := shr(f, r)\n      }\n      assembly {\n        let f := shl(4, gt(r, 0xFFFF))\n        msb := or(msb, f)\n        r := shr(f, r)\n      }\n      assembly {\n        let f := shl(3, gt(r, 0xFF))\n        msb := or(msb, f)\n        r := shr(f, r)\n      }\n      assembly {\n        let f := shl(2, gt(r, 0xF))\n        msb := or(msb, f)\n        r := shr(f, r)\n      }\n      assembly {\n        let f := shl(1, gt(r, 0x3))\n        msb := or(msb, f)\n        r := shr(f, r)\n      }\n      assembly {\n        let f := gt(r, 0x1)\n        msb := or(msb, f)\n      }\n\n      if (msb >= 128) r = ratio >> (msb - 127);\n      else r = ratio << (127 - msb);\n\n      int256 log_2 = (int256(msb) - 128) << 64;\n\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(63, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(62, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(61, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(60, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(59, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(58, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(57, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(56, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(55, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(54, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(53, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(52, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(51, f))\n        r := shr(f, r)\n      }\n      assembly {\n        r := shr(127, mul(r, r))\n        let f := shr(128, r)\n        log_2 := or(log_2, shl(50, f))\n      }\n\n      int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n      int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n      int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n      tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtP ? tickHi : tickLow;\n    }\n  }\n\n  function getMaxNumberTicks(int24 _tickDistance) internal pure returns (uint24 numTicks) {\n    return uint24(TickMath.MAX_TICK / _tickDistance) * 2;\n  }\n}\n"},"contracts/libraries/FullMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\n/// @dev Code has been modified to be compatible with sol 0.8\nlibrary FullMath {\n  /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n  function mulDivFloor(\n    uint256 a,\n    uint256 b,\n    uint256 denominator\n  ) internal pure returns (uint256 result) {\n    // 512-bit multiply [prod1 prod0] = a * b\n    // Compute the product mod 2**256 and mod 2**256 - 1\n    // then use the Chinese Remainder Theorem to reconstruct\n    // the 512 bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2**256 + prod0\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly {\n      let mm := mulmod(a, b, not(0))\n      prod0 := mul(a, b)\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division\n    if (prod1 == 0) {\n      require(denominator > 0, '0 denom');\n      assembly {\n        result := div(prod0, denominator)\n      }\n      return result;\n    }\n\n    // Make sure the result is less than 2**256.\n    // Also prevents denominator == 0\n    require(denominator > prod1, 'denom <= prod1');\n\n    ///////////////////////////////////////////////\n    // 512 by 256 division.\n    ///////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0]\n    // Compute remainder using mulmod\n    uint256 remainder;\n    assembly {\n      remainder := mulmod(a, b, denominator)\n    }\n    // Subtract 256 bit number from 512 bit number\n    assembly {\n      prod1 := sub(prod1, gt(remainder, prod0))\n      prod0 := sub(prod0, remainder)\n    }\n\n    // Factor powers of two out of denominator\n    // Compute largest power of two divisor of denominator.\n    // Always >= 1.\n    uint256 twos = denominator & (~denominator + 1);\n    // Divide denominator by power of two\n    assembly {\n      denominator := div(denominator, twos)\n    }\n\n    // Divide [prod1 prod0] by the factors of two\n    assembly {\n      prod0 := div(prod0, twos)\n    }\n    // Shift in bits from prod1 into prod0. For this we need\n    // to flip `twos` such that it is 2**256 / twos.\n    // If twos is zero, then it becomes one\n    assembly {\n      twos := add(div(sub(0, twos), twos), 1)\n    }\n    unchecked {\n      prod0 |= prod1 * twos;\n\n      // Invert denominator mod 2**256\n      // Now that denominator is an odd number, it has an inverse\n      // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n      // Compute the inverse by starting with a seed that is correct\n      // correct for four bits. That is, denominator * inv = 1 mod 2**4\n      uint256 inv = (3 * denominator) ^ 2;\n\n      // Now use Newton-Raphson iteration to improve the precision.\n      // Thanks to Hensel's lifting lemma, this also works in modular\n      // arithmetic, doubling the correct bits in each step.\n      inv *= 2 - denominator * inv; // inverse mod 2**8\n      inv *= 2 - denominator * inv; // inverse mod 2**16\n      inv *= 2 - denominator * inv; // inverse mod 2**32\n      inv *= 2 - denominator * inv; // inverse mod 2**64\n      inv *= 2 - denominator * inv; // inverse mod 2**128\n      inv *= 2 - denominator * inv; // inverse mod 2**256\n\n      // Because the division is now exact we can divide by multiplying\n      // with the modular inverse of denominator. This will give us the\n      // correct result modulo 2**256. Since the precoditions guarantee\n      // that the outcome is less than 2**256, this is the final result.\n      // We don't need to compute the high bits of the result and prod1\n      // is no longer required.\n      result = prod0 * inv;\n    }\n    return result;\n  }\n\n  /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  function mulDivCeiling(\n    uint256 a,\n    uint256 b,\n    uint256 denominator\n  ) internal pure returns (uint256 result) {\n    result = mulDivFloor(a, b, denominator);\n    if (mulmod(a, b, denominator) > 0) {\n      result++;\n    }\n  }\n}\n"},"contracts/libraries/LiqDeltaMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @title Contains helper function to add or remove uint128 liquidityDelta to uint128 liquidity\nlibrary LiqDeltaMath {\n  function applyLiquidityDelta(\n    uint128 liquidity,\n    uint128 liquidityDelta,\n    bool isAddLiquidity\n  ) internal pure returns (uint128) {\n    return isAddLiquidity ? liquidity + liquidityDelta : liquidity - liquidityDelta;\n  }\n}\n"},"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"contracts/libraries/ReinvestmentMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {MathConstants as C} from './MathConstants.sol';\nimport {FullMath} from './FullMath.sol';\n\n/// @title Contains helper function to calculate the number of reinvestment tokens to be minted\nlibrary ReinvestmentMath {\n  /// @dev calculate the mint amount with given reinvestL, reinvestLLast, baseL and rTotalSupply\n  /// contribution of lp to the increment is calculated by the proportion of baseL with reinvestL + baseL\n  /// then rMintQty is calculated by mutiplying this with the liquidity per reinvestment token\n  /// rMintQty = rTotalSupply * (reinvestL - reinvestLLast) / reinvestLLast * baseL / (baseL + reinvestL)\n  function calcrMintQty(\n    uint256 reinvestL,\n    uint256 reinvestLLast,\n    uint128 baseL,\n    uint256 rTotalSupply\n  ) internal pure returns (uint256 rMintQty) {\n    uint256 lpContribution = FullMath.mulDivFloor(\n      baseL,\n      reinvestL - reinvestLLast,\n      baseL + reinvestL\n    );\n    rMintQty = FullMath.mulDivFloor(rTotalSupply, lpContribution, reinvestLLast);\n  }\n}\n"},"contracts/interfaces/callback/IFlashCallback.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @title Callback for IPool#flash\n/// @notice Any contract that calls IPool#flash must implement this interface\ninterface IFlashCallback {\n  /// @notice Called to `msg.sender` after flash loaning to the recipient from IPool#flash.\n  /// @dev This function's implementation must send the loaned amounts with computed fee amounts\n  /// The caller of this method must be checked to be a Pool deployed by the canonical Factory.\n  /// @param feeQty0 The token0 fee to be sent to the pool.\n  /// @param feeQty1 The token1 fee to be sent to the pool.\n  /// @param data Data passed through by the caller via the IPool#flash call\n  function flashCallback(\n    uint256 feeQty0,\n    uint256 feeQty1,\n    bytes calldata data\n  ) external;\n}\n"},"contracts/interfaces/callback/ISwapCallback.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @title Callback for IPool#swap\n/// @notice Any contract that calls IPool#swap must implement this interface\ninterface ISwapCallback {\n  /// @notice Called to `msg.sender` after swap execution of IPool#swap.\n  /// @dev This function's implementation must pay tokens owed to the pool for the swap.\n  /// The caller of this method must be checked to be a Pool deployed by the canonical Factory.\n  /// deltaQty0 and deltaQty1 can both be 0 if no tokens were swapped.\n  /// @param deltaQty0 The token0 quantity that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send deltaQty0 of token0 to the pool.\n  /// @param deltaQty1 The token1 quantity that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send deltaQty1 of token1 to the pool.\n  /// @param data Data passed through by the caller via the IPool#swap call\n  function swapCallback(\n    int256 deltaQty0,\n    int256 deltaQty1,\n    bytes calldata data\n  ) external;\n}\n"},"contracts/interfaces/oracle/IPoolOracle.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IPoolOracle {\n  /// @notice Owner withdrew funds in the pool oracle in case some funds are stuck there\n  event OwnerWithdrew(\n    address indexed owner,\n    address indexed token,\n    uint256 indexed amount\n  );\n\n  /// @notice Emitted by the Pool Oracle for increases to the number of observations that can be stored\n  /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n  /// just before a mint/swap/burn.\n  /// @param pool The pool address to update\n  /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n  /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n  event IncreaseObservationCardinalityNext(\n    address pool,\n    uint16 observationCardinalityNextOld,\n    uint16 observationCardinalityNextNew\n  );\n\n  /// @notice Initalize observation data for the caller.\n  function initializeOracle(uint32 time)\n    external\n    returns (uint16 cardinality, uint16 cardinalityNext);\n\n  /// @notice Write a new oracle entry into the array\n  ///   and update the observation index and cardinality\n  /// Read the Oralce.write function for more details\n  function writeNewEntry(\n    uint16 index,\n    uint32 blockTimestamp,\n    int24 tick,\n    uint128 liquidity,\n    uint16 cardinality,\n    uint16 cardinalityNext\n  )\n    external\n    returns (uint16 indexUpdated, uint16 cardinalityUpdated);\n\n  /// @notice Write a new oracle entry into the array, take the latest observaion data as inputs\n  ///   and update the observation index and cardinality\n  /// Read the Oralce.write function for more details\n  function write(\n    uint32 blockTimestamp,\n    int24 tick,\n    uint128 liquidity\n  )\n    external\n    returns (uint16 indexUpdated, uint16 cardinalityUpdated);\n\n  /// @notice Increase the maximum number of price observations that this pool will store\n  /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n  /// the input observationCardinalityNext.\n  /// @param pool The pool address to be updated\n  /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n  function increaseObservationCardinalityNext(\n    address pool,\n    uint16 observationCardinalityNext\n  )\n    external;\n\n  /// @notice Returns the accumulator values as of each time seconds ago from the latest block time in the array of `secondsAgos`\n  /// @dev Reverts if `secondsAgos` > oldest observation\n  /// @dev It fetches the latest current tick data from the pool\n  /// Read the Oracle.observe function for more details\n  function observeFromPool(\n    address pool,\n    uint32[] memory secondsAgos\n  )\n    external view\n    returns (int56[] memory tickCumulatives);\n\n  /// @notice Returns the accumulator values as the time seconds ago from the latest block time of secondsAgo\n  /// @dev Reverts if `secondsAgo` > oldest observation\n  /// @dev It fetches the latest current tick data from the pool\n  /// Read the Oracle.observeSingle function for more details\n  function observeSingleFromPool(\n    address pool,\n    uint32 secondsAgo\n  )\n    external view\n    returns (int56 tickCumulative);\n\n  /// @notice Return the latest pool observation data given the pool address\n  function getPoolObservation(address pool)\n    external view\n    returns (bool initialized, uint16 index, uint16 cardinality, uint16 cardinalityNext);\n\n  /// @notice Returns data about a specific observation index\n  /// @param pool The pool address of the observations array to fetch\n  /// @param index The element of the observations array to fetch\n  /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n  /// ago, rather than at a specific index in the array.\n  /// @return blockTimestamp The timestamp of the observation,\n  /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n  /// Returns initialized whether the observation has been initialized and the values are safe to use\n  function getObservationAt(address pool, uint256 index)\n    external view\n    returns (\n      uint32 blockTimestamp,\n      int56 tickCumulative,\n      bool initialized\n    );\n}\n"},"contracts/libraries/SwapMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {MathConstants as C} from './MathConstants.sol';\nimport {FullMath} from './FullMath.sol';\nimport {QuadMath} from './QuadMath.sol';\nimport {SafeCast} from './SafeCast.sol';\n\n/// @title Contains helper functions for swaps\nlibrary SwapMath {\n  using SafeCast for uint256;\n  using SafeCast for int256;\n\n  /// @dev Computes the actual swap input / output amounts to be deducted or added,\n  /// the swap fee to be collected and the resulting sqrtP.\n  /// @notice nextSqrtP should not exceed targetSqrtP.\n  /// @param liquidity active base liquidity + reinvest liquidity\n  /// @param currentSqrtP current sqrt price\n  /// @param targetSqrtP sqrt price limit the new sqrt price can take\n  /// @param feeInFeeUnits swap fee in basis points\n  /// @param specifiedAmount the amount remaining to be used for the swap\n  /// @param isExactInput true if specifiedAmount refers to input amount, false if specifiedAmount refers to output amount\n  /// @param isToken0 true if specifiedAmount is in token0, false if specifiedAmount is in token1\n  /// @return usedAmount actual amount to be used for the swap\n  /// @return returnedAmount output qty to be accumulated if isExactInput = true, input qty if isExactInput = false\n  /// @return deltaL collected swap fee, to be incremented to reinvest liquidity\n  /// @return nextSqrtP the new sqrt price after the computed swap step\n  function computeSwapStep(\n    uint256 liquidity,\n    uint160 currentSqrtP,\n    uint160 targetSqrtP,\n    uint256 feeInFeeUnits,\n    int256 specifiedAmount,\n    bool isExactInput,\n    bool isToken0\n  )\n    internal\n    pure\n    returns (\n      int256 usedAmount,\n      int256 returnedAmount,\n      uint256 deltaL,\n      uint160 nextSqrtP\n    )\n  {\n    // in the event currentSqrtP == targetSqrtP because of tick movements, return\n    // eg. swapped up tick where specified price limit is on an initialised tick\n    // then swapping down tick will cause next tick to be the same as the current tick\n    if (currentSqrtP == targetSqrtP) return (0, 0, 0, currentSqrtP);\n    usedAmount = calcReachAmount(\n      liquidity,\n      currentSqrtP,\n      targetSqrtP,\n      feeInFeeUnits,\n      isExactInput,\n      isToken0\n    );\n\n    if (\n      (isExactInput && usedAmount > specifiedAmount) ||\n      (!isExactInput && usedAmount <= specifiedAmount)\n    ) {\n      usedAmount = specifiedAmount;\n    } else {\n      nextSqrtP = targetSqrtP;\n    }\n\n    uint256 absDelta = usedAmount >= 0 ? uint256(usedAmount) : usedAmount.revToUint256();\n    if (nextSqrtP == 0) {\n      deltaL = estimateIncrementalLiquidity(\n        absDelta,\n        liquidity,\n        currentSqrtP,\n        feeInFeeUnits,\n        isExactInput,\n        isToken0\n      );\n      nextSqrtP = calcFinalPrice(absDelta, liquidity, deltaL, currentSqrtP, isExactInput, isToken0)\n      .toUint160();\n    } else {\n      deltaL = calcIncrementalLiquidity(\n        absDelta,\n        liquidity,\n        currentSqrtP,\n        nextSqrtP,\n        isExactInput,\n        isToken0\n      );\n    }\n    returnedAmount = calcReturnedAmount(\n      liquidity,\n      currentSqrtP,\n      nextSqrtP,\n      deltaL,\n      isExactInput,\n      isToken0\n    );\n  }\n\n  /// @dev calculates the amount needed to reach targetSqrtP from currentSqrtP\n  /// @dev we cast currentSqrtP and targetSqrtP to uint256 as they are multiplied by TWO_FEE_UNITS or feeInFeeUnits\n  function calcReachAmount(\n    uint256 liquidity,\n    uint256 currentSqrtP,\n    uint256 targetSqrtP,\n    uint256 feeInFeeUnits,\n    bool isExactInput,\n    bool isToken0\n  ) internal pure returns (int256 reachAmount) {\n    uint256 absPriceDiff;\n    unchecked {\n      absPriceDiff = (currentSqrtP >= targetSqrtP)\n        ? (currentSqrtP - targetSqrtP)\n        : (targetSqrtP - currentSqrtP);\n    }\n    if (isExactInput) {\n      // we round down so that we avoid taking giving away too much for the specified input\n      // ie. require less input qty to move ticks\n      if (isToken0) {\n        // numerator = 2 * liquidity * absPriceDiff\n        // denominator = currentSqrtP * (2 * targetSqrtP - currentSqrtP * feeInFeeUnits / FEE_UNITS)\n        // overflow should not happen because the absPriceDiff is capped to ~5%\n        uint256 denominator = C.TWO_FEE_UNITS * targetSqrtP - feeInFeeUnits * currentSqrtP;\n        uint256 numerator = FullMath.mulDivFloor(\n          liquidity,\n          C.TWO_FEE_UNITS * absPriceDiff,\n          denominator\n        );\n        reachAmount = FullMath.mulDivFloor(numerator, C.TWO_POW_96, currentSqrtP).toInt256();\n      } else {\n        // numerator = 2 * liquidity * absPriceDiff * currentSqrtP\n        // denominator = 2 * currentSqrtP - targetSqrtP * feeInFeeUnits / FEE_UNITS\n        // overflow should not happen because the absPriceDiff is capped to ~5%\n        uint256 denominator = C.TWO_FEE_UNITS * currentSqrtP - feeInFeeUnits * targetSqrtP;\n        uint256 numerator = FullMath.mulDivFloor(\n          liquidity,\n          C.TWO_FEE_UNITS * absPriceDiff,\n          denominator\n        );\n        reachAmount = FullMath.mulDivFloor(numerator, currentSqrtP, C.TWO_POW_96).toInt256();\n      }\n    } else {\n      // we will perform negation as the last step\n      // we round down so that we require less output qty to move ticks\n      if (isToken0) {\n        // numerator: (liquidity)(absPriceDiff)(2 * currentSqrtP - deltaL * (currentSqrtP + targetSqrtP))\n        // denominator: (currentSqrtP * targetSqrtP) * (2 * currentSqrtP - deltaL * targetSqrtP)\n        // overflow should not happen because the absPriceDiff is capped to ~5%\n        uint256 denominator = C.TWO_FEE_UNITS * currentSqrtP - feeInFeeUnits * targetSqrtP;\n        uint256 numerator = denominator - feeInFeeUnits * currentSqrtP;\n        numerator = FullMath.mulDivFloor(liquidity << C.RES_96, numerator, denominator);\n        reachAmount = (FullMath.mulDivFloor(numerator, absPriceDiff, currentSqrtP) / targetSqrtP)\n        .revToInt256();\n      } else {\n        // numerator: liquidity * absPriceDiff * (TWO_FEE_UNITS * targetSqrtP - feeInFeeUnits * (targetSqrtP + currentSqrtP))\n        // denominator: (TWO_FEE_UNITS * targetSqrtP - feeInFeeUnits * currentSqrtP)\n        // overflow should not happen because the absPriceDiff is capped to ~5%\n        uint256 denominator = C.TWO_FEE_UNITS * targetSqrtP - feeInFeeUnits * currentSqrtP;\n        uint256 numerator = denominator - feeInFeeUnits * targetSqrtP;\n        numerator = FullMath.mulDivFloor(liquidity, numerator, denominator);\n        reachAmount = FullMath.mulDivFloor(numerator, absPriceDiff, C.TWO_POW_96).revToInt256();\n      }\n    }\n  }\n\n  /// @dev estimates deltaL, the swap fee to be collected based on amount specified\n  /// for the final swap step to be performed,\n  /// where the next (temporary) tick will not be crossed\n  function estimateIncrementalLiquidity(\n    uint256 absDelta,\n    uint256 liquidity,\n    uint160 currentSqrtP,\n    uint256 feeInFeeUnits,\n    bool isExactInput,\n    bool isToken0\n  ) internal pure returns (uint256 deltaL) {\n    if (isExactInput) {\n      if (isToken0) {\n        // deltaL = feeInFeeUnits * absDelta * currentSqrtP / 2\n        deltaL = FullMath.mulDivFloor(\n          currentSqrtP,\n          absDelta * feeInFeeUnits,\n          C.TWO_FEE_UNITS << C.RES_96\n        );\n      } else {\n        // deltaL = feeInFeeUnits * absDelta * / (currentSqrtP * 2)\n        // Because nextSqrtP = (liquidity + absDelta / currentSqrtP) * currentSqrtP / (liquidity + deltaL)\n        // so we round up deltaL, to round down nextSqrtP\n        deltaL = FullMath.mulDivFloor(\n          C.TWO_POW_96,\n          absDelta * feeInFeeUnits,\n          C.TWO_FEE_UNITS * currentSqrtP\n        );\n      }\n    } else {\n      // obtain the smaller root of the quadratic equation\n      // ax^2 - 2bx + c = 0 such that b > 0, and x denotes deltaL\n      uint256 a = feeInFeeUnits;\n      uint256 b = (C.FEE_UNITS - feeInFeeUnits) * liquidity;\n      uint256 c = feeInFeeUnits * liquidity * absDelta;\n      if (isToken0) {\n        // a = feeInFeeUnits\n        // b = (FEE_UNITS - feeInFeeUnits) * liquidity - FEE_UNITS * absDelta * currentSqrtP\n        // c = feeInFeeUnits * liquidity * absDelta * currentSqrtP\n        b -= FullMath.mulDivFloor(C.FEE_UNITS * absDelta, currentSqrtP, C.TWO_POW_96);\n        c = FullMath.mulDivFloor(c, currentSqrtP, C.TWO_POW_96);\n      } else {\n        // a = feeInFeeUnits\n        // b = (FEE_UNITS - feeInFeeUnits) * liquidity - FEE_UNITS * absDelta / currentSqrtP\n        // c = liquidity * feeInFeeUnits * absDelta / currentSqrtP\n        b -= FullMath.mulDivFloor(C.FEE_UNITS * absDelta, C.TWO_POW_96, currentSqrtP);\n        c = FullMath.mulDivFloor(c, C.TWO_POW_96, currentSqrtP);\n      }\n      deltaL = QuadMath.getSmallerRootOfQuadEqn(a, b, c);\n    }\n  }\n\n  /// @dev calculates deltaL, the swap fee to be collected for an intermediate swap step,\n  /// where the next (temporary) tick will be crossed\n  function calcIncrementalLiquidity(\n    uint256 absDelta,\n    uint256 liquidity,\n    uint160 currentSqrtP,\n    uint160 nextSqrtP,\n    bool isExactInput,\n    bool isToken0\n  ) internal pure returns (uint256 deltaL) {\n    if (isToken0) {\n      // deltaL = nextSqrtP * (liquidity / currentSqrtP +/- absDelta)) - liquidity\n      // needs to be minimum\n      uint256 tmp1 = FullMath.mulDivFloor(liquidity, C.TWO_POW_96, currentSqrtP);\n      uint256 tmp2 = isExactInput ? tmp1 + absDelta : tmp1 - absDelta;\n      uint256 tmp3 = FullMath.mulDivFloor(nextSqrtP, tmp2, C.TWO_POW_96);\n      // in edge cases where liquidity or absDelta is small\n      // liquidity might be greater than nextSqrtP * ((liquidity / currentSqrtP) +/- absDelta))\n      // due to rounding\n      deltaL = (tmp3 > liquidity) ? tmp3 - liquidity : 0;\n    } else {\n      // deltaL = (liquidity * currentSqrtP +/- absDelta) / nextSqrtP - liquidity\n      // needs to be minimum\n      uint256 tmp1 = FullMath.mulDivFloor(liquidity, currentSqrtP, C.TWO_POW_96);\n      uint256 tmp2 = isExactInput ? tmp1 + absDelta : tmp1 - absDelta;\n      uint256 tmp3 = FullMath.mulDivFloor(tmp2, C.TWO_POW_96, nextSqrtP);\n      // in edge cases where liquidity or absDelta is small\n      // liquidity might be greater than nextSqrtP * ((liquidity / currentSqrtP) +/- absDelta))\n      // due to rounding\n      deltaL = (tmp3 > liquidity) ? tmp3 - liquidity : 0;\n    }\n  }\n\n  /// @dev calculates the sqrt price of the final swap step\n  /// where the next (temporary) tick will not be crossed\n  function calcFinalPrice(\n    uint256 absDelta,\n    uint256 liquidity,\n    uint256 deltaL,\n    uint160 currentSqrtP,\n    bool isExactInput,\n    bool isToken0\n  ) internal pure returns (uint256) {\n    if (isToken0) {\n      // if isExactInput: swap 0 -> 1, sqrtP decreases, we round up\n      // else swap: 1 -> 0, sqrtP increases, we round down\n      uint256 tmp = FullMath.mulDivFloor(absDelta, currentSqrtP, C.TWO_POW_96);\n      if (isExactInput) {\n        return FullMath.mulDivCeiling(liquidity + deltaL, currentSqrtP, liquidity + tmp);\n      } else {\n        return FullMath.mulDivFloor(liquidity + deltaL, currentSqrtP, liquidity - tmp);\n      }\n    } else {\n      // if isExactInput: swap 1 -> 0, sqrtP increases, we round down\n      // else swap: 0 -> 1, sqrtP decreases, we round up\n      uint256 tmp = FullMath.mulDivFloor(absDelta, C.TWO_POW_96, currentSqrtP);\n      if (isExactInput) {\n        return FullMath.mulDivFloor(liquidity + tmp, currentSqrtP, liquidity + deltaL);\n      } else {\n        return FullMath.mulDivCeiling(liquidity - tmp, currentSqrtP, liquidity + deltaL);\n      }\n    }\n  }\n\n  /// @dev calculates returned output | input tokens in exchange for specified amount\n  /// @dev round down when calculating returned output (isExactInput) so we avoid sending too much\n  /// @dev round up when calculating returned input (!isExactInput) so we get desired output amount\n  function calcReturnedAmount(\n    uint256 liquidity,\n    uint160 currentSqrtP,\n    uint160 nextSqrtP,\n    uint256 deltaL,\n    bool isExactInput,\n    bool isToken0\n  ) internal pure returns (int256 returnedAmount) {\n    if (isToken0) {\n      if (isExactInput) {\n        // minimise actual output (<0, make less negative) so we avoid sending too much\n        // returnedAmount = deltaL * nextSqrtP - liquidity * (currentSqrtP - nextSqrtP)\n        returnedAmount =\n          FullMath.mulDivCeiling(deltaL, nextSqrtP, C.TWO_POW_96).toInt256() +\n          FullMath.mulDivFloor(liquidity, currentSqrtP - nextSqrtP, C.TWO_POW_96).revToInt256();\n      } else {\n        // maximise actual input (>0) so we get desired output amount\n        // returnedAmount = deltaL * nextSqrtP + liquidity * (nextSqrtP - currentSqrtP)\n        returnedAmount =\n          FullMath.mulDivCeiling(deltaL, nextSqrtP, C.TWO_POW_96).toInt256() +\n          FullMath.mulDivCeiling(liquidity, nextSqrtP - currentSqrtP, C.TWO_POW_96).toInt256();\n      }\n    } else {\n      // returnedAmount = (liquidity + deltaL)/nextSqrtP - (liquidity)/currentSqrtP\n      // if exactInput, minimise actual output (<0, make less negative) so we avoid sending too much\n      // if exactOutput, maximise actual input (>0) so we get desired output amount\n      returnedAmount =\n        FullMath.mulDivCeiling(liquidity + deltaL, C.TWO_POW_96, nextSqrtP).toInt256() +\n        FullMath.mulDivFloor(liquidity, C.TWO_POW_96, currentSqrtP).revToInt256();\n    }\n\n    if (isExactInput && returnedAmount == 1) {\n      // rounding make returnedAmount == 1\n      returnedAmount = 0;\n    }\n  }\n}\n"},"contracts/interfaces/pool/IPoolActions.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IPoolActions {\n  /// @notice Sets the initial price for the pool and seeds reinvestment liquidity\n  /// @dev Assumes the caller has sent the necessary token amounts\n  /// required for initializing reinvestment liquidity prior to calling this function\n  /// @param initialSqrtP the initial sqrt price of the pool\n  /// @param qty0 token0 quantity sent to and locked permanently in the pool\n  /// @param qty1 token1 quantity sent to and locked permanently in the pool\n  function unlockPool(uint160 initialSqrtP) external returns (uint256 qty0, uint256 qty1);\n\n  /// @notice Adds liquidity for the specified recipient/tickLower/tickUpper position\n  /// @dev Any token0 or token1 owed for the liquidity provision have to be paid for when\n  /// the IMintCallback#mintCallback is called to this method's caller\n  /// The quantity of token0/token1 to be sent depends on\n  /// tickLower, tickUpper, the amount of liquidity, and the current price of the pool.\n  /// Also sends reinvestment tokens (fees) to the recipient for any fees collected\n  /// while the position is in range\n  /// Reinvestment tokens have to be burnt via #burnRTokens in exchange for token0 and token1\n  /// @param recipient Address for which the added liquidity is credited to\n  /// @param tickLower Recipient position's lower tick\n  /// @param tickUpper Recipient position's upper tick\n  /// @param ticksPrevious The nearest tick that is initialized and <= the lower & upper ticks\n  /// @param qty Liquidity quantity to mint\n  /// @param data Data (if any) to be passed through to the callback\n  /// @return qty0 token0 quantity sent to the pool in exchange for the minted liquidity\n  /// @return qty1 token1 quantity sent to the pool in exchange for the minted liquidity\n  /// @return feeGrowthInside position's updated feeGrowthInside value\n  function mint(\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    int24[2] calldata ticksPrevious,\n    uint128 qty,\n    bytes calldata data\n  )\n    external\n    returns (\n      uint256 qty0,\n      uint256 qty1,\n      uint256 feeGrowthInside\n    );\n\n  /// @notice Remove liquidity from the caller\n  /// Also sends reinvestment tokens (fees) to the caller for any fees collected\n  /// while the position is in range\n  /// Reinvestment tokens have to be burnt via #burnRTokens in exchange for token0 and token1\n  /// @param tickLower Position's lower tick for which to burn liquidity\n  /// @param tickUpper Position's upper tick for which to burn liquidity\n  /// @param qty Liquidity quantity to burn\n  /// @return qty0 token0 quantity sent to the caller\n  /// @return qty1 token1 quantity sent to the caller\n  /// @return feeGrowthInside position's updated feeGrowthInside value\n  function burn(\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 qty\n  )\n    external\n    returns (\n      uint256 qty0,\n      uint256 qty1,\n      uint256 feeGrowthInside\n    );\n\n  /// @notice Burns reinvestment tokens in exchange to receive the fees collected in token0 and token1\n  /// @param qty Reinvestment token quantity to burn\n  /// @param isLogicalBurn true if burning rTokens without returning any token0/token1\n  ///         otherwise should transfer token0/token1 to sender\n  /// @return qty0 token0 quantity sent to the caller for burnt reinvestment tokens\n  /// @return qty1 token1 quantity sent to the caller for burnt reinvestment tokens\n  function burnRTokens(uint256 qty, bool isLogicalBurn)\n    external\n    returns (uint256 qty0, uint256 qty1);\n\n  /// @notice Swap token0 -> token1, or vice versa\n  /// @dev This method's caller receives a callback in the form of ISwapCallback#swapCallback\n  /// @dev swaps will execute up to limitSqrtP or swapQty is fully used\n  /// @param recipient The address to receive the swap output\n  /// @param swapQty The swap quantity, which implicitly configures the swap as exact input (>0), or exact output (<0)\n  /// @param isToken0 Whether the swapQty is specified in token0 (true) or token1 (false)\n  /// @param limitSqrtP the limit of sqrt price after swapping\n  /// could be MAX_SQRT_RATIO-1 when swapping 1 -> 0 and MIN_SQRT_RATIO+1 when swapping 0 -> 1 for no limit swap\n  /// @param data Any data to be passed through to the callback\n  /// @return qty0 Exact token0 qty sent to recipient if < 0. Minimally received quantity if > 0.\n  /// @return qty1 Exact token1 qty sent to recipient if < 0. Minimally received quantity if > 0.\n  function swap(\n    address recipient,\n    int256 swapQty,\n    bool isToken0,\n    uint160 limitSqrtP,\n    bytes calldata data\n  ) external returns (int256 qty0, int256 qty1);\n\n  /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n  /// @dev The caller of this method receives a callback in the form of IFlashCallback#flashCallback\n  /// @dev Fees collected are sent to the feeTo address if it is set in Factory\n  /// @param recipient The address which will receive the token0 and token1 quantities\n  /// @param qty0 token0 quantity to be loaned to the recipient\n  /// @param qty1 token1 quantity to be loaned to the recipient\n  /// @param data Any data to be passed through to the callback\n  function flash(\n    address recipient,\n    uint256 qty0,\n    uint256 qty1,\n    bytes calldata data\n  ) external;\n\n\n  /// @notice sync fee of position\n  /// @param tickLower Position's lower tick\n  /// @param tickUpper Position's upper tick\n  function tweakPosZeroLiq(int24 tickLower, int24 tickUpper)\n    external returns(uint256 feeGrowthInsideLast);\n}\n"},"contracts/PoolTicksState.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport {LiqDeltaMath} from './libraries/LiqDeltaMath.sol';\nimport {SafeCast} from './libraries/SafeCast.sol';\nimport {MathConstants} from './libraries/MathConstants.sol';\nimport {FullMath} from './libraries/FullMath.sol';\nimport {TickMath} from './libraries/TickMath.sol';\nimport {Linkedlist} from './libraries/Linkedlist.sol';\n\nimport {PoolStorage} from './PoolStorage.sol';\n\ncontract PoolTicksState is PoolStorage {\n  using SafeCast for int128;\n  using SafeCast for uint128;\n  using Linkedlist for mapping(int24 => Linkedlist.Data);\n\n  struct UpdatePositionData {\n    // address of owner of the position\n    address owner;\n    // position's lower and upper ticks\n    int24 tickLower;\n    int24 tickUpper;\n    // if minting, need to pass the previous initialized ticks for tickLower and tickUpper\n    int24 tickLowerPrevious;\n    int24 tickUpperPrevious;\n    // any change in liquidity\n    uint128 liquidityDelta;\n    // true = adding liquidity, false = removing liquidity\n    bool isAddLiquidity;\n  }\n\n  function _updatePosition(\n    UpdatePositionData memory updateData,\n    int24 currentTick,\n    CumulativesData memory cumulatives\n  ) internal returns (uint256 feesClaimable, uint256 feeGrowthInside) {\n    // update ticks if necessary\n    uint256 feeGrowthOutsideLowerTick = _updateTick(\n      updateData.tickLower,\n      currentTick,\n      updateData.tickLowerPrevious,\n      updateData.liquidityDelta,\n      updateData.isAddLiquidity,\n      cumulatives,\n      true\n    );\n\n    uint256 feeGrowthOutsideUpperTick = _updateTick(\n      updateData.tickUpper,\n      currentTick,\n      updateData.tickUpperPrevious,\n      updateData.liquidityDelta,\n      updateData.isAddLiquidity,\n      cumulatives,\n      false\n    );\n\n    // calculate feeGrowthInside\n    unchecked {\n      if (currentTick < updateData.tickLower) {\n        feeGrowthInside = feeGrowthOutsideLowerTick - feeGrowthOutsideUpperTick;\n      } else if (currentTick >= updateData.tickUpper) {\n        feeGrowthInside = feeGrowthOutsideUpperTick - feeGrowthOutsideLowerTick;\n      } else {\n        feeGrowthInside =\n          cumulatives.feeGrowth -\n          feeGrowthOutsideLowerTick -\n          feeGrowthOutsideUpperTick;\n      }\n    }\n\n    // calc rTokens to be minted for the position's accumulated fees\n    feesClaimable = _updatePositionData(updateData, feeGrowthInside);\n  }\n\n  /// @dev Update liquidity net data and do cross tick\n  function _updateLiquidityAndCrossTick(\n    int24 nextTick,\n    uint128 currentLiquidity,\n    uint256 feeGrowthGlobal,\n    uint128 secondsPerLiquidityGlobal,\n    bool willUpTick\n  ) internal returns (uint128 newLiquidity, int24 newNextTick) {\n    unchecked {\n      ticks[nextTick].feeGrowthOutside = feeGrowthGlobal - ticks[nextTick].feeGrowthOutside;\n      ticks[nextTick].secondsPerLiquidityOutside =\n        secondsPerLiquidityGlobal -\n        ticks[nextTick].secondsPerLiquidityOutside;\n    }\n    int128 liquidityNet = ticks[nextTick].liquidityNet;\n    if (willUpTick) {\n      newNextTick = initializedTicks[nextTick].next;\n    } else {\n      newNextTick = initializedTicks[nextTick].previous;\n      liquidityNet = -liquidityNet;\n    }\n    newLiquidity = LiqDeltaMath.applyLiquidityDelta(\n      currentLiquidity,\n      liquidityNet >= 0 ? uint128(liquidityNet) : liquidityNet.revToUint128(),\n      liquidityNet >= 0\n    );\n  }\n\n  function _updatePoolData(\n    uint128 baseL,\n    uint128 reinvestL,\n    uint160 sqrtP,\n    int24 currentTick,\n    int24 nextTick\n  ) internal {\n    poolData.baseL = baseL;\n    poolData.reinvestL = reinvestL;\n    poolData.sqrtP = sqrtP;\n    poolData.currentTick = currentTick;\n    poolData.nearestCurrentTick = nextTick > currentTick\n      ? initializedTicks[nextTick].previous\n      : nextTick;\n  }\n\n  /// @dev Return initial data before swapping\n  /// @param willUpTick whether is up/down tick\n  /// @return baseL current pool base liquidity without reinvestment liquidity\n  /// @return reinvestL current pool reinvestment liquidity\n  /// @return sqrtP current pool sqrt price\n  /// @return currentTick current pool tick\n  /// @return nextTick next tick to calculate data\n  function _getInitialSwapData(bool willUpTick)\n    internal\n    view\n    returns (\n      uint128 baseL,\n      uint128 reinvestL,\n      uint160 sqrtP,\n      int24 currentTick,\n      int24 nextTick\n    )\n  {\n    baseL = poolData.baseL;\n    reinvestL = poolData.reinvestL;\n    sqrtP = poolData.sqrtP;\n    currentTick = poolData.currentTick;\n    nextTick = poolData.nearestCurrentTick;\n    if (willUpTick) {\n      nextTick = initializedTicks[nextTick].next;\n    }\n  }\n\n  function _updatePositionData(UpdatePositionData memory _data, uint256 feeGrowthInside)\n    private\n    returns (uint256 feesClaimable)\n  {\n    bytes32 key = _positionKey(_data.owner, _data.tickLower, _data.tickUpper);\n    // calculate accumulated fees for current liquidity\n    // feeGrowthInside is relative value, hence underflow is acceptable\n    uint256 feeGrowth;\n    unchecked {\n      feeGrowth = feeGrowthInside - positions[key].feeGrowthInsideLast;\n    }\n    uint128 prevLiquidity = positions[key].liquidity;\n    feesClaimable = FullMath.mulDivFloor(feeGrowth, prevLiquidity, MathConstants.TWO_POW_96);\n    // update the position\n    if (_data.liquidityDelta != 0) {\n      positions[key].liquidity = LiqDeltaMath.applyLiquidityDelta(\n        prevLiquidity,\n        _data.liquidityDelta,\n        _data.isAddLiquidity\n      );\n    }\n    positions[key].feeGrowthInsideLast = feeGrowthInside;\n  }\n\n  /// @notice Updates a tick and returns the fee growth outside of that tick\n  /// @param tick Tick to be updated\n  /// @param tickCurrent Current tick\n  /// @param tickPrevious the nearest initialized tick which is lower than or equal to `tick`\n  /// @param liquidityDelta Liquidity quantity to be added | removed when tick is crossed up | down\n  /// @param cumulatives All-time global fee growth and seconds, per unit of liquidity\n  /// @param isLower true | false if updating a position's lower | upper tick\n  /// @return feeGrowthOutside last value of feeGrowthOutside\n  function _updateTick(\n    int24 tick,\n    int24 tickCurrent,\n    int24 tickPrevious,\n    uint128 liquidityDelta,\n    bool isAdd,\n    CumulativesData memory cumulatives,\n    bool isLower\n  ) private returns (uint256 feeGrowthOutside) {\n    uint128 liquidityGrossBefore = ticks[tick].liquidityGross;\n    require(liquidityGrossBefore != 0 || liquidityDelta != 0, 'invalid liq');\n\n    if (liquidityDelta == 0) return ticks[tick].feeGrowthOutside;\n\n    uint128 liquidityGrossAfter = LiqDeltaMath.applyLiquidityDelta(\n      liquidityGrossBefore,\n      liquidityDelta,\n      isAdd\n    );\n    require(liquidityGrossAfter <= maxTickLiquidity, '> max liquidity');\n    int128 signedLiquidityDelta = isAdd ? liquidityDelta.toInt128() : -(liquidityDelta.toInt128());\n    // if lower tick, liquidityDelta should be added | removed when crossed up | down\n    // else, for upper tick, liquidityDelta should be removed | added when crossed up | down\n    int128 liquidityNetAfter = isLower\n      ? ticks[tick].liquidityNet + signedLiquidityDelta\n      : ticks[tick].liquidityNet - signedLiquidityDelta;\n\n    if (liquidityGrossBefore == 0) {\n      // by convention, all growth before a tick was initialized is assumed to happen below it\n      if (tick <= tickCurrent) {\n        ticks[tick].feeGrowthOutside = cumulatives.feeGrowth;\n        ticks[tick].secondsPerLiquidityOutside = cumulatives.secondsPerLiquidity;\n      }\n    }\n\n    ticks[tick].liquidityGross = liquidityGrossAfter;\n    ticks[tick].liquidityNet = liquidityNetAfter;\n    feeGrowthOutside = ticks[tick].feeGrowthOutside;\n\n    if (liquidityGrossBefore > 0 && liquidityGrossAfter == 0) {\n      delete ticks[tick];\n    }\n\n    if ((liquidityGrossBefore > 0) != (liquidityGrossAfter > 0)) {\n      _updateTickList(tick, tickPrevious, tickCurrent, isAdd);\n    }\n  }\n\n  /// @dev Update the tick linkedlist, assume that tick is not in the list\n  /// @param tick tick index to update\n  /// @param currentTick the pool currentt tick\n  /// @param previousTick the nearest initialized tick that is lower than the tick, in case adding\n  /// @param isAdd whether is add or remove the tick\n  function _updateTickList(\n    int24 tick,\n    int24 previousTick,\n    int24 currentTick,\n    bool isAdd\n  ) internal {\n    if (isAdd) {\n      if (tick == TickMath.MIN_TICK || tick == TickMath.MAX_TICK) return;\n      // find the correct previousTick to the `tick`, avoid revert when new liquidity has been added between tick & previousTick\n      int24 nextTick = initializedTicks[previousTick].next;\n      require(\n        nextTick != initializedTicks[previousTick].previous,\n        'previous tick has been removed'\n      );\n      uint256 iteration = 0;\n      while (nextTick <= tick && iteration < MathConstants.MAX_TICK_TRAVEL) {\n        previousTick = nextTick;\n        nextTick = initializedTicks[previousTick].next;\n        iteration++;\n      }\n      initializedTicks.insert(tick, previousTick, nextTick);\n      if (poolData.nearestCurrentTick < tick && tick <= currentTick) {\n        poolData.nearestCurrentTick = tick;\n      }\n    } else {\n      if (tick == poolData.nearestCurrentTick) {\n        poolData.nearestCurrentTick = initializedTicks.remove(tick);\n      } else {\n        initializedTicks.remove(tick);\n      }\n    }\n  }\n}\n"},"@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"contracts/libraries/MathConstants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @title Contains constants needed for math libraries\nlibrary MathConstants {\n  uint256 internal constant TWO_FEE_UNITS = 200_000;\n  uint256 internal constant TWO_POW_96 = 2 ** 96;\n  uint128 internal constant MIN_LIQUIDITY = 100;\n  uint8 internal constant RES_96 = 96;\n  uint24 internal constant FEE_UNITS = 100000;\n  // it is strictly less than 5% price movement if jumping MAX_TICK_DISTANCE ticks\n  int24 internal constant MAX_TICK_DISTANCE = 480;\n  // max number of tick travel when inserting if data changes\n  uint256 internal constant MAX_TICK_TRAVEL = 10;\n}\n"},"contracts/interfaces/IFactory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @title KyberSwap v2 factory\n/// @notice Deploys KyberSwap v2 pools and manages control over government fees\ninterface IFactory {\n  /// @notice Emitted when a pool is created\n  /// @param token0 First pool token by address sort order\n  /// @param token1 Second pool token by address sort order\n  /// @param swapFeeUnits Fee to be collected upon every swap in the pool, in fee units\n  /// @param tickDistance Minimum number of ticks between initialized ticks\n  /// @param pool The address of the created pool\n  event PoolCreated(\n    address indexed token0,\n    address indexed token1,\n    uint24 indexed swapFeeUnits,\n    int24 tickDistance,\n    address pool\n  );\n\n  /// @notice Emitted when a new fee is enabled for pool creation via the factory\n  /// @param swapFeeUnits Fee to be collected upon every swap in the pool, in fee units\n  /// @param tickDistance Minimum number of ticks between initialized ticks for pools created with the given fee\n  event SwapFeeEnabled(uint24 indexed swapFeeUnits, int24 indexed tickDistance);\n\n  /// @notice Emitted when vesting period changes\n  /// @param vestingPeriod The maximum time duration for which LP fees\n  /// are proportionally burnt upon LP removals\n  event VestingPeriodUpdated(uint32 vestingPeriod);\n\n  /// @notice Emitted when configMaster changes\n  /// @param oldConfigMaster configMaster before the update\n  /// @param newConfigMaster configMaster after the update\n  event ConfigMasterUpdated(address oldConfigMaster, address newConfigMaster);\n\n  /// @notice Emitted when fee configuration changes\n  /// @param feeTo Recipient of government fees\n  /// @param governmentFeeUnits Fee amount, in fee units,\n  /// to be collected out of the fee charged for a pool swap\n  event FeeConfigurationUpdated(address feeTo, uint24 governmentFeeUnits);\n\n  /// @notice Emitted when whitelist feature is enabled\n  event WhitelistEnabled();\n\n  /// @notice Emitted when whitelist feature is disabled\n  event WhitelistDisabled();\n\n  /// @notice Returns the maximum time duration for which LP fees\n  /// are proportionally burnt upon LP removals\n  function vestingPeriod() external view returns (uint32);\n\n  /// @notice Returns the tick distance for a specified fee.\n  /// @dev Once added, cannot be updated or removed.\n  /// @param swapFeeUnits Swap fee, in fee units.\n  /// @return The tick distance. Returns 0 if fee has not been added.\n  function feeAmountTickDistance(uint24 swapFeeUnits) external view returns (int24);\n\n  /// @notice Returns the address which can update the fee configuration\n  function configMaster() external view returns (address);\n\n  /// @notice Returns the keccak256 hash of the Pool creation code\n  /// This is used for pre-computation of pool addresses\n  function poolInitHash() external view returns (bytes32);\n\n  /// @notice Returns the pool oracle contract for twap\n  function poolOracle() external view returns (address);\n\n  /// @notice Fetches the recipient of government fees\n  /// and current government fee charged in fee units\n  function feeConfiguration() external view returns (address _feeTo, uint24 _governmentFeeUnits);\n\n  /// @notice Returns the status of whitelisting feature of NFT managers\n  /// If true, anyone can mint liquidity tokens\n  /// Otherwise, only whitelisted NFT manager(s) are allowed to mint liquidity tokens\n  function whitelistDisabled() external view returns (bool);\n\n  //// @notice Returns all whitelisted NFT managers\n  /// If the whitelisting feature is turned on,\n  /// only whitelisted NFT manager(s) are allowed to mint liquidity tokens\n  function getWhitelistedNFTManagers() external view returns (address[] memory);\n\n  /// @notice Checks if sender is a whitelisted NFT manager\n  /// If the whitelisting feature is turned on,\n  /// only whitelisted NFT manager(s) are allowed to mint liquidity tokens\n  /// @param sender address to be checked\n  /// @return true if sender is a whistelisted NFT manager, false otherwise\n  function isWhitelistedNFTManager(address sender) external view returns (bool);\n\n  /// @notice Returns the pool address for a given pair of tokens and a swap fee\n  /// @dev Token order does not matter\n  /// @param tokenA Contract address of either token0 or token1\n  /// @param tokenB Contract address of the other token\n  /// @param swapFeeUnits Fee to be collected upon every swap in the pool, in fee units\n  /// @return pool The pool address. Returns null address if it does not exist\n  function getPool(\n    address tokenA,\n    address tokenB,\n    uint24 swapFeeUnits\n  ) external view returns (address pool);\n\n  /// @notice Fetch parameters to be used for pool creation\n  /// @dev Called by the pool constructor to fetch the parameters of the pool\n  /// @return factory The factory address\n  /// @return poolOracle The pool oracle for twap\n  /// @return token0 First pool token by address sort order\n  /// @return token1 Second pool token by address sort order\n  /// @return swapFeeUnits Fee to be collected upon every swap in the pool, in fee units\n  /// @return tickDistance Minimum number of ticks between initialized ticks\n  function parameters()\n    external\n    view\n    returns (\n      address factory,\n      address poolOracle,\n      address token0,\n      address token1,\n      uint24 swapFeeUnits,\n      int24 tickDistance\n    );\n\n  /// @notice Creates a pool for the given two tokens and fee\n  /// @param tokenA One of the two tokens in the desired pool\n  /// @param tokenB The other of the two tokens in the desired pool\n  /// @param swapFeeUnits Desired swap fee for the pool, in fee units\n  /// @dev Token order does not matter. tickDistance is determined from the fee.\n  /// Call will revert under any of these conditions:\n  ///     1) pool already exists\n  ///     2) invalid swap fee\n  ///     3) invalid token arguments\n  /// @return pool The address of the newly created pool\n  function createPool(\n    address tokenA,\n    address tokenB,\n    uint24 swapFeeUnits\n  ) external returns (address pool);\n\n  /// @notice Enables a fee amount with the given tickDistance\n  /// @dev Fee amounts may never be removed once enabled\n  /// @param swapFeeUnits The fee amount to enable, in fee units\n  /// @param tickDistance The distance between ticks to be enforced for all pools created with the given fee amount\n  function enableSwapFee(uint24 swapFeeUnits, int24 tickDistance) external;\n\n  /// @notice Updates the address which can update the fee configuration\n  /// @dev Must be called by the current configMaster\n  function updateConfigMaster(address) external;\n\n  /// @notice Updates the vesting period\n  /// @dev Must be called by the current configMaster\n  function updateVestingPeriod(uint32) external;\n\n  /// @notice Updates the address receiving government fees and fee quantity\n  /// @dev Only configMaster is able to perform the update\n  /// @param feeTo Address to receive government fees collected from pools\n  /// @param governmentFeeUnits Fee amount, in fee units,\n  /// to be collected out of the fee charged for a pool swap\n  function updateFeeConfiguration(address feeTo, uint24 governmentFeeUnits) external;\n\n  /// @notice Enables the whitelisting feature\n  /// @dev Only configMaster is able to perform the update\n  function enableWhitelist() external;\n\n  /// @notice Disables the whitelisting feature\n  /// @dev Only configMaster is able to perform the update\n  function disableWhitelist() external;\n}\n"},"@openzeppelin/contracts/token/ERC20/ERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"},"contracts/interfaces/pool/IPoolStorage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {IFactory} from '../IFactory.sol';\nimport {IPoolOracle} from '../oracle/IPoolOracle.sol';\n\ninterface IPoolStorage {\n  /// @notice The contract that deployed the pool, which must adhere to the IFactory interface\n  /// @return The contract address\n  function factory() external view returns (IFactory);\n\n  /// @notice The oracle contract that stores necessary data for price oracle\n  /// @return The contract address\n  function poolOracle() external view returns (IPoolOracle);\n\n  /// @notice The first of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token0() external view returns (IERC20);\n\n  /// @notice The second of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token1() external view returns (IERC20);\n\n  /// @notice The fee to be charged for a swap in basis points\n  /// @return The swap fee in basis points\n  function swapFeeUnits() external view returns (uint24);\n\n  /// @notice The pool tick distance\n  /// @dev Ticks can only be initialized and used at multiples of this value\n  /// It remains an int24 to avoid casting even though it is >= 1.\n  /// e.g: a tickDistance of 5 means ticks can be initialized every 5th tick, i.e., ..., -10, -5, 0, 5, 10, ...\n  /// @return The tick distance\n  function tickDistance() external view returns (int24);\n\n  /// @notice Maximum gross liquidity that an initialized tick can have\n  /// @dev This is to prevent overflow the pool's active base liquidity (uint128)\n  /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n  /// @return The max amount of liquidity per tick\n  function maxTickLiquidity() external view returns (uint128);\n\n  /// @notice Look up information about a specific tick in the pool\n  /// @param tick The tick to look up\n  /// @return liquidityGross total liquidity amount from positions that uses this tick as a lower or upper tick\n  /// liquidityNet how much liquidity changes when the pool tick crosses above the tick\n  /// feeGrowthOutside the fee growth on the other side of the tick relative to the current tick\n  /// secondsPerLiquidityOutside the seconds per unit of liquidity  spent on the other side of the tick relative to the current tick\n  function ticks(int24 tick)\n    external\n    view\n    returns (\n      uint128 liquidityGross,\n      int128 liquidityNet,\n      uint256 feeGrowthOutside,\n      uint128 secondsPerLiquidityOutside\n    );\n\n  /// @notice Returns the previous and next initialized ticks of a specific tick\n  /// @dev If specified tick is uninitialized, the returned values are zero.\n  /// @param tick The tick to look up\n  function initializedTicks(int24 tick) external view returns (int24 previous, int24 next);\n\n  /// @notice Returns the information about a position by the position's key\n  /// @return liquidity the liquidity quantity of the position\n  /// @return feeGrowthInsideLast fee growth inside the tick range as of the last mint / burn action performed\n  function getPositions(\n    address owner,\n    int24 tickLower,\n    int24 tickUpper\n  ) external view returns (uint128 liquidity, uint256 feeGrowthInsideLast);\n\n  /// @notice Fetches the pool's prices, ticks and lock status\n  /// @return sqrtP sqrt of current price: sqrt(token1/token0)\n  /// @return currentTick pool's current tick\n  /// @return nearestCurrentTick pool's nearest initialized tick that is <= currentTick\n  /// @return locked true if pool is locked, false otherwise\n  function getPoolState()\n    external\n    view\n    returns (\n      uint160 sqrtP,\n      int24 currentTick,\n      int24 nearestCurrentTick,\n      bool locked\n    );\n\n  /// @notice Fetches the pool's liquidity values\n  /// @return baseL pool's base liquidity without reinvest liqudity\n  /// @return reinvestL the liquidity is reinvested into the pool\n  /// @return reinvestLLast last cached value of reinvestL, used for calculating reinvestment token qty\n  function getLiquidityState()\n    external\n    view\n    returns (\n      uint128 baseL,\n      uint128 reinvestL,\n      uint128 reinvestLLast\n    );\n\n  /// @return feeGrowthGlobal All-time fee growth per unit of liquidity of the pool\n  function getFeeGrowthGlobal() external view returns (uint256);\n\n  /// @return secondsPerLiquidityGlobal All-time seconds per unit of liquidity of the pool\n  /// @return lastUpdateTime The timestamp in which secondsPerLiquidityGlobal was last updated\n  function getSecondsPerLiquidityData()\n    external\n    view\n    returns (uint128 secondsPerLiquidityGlobal, uint32 lastUpdateTime);\n\n  /// @notice Calculates and returns the active time per unit of liquidity until current block.timestamp\n  /// @param tickLower The lower tick (of a position)\n  /// @param tickUpper The upper tick (of a position)\n  /// @return secondsPerLiquidityInside active time (multiplied by 2^96)\n  /// between the 2 ticks, per unit of liquidity.\n  function getSecondsPerLiquidityInside(int24 tickLower, int24 tickUpper)\n    external\n    view\n    returns (uint128 secondsPerLiquidityInside);\n}\n"},"@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"contracts/libraries/SafeCast.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n  /// @notice Cast a uint256 to uint32, revert on overflow\n  /// @param y The uint256 to be downcasted\n  /// @return z The downcasted integer, now type uint32\n  function toUint32(uint256 y) internal pure returns (uint32 z) {\n    require((z = uint32(y)) == y);\n  }\n\n  /// @notice Cast a uint128 to a int128, revert on overflow\n  /// @param y The uint256 to be casted\n  /// @return z The casted integer, now type int256\n  function toInt128(uint128 y) internal pure returns (int128 z) {\n    require(y < 2**127);\n    z = int128(y);\n  }\n\n  /// @notice Cast a uint256 to a uint128, revert on overflow\n  /// @param y the uint256 to be downcasted\n  /// @return z The downcasted integer, now type uint128\n  function toUint128(uint256 y) internal pure returns (uint128 z) {\n    require((z = uint128(y)) == y);\n  }\n\n  /// @notice Cast a int128 to a uint128 and reverses the sign.\n  /// @param y The int128 to be casted\n  /// @return z = -y, now type uint128\n  function revToUint128(int128 y) internal pure returns (uint128 z) {\n    unchecked {\n      return type(uint128).max - uint128(y) + 1;\n    }\n  }\n\n  /// @notice Cast a uint256 to a uint160, revert on overflow\n  /// @param y The uint256 to be downcasted\n  /// @return z The downcasted integer, now type uint160\n  function toUint160(uint256 y) internal pure returns (uint160 z) {\n    require((z = uint160(y)) == y);\n  }\n\n  /// @notice Cast a uint256 to a int256, revert on overflow\n  /// @param y The uint256 to be casted\n  /// @return z The casted integer, now type int256\n  function toInt256(uint256 y) internal pure returns (int256 z) {\n    require(y < 2**255);\n    z = int256(y);\n  }\n\n  /// @notice Cast a uint256 to a int256 and reverses the sign, revert on overflow\n  /// @param y The uint256 to be casted\n  /// @return z = -y, now type int256\n  function revToInt256(uint256 y) internal pure returns (int256 z) {\n    require(y < 2**255);\n    z = -int256(y);\n  }\n\n  /// @notice Cast a int256 to a uint256 and reverses the sign.\n  /// @param y The int256 to be casted\n  /// @return z = -y, now type uint256\n  function revToUint256(int256 y) internal pure returns (uint256 z) {\n    unchecked {\n      return type(uint256).max - uint256(y) + 1;\n    }\n  }\n}\n"},"contracts/libraries/Linkedlist.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @title The implementation for a LinkedList\nlibrary Linkedlist {\n  struct Data {\n    int24 previous;\n    int24 next;\n  }\n\n  /// @dev init data with the lowest and highest value of the LinkedList\n  /// @param lowestValue the lowest and also the HEAD of LinkedList\n  /// @param highestValue the highest and also the TAIL of the LinkedList\n  function init(\n    mapping(int24 => Linkedlist.Data) storage self,\n    int24 lowestValue,\n    int24 highestValue\n  ) internal {\n    (self[lowestValue].previous, self[lowestValue].next) = (lowestValue, highestValue);\n    (self[highestValue].previous, self[highestValue].next) = (lowestValue, highestValue);\n  }\n\n  /// @dev Remove a value from the linked list, return the lower value\n  ///   Return the lower value after removing, in case removedValue is the lowest/highest, no removing is done\n  function remove(mapping(int24 => Linkedlist.Data) storage self, int24 removedValue)\n    internal\n    returns (int24 lowerValue)\n  {\n    Data memory removedValueData = self[removedValue];\n    require(removedValueData.next != removedValueData.previous, 'remove non-existent value');\n    if (removedValueData.previous == removedValue) return removedValue; // remove the lowest value, nothing is done\n    lowerValue = removedValueData.previous;\n    if (removedValueData.next == removedValue) return lowerValue; // remove the highest value, nothing is done\n    self[removedValueData.previous].next = removedValueData.next;\n    self[removedValueData.next].previous = removedValueData.previous;\n    delete self[removedValue];\n  }\n\n  /// @dev Insert a new value to the linked list given its lower value that is inside the linked list\n  /// @param newValue the new value to insert, it must not exist in the LinkedList\n  /// @param lowerValue the nearest value which is <= newValue and is in the LinkedList\n  function insert(\n    mapping(int24 => Linkedlist.Data) storage self,\n    int24 newValue,\n    int24 lowerValue,\n    int24 nextValue\n  ) internal {\n    require(nextValue != self[lowerValue].previous, 'lower value is not initialized');\n    require(lowerValue < newValue && nextValue > newValue, 'invalid lower value');\n    self[newValue].next = nextValue;\n    self[newValue].previous = lowerValue;\n    self[nextValue].previous = newValue;\n    self[lowerValue].next = newValue;\n  }\n}\n"},"contracts/libraries/QtyDeltaMath.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {MathConstants as C} from './MathConstants.sol';\nimport {TickMath} from './TickMath.sol';\nimport {FullMath} from './FullMath.sol';\nimport {SafeCast} from './SafeCast.sol';\n\n/// @title Contains helper functions for calculating\n/// token0 and token1 quantites from differences in prices\n/// or from burning reinvestment tokens\nlibrary QtyDeltaMath {\n  using SafeCast for uint256;\n  using SafeCast for int128;\n\n  function calcUnlockQtys(uint160 initialSqrtP)\n    internal\n    pure\n    returns (uint256 qty0, uint256 qty1)\n  {\n    qty0 = FullMath.mulDivCeiling(C.MIN_LIQUIDITY, C.TWO_POW_96, initialSqrtP);\n    qty1 = FullMath.mulDivCeiling(C.MIN_LIQUIDITY, initialSqrtP, C.TWO_POW_96);\n  }\n\n  /// @notice Gets the qty0 delta between two prices\n  /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\n  /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n  /// rounds up if adding liquidity, rounds down if removing liquidity\n  /// @param lowerSqrtP The lower sqrt price.\n  /// @param upperSqrtP The upper sqrt price. Should be >= lowerSqrtP\n  /// @param liquidity Liquidity quantity\n  /// @param isAddLiquidity true = add liquidity, false = remove liquidity\n  /// @return token0 qty required for position with liquidity between the 2 sqrt prices\n  function calcRequiredQty0(\n    uint160 lowerSqrtP,\n    uint160 upperSqrtP,\n    uint128 liquidity,\n    bool isAddLiquidity\n  ) internal pure returns (int256) {\n    uint256 numerator1 = uint256(liquidity) << C.RES_96;\n    uint256 numerator2;\n    unchecked {\n      numerator2 = upperSqrtP - lowerSqrtP;\n    }\n    return\n      isAddLiquidity\n        ? (divCeiling(FullMath.mulDivCeiling(numerator1, numerator2, upperSqrtP), lowerSqrtP))\n          .toInt256()\n        : (FullMath.mulDivFloor(numerator1, numerator2, upperSqrtP) / lowerSqrtP).revToInt256();\n  }\n\n  /// @notice Gets the token1 delta quantity between two prices\n  /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\n  /// rounds up if adding liquidity, rounds down if removing liquidity\n  /// @param lowerSqrtP The lower sqrt price.\n  /// @param upperSqrtP The upper sqrt price. Should be >= lowerSqrtP\n  /// @param liquidity Liquidity quantity\n  /// @param isAddLiquidity true = add liquidity, false = remove liquidity\n  /// @return token1 qty required for position with liquidity between the 2 sqrt prices\n  function calcRequiredQty1(\n    uint160 lowerSqrtP,\n    uint160 upperSqrtP,\n    uint128 liquidity,\n    bool isAddLiquidity\n  ) internal pure returns (int256) {\n    unchecked {\n      return\n        isAddLiquidity\n          ? (FullMath.mulDivCeiling(liquidity, upperSqrtP - lowerSqrtP, C.TWO_POW_96)).toInt256()\n          : (FullMath.mulDivFloor(liquidity, upperSqrtP - lowerSqrtP, C.TWO_POW_96)).revToInt256();\n    }\n  }\n\n  /// @notice Calculates the token0 quantity proportion to be sent to the user\n  /// for burning reinvestment tokens\n  /// @param sqrtP Current pool sqrt price\n  /// @param liquidity Difference in reinvestment liquidity due to reinvestment token burn\n  /// @return token0 quantity to be sent to the user\n  function getQty0FromBurnRTokens(uint160 sqrtP, uint256 liquidity)\n    internal\n    pure\n    returns (uint256)\n  {\n    return FullMath.mulDivFloor(liquidity, C.TWO_POW_96, sqrtP);\n  }\n\n  /// @notice Calculates the token1 quantity proportion to be sent to the user\n  /// for burning reinvestment tokens\n  /// @param sqrtP Current pool sqrt price\n  /// @param liquidity Difference in reinvestment liquidity due to reinvestment token burn\n  /// @return token1 quantity to be sent to the user\n  function getQty1FromBurnRTokens(uint160 sqrtP, uint256 liquidity)\n    internal\n    pure\n    returns (uint256)\n  {\n    return FullMath.mulDivFloor(liquidity, sqrtP, C.TWO_POW_96);\n  }\n\n  /// @notice Returns ceil(x / y)\n  /// @dev division by 0 has unspecified behavior, and must be checked externally\n  /// @param x The dividend\n  /// @param y The divisor\n  /// @return z The quotient, ceil(x / y)\n  function divCeiling(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    // return x / y + ((x % y == 0) ? 0 : 1);\n    require(y > 0);\n    assembly {\n      z := add(div(x, y), gt(mod(x, y), 0))\n    }\n  }\n}\n"},"contracts/Pool.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport {SafeERC20} from '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport {ERC20} from '@openzeppelin/contracts/token/ERC20/ERC20.sol';\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {LiqDeltaMath} from './libraries/LiqDeltaMath.sol';\nimport {QtyDeltaMath} from './libraries/QtyDeltaMath.sol';\nimport {MathConstants as C} from './libraries/MathConstants.sol';\nimport {ReinvestmentMath} from './libraries/ReinvestmentMath.sol';\nimport {SwapMath} from './libraries/SwapMath.sol';\nimport {FullMath} from './libraries/FullMath.sol';\nimport {SafeCast} from './libraries/SafeCast.sol';\nimport {TickMath} from './libraries/TickMath.sol';\n\nimport {IPool} from './interfaces/IPool.sol';\nimport {IPoolActions} from './interfaces/pool/IPoolActions.sol';\nimport {IFactory} from './interfaces/IFactory.sol';\nimport {IMintCallback} from './interfaces/callback/IMintCallback.sol';\nimport {ISwapCallback} from './interfaces/callback/ISwapCallback.sol';\nimport {IFlashCallback} from './interfaces/callback/IFlashCallback.sol';\n\nimport {PoolTicksState} from './PoolTicksState.sol';\n\ncontract Pool is IPool, PoolTicksState, ERC20('KyberSwap v2 Reinvestment Token', 'KS2-RT') {\n  using SafeCast for uint256;\n  using SafeCast for int256;\n  using SafeERC20 for IERC20;\n\n  constructor() {}\n\n  /// @dev Get pool's balance of token0\n  /// Gas saving to avoid a redundant extcodesize check\n  /// in addition to the returndatasize check\n  function _poolBalToken0() private view returns (uint256) {\n    (bool success, bytes memory data) = address(token0).staticcall(\n      abi.encodeWithSelector(IERC20.balanceOf.selector, address(this))\n    );\n    require(success && data.length >= 32);\n    return abi.decode(data, (uint256));\n  }\n\n  /// @dev Get pool's balance of token1\n  /// Gas saving to avoid a redundant extcodesize check\n  /// in addition to the returndatasize check\n  function _poolBalToken1() private view returns (uint256) {\n    (bool success, bytes memory data) = address(token1).staticcall(\n      abi.encodeWithSelector(IERC20.balanceOf.selector, address(this))\n    );\n    require(success && data.length >= 32);\n    return abi.decode(data, (uint256));\n  }\n\n  /// @inheritdoc IPoolActions\n  function unlockPool(uint160 initialSqrtP)\n    external\n    override\n    returns (uint256 qty0, uint256 qty1)\n  {\n    require(poolData.sqrtP == 0, 'already inited');\n    // initial tick bounds (min & max price limits) are checked in this function\n    int24 initialTick = TickMath.getTickAtSqrtRatio(initialSqrtP);\n    (qty0, qty1) = QtyDeltaMath.calcUnlockQtys(initialSqrtP);\n    // because of price bounds, qty0 and qty1 >= 1\n    require(qty0 <= _poolBalToken0(), 'lacking qty0');\n    require(qty1 <= _poolBalToken1(), 'lacking qty1');\n    _mint(address(this), C.MIN_LIQUIDITY);\n\n    _initPoolStorage(initialSqrtP, initialTick);\n\n    emit Initialize(initialSqrtP, initialTick);\n  }\n\n  /// @dev Make changes to a position\n  /// @param posData the position details and the change to the position's liquidity to effect\n  /// @return qty0 token0 qty owed to the pool, negative if the pool should pay the recipient\n  /// @return qty1 token1 qty owed to the pool, negative if the pool should pay the recipient\n  function _tweakPosition(UpdatePositionData memory posData)\n    private\n    returns (\n      int256 qty0,\n      int256 qty1,\n      uint256 feeGrowthInsideLast\n    )\n  {\n    require(posData.tickLower < posData.tickUpper, 'invalid tick range');\n    require(TickMath.MIN_TICK <= posData.tickLower, 'invalid lower tick');\n    require(posData.tickUpper <= TickMath.MAX_TICK, 'invalid upper tick');\n    require(\n      posData.tickLower % tickDistance == 0 && posData.tickUpper % tickDistance == 0,\n      'tick not in distance'\n    );\n\n    // SLOAD variables into memory\n    uint160 sqrtP = poolData.sqrtP;\n    int24 currentTick = poolData.currentTick;\n    uint128 baseL = poolData.baseL;\n    uint128 reinvestL = poolData.reinvestL;\n    CumulativesData memory cumulatives;\n    cumulatives.feeGrowth = _syncFeeGrowth(baseL, reinvestL, poolData.feeGrowthGlobal, true);\n    cumulatives.secondsPerLiquidity = _syncSecondsPerLiquidity(\n      poolData.secondsPerLiquidityGlobal,\n      baseL\n    );\n\n    uint256 feesClaimable;\n    (feesClaimable, feeGrowthInsideLast) = _updatePosition(posData, currentTick, cumulatives);\n    if (feesClaimable != 0) _transfer(address(this), posData.owner, feesClaimable);\n\n    if (currentTick < posData.tickLower) {\n      // current tick < position range\n      // liquidity only comes in range when tick increases\n      // which occurs when pool increases in token1, decreases in token0\n      // means token0 is appreciating more against token1\n      // hence user should provide token0\n      return (\n        QtyDeltaMath.calcRequiredQty0(\n          TickMath.getSqrtRatioAtTick(posData.tickLower),\n          TickMath.getSqrtRatioAtTick(posData.tickUpper),\n          posData.liquidityDelta,\n          posData.isAddLiquidity\n        ),\n        0,\n        feeGrowthInsideLast\n      );\n    }\n    if (currentTick >= posData.tickUpper) {\n      // current tick > position range\n      // liquidity only comes in range when tick decreases\n      // which occurs when pool decreases in token1, increases in token0\n      // means token1 is appreciating more against token0\n      // hence user should provide token1\n      return (\n        0,\n        QtyDeltaMath.calcRequiredQty1(\n          TickMath.getSqrtRatioAtTick(posData.tickLower),\n          TickMath.getSqrtRatioAtTick(posData.tickUpper),\n          posData.liquidityDelta,\n          posData.isAddLiquidity\n        ),\n        feeGrowthInsideLast\n      );\n    }\n    // write an oracle entry\n    poolOracle.write(_blockTimestamp(), currentTick, baseL);\n    // current tick is inside the passed range\n    qty0 = QtyDeltaMath.calcRequiredQty0(\n      sqrtP,\n      TickMath.getSqrtRatioAtTick(posData.tickUpper),\n      posData.liquidityDelta,\n      posData.isAddLiquidity\n    );\n    qty1 = QtyDeltaMath.calcRequiredQty1(\n      TickMath.getSqrtRatioAtTick(posData.tickLower),\n      sqrtP,\n      posData.liquidityDelta,\n      posData.isAddLiquidity\n    );\n\n    // in addition, add liquidityDelta to current poolData.baseL\n    // since liquidity is in range\n    poolData.baseL = LiqDeltaMath.applyLiquidityDelta(\n      baseL,\n      posData.liquidityDelta,\n      posData.isAddLiquidity\n    );\n  }\n\n  /// @inheritdoc IPoolActions\n  function mint(\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    int24[2] calldata ticksPrevious,\n    uint128 qty,\n    bytes calldata data\n  )\n    external\n    override\n    lock\n    returns (\n      uint256 qty0,\n      uint256 qty1,\n      uint256 feeGrowthInsideLast\n    )\n  {\n    require(qty != 0, '0 qty');\n    require(factory.isWhitelistedNFTManager(msg.sender), 'forbidden');\n    int256 qty0Int;\n    int256 qty1Int;\n    (qty0Int, qty1Int, feeGrowthInsideLast) = _tweakPosition(\n      UpdatePositionData({\n        owner: recipient,\n        tickLower: tickLower,\n        tickUpper: tickUpper,\n        tickLowerPrevious: ticksPrevious[0],\n        tickUpperPrevious: ticksPrevious[1],\n        liquidityDelta: qty,\n        isAddLiquidity: true\n      })\n    );\n    qty0 = uint256(qty0Int);\n    qty1 = uint256(qty1Int);\n\n    uint256 balance0Before;\n    uint256 balance1Before;\n    if (qty0 > 0) balance0Before = _poolBalToken0();\n    if (qty1 > 0) balance1Before = _poolBalToken1();\n    IMintCallback(msg.sender).mintCallback(qty0, qty1, data);\n    if (qty0 > 0) require(balance0Before + qty0 <= _poolBalToken0(), 'lacking qty0');\n    if (qty1 > 0) require(balance1Before + qty1 <= _poolBalToken1(), 'lacking qty1');\n\n    emit Mint(msg.sender, recipient, tickLower, tickUpper, qty, qty0, qty1);\n  }\n\n  /// @inheritdoc IPoolActions\n  function burn(\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 qty\n  )\n    external\n    override\n    lock\n    returns (\n      uint256 qty0,\n      uint256 qty1,\n      uint256 feeGrowthInsideLast\n    )\n  {\n    require(qty != 0, '0 qty');\n    int256 qty0Int;\n    int256 qty1Int;\n    (qty0Int, qty1Int, feeGrowthInsideLast) = _tweakPosition(\n      UpdatePositionData({\n        owner: msg.sender,\n        tickLower: tickLower,\n        tickUpper: tickUpper,\n        tickLowerPrevious: 0, // no use as there is no insertion\n        tickUpperPrevious: 0, // no use as there is no insertion\n        liquidityDelta: qty,\n        isAddLiquidity: false\n      })\n    );\n\n    if (qty0Int < 0) {\n      qty0 = qty0Int.revToUint256();\n      token0.safeTransfer(msg.sender, qty0);\n    }\n    if (qty1Int < 0) {\n      qty1 = qty1Int.revToUint256();\n      token1.safeTransfer(msg.sender, qty1);\n    }\n\n    emit Burn(msg.sender, tickLower, tickUpper, qty, qty0, qty1);\n  }\n\n  /// @inheritdoc IPoolActions\n  function burnRTokens(uint256 _qty, bool isLogicalBurn)\n    external\n    override\n    lock\n    returns (uint256 qty0, uint256 qty1)\n  {\n    if (isLogicalBurn) {\n      _burn(msg.sender, _qty);\n\n      emit BurnRTokens(msg.sender, _qty, 0, 0);\n      return (0, 0);\n    }\n    // SLOADs for gas optimizations\n    uint128 baseL = poolData.baseL;\n    uint128 reinvestL = poolData.reinvestL;\n    uint160 sqrtP = poolData.sqrtP;\n    _syncFeeGrowth(baseL, reinvestL, poolData.feeGrowthGlobal, false);\n\n    // totalSupply() is the reinvestment token supply after syncing, but before burning\n    uint256 deltaL = FullMath.mulDivFloor(_qty, reinvestL, totalSupply());\n    reinvestL = reinvestL - deltaL.toUint128();\n    poolData.reinvestL = reinvestL;\n    poolData.reinvestLLast = reinvestL;\n    // finally, calculate and send token quantities to user\n    qty0 = QtyDeltaMath.getQty0FromBurnRTokens(sqrtP, deltaL);\n    qty1 = QtyDeltaMath.getQty1FromBurnRTokens(sqrtP, deltaL);\n\n    _burn(msg.sender, _qty);\n\n    if (qty0 > 0) token0.safeTransfer(msg.sender, qty0);\n    if (qty1 > 0) token1.safeTransfer(msg.sender, qty1);\n\n    emit BurnRTokens(msg.sender, _qty, qty0, qty1);\n  }\n\n  // temporary swap variables, some of which will be used to update the pool state\n  struct SwapData {\n    int256 specifiedAmount; // the specified amount (could be tokenIn or tokenOut)\n    int256 returnedAmount; // the opposite amout of sourceQty\n    uint160 sqrtP; // current sqrt(price), multiplied by 2^96\n    int24 currentTick; // the tick associated with the current price\n    int24 nextTick; // the next initialized tick\n    uint160 nextSqrtP; // the price of nextTick\n    bool isToken0; // true if specifiedAmount is in token0, false if in token1\n    bool isExactInput; // true = input qty, false = output qty\n    uint128 baseL; // the cached base pool liquidity without reinvestment liquidity\n    uint128 reinvestL; // the cached reinvestment liquidity\n    uint160 startSqrtP; // the start sqrt price before each iteration\n  }\n\n  // variables below are loaded only when crossing a tick\n  struct SwapCache {\n    uint256 rTotalSupply; // cache of total reinvestment token supply\n    uint128 reinvestLLast; // collected liquidity\n    uint256 feeGrowthGlobal; // cache of fee growth of the reinvestment token, multiplied by 2^96\n    uint128 secondsPerLiquidityGlobal; // all-time seconds per liquidity, multiplied by 2^96\n    address feeTo; // recipient of govt fees\n    uint24 governmentFeeUnits; // governmentFeeUnits to be charged\n    uint256 governmentFee; // qty of reinvestment token for government fee\n    uint256 lpFee; // qty of reinvestment token for liquidity provider\n  }\n\n  struct OracleCache {\n    int24 currentTick;\n    uint128 baseL;\n  }\n\n  // @inheritdoc IPoolActions\n  function swap(\n    address recipient,\n    int256 swapQty,\n    bool isToken0,\n    uint160 limitSqrtP,\n    bytes calldata data\n  ) external override lock returns (int256 deltaQty0, int256 deltaQty1) {\n    require(swapQty != 0, '0 swapQty');\n\n    SwapData memory swapData;\n    swapData.specifiedAmount = swapQty;\n    swapData.isToken0 = isToken0;\n    swapData.isExactInput = swapData.specifiedAmount > 0;\n    // tick (token1Qty/token0Qty) will increase for swapping from token1 to token0\n    bool willUpTick = (swapData.isExactInput != isToken0);\n    (\n      swapData.baseL,\n      swapData.reinvestL,\n      swapData.sqrtP,\n      swapData.currentTick,\n      swapData.nextTick\n    ) = _getInitialSwapData(willUpTick);\n\n    // cache data before swap to write into oracle if needed\n    OracleCache memory oracleCache = OracleCache({\n      currentTick: swapData.currentTick,\n      baseL: swapData.baseL\n    });\n\n    // verify limitSqrtP\n    if (willUpTick) {\n      require(\n        limitSqrtP > swapData.sqrtP && limitSqrtP < TickMath.MAX_SQRT_RATIO,\n        'bad limitSqrtP'\n      );\n    } else {\n      require(\n        limitSqrtP < swapData.sqrtP && limitSqrtP > TickMath.MIN_SQRT_RATIO,\n        'bad limitSqrtP'\n      );\n    }\n    SwapCache memory cache;\n    // continue swapping while specified input/output isn't satisfied or price limit not reached\n    while (swapData.specifiedAmount != 0 && swapData.sqrtP != limitSqrtP) {\n      // math calculations work with the assumption that the price diff is capped to 5%\n      // since tick distance is uncapped between currentTick and nextTick\n      // we use tempNextTick to satisfy our assumption with MAX_TICK_DISTANCE is set to be matched this condition\n\n      int24 tempNextTick = swapData.nextTick;\n      if (willUpTick && tempNextTick > C.MAX_TICK_DISTANCE + swapData.currentTick) {\n        tempNextTick = swapData.currentTick + C.MAX_TICK_DISTANCE;\n      } else if (!willUpTick && tempNextTick < swapData.currentTick - C.MAX_TICK_DISTANCE) {\n        tempNextTick = swapData.currentTick - C.MAX_TICK_DISTANCE;\n      }\n\n      swapData.startSqrtP = swapData.sqrtP;\n      swapData.nextSqrtP = TickMath.getSqrtRatioAtTick(tempNextTick);\n\n      // local scope for targetSqrtP, usedAmount, returnedAmount and deltaL\n      {\n        uint160 targetSqrtP = swapData.nextSqrtP;\n        // ensure next sqrtP (and its corresponding tick) does not exceed price limit\n        if (willUpTick == (swapData.nextSqrtP > limitSqrtP)) {\n          targetSqrtP = limitSqrtP;\n        }\n\n        int256 usedAmount;\n        int256 returnedAmount;\n        uint256 deltaL;\n        (usedAmount, returnedAmount, deltaL, swapData.sqrtP) = SwapMath.computeSwapStep(\n          swapData.baseL + swapData.reinvestL,\n          swapData.sqrtP,\n          targetSqrtP,\n          swapFeeUnits,\n          swapData.specifiedAmount,\n          swapData.isExactInput,\n          swapData.isToken0\n        );\n\n        swapData.specifiedAmount -= usedAmount;\n        swapData.returnedAmount += returnedAmount;\n        swapData.reinvestL += deltaL.toUint128();\n      }\n\n      // if price has not reached the next sqrt price\n      if (swapData.sqrtP != swapData.nextSqrtP) {\n        if (swapData.sqrtP != swapData.startSqrtP) {\n          // update the current tick data in case the sqrtP has changed\n          swapData.currentTick = TickMath.getTickAtSqrtRatio(swapData.sqrtP);\n        }\n        break;\n      }\n      swapData.currentTick = willUpTick ? tempNextTick : tempNextTick - 1;\n      // if tempNextTick is not next initialized tick\n      if (tempNextTick != swapData.nextTick) continue;\n\n      if (cache.rTotalSupply == 0) {\n        // load variables that are only initialized when crossing a tick\n        cache.rTotalSupply = totalSupply();\n        cache.reinvestLLast = poolData.reinvestLLast;\n        cache.feeGrowthGlobal = poolData.feeGrowthGlobal;\n        cache.secondsPerLiquidityGlobal = _syncSecondsPerLiquidity(\n          poolData.secondsPerLiquidityGlobal,\n          swapData.baseL\n        );\n        (cache.feeTo, cache.governmentFeeUnits) = factory.feeConfiguration();\n      }\n      // update rTotalSupply, feeGrowthGlobal and reinvestL\n      uint256 rMintQty = ReinvestmentMath.calcrMintQty(\n        swapData.reinvestL,\n        cache.reinvestLLast,\n        swapData.baseL,\n        cache.rTotalSupply\n      );\n      if (rMintQty != 0) {\n        cache.rTotalSupply += rMintQty;\n        // overflow/underflow not possible bc governmentFeeUnits < 20000\n        unchecked {\n          uint256 governmentFee = (rMintQty * cache.governmentFeeUnits) / C.FEE_UNITS;\n          cache.governmentFee += governmentFee;\n\n          uint256 lpFee = rMintQty - governmentFee;\n          cache.lpFee += lpFee;\n\n          cache.feeGrowthGlobal += FullMath.mulDivFloor(lpFee, C.TWO_POW_96, swapData.baseL);\n        }\n      }\n      cache.reinvestLLast = swapData.reinvestL;\n\n      (swapData.baseL, swapData.nextTick) = _updateLiquidityAndCrossTick(\n        swapData.nextTick,\n        swapData.baseL,\n        cache.feeGrowthGlobal,\n        cache.secondsPerLiquidityGlobal,\n        willUpTick\n      );\n    }\n\n    // if the swap crosses at least 1 initalized tick\n    if (cache.rTotalSupply != 0) {\n      if (cache.governmentFee > 0) _mint(cache.feeTo, cache.governmentFee);\n      if (cache.lpFee > 0) _mint(address(this), cache.lpFee);\n      poolData.reinvestLLast = cache.reinvestLLast;\n      poolData.feeGrowthGlobal = cache.feeGrowthGlobal;\n    }\n\n    // write an oracle entry if tick changed\n    if (swapData.currentTick != oracleCache.currentTick) {\n      poolOracle.write(_blockTimestamp(), oracleCache.currentTick, oracleCache.baseL);\n    }\n\n    _updatePoolData(\n      swapData.baseL,\n      swapData.reinvestL,\n      swapData.sqrtP,\n      swapData.currentTick,\n      swapData.nextTick\n    );\n\n    (deltaQty0, deltaQty1) = isToken0\n      ? (swapQty - swapData.specifiedAmount, swapData.returnedAmount)\n      : (swapData.returnedAmount, swapQty - swapData.specifiedAmount);\n\n    // handle token transfers and perform callback\n    if (willUpTick) {\n      // outbound deltaQty0 (negative), inbound deltaQty1 (positive)\n      // transfer deltaQty0 to recipient\n      if (deltaQty0 < 0) token0.safeTransfer(recipient, deltaQty0.revToUint256());\n\n      // collect deltaQty1\n      uint256 balance1Before = _poolBalToken1();\n      ISwapCallback(msg.sender).swapCallback(deltaQty0, deltaQty1, data);\n      require(_poolBalToken1() >= balance1Before + uint256(deltaQty1), 'lacking deltaQty1');\n    } else {\n      // inbound deltaQty0 (positive), outbound deltaQty1 (negative)\n      // transfer deltaQty1 to recipient\n      if (deltaQty1 < 0) token1.safeTransfer(recipient, deltaQty1.revToUint256());\n\n      // collect deltaQty0\n      uint256 balance0Before = _poolBalToken0();\n      ISwapCallback(msg.sender).swapCallback(deltaQty0, deltaQty1, data);\n      require(_poolBalToken0() >= balance0Before + uint256(deltaQty0), 'lacking deltaQty0');\n    }\n\n    emit Swap(\n      msg.sender,\n      recipient,\n      deltaQty0,\n      deltaQty1,\n      swapData.sqrtP,\n      swapData.baseL,\n      swapData.currentTick\n    );\n  }\n\n  /// @inheritdoc IPoolActions\n  function flash(\n    address recipient,\n    uint256 qty0,\n    uint256 qty1,\n    bytes calldata data\n  ) external override lock {\n    // send all collected fees to feeTo\n    (address feeTo, ) = factory.feeConfiguration();\n    uint256 feeQty0;\n    uint256 feeQty1;\n    if (feeTo != address(0)) {\n      feeQty0 = (qty0 * swapFeeUnits) / C.FEE_UNITS;\n      feeQty1 = (qty1 * swapFeeUnits) / C.FEE_UNITS;\n    }\n    uint256 balance0Before = _poolBalToken0();\n    uint256 balance1Before = _poolBalToken1();\n\n    if (qty0 > 0) token0.safeTransfer(recipient, qty0);\n    if (qty1 > 0) token1.safeTransfer(recipient, qty1);\n\n    IFlashCallback(msg.sender).flashCallback(feeQty0, feeQty1, data);\n\n    uint256 balance0After = _poolBalToken0();\n    uint256 balance1After = _poolBalToken1();\n\n    require(balance0Before + feeQty0 <= balance0After, 'lacking feeQty0');\n    require(balance1Before + feeQty1 <= balance1After, 'lacking feeQty1');\n\n    uint256 paid0;\n    uint256 paid1;\n    unchecked {\n      paid0 = balance0After - balance0Before;\n      paid1 = balance1After - balance1Before;\n    }\n\n    if (paid0 > 0) token0.safeTransfer(feeTo, paid0);\n    if (paid1 > 0) token1.safeTransfer(feeTo, paid1);\n\n    emit Flash(msg.sender, recipient, qty0, qty1, paid0, paid1);\n  }\n\n  /// @dev sync the value of secondsPerLiquidity data to current block.timestamp\n  /// @return new value of _secondsPerLiquidityGlobal\n  function _syncSecondsPerLiquidity(uint128 _secondsPerLiquidityGlobal, uint128 baseL)\n    internal\n    returns (uint128)\n  {\n    uint256 secondsElapsed = _blockTimestamp() - poolData.secondsPerLiquidityUpdateTime;\n    // update secondsPerLiquidityGlobal and secondsPerLiquidityUpdateTime if needed\n    if (secondsElapsed > 0) {\n      poolData.secondsPerLiquidityUpdateTime = _blockTimestamp();\n      if (baseL > 0) {\n        _secondsPerLiquidityGlobal += uint128((secondsElapsed << C.RES_96) / baseL);\n        // write to storage\n        poolData.secondsPerLiquidityGlobal = _secondsPerLiquidityGlobal;\n      }\n    }\n    return _secondsPerLiquidityGlobal;\n  }\n\n  function tweakPosZeroLiq(int24 tickLower, int24 tickUpper) external override lock returns (uint256 feeGrowthInsideLast) {\n    require(factory.isWhitelistedNFTManager(msg.sender), 'forbidden');\n    require(tickLower < tickUpper, 'invalid tick range');\n    require(TickMath.MIN_TICK <= tickLower, 'invalid lower tick');\n    require(tickUpper <= TickMath.MAX_TICK, 'invalid upper tick');\n    require(\n      tickLower % tickDistance == 0 && tickUpper % tickDistance == 0,\n      'tick not in distance'\n    );\n    bytes32 key = _positionKey(msg.sender, tickLower, tickUpper);\n    require(positions[key].liquidity > 0, 'invalid position');\n\n    // SLOAD variables into memory\n    uint128 baseL = poolData.baseL;\n    CumulativesData memory cumulatives;\n    cumulatives.feeGrowth = _syncFeeGrowth(baseL, poolData.reinvestL, poolData.feeGrowthGlobal, true);\n    cumulatives.secondsPerLiquidity = _syncSecondsPerLiquidity(\n      poolData.secondsPerLiquidityGlobal,\n      baseL\n    );\n\n    uint256 feesClaimable;\n    (feesClaimable, feeGrowthInsideLast) = _updatePosition(\n      UpdatePositionData({\n        owner: msg.sender,\n        tickLower: tickLower,\n        tickUpper: tickUpper,\n        tickLowerPrevious: 0,\n        tickUpperPrevious: 0,\n        liquidityDelta: 0,\n        isAddLiquidity: false\n      })\n      , poolData.currentTick, cumulatives);\n    if (feesClaimable != 0) _transfer(address(this), msg.sender, feesClaimable);\n  }\n\n  /// @dev sync the value of feeGrowthGlobal and the value of each reinvestment token.\n  /// @dev update reinvestLLast to latest value if necessary\n  /// @return the lastest value of _feeGrowthGlobal\n  function _syncFeeGrowth(\n    uint128 baseL,\n    uint128 reinvestL,\n    uint256 _feeGrowthGlobal,\n    bool updateReinvestLLast\n  ) internal returns (uint256) {\n    uint256 rMintQty = ReinvestmentMath.calcrMintQty(\n      uint256(reinvestL),\n      uint256(poolData.reinvestLLast),\n      baseL,\n      totalSupply()\n    );\n    if (rMintQty != 0) {\n      rMintQty = _deductGovermentFee(rMintQty);\n      _mint(address(this), rMintQty);\n      // baseL != 0 because baseL = 0 => rMintQty = 0\n      unchecked {\n        _feeGrowthGlobal += FullMath.mulDivFloor(rMintQty, C.TWO_POW_96, baseL);\n      }\n      poolData.feeGrowthGlobal = _feeGrowthGlobal;\n    }\n    // update poolData.reinvestLLast if required\n    if (updateReinvestLLast) poolData.reinvestLLast = reinvestL;\n    return _feeGrowthGlobal;\n  }\n\n  /// @return the lp fee without governance fee\n  function _deductGovermentFee(uint256 rMintQty) internal returns (uint256) {\n    // fetch governmentFeeUnits\n    (address feeTo, uint24 governmentFeeUnits) = factory.feeConfiguration();\n    if (governmentFeeUnits == 0) {\n      return rMintQty;\n    }\n\n    // unchecked due to governmentFeeUnits <= 20000\n    unchecked {\n      uint256 rGovtQty = (rMintQty * governmentFeeUnits) / C.FEE_UNITS;\n      if (rGovtQty != 0) {\n        _mint(feeTo, rGovtQty);\n      }\n      return rMintQty - rGovtQty;\n    }\n  }\n}\n"},"contracts/interfaces/callback/IMintCallback.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @title Callback for IPool#mint\n/// @notice Any contract that calls IPool#mint must implement this interface\ninterface IMintCallback {\n  /// @notice Called to `msg.sender` after minting liquidity via IPool#mint.\n  /// @dev This function's implementation must send pool tokens to the pool for the minted LP tokens.\n  /// The caller of this method must be checked to be a Pool deployed by the canonical Factory.\n  /// @param deltaQty0 The token0 quantity to be sent to the pool.\n  /// @param deltaQty1 The token1 quantity to be sent to the pool.\n  /// @param data Data passed through by the caller via the IPool#mint call\n  function mintCallback(\n    uint256 deltaQty0,\n    uint256 deltaQty1,\n    bytes calldata data\n  ) external;\n}\n"},"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"}},"settings":{"libraries":{},"metadata":{"bytecodeHash":"none"},"optimizer":{"enabled":true,"runs":500},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}}},"ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"indexed\":true,\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"qty\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qty0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qty1\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qty0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qty1\",\"type\":\"uint256\"}],\"name\":\"BurnRTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qty0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qty1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paid0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paid1\",\"type\":\"uint256\"}],\"name\":\"Flash\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint160\",\"name\":\"sqrtP\",\"type\":\"uint160\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"}],\"name\":\"Initialize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"indexed\":true,\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"qty\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qty0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"qty1\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"deltaQty0\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"deltaQty1\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint160\",\"name\":\"sqrtP\",\"type\":\"uint160\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"int24\",\"name\":\"currentTick\",\"type\":\"int24\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"uint128\",\"name\":\"qty\",\"type\":\"uint128\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"qty0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qty1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeGrowthInsideLast\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_qty\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isLogicalBurn\",\"type\":\"bool\"}],\"name\":\"burnRTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"qty0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qty1\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract IFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"qty0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qty1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"flash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeGrowthGlobal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiquidityState\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"baseL\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"reinvestL\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"reinvestLLast\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPoolState\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtP\",\"type\":\"uint160\"},{\"internalType\":\"int24\",\"name\":\"currentTick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"nearestCurrentTick\",\"type\":\"int24\"},{\"internalType\":\"bool\",\"name\":\"locked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"}],\"name\":\"getPositions\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"feeGrowthInsideLast\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSecondsPerLiquidityData\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"secondsPerLiquidityGlobal\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"lastUpdateTime\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"}],\"name\":\"getSecondsPerLiquidityInside\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"secondsPerLiquidityInside\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"name\":\"initializedTicks\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"previous\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"next\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTickLiquidity\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"int24[2]\",\"name\":\"ticksPrevious\",\"type\":\"int24[2]\"},{\"internalType\":\"uint128\",\"name\":\"qty\",\"type\":\"uint128\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"qty0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qty1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeGrowthInsideLast\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolOracle\",\"outputs\":[{\"internalType\":\"contract IPoolOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"swapQty\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"isToken0\",\"type\":\"bool\"},{\"internalType\":\"uint160\",\"name\":\"limitSqrtP\",\"type\":\"uint160\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"deltaQty0\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"deltaQty1\",\"type\":\"int256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapFeeUnits\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tickDistance\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"name\":\"ticks\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"liquidityGross\",\"type\":\"uint128\"},{\"internalType\":\"int128\",\"name\":\"liquidityNet\",\"type\":\"int128\"},{\"internalType\":\"uint256\",\"name\":\"feeGrowthOutside\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"secondsPerLiquidityOutside\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"}],\"name\":\"tweakPosZeroLiq\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"feeGrowthInsideLast\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"initialSqrtP\",\"type\":\"uint160\"}],\"name\":\"unlockPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"qty0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qty1\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Pool","CompilerVersion":"v0.8.9+commit.e5eed63a","OptimizationUsed":1,"Runs":500,"ConstructorArguments":"0x","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}