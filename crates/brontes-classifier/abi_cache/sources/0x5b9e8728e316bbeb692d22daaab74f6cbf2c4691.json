{"expiry":1699579843,"data":[{"SourceCode":"pragma solidity ^0.4.14;\r\n\r\n/**\r\n * Contract that exposes the needed erc20 token functions\r\n */\r\n\r\ncontract ERC20Interface {\r\n  // Send _value amount of tokens to address _to\r\n  function transfer(address _to, uint256 _value) returns (bool success);\r\n  // Get the account balance of another account with address _owner\r\n  function balanceOf(address _owner) constant returns (uint256 balance);\r\n}\r\n\r\n/**\r\n * Contract that will forward any incoming Ether to its creator\r\n */\r\ncontract Forwarder {\r\n  // Address to which any funds sent to this contract will be forwarded\r\n  address public parentAddress;\r\n  event ForwarderDeposited(address from, uint value, bytes data);\r\n\r\n  event TokensFlushed(\r\n    address tokenContractAddress, // The contract address of the token\r\n    uint value // Amount of token sent\r\n  );\r\n\r\n  /**\r\n   * Create the contract, and set the destination address to that of the creator\r\n   */\r\n  function Forwarder() {\r\n    parentAddress = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * Modifier that will execute internal code block only if the sender is a parent of the forwarder contract\r\n   */\r\n  modifier onlyParent {\r\n    if (msg.sender != parentAddress) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Default function; Gets called when Ether is deposited, and forwards it to the destination address\r\n   */\r\n  function() payable {\r\n    if (!parentAddress.call.value(msg.value)(msg.data))\r\n      throw;\r\n    // Fire off the deposited event if we can forward it  \r\n    ForwarderDeposited(msg.sender, msg.value, msg.data);\r\n  }\r\n\r\n  /**\r\n   * Execute a token transfer of the full balance from the forwarder token to the main wallet contract\r\n   * @param tokenContractAddress the address of the erc20 token contract\r\n   */\r\n  function flushTokens(address tokenContractAddress) onlyParent {\r\n    ERC20Interface instance = ERC20Interface(tokenContractAddress);\r\n    var forwarderAddress = address(this);\r\n    var forwarderBalance = instance.balanceOf(forwarderAddress);\r\n    if (forwarderBalance == 0) {\r\n      return;\r\n    }\r\n    if (!instance.transfer(parentAddress, forwarderBalance)) {\r\n      throw;\r\n    }\r\n    TokensFlushed(tokenContractAddress, forwarderBalance);\r\n  }\r\n\r\n  /**\r\n   * It is possible that funds were sent to this address before the contract was deployed.\r\n   * We can flush those funds to the destination address.\r\n   */\r\n  function flush() {\r\n    if (!parentAddress.call.value(this.balance)())\r\n      throw;\r\n  }\r\n}\r\n\r\n/**\r\n * Basic multi-signer wallet designed for use in a co-signing environment where 2 signatures are required to move funds.\r\n * Typically used in a 2-of-3 signing configuration. Uses ecrecover to allow for 2 signatures in a single transaction.\r\n */\r\ncontract WalletSimple {\r\n  // Events\r\n  event Deposited(address from, uint value, bytes data);\r\n  event SafeModeActivated(address msgSender);\r\n  event Transacted(\r\n    address msgSender, // Address of the sender of the message initiating the transaction\r\n    address otherSigner, // Address of the signer (second signature) used to initiate the transaction\r\n    bytes32 operation, // Operation hash (sha3 of toAddress, value, data, expireTime, sequenceId)\r\n    address toAddress, // The address the transaction was sent to\r\n    uint value, // Amount of Wei sent to the address\r\n    bytes data // Data sent when invoking the transaction\r\n  );\r\n  event TokenTransacted(\r\n    address msgSender, // Address of the sender of the message initiating the transaction\r\n    address otherSigner, // Address of the signer (second signature) used to initiate the transaction\r\n    bytes32 operation, // Operation hash (sha3 of toAddress, value, tokenContractAddress, expireTime, sequenceId)\r\n    address toAddress, // The address the transaction was sent to\r\n    uint value, // Amount of token sent\r\n    address tokenContractAddress // The contract address of the token\r\n  );\r\n\r\n  // Public fields\r\n  address[] public signers; // The addresses that can co-sign transactions on the wallet\r\n  bool public safeMode = false; // When active, wallet may only send to signer addresses\r\n\r\n  // Internal fields\r\n  uint constant SEQUENCE_ID_WINDOW_SIZE = 10;\r\n  uint[10] recentSequenceIds;\r\n\r\n  /**\r\n   * Modifier that will execute internal code block only if the sender is an authorized signer on this wallet\r\n   */\r\n  modifier onlysigner {\r\n    if (!isSigner(msg.sender)) {\r\n      throw;\r\n    }\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Set up a simple multi-sig wallet by specifying the signers allowed to be used on this wallet.\r\n   * 2 signers will be required to send a transaction from this wallet.\r\n   * Note: The sender is NOT automatically added to the list of signers.\r\n   * Signers CANNOT be changed once they are set\r\n   *\r\n   * @param allowedSigners An array of signers on the wallet\r\n   */\r\n  function WalletSimple(address[] allowedSigners) {\r\n    if (allowedSigners.length != 3) {\r\n      // Invalid number of signers\r\n      throw;\r\n    }\r\n    signers = allowedSigners;\r\n  }\r\n\r\n  /**\r\n   * Gets called when a transaction is received without calling a method\r\n   */\r\n  function() payable {\r\n    if (msg.value > 0) {\r\n      // Fire deposited event if we are receiving funds\r\n      Deposited(msg.sender, msg.value, msg.data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new contract (and also address) that forwards funds to this contract\r\n   * returns address of newly created forwarder address\r\n   */\r\n  function createForwarder() onlysigner returns (address) {\r\n    return new Forwarder();\r\n  }\r\n\r\n  /**\r\n   * Execute a multi-signature transaction from this wallet using 2 signers: one from msg.sender and the other from ecrecover.\r\n   * The signature is a signed form (using eth.sign) of tightly packed toAddress, value, data, expireTime and sequenceId\r\n   * Sequence IDs are numbers starting from 1. They are used to prevent replay attacks and may not be repeated.\r\n   *\r\n   * @param toAddress the destination address to send an outgoing transaction\r\n   * @param value the amount in Wei to be sent\r\n   * @param data the data to send to the toAddress when invoking the transaction\r\n   * @param expireTime the number of seconds since 1970 for which this transaction is valid\r\n   * @param sequenceId the unique sequence id obtainable from getNextSequenceId\r\n   * @param signature the result of eth.sign on the operationHash sha3(toAddress, value, data, expireTime, sequenceId)\r\n   */\r\n  function sendMultiSig(address toAddress, uint value, bytes data, uint expireTime, uint sequenceId, bytes signature) onlysigner {\r\n    // Verify the other signer\r\n    var operationHash = sha3(\"ETHER\", toAddress, value, data, expireTime, sequenceId);\r\n    \r\n    var otherSigner = verifyMultiSig(toAddress, operationHash, signature, expireTime, sequenceId);\r\n\r\n    // Success, send the transaction\r\n    if (!(toAddress.call.value(value)(data))) {\r\n      // Failed executing transaction\r\n      throw;\r\n    }\r\n    Transacted(msg.sender, otherSigner, operationHash, toAddress, value, data);\r\n  }\r\n  \r\n  /**\r\n   * Execute a multi-signature token transfer from this wallet using 2 signers: one from msg.sender and the other from ecrecover.\r\n   * The signature is a signed form (using eth.sign) of tightly packed toAddress, value, tokenContractAddress, expireTime and sequenceId\r\n   * Sequence IDs are numbers starting from 1. They are used to prevent replay attacks and may not be repeated.\r\n   *\r\n   * @param toAddress the destination address to send an outgoing transaction\r\n   * @param value the amount in tokens to be sent\r\n   * @param tokenContractAddress the address of the erc20 token contract\r\n   * @param expireTime the number of seconds since 1970 for which this transaction is valid\r\n   * @param sequenceId the unique sequence id obtainable from getNextSequenceId\r\n   * @param signature the result of eth.sign on the operationHash sha3(toAddress, value, tokenContractAddress, expireTime, sequenceId)\r\n   */\r\n  function sendMultiSigToken(address toAddress, uint value, address tokenContractAddress, uint expireTime, uint sequenceId, bytes signature) onlysigner {\r\n    // Verify the other signer\r\n    var operationHash = sha3(\"ERC20\", toAddress, value, tokenContractAddress, expireTime, sequenceId);\r\n    \r\n    var otherSigner = verifyMultiSig(toAddress, operationHash, signature, expireTime, sequenceId);\r\n    \r\n    ERC20Interface instance = ERC20Interface(tokenContractAddress);\r\n    if (!instance.transfer(toAddress, value)) {\r\n        throw;\r\n    }\r\n    TokenTransacted(msg.sender, otherSigner, operationHash, toAddress, value, tokenContractAddress);\r\n  }\r\n\r\n  /**\r\n   * Execute a token flush from one of the forwarder addresses. This transfer needs only a single signature and can be done by any signer\r\n   *\r\n   * @param forwarderAddress the address of the forwarder address to flush the tokens from\r\n   * @param tokenContractAddress the address of the erc20 token contract\r\n   */\r\n  function flushForwarderTokens(address forwarderAddress, address tokenContractAddress) onlysigner {    \r\n    Forwarder forwarder = Forwarder(forwarderAddress);\r\n    forwarder.flushTokens(tokenContractAddress);\r\n  }  \r\n  \r\n  /**\r\n   * Do common multisig verification for both eth sends and erc20token transfers\r\n   *\r\n   * @param toAddress the destination address to send an outgoing transaction\r\n   * @param operationHash the sha3 of the toAddress, value, data/tokenContractAddress and expireTime\r\n   * @param signature the tightly packed signature of r, s, and v as an array of 65 bytes (returned by eth.sign)\r\n   * @param expireTime the number of seconds since 1970 for which this transaction is valid\r\n   * @param sequenceId the unique sequence id obtainable from getNextSequenceId\r\n   * returns address of the address to send tokens or eth to\r\n   */\r\n  function verifyMultiSig(address toAddress, bytes32 operationHash, bytes signature, uint expireTime, uint sequenceId) private returns (address) {\r\n\r\n    var otherSigner = recoverAddressFromSignature(operationHash, signature);\r\n\r\n    // Verify if we are in safe mode. In safe mode, the wallet can only send to signers\r\n    if (safeMode && !isSigner(toAddress)) {\r\n      // We are in safe mode and the toAddress is not a signer. Disallow!\r\n      throw;\r\n    }\r\n    // Verify that the transaction has not expired\r\n    if (expireTime < block.timestamp) {\r\n      // Transaction expired\r\n      throw;\r\n    }\r\n\r\n    // Try to insert the sequence ID. Will throw if the sequence id was invalid\r\n    tryInsertSequenceId(sequenceId);\r\n\r\n    if (!isSigner(otherSigner)) {\r\n      // Other signer not on this wallet or operation does not match arguments\r\n      throw;\r\n    }\r\n    if (otherSigner == msg.sender) {\r\n      // Cannot approve own transaction\r\n      throw;\r\n    }\r\n\r\n    return otherSigner;\r\n  }\r\n\r\n  /**\r\n   * Irrevocably puts contract into safe mode. When in this mode, transactions may only be sent to signing addresses.\r\n   */\r\n  function activateSafeMode() onlysigner {\r\n    safeMode = true;\r\n    SafeModeActivated(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * Determine if an address is a signer on this wallet\r\n   * @param signer address to check\r\n   * returns boolean indicating whether address is signer or not\r\n   */\r\n  function isSigner(address signer) returns (bool) {\r\n    // Iterate through all signers on the wallet and\r\n    for (uint i = 0; i < signers.length; i++) {\r\n      if (signers[i] == signer) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Gets the second signer's address using ecrecover\r\n   * @param operationHash the sha3 of the toAddress, value, data/tokenContractAddress and expireTime\r\n   * @param signature the tightly packed signature of r, s, and v as an array of 65 bytes (returned by eth.sign)\r\n   * returns address recovered from the signature\r\n   */\r\n  function recoverAddressFromSignature(bytes32 operationHash, bytes signature) private returns (address) {\r\n    if (signature.length != 65) {\r\n      throw;\r\n    }\r\n    // We need to unpack the signature, which is given as an array of 65 bytes (from eth.sign)\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n    assembly {\r\n      r := mload(add(signature, 32))\r\n      s := mload(add(signature, 64))\r\n      v := and(mload(add(signature, 65)), 255)\r\n    }\r\n    if (v < 27) {\r\n      v += 27; // Ethereum versions are 27 or 28 as opposed to 0 or 1 which is submitted by some signing libs\r\n    }\r\n    return ecrecover(operationHash, v, r, s);\r\n  }\r\n\r\n  /**\r\n   * Verify that the sequence id has not been used before and inserts it. Throws if the sequence ID was not accepted.\r\n   * We collect a window of up to 10 recent sequence ids, and allow any sequence id that is not in the window and\r\n   * greater than the minimum element in the window.\r\n   * @param sequenceId to insert into array of stored ids\r\n   */\r\n  function tryInsertSequenceId(uint sequenceId) onlysigner private {\r\n    // Keep a pointer to the lowest value element in the window\r\n    uint lowestValueIndex = 0;\r\n    for (uint i = 0; i < SEQUENCE_ID_WINDOW_SIZE; i++) {\r\n      if (recentSequenceIds[i] == sequenceId) {\r\n        // This sequence ID has been used before. Disallow!\r\n        throw;\r\n      }\r\n      if (recentSequenceIds[i] < recentSequenceIds[lowestValueIndex]) {\r\n        lowestValueIndex = i;\r\n      }\r\n    }\r\n    if (sequenceId < recentSequenceIds[lowestValueIndex]) {\r\n      // The sequence ID being used is lower than the lowest value in the window\r\n      // so we cannot accept it as it may have been used before\r\n      throw;\r\n    }\r\n    if (sequenceId > (recentSequenceIds[lowestValueIndex] + 10000)) {\r\n      // Block sequence IDs which are much higher than the lowest value\r\n      // This prevents people blocking the contract by using very large sequence IDs quickly\r\n      throw;\r\n    }\r\n    recentSequenceIds[lowestValueIndex] = sequenceId;\r\n  }\r\n\r\n  /**\r\n   * Gets the next available sequence ID for signing when using executeAndConfirm\r\n   * returns the sequenceId one higher than the highest currently stored\r\n   */\r\n  function getNextSequenceId() returns (uint) {\r\n    uint highestSequenceId = 0;\r\n    for (uint i = 0; i < SEQUENCE_ID_WINDOW_SIZE; i++) {\r\n      if (recentSequenceIds[i] > highestSequenceId) {\r\n        highestSequenceId = recentSequenceIds[i];\r\n      }\r\n    }\r\n    return highestSequenceId + 1;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"toAddress\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"tokenContractAddress\",\"type\":\"address\"},{\"name\":\"expireTime\",\"type\":\"uint256\"},{\"name\":\"sequenceId\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"sendMultiSigToken\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"signers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"forwarderAddress\",\"type\":\"address\"},{\"name\":\"tokenContractAddress\",\"type\":\"address\"}],\"name\":\"flushForwarderTokens\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toAddress\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"expireTime\",\"type\":\"uint256\"},{\"name\":\"sequenceId\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"sendMultiSig\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"isSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getNextSequenceId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"createForwarder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"safeMode\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activateSafeMode\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"allowedSigners\",\"type\":\"address[]\"}],\"payable\":false,\"type\":\"constructor\"},{\"payable\":true,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msgSender\",\"type\":\"address\"}],\"name\":\"SafeModeActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msgSender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"otherSigner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Transacted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msgSender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"otherSigner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenContractAddress\",\"type\":\"address\"}],\"name\":\"TokenTransacted\",\"type\":\"event\"}]","ContractName":"WalletSimple","CompilerVersion":"v0.4.14+commit.c2215d46","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000003000000000000000000000000058251232c086247ca91998472245d8ae213666c000000000000000000000000b1b359cb06b3a40c53b2fa5ec112214626bc187a000000000000000000000000bcbd7ec77f3f286bdafcde2a3720e39e93a726c6","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":"bzzr://2a6e0c0758687b7db0ac38676ef952bba28bd4a5a580a99285dd37ea18d4fc0a"}]}