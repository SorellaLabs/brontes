{"expiry":1699513245,"data":[{"SourceCode":"# @version 0.2.12\r\n# (c) Curve.Fi, 2021\r\n# Pool for USDT/BTC/ETH or similar\r\n\r\ninterface ERC20:  # Custom ERC20 which works for USDT, WETH and WBTC\r\n    def transfer(_to: address, _amount: uint256): nonpayable\r\n    def transferFrom(_from: address, _to: address, _amount: uint256): nonpayable\r\n    def balanceOf(_user: address) -> uint256: view\r\n\r\ninterface CurveToken:\r\n    def totalSupply() -> uint256: view\r\n    def mint(_to: address, _value: uint256) -> bool: nonpayable\r\n    def mint_relative(_to: address, frac: uint256) -> uint256: nonpayable\r\n    def burnFrom(_to: address, _value: uint256) -> bool: nonpayable\r\n\r\n\r\ninterface Math:\r\n    def geometric_mean(unsorted_x: uint256[N_COINS]) -> uint256: view\r\n    def reduction_coefficient(x: uint256[N_COINS], fee_gamma: uint256) -> uint256: view\r\n    def newton_D(ANN: uint256, gamma: uint256, x_unsorted: uint256[N_COINS]) -> uint256: view\r\n    def newton_y(ANN: uint256, gamma: uint256, x: uint256[N_COINS], D: uint256, i: uint256) -> uint256: view\r\n    def halfpow(power: uint256, precision: uint256) -> uint256: view\r\n    def sqrt_int(x: uint256) -> uint256: view\r\n\r\n\r\ninterface Views:\r\n    def get_dy(i: uint256, j: uint256, dx: uint256) -> uint256: view\r\n    def calc_token_amount(amounts: uint256[N_COINS], deposit: bool) -> uint256: view\r\n\r\n\r\ninterface WETH:\r\n    def deposit(): payable\r\n    def withdraw(_amount: uint256): nonpayable\r\n\r\n\r\n# Events\r\nevent TokenExchange:\r\n    buyer: indexed(address)\r\n    sold_id: uint256\r\n    tokens_sold: uint256\r\n    bought_id: uint256\r\n    tokens_bought: uint256\r\n\r\nevent AddLiquidity:\r\n    provider: indexed(address)\r\n    token_amounts: uint256[N_COINS]\r\n    fee: uint256\r\n    token_supply: uint256\r\n\r\nevent RemoveLiquidity:\r\n    provider: indexed(address)\r\n    token_amounts: uint256[N_COINS]\r\n    token_supply: uint256\r\n\r\nevent RemoveLiquidityOne:\r\n    provider: indexed(address)\r\n    token_amount: uint256\r\n    coin_index: uint256\r\n    coin_amount: uint256\r\n\r\nevent CommitNewAdmin:\r\n    deadline: indexed(uint256)\r\n    admin: indexed(address)\r\n\r\nevent NewAdmin:\r\n    admin: indexed(address)\r\n\r\nevent CommitNewParameters:\r\n    deadline: indexed(uint256)\r\n    admin_fee: uint256\r\n    mid_fee: uint256\r\n    out_fee: uint256\r\n    fee_gamma: uint256\r\n    allowed_extra_profit: uint256\r\n    adjustment_step: uint256\r\n    ma_half_time: uint256\r\n\r\nevent NewParameters:\r\n    admin_fee: uint256\r\n    mid_fee: uint256\r\n    out_fee: uint256\r\n    fee_gamma: uint256\r\n    allowed_extra_profit: uint256\r\n    adjustment_step: uint256\r\n    ma_half_time: uint256\r\n\r\nevent RampAgamma:\r\n    initial_A: uint256\r\n    future_A: uint256\r\n    initial_gamma: uint256\r\n    future_gamma: uint256\r\n    initial_time: uint256\r\n    future_time: uint256\r\n\r\nevent StopRampA:\r\n    current_A: uint256\r\n    current_gamma: uint256\r\n    time: uint256\r\n\r\nevent ClaimAdminFee:\r\n    admin: indexed(address)\r\n    tokens: uint256\r\n\r\n\r\nN_COINS: constant(int128) = 3  # <- change\r\nPRECISION: constant(uint256) = 10 ** 18  # The precision to convert to\r\nA_MULTIPLIER: constant(uint256) = 10000\r\n\r\n# These addresses are replaced by the deployer\r\nmath: constant(address) = 0x8F68f4810CcE3194B6cB6F3d50fa58c2c9bDD1d5\r\ntoken: constant(address) = 0xc4AD29ba4B3c580e6D59105FFf484999997675Ff\r\nviews: constant(address) = 0x40745803C2faA8E8402E2Ae935933D07cA8f355c\r\ncoins: constant(address[N_COINS]) = [\r\n    0xdAC17F958D2ee523a2206206994597C13D831ec7,\r\n    0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599,\r\n    0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2,\r\n]\r\n\r\nprice_scale_packed: uint256   # Internal price scale\r\nprice_oracle_packed: uint256  # Price target given by MA\r\n\r\nlast_prices_packed: uint256\r\nlast_prices_timestamp: public(uint256)\r\n\r\ninitial_A_gamma: public(uint256)\r\nfuture_A_gamma: public(uint256)\r\ninitial_A_gamma_time: public(uint256)\r\nfuture_A_gamma_time: public(uint256)\r\n\r\nallowed_extra_profit: public(uint256)  # 2 * 10**12 - recommended value\r\nfuture_allowed_extra_profit: public(uint256)\r\n\r\nfee_gamma: public(uint256)\r\nfuture_fee_gamma: public(uint256)\r\n\r\nadjustment_step: public(uint256)\r\nfuture_adjustment_step: public(uint256)\r\n\r\nma_half_time: public(uint256)\r\nfuture_ma_half_time: public(uint256)\r\n\r\nmid_fee: public(uint256)\r\nout_fee: public(uint256)\r\nadmin_fee: public(uint256)\r\nfuture_mid_fee: public(uint256)\r\nfuture_out_fee: public(uint256)\r\nfuture_admin_fee: public(uint256)\r\n\r\nbalances: public(uint256[N_COINS])\r\nD: public(uint256)\r\n\r\nowner: public(address)\r\nfuture_owner: public(address)\r\n\r\nxcp_profit: public(uint256)\r\nxcp_profit_a: public(uint256)  # Full profit at last claim of admin fees\r\nvirtual_price: public(uint256)  # Cached (fast to read) virtual price also used internally\r\nnot_adjusted: bool\r\n\r\nis_killed: public(bool)\r\nkill_deadline: public(uint256)\r\ntransfer_ownership_deadline: public(uint256)\r\nadmin_actions_deadline: public(uint256)\r\n\r\nadmin_fee_receiver: public(address)\r\n\r\nKILL_DEADLINE_DT: constant(uint256) = 2 * 30 * 86400\r\nADMIN_ACTIONS_DELAY: constant(uint256) = 3 * 86400\r\nMIN_RAMP_TIME: constant(uint256) = 86400\r\n\r\nMAX_ADMIN_FEE: constant(uint256) = 10 * 10 ** 9\r\nMIN_FEE: constant(uint256) = 5 * 10 ** 5  # 0.5 bps\r\nMAX_FEE: constant(uint256) = 10 * 10 ** 9\r\nMAX_A: constant(uint256) = 10000 * A_MULTIPLIER * N_COINS**N_COINS\r\nMAX_A_CHANGE: constant(uint256) = 10\r\nMIN_GAMMA: constant(uint256) = 10**10\r\nMAX_GAMMA: constant(uint256) = 10**16\r\nNOISE_FEE: constant(uint256) = 10**5  # 0.1 bps\r\n\r\nPRICE_SIZE: constant(int128) = 256 / (N_COINS-1)\r\nPRICE_MASK: constant(uint256) = 2**PRICE_SIZE - 1\r\n\r\n# This must be changed for different N_COINS\r\n# For example:\r\n# N_COINS = 3 -> 1  (10**18 -> 10**18)\r\n# N_COINS = 4 -> 10**8  (10**18 -> 10**10)\r\n# PRICE_PRECISION_MUL: constant(uint256) = 1\r\nPRECISIONS: constant(uint256[N_COINS]) = [\r\n    1000000000000,\r\n    10000000000,\r\n    1,\r\n]\r\n\r\nINF_COINS: constant(uint256) = 15\r\n\r\n\r\n@external\r\ndef __init__(\r\n    owner: address,\r\n    admin_fee_receiver: address,\r\n    A: uint256,\r\n    gamma: uint256,\r\n    mid_fee: uint256,\r\n    out_fee: uint256,\r\n    allowed_extra_profit: uint256,\r\n    fee_gamma: uint256,\r\n    adjustment_step: uint256,\r\n    admin_fee: uint256,\r\n    ma_half_time: uint256,\r\n    initial_prices: uint256[N_COINS-1]\r\n):\r\n    self.owner = owner\r\n\r\n    # Pack A and gamma:\r\n    # shifted A + gamma\r\n    A_gamma: uint256 = shift(A, 128)\r\n    A_gamma = bitwise_or(A_gamma, gamma)\r\n    self.initial_A_gamma = A_gamma\r\n    self.future_A_gamma = A_gamma\r\n\r\n    self.mid_fee = mid_fee\r\n    self.out_fee = out_fee\r\n    self.allowed_extra_profit = allowed_extra_profit\r\n    self.fee_gamma = fee_gamma\r\n    self.adjustment_step = adjustment_step\r\n    self.admin_fee = admin_fee\r\n\r\n    # Packing prices\r\n    packed_prices: uint256 = 0\r\n    for k in range(N_COINS-1):\r\n        packed_prices = shift(packed_prices, PRICE_SIZE)\r\n        p: uint256 = initial_prices[N_COINS-2 - k]  # / PRICE_PRECISION_MUL\r\n        assert p < PRICE_MASK\r\n        packed_prices = bitwise_or(p, packed_prices)\r\n\r\n    self.price_scale_packed = packed_prices\r\n    self.price_oracle_packed = packed_prices\r\n    self.last_prices_packed = packed_prices\r\n    self.last_prices_timestamp = block.timestamp\r\n    self.ma_half_time = ma_half_time\r\n\r\n    self.xcp_profit_a = 10**18\r\n\r\n    self.kill_deadline = block.timestamp + KILL_DEADLINE_DT\r\n\r\n    self.admin_fee_receiver = admin_fee_receiver\r\n\r\n\r\n@payable\r\n@external\r\ndef __default__():\r\n    pass\r\n\r\n\r\n@internal\r\n@view\r\ndef _packed_view(k: uint256, p: uint256) -> uint256:\r\n    assert k < N_COINS-1\r\n    return bitwise_and(\r\n        shift(p, -PRICE_SIZE * convert(k, int256)),\r\n        PRICE_MASK\r\n    )  # * PRICE_PRECISION_MUL\r\n\r\n\r\n@external\r\n@view\r\ndef price_oracle(k: uint256) -> uint256:\r\n    return self._packed_view(k, self.price_oracle_packed)\r\n\r\n\r\n@external\r\n@view\r\ndef price_scale(k: uint256) -> uint256:\r\n    return self._packed_view(k, self.price_scale_packed)\r\n\r\n\r\n@external\r\n@view\r\ndef last_prices(k: uint256) -> uint256:\r\n    return self._packed_view(k, self.last_prices_packed)\r\n\r\n\r\n@external\r\n@view\r\ndef token() -> address:\r\n    return token\r\n\r\n\r\n@external\r\n@view\r\ndef coins(i: uint256) -> address:\r\n    _coins: address[N_COINS] = coins\r\n    return _coins[i]\r\n\r\n\r\n@internal\r\n@view\r\ndef xp() -> uint256[N_COINS]:\r\n    result: uint256[N_COINS] = self.balances\r\n    packed_prices: uint256 = self.price_scale_packed\r\n\r\n    precisions: uint256[N_COINS] = PRECISIONS\r\n\r\n    result[0] *= PRECISIONS[0]\r\n    for i in range(1, N_COINS):\r\n        p: uint256 = bitwise_and(packed_prices, PRICE_MASK) * precisions[i]  # * PRICE_PRECISION_MUL\r\n        result[i] = result[i] * p / PRECISION\r\n        packed_prices = shift(packed_prices, -PRICE_SIZE)\r\n\r\n    return result\r\n\r\n\r\n@view\r\n@internal\r\ndef _A_gamma() -> uint256[2]:\r\n    t1: uint256 = self.future_A_gamma_time\r\n\r\n    A_gamma_1: uint256 = self.future_A_gamma\r\n    gamma1: uint256 = bitwise_and(A_gamma_1, 2**128-1)\r\n    A1: uint256 = shift(A_gamma_1, -128)\r\n\r\n    if block.timestamp < t1:\r\n        # handle ramping up and down of A\r\n        A_gamma_0: uint256 = self.initial_A_gamma\r\n        t0: uint256 = self.initial_A_gamma_time\r\n\r\n        # Less readable but more compact way of writing and converting to uint256\r\n        # gamma0: uint256 = bitwise_and(A_gamma_0, 2**128-1)\r\n        # A0: uint256 = shift(A_gamma_0, -128)\r\n        # A1 = A0 + (A1 - A0) * (block.timestamp - t0) / (t1 - t0)\r\n        # gamma1 = gamma0 + (gamma1 - gamma0) * (block.timestamp - t0) / (t1 - t0)\r\n\r\n        t1 -= t0\r\n        t0 = block.timestamp - t0\r\n        t2: uint256 = t1 - t0\r\n\r\n        A1 = (shift(A_gamma_0, -128) * t2 + A1 * t0) / t1\r\n        gamma1 = (bitwise_and(A_gamma_0, 2**128-1) * t2 + gamma1 * t0) / t1\r\n\r\n    return [A1, gamma1]\r\n\r\n\r\n@view\r\n@external\r\ndef A() -> uint256:\r\n    return self._A_gamma()[0]\r\n\r\n\r\n@view\r\n@external\r\ndef gamma() -> uint256:\r\n    return self._A_gamma()[1]\r\n\r\n\r\n@internal\r\n@view\r\ndef _fee(xp: uint256[N_COINS]) -> uint256:\r\n    f: uint256 = Math(math).reduction_coefficient(xp, self.fee_gamma)\r\n    return (self.mid_fee * f + self.out_fee * (10**18 - f)) / 10**18\r\n\r\n\r\n@external\r\n@view\r\ndef fee() -> uint256:\r\n    return self._fee(self.xp())\r\n\r\n\r\n@external\r\n@view\r\ndef fee_calc(xp: uint256[N_COINS]) -> uint256:\r\n    return self._fee(xp)\r\n\r\n\r\n@internal\r\n@view\r\ndef get_xcp(D: uint256) -> uint256:\r\n    x: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    x[0] = D / N_COINS\r\n    packed_prices: uint256 = self.price_scale_packed\r\n    # No precisions here because we don't switch to \"real\" units\r\n\r\n    for i in range(1, N_COINS):\r\n        x[i] = D * 10**18 / (N_COINS * bitwise_and(packed_prices, PRICE_MASK))  # ... * PRICE_PRECISION_MUL)\r\n        packed_prices = shift(packed_prices, -PRICE_SIZE)\r\n\r\n    return Math(math).geometric_mean(x)\r\n\r\n\r\n@external\r\n@view\r\ndef get_virtual_price() -> uint256:\r\n    return 10**18 * self.get_xcp(self.D) / CurveToken(token).totalSupply()\r\n\r\n\r\n@internal\r\ndef _claim_admin_fees():\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n\r\n    xcp_profit: uint256 = self.xcp_profit\r\n    xcp_profit_a: uint256 = self.xcp_profit_a\r\n\r\n    # Gulp here\r\n    _coins: address[N_COINS] = coins\r\n    for i in range(N_COINS):\r\n        self.balances[i] = ERC20(_coins[i]).balanceOf(self)\r\n\r\n    vprice: uint256 = self.virtual_price\r\n\r\n    if xcp_profit > xcp_profit_a:\r\n        fees: uint256 = (xcp_profit - xcp_profit_a) * self.admin_fee / (2 * 10**10)\r\n        if fees > 0:\r\n            receiver: address = self.admin_fee_receiver\r\n            frac: uint256 = vprice * 10**18 / (vprice - fees) - 10**18\r\n            claimed: uint256 = CurveToken(token).mint_relative(receiver, frac)\r\n            xcp_profit -= fees*2\r\n            self.xcp_profit = xcp_profit\r\n            log ClaimAdminFee(receiver, claimed)\r\n\r\n    total_supply: uint256 = CurveToken(token).totalSupply()\r\n\r\n    # Recalculate D b/c we gulped\r\n    D: uint256 = Math(math).newton_D(A_gamma[0], A_gamma[1], self.xp())\r\n    self.D = D\r\n\r\n    self.virtual_price = 10**18 * self.get_xcp(D) / total_supply\r\n\r\n    if xcp_profit > xcp_profit_a:\r\n        self.xcp_profit_a = xcp_profit\r\n\r\n\r\n@internal\r\ndef tweak_price(A_gamma: uint256[2],\r\n                _xp: uint256[N_COINS], i: uint256, p_i: uint256,\r\n                new_D: uint256):\r\n    price_oracle: uint256[N_COINS-1] = empty(uint256[N_COINS-1])\r\n    last_prices: uint256[N_COINS-1] = empty(uint256[N_COINS-1])\r\n    price_scale: uint256[N_COINS-1] = empty(uint256[N_COINS-1])\r\n    xp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    p_new: uint256[N_COINS-1] = empty(uint256[N_COINS-1])\r\n\r\n    # Update MA if needed\r\n    packed_prices: uint256 = self.price_oracle_packed\r\n    for k in range(N_COINS-1):\r\n        price_oracle[k] = bitwise_and(packed_prices, PRICE_MASK)  # * PRICE_PRECISION_MUL\r\n        packed_prices = shift(packed_prices, -PRICE_SIZE)\r\n\r\n    last_prices_timestamp: uint256 = self.last_prices_timestamp\r\n    packed_prices = self.last_prices_packed\r\n    for k in range(N_COINS-1):\r\n        last_prices[k] = bitwise_and(packed_prices, PRICE_MASK)   # * PRICE_PRECISION_MUL\r\n        packed_prices = shift(packed_prices, -PRICE_SIZE)\r\n\r\n    if last_prices_timestamp < block.timestamp:\r\n        # MA update required\r\n        ma_half_time: uint256 = self.ma_half_time\r\n        alpha: uint256 = Math(math).halfpow((block.timestamp - last_prices_timestamp) * 10**18 / ma_half_time, 10**10)\r\n        packed_prices = 0\r\n        for k in range(N_COINS-1):\r\n            price_oracle[k] = (last_prices[k] * (10**18 - alpha) + price_oracle[k] * alpha) / 10**18\r\n        for k in range(N_COINS-1):\r\n            packed_prices = shift(packed_prices, PRICE_SIZE)\r\n            p: uint256 = price_oracle[N_COINS-2 - k]  # / PRICE_PRECISION_MUL\r\n            assert p < PRICE_MASK\r\n            packed_prices = bitwise_or(p, packed_prices)\r\n        self.price_oracle_packed = packed_prices\r\n        self.last_prices_timestamp = block.timestamp\r\n\r\n    D_unadjusted: uint256 = new_D  # Withdrawal methods know new D already\r\n    if new_D == 0:\r\n        # We will need this a few times (35k gas)\r\n        D_unadjusted = Math(math).newton_D(A_gamma[0], A_gamma[1], _xp)\r\n    packed_prices = self.price_scale_packed\r\n    for k in range(N_COINS-1):\r\n        price_scale[k] = bitwise_and(packed_prices, PRICE_MASK)  # * PRICE_PRECISION_MUL\r\n        packed_prices = shift(packed_prices, -PRICE_SIZE)\r\n\r\n    if p_i > 0:\r\n        # Save the last price\r\n        if i > 0:\r\n            last_prices[i-1] = p_i\r\n        else:\r\n            # If 0th price changed - change all prices instead\r\n            for k in range(N_COINS-1):\r\n                last_prices[k] = last_prices[k] * 10**18 / p_i\r\n    else:\r\n        # calculate real prices\r\n        # it would cost 70k gas for a 3-token pool. Sad. How do we do better?\r\n        __xp: uint256[N_COINS] = _xp\r\n        dx_price: uint256 = __xp[0] / 10**6\r\n        __xp[0] += dx_price\r\n        for k in range(N_COINS-1):\r\n            last_prices[k] = price_scale[k] * dx_price / (_xp[k+1] - Math(math).newton_y(A_gamma[0], A_gamma[1], __xp, D_unadjusted, k+1))\r\n\r\n    packed_prices = 0\r\n    for k in range(N_COINS-1):\r\n        packed_prices = shift(packed_prices, PRICE_SIZE)\r\n        p: uint256 = last_prices[N_COINS-2 - k]  # / PRICE_PRECISION_MUL\r\n        assert p < PRICE_MASK\r\n        packed_prices = bitwise_or(p, packed_prices)\r\n    self.last_prices_packed = packed_prices\r\n\r\n    total_supply: uint256 = CurveToken(token).totalSupply()\r\n    old_xcp_profit: uint256 = self.xcp_profit\r\n    old_virtual_price: uint256 = self.virtual_price\r\n\r\n    # Update profit numbers without price adjustment first\r\n    xp[0] = D_unadjusted / N_COINS\r\n    for k in range(N_COINS-1):\r\n        xp[k+1] = D_unadjusted * 10**18 / (N_COINS * price_scale[k])\r\n    xcp_profit: uint256 = 10**18\r\n    virtual_price: uint256 = 10**18\r\n\r\n    if old_virtual_price > 0:\r\n        xcp: uint256 = Math(math).geometric_mean(xp)\r\n        virtual_price = 10**18 * xcp / total_supply\r\n        xcp_profit = old_xcp_profit * virtual_price / old_virtual_price\r\n\r\n        t: uint256 = self.future_A_gamma_time\r\n        if virtual_price < old_virtual_price and t == 0:\r\n            raise \"Loss\"\r\n        if t == 1:\r\n            self.future_A_gamma_time = 0\r\n\r\n    self.xcp_profit = xcp_profit\r\n\r\n    needs_adjustment: bool = self.not_adjusted\r\n    # if not needs_adjustment and (virtual_price-10**18 > (xcp_profit-10**18)/2 + self.allowed_extra_profit):\r\n    # (re-arrange for gas efficiency)\r\n    if not needs_adjustment and (virtual_price * 2 - 10**18 > xcp_profit + 2*self.allowed_extra_profit):\r\n        needs_adjustment = True\r\n        self.not_adjusted = True\r\n\r\n    if needs_adjustment:\r\n        adjustment_step: uint256 = self.adjustment_step\r\n        norm: uint256 = 0\r\n\r\n        for k in range(N_COINS-1):\r\n            ratio: uint256 = price_oracle[k] * 10**18 / price_scale[k]\r\n            if ratio > 10**18:\r\n                ratio -= 10**18\r\n            else:\r\n                ratio = 10**18 - ratio\r\n            norm += ratio**2\r\n\r\n        if norm > adjustment_step ** 2 and old_virtual_price > 0:\r\n            norm = Math(math).sqrt_int(norm / 10**18)  # Need to convert to 1e18 units!\r\n\r\n            for k in range(N_COINS-1):\r\n                p_new[k] = (price_scale[k] * (norm - adjustment_step) + adjustment_step * price_oracle[k]) / norm\r\n\r\n            # Calculate balances*prices\r\n            xp = _xp\r\n            for k in range(N_COINS-1):\r\n                xp[k+1] = _xp[k+1] * p_new[k] / price_scale[k]\r\n\r\n            # Calculate \"extended constant product\" invariant xCP and virtual price\r\n            D: uint256 = Math(math).newton_D(A_gamma[0], A_gamma[1], xp)\r\n            xp[0] = D / N_COINS\r\n            for k in range(N_COINS-1):\r\n                xp[k+1] = D * 10**18 / (N_COINS * p_new[k])\r\n            # We reuse old_virtual_price here but it's not old anymore\r\n            old_virtual_price = 10**18 * Math(math).geometric_mean(xp) / total_supply\r\n\r\n            # Proceed if we've got enough profit\r\n            # if (old_virtual_price > 10**18) and (2 * (old_virtual_price - 10**18) > xcp_profit - 10**18):\r\n            if (old_virtual_price > 10**18) and (2 * old_virtual_price - 10**18 > xcp_profit):\r\n                packed_prices = 0\r\n                for k in range(N_COINS-1):\r\n                    packed_prices = shift(packed_prices, PRICE_SIZE)\r\n                    p: uint256 = p_new[N_COINS-2 - k]  # / PRICE_PRECISION_MUL\r\n                    assert p < PRICE_MASK\r\n                    packed_prices = bitwise_or(p, packed_prices)\r\n                self.price_scale_packed = packed_prices\r\n                self.D = D\r\n                self.virtual_price = old_virtual_price\r\n\r\n                return\r\n\r\n            else:\r\n                self.not_adjusted = False\r\n\r\n    # If we are here, the price_scale adjustment did not happen\r\n    # Still need to update the profit counter and D\r\n    self.D = D_unadjusted\r\n    self.virtual_price = virtual_price\r\n\r\n\r\n\r\n@payable\r\n@external\r\n@nonreentrant('lock')\r\ndef exchange(i: uint256, j: uint256, dx: uint256, min_dy: uint256, use_eth: bool = False):\r\n    assert not self.is_killed  # dev: the pool is killed\r\n    assert i != j  # dev: coin index out of range\r\n    assert i < N_COINS  # dev: coin index out of range\r\n    assert j < N_COINS  # dev: coin index out of range\r\n    assert dx > 0  # dev: do not exchange 0 coins\r\n\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n    xp: uint256[N_COINS] = self.balances\r\n    ix: uint256 = j\r\n    p: uint256 = 0\r\n    dy: uint256 = 0\r\n\r\n    if True:  # scope to reduce size of memory when making internal calls later\r\n        _coins: address[N_COINS] = coins\r\n        if i == 2 and use_eth:\r\n            assert msg.value == dx  # dev: incorrect eth amount\r\n            WETH(coins[2]).deposit(value=msg.value)\r\n        else:\r\n            assert msg.value == 0  # dev: nonzero eth amount\r\n            # assert might be needed for some tokens - removed one to save bytespace\r\n            ERC20(_coins[i]).transferFrom(msg.sender, self, dx)\r\n\r\n        y: uint256 = xp[j]\r\n        x0: uint256 = xp[i]\r\n        xp[i] = x0 + dx\r\n        self.balances[i] = xp[i]\r\n\r\n        price_scale: uint256[N_COINS-1] = empty(uint256[N_COINS-1])\r\n        packed_prices: uint256 = self.price_scale_packed\r\n        for k in range(N_COINS-1):\r\n            price_scale[k] = bitwise_and(packed_prices, PRICE_MASK)  # * PRICE_PRECISION_MUL\r\n            packed_prices = shift(packed_prices, -PRICE_SIZE)\r\n\r\n        precisions: uint256[N_COINS] = PRECISIONS\r\n        xp[0] *= PRECISIONS[0]\r\n        for k in range(1, N_COINS):\r\n            xp[k] = xp[k] * price_scale[k-1] * precisions[k] / PRECISION\r\n\r\n        prec_i: uint256 = precisions[i]\r\n\r\n        # In case ramp is happening\r\n        if True:\r\n            t: uint256 = self.future_A_gamma_time\r\n            if t > 0:\r\n                x0 *= prec_i\r\n                if i > 0:\r\n                    x0 = x0 * price_scale[i-1] / PRECISION\r\n                x1: uint256 = xp[i]  # Back up old value in xp\r\n                xp[i] = x0\r\n                self.D = Math(math).newton_D(A_gamma[0], A_gamma[1], xp)\r\n                xp[i] = x1  # And restore\r\n                if block.timestamp >= t:\r\n                    self.future_A_gamma_time = 1\r\n\r\n        prec_j: uint256 = precisions[j]\r\n\r\n        dy = xp[j] - Math(math).newton_y(A_gamma[0], A_gamma[1], xp, self.D, j)\r\n        # Not defining new \"y\" here to have less variables / make subsequent calls cheaper\r\n        xp[j] -= dy\r\n        dy -= 1\r\n\r\n        if j > 0:\r\n            dy = dy * PRECISION / price_scale[j-1]\r\n        dy /= prec_j\r\n\r\n        dy -= self._fee(xp) * dy / 10**10\r\n        assert dy >= min_dy, \"Slippage\"\r\n        y -= dy\r\n\r\n        self.balances[j] = y\r\n        # assert might be needed for some tokens - removed one to save bytespace\r\n        if j == 2 and use_eth:\r\n            WETH(coins[2]).withdraw(dy)\r\n            raw_call(msg.sender, b\"\", value=dy)\r\n        else:\r\n            ERC20(_coins[j]).transfer(msg.sender, dy)\r\n\r\n        y *= prec_j\r\n        if j > 0:\r\n            y = y * price_scale[j-1] / PRECISION\r\n        xp[j] = y\r\n\r\n        # Calculate price\r\n        if dx > 10**5 and dy > 10**5:\r\n            _dx: uint256 = dx * prec_i\r\n            _dy: uint256 = dy * prec_j\r\n            if i != 0 and j != 0:\r\n                p = bitwise_and(\r\n                    shift(self.last_prices_packed, -PRICE_SIZE * convert(i-1, int256)),\r\n                    PRICE_MASK\r\n                ) * _dx / _dy  # * PRICE_PRECISION_MUL\r\n            elif i == 0:\r\n                p = _dx * 10**18 / _dy\r\n            else:  # j == 0\r\n                p = _dy * 10**18 / _dx\r\n                ix = i\r\n\r\n    self.tweak_price(A_gamma, xp, ix, p, 0)\r\n\r\n    log TokenExchange(msg.sender, i, dx, j, dy)\r\n\r\n\r\n@external\r\n@view\r\ndef get_dy(i: uint256, j: uint256, dx: uint256) -> uint256:\r\n    return Views(views).get_dy(i, j, dx)\r\n\r\n\r\n@view\r\n@internal\r\ndef _calc_token_fee(amounts: uint256[N_COINS], xp: uint256[N_COINS]) -> uint256:\r\n    # fee = sum(amounts_i - avg(amounts)) * fee' / sum(amounts)\r\n    fee: uint256 = self._fee(xp) * N_COINS / (4 * (N_COINS-1))\r\n    S: uint256 = 0\r\n    for _x in amounts:\r\n        S += _x\r\n    avg: uint256 = S / N_COINS\r\n    Sdiff: uint256 = 0\r\n    for _x in amounts:\r\n        if _x > avg:\r\n            Sdiff += _x - avg\r\n        else:\r\n            Sdiff += avg - _x\r\n    return fee * Sdiff / S + NOISE_FEE\r\n\r\n\r\n@external\r\n@view\r\ndef calc_token_fee(amounts: uint256[N_COINS], xp: uint256[N_COINS]) -> uint256:\r\n    return self._calc_token_fee(amounts, xp)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256):\r\n    assert not self.is_killed  # dev: the pool is killed\r\n\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n\r\n    _coins: address[N_COINS] = coins\r\n\r\n    xp: uint256[N_COINS] = self.balances\r\n    amountsp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    xx: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    d_token: uint256 = 0\r\n    d_token_fee: uint256 = 0\r\n    old_D: uint256 = 0\r\n    ix: uint256 = INF_COINS\r\n\r\n    if True:  # Scope to avoid having extra variables in memory later\r\n        xp_old: uint256[N_COINS] = xp\r\n\r\n        for i in range(N_COINS):\r\n            bal: uint256 = xp[i] + amounts[i]\r\n            xp[i] = bal\r\n            self.balances[i] = bal\r\n        xx = xp\r\n\r\n        precisions: uint256[N_COINS] = PRECISIONS\r\n        packed_prices: uint256 = self.price_scale_packed\r\n        xp[0] *= PRECISIONS[0]\r\n        xp_old[0] *= PRECISIONS[0]\r\n        for i in range(1, N_COINS):\r\n            price_scale: uint256 = bitwise_and(packed_prices, PRICE_MASK) * precisions[i]  # * PRICE_PRECISION_MUL\r\n            xp[i] = xp[i] * price_scale / PRECISION\r\n            xp_old[i] = xp_old[i] * price_scale / PRECISION\r\n            packed_prices = shift(packed_prices, -PRICE_SIZE)\r\n\r\n        for i in range(N_COINS):\r\n            if amounts[i] > 0:\r\n                # assert might be needed for some tokens - removed one to save bytespace\r\n                ERC20(_coins[i]).transferFrom(msg.sender, self, amounts[i])\r\n                amountsp[i] = xp[i] - xp_old[i]\r\n                if ix == INF_COINS:\r\n                    ix = i\r\n                else:\r\n                    ix = INF_COINS-1\r\n        assert ix != INF_COINS  # dev: no coins to add\r\n\r\n        t: uint256 = self.future_A_gamma_time\r\n        if t > 0:\r\n            old_D = Math(math).newton_D(A_gamma[0], A_gamma[1], xp_old)\r\n            if block.timestamp >= t:\r\n                self.future_A_gamma_time = 1\r\n        else:\r\n            old_D = self.D\r\n\r\n    D: uint256 = Math(math).newton_D(A_gamma[0], A_gamma[1], xp)\r\n\r\n    token_supply: uint256 = CurveToken(token).totalSupply()\r\n    if old_D > 0:\r\n        d_token = token_supply * D / old_D - token_supply\r\n    else:\r\n        d_token = self.get_xcp(D)  # making initial virtual price equal to 1\r\n    assert d_token > 0  # dev: nothing minted\r\n\r\n    if old_D > 0:\r\n        d_token_fee = self._calc_token_fee(amountsp, xp) * d_token / 10**10 + 1\r\n        d_token -= d_token_fee\r\n        token_supply += d_token\r\n        CurveToken(token).mint(msg.sender, d_token)\r\n\r\n        # Calculate price\r\n        # p_i * (dx_i - dtoken / token_supply * xx_i) = sum{k!=i}(p_k * (dtoken / token_supply * xx_k - dx_k))\r\n        # Only ix is nonzero\r\n        p: uint256 = 0\r\n        if d_token > 10**5:\r\n            if ix < N_COINS:\r\n                S: uint256 = 0\r\n                last_prices: uint256[N_COINS-1] = empty(uint256[N_COINS-1])\r\n                packed_prices: uint256 = self.last_prices_packed\r\n                precisions: uint256[N_COINS] = PRECISIONS\r\n                for k in range(N_COINS-1):\r\n                    last_prices[k] = bitwise_and(packed_prices, PRICE_MASK)  # * PRICE_PRECISION_MUL\r\n                    packed_prices = shift(packed_prices, -PRICE_SIZE)\r\n                for i in range(N_COINS):\r\n                    if i != ix:\r\n                        if i == 0:\r\n                            S += xx[0] * PRECISIONS[0]\r\n                        else:\r\n                            S += xx[i] * last_prices[i-1] * precisions[i] / PRECISION\r\n                S = S * d_token / token_supply\r\n                p = S * PRECISION / (amounts[ix] * precisions[ix] - d_token * xx[ix] * precisions[ix] / token_supply)\r\n\r\n        self.tweak_price(A_gamma, xp, ix, p, D)\r\n\r\n    else:\r\n        self.D = D\r\n        self.virtual_price = 10**18\r\n        self.xcp_profit = 10**18\r\n        CurveToken(token).mint(msg.sender, d_token)\r\n\r\n    assert d_token >= min_mint_amount, \"Slippage\"\r\n\r\n    log AddLiquidity(msg.sender, amounts, d_token_fee, token_supply)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS]):\r\n    \"\"\"\r\n    This withdrawal method is very safe, does no complex math\r\n    \"\"\"\r\n    _coins: address[N_COINS] = coins\r\n    total_supply: uint256 = CurveToken(token).totalSupply()\r\n    CurveToken(token).burnFrom(msg.sender, _amount)\r\n    balances: uint256[N_COINS] = self.balances\r\n    amount: uint256 = _amount - 1  # Make rounding errors favoring other LPs a tiny bit\r\n\r\n    for i in range(N_COINS):\r\n        d_balance: uint256 = balances[i] * amount / total_supply\r\n        assert d_balance >= min_amounts[i]\r\n        self.balances[i] = balances[i] - d_balance\r\n        balances[i] = d_balance  # now it's the amounts going out\r\n        # assert might be needed for some tokens - removed one to save bytespace\r\n        ERC20(_coins[i]).transfer(msg.sender, d_balance)\r\n\r\n    D: uint256 = self.D\r\n    self.D = D - D * amount / total_supply\r\n\r\n    log RemoveLiquidity(msg.sender, balances, total_supply - _amount)\r\n\r\n\r\n@view\r\n@external\r\ndef calc_token_amount(amounts: uint256[N_COINS], deposit: bool) -> uint256:\r\n    return Views(views).calc_token_amount(amounts, deposit)\r\n\r\n\r\n@internal\r\n@view\r\ndef _calc_withdraw_one_coin(A_gamma: uint256[2], token_amount: uint256, i: uint256, update_D: bool,\r\n                            calc_price: bool) -> (uint256, uint256, uint256, uint256[N_COINS]):\r\n    token_supply: uint256 = CurveToken(token).totalSupply()\r\n    assert token_amount <= token_supply  # dev: token amount more than supply\r\n    assert i < N_COINS  # dev: coin out of range\r\n\r\n    xx: uint256[N_COINS] = self.balances\r\n    xp: uint256[N_COINS] = PRECISIONS\r\n    D0: uint256 = 0\r\n\r\n    price_scale_i: uint256 = PRECISION * PRECISIONS[0]\r\n    if True:  # To remove packed_prices from memory\r\n        packed_prices: uint256 = self.price_scale_packed\r\n        xp[0] *= xx[0]\r\n        for k in range(1, N_COINS):\r\n            p: uint256 = bitwise_and(packed_prices, PRICE_MASK)  # * PRICE_PRECISION_MUL\r\n            if i == k:\r\n                price_scale_i = p * xp[i]\r\n            xp[k] = xp[k] * xx[k] * p / PRECISION\r\n            packed_prices = shift(packed_prices, -PRICE_SIZE)\r\n\r\n    if update_D:\r\n        D0 = Math(math).newton_D(A_gamma[0], A_gamma[1], xp)\r\n    else:\r\n        D0 = self.D\r\n\r\n    D: uint256 = D0\r\n\r\n    # Charge the fee on D, not on y, e.g. reducing invariant LESS than charging the user\r\n    fee: uint256 = self._fee(xp)\r\n    dD: uint256 = token_amount * D / token_supply\r\n    D -= (dD - (fee * dD / (2 * 10**10) + 1))\r\n    y: uint256 = Math(math).newton_y(A_gamma[0], A_gamma[1], xp, D, i)\r\n    dy: uint256 = (xp[i] - y) * PRECISION / price_scale_i\r\n    xp[i] = y\r\n\r\n    # Price calc\r\n    p: uint256 = 0\r\n    if calc_price and dy > 10**5 and token_amount > 10**5:\r\n        # p_i = dD / D0 * sum'(p_k * x_k) / (dy - dD / D0 * y0)\r\n        S: uint256 = 0\r\n        precisions: uint256[N_COINS] = PRECISIONS\r\n        last_prices: uint256[N_COINS-1] = empty(uint256[N_COINS-1])\r\n        packed_prices: uint256 = self.last_prices_packed\r\n        for k in range(N_COINS-1):\r\n            last_prices[k] = bitwise_and(packed_prices, PRICE_MASK)  # * PRICE_PRECISION_MUL\r\n            packed_prices = shift(packed_prices, -PRICE_SIZE)\r\n        for k in range(N_COINS):\r\n            if k != i:\r\n                if k == 0:\r\n                    S += xx[0] * PRECISIONS[0]\r\n                else:\r\n                    S += xx[k] * last_prices[k-1] * precisions[k] / PRECISION\r\n        S = S * dD / D0\r\n        p = S * PRECISION / (dy * precisions[i] - dD * xx[i] * precisions[i] / D0)\r\n\r\n    return dy, p, D, xp\r\n\r\n\r\n@view\r\n@external\r\ndef calc_withdraw_one_coin(token_amount: uint256, i: uint256) -> uint256:\r\n    return self._calc_withdraw_one_coin(self._A_gamma(), token_amount, i, True, False)[0]\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef remove_liquidity_one_coin(token_amount: uint256, i: uint256, min_amount: uint256):\r\n    assert not self.is_killed  # dev: the pool is killed\r\n\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n\r\n    dy: uint256 = 0\r\n    D: uint256 = 0\r\n    p: uint256 = 0\r\n    xp: uint256[N_COINS] = empty(uint256[N_COINS])\r\n    future_A_gamma_time: uint256 = self.future_A_gamma_time\r\n    dy, p, D, xp = self._calc_withdraw_one_coin(A_gamma, token_amount, i, (future_A_gamma_time > 0), True)\r\n    assert dy >= min_amount, \"Slippage\"\r\n\r\n    if block.timestamp >= future_A_gamma_time:\r\n        self.future_A_gamma_time = 1\r\n\r\n    self.balances[i] -= dy\r\n    CurveToken(token).burnFrom(msg.sender, token_amount)\r\n    self.tweak_price(A_gamma, xp, i, p, D)\r\n\r\n    _coins: address[N_COINS] = coins\r\n    # assert might be needed for some tokens - removed one to save bytespace\r\n    ERC20(_coins[i]).transfer(msg.sender, dy)\r\n\r\n    log RemoveLiquidityOne(msg.sender, token_amount, i, dy)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef claim_admin_fees():\r\n    self._claim_admin_fees()\r\n\r\n\r\n# Admin parameters\r\n@external\r\ndef ramp_A_gamma(future_A: uint256, future_gamma: uint256, future_time: uint256):\r\n    assert msg.sender == self.owner  # dev: only owner\r\n    assert block.timestamp > self.initial_A_gamma_time + (MIN_RAMP_TIME-1)\r\n    assert future_time > block.timestamp + (MIN_RAMP_TIME-1)  # dev: insufficient time\r\n\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n    initial_A_gamma: uint256 = shift(A_gamma[0], 128)\r\n    initial_A_gamma = bitwise_or(initial_A_gamma, A_gamma[1])\r\n\r\n    assert future_A > 0\r\n    assert future_A < MAX_A+1\r\n    assert future_gamma > MIN_GAMMA-1\r\n    assert future_gamma < MAX_GAMMA+1\r\n\r\n    ratio: uint256 = 10**18 * future_A / A_gamma[0]\r\n    assert ratio < 10**18 * MAX_A_CHANGE + 1\r\n    assert ratio > 10**18 / MAX_A_CHANGE - 1\r\n\r\n    ratio = 10**18 * future_gamma / A_gamma[1]\r\n    assert ratio < 10**18 * MAX_A_CHANGE + 1\r\n    assert ratio > 10**18 / MAX_A_CHANGE - 1\r\n\r\n    self.initial_A_gamma = initial_A_gamma\r\n    self.initial_A_gamma_time = block.timestamp\r\n\r\n    future_A_gamma: uint256 = shift(future_A, 128)\r\n    future_A_gamma = bitwise_or(future_A_gamma, future_gamma)\r\n    self.future_A_gamma_time = future_time\r\n    self.future_A_gamma = future_A_gamma\r\n\r\n    log RampAgamma(A_gamma[0], future_A, A_gamma[1], future_gamma, block.timestamp, future_time)\r\n\r\n\r\n@external\r\ndef stop_ramp_A_gamma():\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    A_gamma: uint256[2] = self._A_gamma()\r\n    current_A_gamma: uint256 = shift(A_gamma[0], 128)\r\n    current_A_gamma = bitwise_or(current_A_gamma, A_gamma[1])\r\n    self.initial_A_gamma = current_A_gamma\r\n    self.future_A_gamma = current_A_gamma\r\n    self.initial_A_gamma_time = block.timestamp\r\n    self.future_A_gamma_time = block.timestamp\r\n    # now (block.timestamp < t1) is always False, so we return saved A\r\n\r\n    log StopRampA(A_gamma[0], A_gamma[1], block.timestamp)\r\n\r\n\r\n@external\r\ndef commit_new_parameters(\r\n    _new_mid_fee: uint256,\r\n    _new_out_fee: uint256,\r\n    _new_admin_fee: uint256,\r\n    _new_fee_gamma: uint256,\r\n    _new_allowed_extra_profit: uint256,\r\n    _new_adjustment_step: uint256,\r\n    _new_ma_half_time: uint256,\r\n    ):\r\n    assert msg.sender == self.owner  # dev: only owner\r\n    assert self.admin_actions_deadline == 0  # dev: active action\r\n\r\n    new_mid_fee: uint256 = _new_mid_fee\r\n    new_out_fee: uint256 = _new_out_fee\r\n    new_admin_fee: uint256 = _new_admin_fee\r\n    new_fee_gamma: uint256 = _new_fee_gamma\r\n    new_allowed_extra_profit: uint256 = _new_allowed_extra_profit\r\n    new_adjustment_step: uint256 = _new_adjustment_step\r\n    new_ma_half_time: uint256 = _new_ma_half_time\r\n\r\n    # Fees\r\n    if new_out_fee < MAX_FEE+1:\r\n        assert new_out_fee > MIN_FEE-1  # dev: fee is out of range\r\n    else:\r\n        new_out_fee = self.out_fee\r\n    if new_mid_fee > MAX_FEE:\r\n        new_mid_fee = self.mid_fee\r\n    assert new_mid_fee <= new_out_fee  # dev: mid-fee is too high\r\n    if new_admin_fee > MAX_ADMIN_FEE:\r\n        new_admin_fee = self.admin_fee\r\n\r\n    # AMM parameters\r\n    if new_fee_gamma < 10**18:\r\n        assert new_fee_gamma > 0  # dev: fee_gamma out of range [1 .. 10**18]\r\n    else:\r\n        new_fee_gamma = self.fee_gamma\r\n    if new_allowed_extra_profit > 10**18:\r\n        new_allowed_extra_profit = self.allowed_extra_profit\r\n    if new_adjustment_step > 10**18:\r\n        new_adjustment_step = self.adjustment_step\r\n\r\n    # MA\r\n    if new_ma_half_time < 7*86400:\r\n        assert new_ma_half_time > 0  # dev: MA time should be longer than 1 second\r\n    else:\r\n        new_ma_half_time = self.ma_half_time\r\n\r\n    _deadline: uint256 = block.timestamp + ADMIN_ACTIONS_DELAY\r\n    self.admin_actions_deadline = _deadline\r\n\r\n    self.future_admin_fee = new_admin_fee\r\n    self.future_mid_fee = new_mid_fee\r\n    self.future_out_fee = new_out_fee\r\n    self.future_fee_gamma = new_fee_gamma\r\n    self.future_allowed_extra_profit = new_allowed_extra_profit\r\n    self.future_adjustment_step = new_adjustment_step\r\n    self.future_ma_half_time = new_ma_half_time\r\n\r\n    log CommitNewParameters(_deadline, new_admin_fee, new_mid_fee, new_out_fee,\r\n                            new_fee_gamma,\r\n                            new_allowed_extra_profit, new_adjustment_step,\r\n                            new_ma_half_time)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef apply_new_parameters():\r\n    assert msg.sender == self.owner  # dev: only owner\r\n    assert block.timestamp >= self.admin_actions_deadline  # dev: insufficient time\r\n    assert self.admin_actions_deadline != 0  # dev: no active action\r\n\r\n    self.admin_actions_deadline = 0\r\n\r\n    admin_fee: uint256 = self.future_admin_fee\r\n    if self.admin_fee != admin_fee:\r\n        self._claim_admin_fees()\r\n        self.admin_fee = admin_fee\r\n\r\n    mid_fee: uint256 = self.future_mid_fee\r\n    self.mid_fee = mid_fee\r\n    out_fee: uint256 = self.future_out_fee\r\n    self.out_fee = out_fee\r\n    fee_gamma: uint256 = self.future_fee_gamma\r\n    self.fee_gamma = fee_gamma\r\n    allowed_extra_profit: uint256 = self.future_allowed_extra_profit\r\n    self.allowed_extra_profit = allowed_extra_profit\r\n    adjustment_step: uint256 = self.future_adjustment_step\r\n    self.adjustment_step = adjustment_step\r\n    ma_half_time: uint256 = self.future_ma_half_time\r\n    self.ma_half_time = ma_half_time\r\n\r\n    log NewParameters(admin_fee, mid_fee, out_fee,\r\n                      fee_gamma,\r\n                      allowed_extra_profit, adjustment_step,\r\n                      ma_half_time)\r\n\r\n\r\n@external\r\ndef revert_new_parameters():\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    self.admin_actions_deadline = 0\r\n\r\n\r\n@external\r\ndef commit_transfer_ownership(_owner: address):\r\n    assert msg.sender == self.owner  # dev: only owner\r\n    assert self.transfer_ownership_deadline == 0  # dev: active transfer\r\n\r\n    _deadline: uint256 = block.timestamp + ADMIN_ACTIONS_DELAY\r\n    self.transfer_ownership_deadline = _deadline\r\n    self.future_owner = _owner\r\n\r\n    log CommitNewAdmin(_deadline, _owner)\r\n\r\n\r\n@external\r\ndef apply_transfer_ownership():\r\n    assert msg.sender == self.owner  # dev: only owner\r\n    assert block.timestamp >= self.transfer_ownership_deadline  # dev: insufficient time\r\n    assert self.transfer_ownership_deadline != 0  # dev: no active transfer\r\n\r\n    self.transfer_ownership_deadline = 0\r\n    _owner: address = self.future_owner\r\n    self.owner = _owner\r\n\r\n    log NewAdmin(_owner)\r\n\r\n\r\n@external\r\ndef revert_transfer_ownership():\r\n    assert msg.sender == self.owner  # dev: only owner\r\n\r\n    self.transfer_ownership_deadline = 0\r\n\r\n\r\n@external\r\ndef kill_me():\r\n    assert msg.sender == self.owner  # dev: only owner\r\n    assert self.kill_deadline > block.timestamp  # dev: deadline has passed\r\n    self.is_killed = True\r\n\r\n\r\n@external\r\ndef unkill_me():\r\n    assert msg.sender == self.owner  # dev: only owner\r\n    self.is_killed = False\r\n\r\n\r\n@external\r\ndef set_admin_fee_receiver(_admin_fee_receiver: address):\r\n    assert msg.sender == self.owner  # dev: only owner\r\n    self.admin_fee_receiver = _admin_fee_receiver","ABI":"[{\"name\":\"TokenExchange\",\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\",\"indexed\":true},{\"name\":\"sold_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"tokens_sold\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"bought_id\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"tokens_bought\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AddLiquidity\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amounts\",\"type\":\"uint256[3]\",\"indexed\":false},{\"name\":\"fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"token_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidity\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amounts\",\"type\":\"uint256[3]\",\"indexed\":false},{\"name\":\"token_supply\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RemoveLiquidityOne\",\"inputs\":[{\"name\":\"provider\",\"type\":\"address\",\"indexed\":true},{\"name\":\"token_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"coin_index\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"coin_amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"CommitNewAdmin\",\"inputs\":[{\"name\":\"deadline\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"admin\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewAdmin\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"CommitNewParameters\",\"inputs\":[{\"name\":\"deadline\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"admin_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"mid_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"out_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"fee_gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"allowed_extra_profit\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"adjustment_step\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"ma_half_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"NewParameters\",\"inputs\":[{\"name\":\"admin_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"mid_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"out_fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"fee_gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"allowed_extra_profit\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"adjustment_step\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"ma_half_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RampAgamma\",\"inputs\":[{\"name\":\"initial_A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"future_A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"initial_gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"future_gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"initial_time\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"future_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"StopRampA\",\"inputs\":[{\"name\":\"current_A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"current_gamma\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ClaimAdminFee\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":true},{\"name\":\"tokens\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"admin_fee_receiver\",\"type\":\"address\"},{\"name\":\"A\",\"type\":\"uint256\"},{\"name\":\"gamma\",\"type\":\"uint256\"},{\"name\":\"mid_fee\",\"type\":\"uint256\"},{\"name\":\"out_fee\",\"type\":\"uint256\"},{\"name\":\"allowed_extra_profit\",\"type\":\"uint256\"},{\"name\":\"fee_gamma\",\"type\":\"uint256\"},{\"name\":\"adjustment_step\",\"type\":\"uint256\"},{\"name\":\"admin_fee\",\"type\":\"uint256\"},{\"name\":\"ma_half_time\",\"type\":\"uint256\"},{\"name\":\"initial_prices\",\"type\":\"uint256[2]\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"price_oracle\",\"inputs\":[{\"name\":\"k\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3361},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"price_scale\",\"inputs\":[{\"name\":\"k\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3391},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_prices\",\"inputs\":[{\"name\":\"k\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3421},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":468},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"coins\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":582},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"A\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":597},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gamma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":11991},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":21673},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee_calc\",\"inputs\":[{\"name\":\"xp\",\"type\":\"uint256[3]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":11096},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_virtual_price\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":11582},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"min_dy\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"},{\"name\":\"min_dy\",\"type\":\"uint256\"},{\"name\":\"use_eth\",\"type\":\"bool\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dy\",\"inputs\":[{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"j\",\"type\":\"uint256\"},{\"name\":\"dx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3122},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_token_fee\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[3]\"},{\"name\":\"xp\",\"type\":\"uint256[3]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":26582},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_liquidity\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[3]\"},{\"name\":\"min_mint_amount\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":738687},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"min_amounts\",\"type\":\"uint256[3]\"}],\"outputs\":[],\"gas\":233981},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_token_amount\",\"inputs\":[{\"name\":\"amounts\",\"type\":\"uint256[3]\"},{\"name\":\"deposit\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3429},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"calc_withdraw_one_coin\",\"inputs\":[{\"name\":\"token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":13432},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"remove_liquidity_one_coin\",\"inputs\":[{\"name\":\"token_amount\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"},{\"name\":\"min_amount\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":648579},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"claim_admin_fees\",\"inputs\":[],\"outputs\":[],\"gas\":389808},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"ramp_A_gamma\",\"inputs\":[{\"name\":\"future_A\",\"type\":\"uint256\"},{\"name\":\"future_gamma\",\"type\":\"uint256\"},{\"name\":\"future_time\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":163102},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"stop_ramp_A_gamma\",\"inputs\":[],\"outputs\":[],\"gas\":157247},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_new_parameters\",\"inputs\":[{\"name\":\"_new_mid_fee\",\"type\":\"uint256\"},{\"name\":\"_new_out_fee\",\"type\":\"uint256\"},{\"name\":\"_new_admin_fee\",\"type\":\"uint256\"},{\"name\":\"_new_fee_gamma\",\"type\":\"uint256\"},{\"name\":\"_new_allowed_extra_profit\",\"type\":\"uint256\"},{\"name\":\"_new_adjustment_step\",\"type\":\"uint256\"},{\"name\":\"_new_ma_half_time\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":306190},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply_new_parameters\",\"inputs\":[],\"outputs\":[],\"gas\":683438},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"revert_new_parameters\",\"inputs\":[],\"outputs\":[],\"gas\":23222},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"outputs\":[],\"gas\":77260},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply_transfer_ownership\",\"inputs\":[],\"outputs\":[],\"gas\":65937},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"revert_transfer_ownership\",\"inputs\":[],\"outputs\":[],\"gas\":23312},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"kill_me\",\"inputs\":[],\"outputs\":[],\"gas\":40535},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"unkill_me\",\"inputs\":[],\"outputs\":[],\"gas\":23372},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_admin_fee_receiver\",\"inputs\":[{\"name\":\"_admin_fee_receiver\",\"type\":\"address\"}],\"outputs\":[],\"gas\":38505},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_prices_timestamp\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3378},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"initial_A_gamma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3408},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_A_gamma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3438},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"initial_A_gamma_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3468},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_A_gamma_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3498},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowed_extra_profit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3528},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_allowed_extra_profit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3558},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee_gamma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3588},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_fee_gamma\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3618},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"adjustment_step\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3648},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_adjustment_step\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3678},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"ma_half_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3708},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_ma_half_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3738},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"mid_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3768},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"out_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3798},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3828},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_mid_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3858},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_out_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3888},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_admin_fee\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3918},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balances\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":4057},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"D\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3978},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":4008},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_owner\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":4038},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"xcp_profit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":4068},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"xcp_profit_a\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":4098},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"virtual_price\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":4128},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_killed\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":4158},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"kill_deadline\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":4188},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"transfer_ownership_deadline\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":4218},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin_actions_deadline\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":4248},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin_fee_receiver\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":4278}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.12","OptimizationUsed":0,"Runs":0,"ConstructorArguments":"0x000000000000000000000000babe61887f1de2713c6f97e567623453d3c79f67000000000000000000000000ecb456ea5365865ebab8a2661b0c503410e9b347000000000000000000000000000000000000000000000000000000000000d2f0000000000000000000000000000000000000000000000000000c6f3b40b6c0000000000000000000000000000000000000000000000000000000000000a7d8c00000000000000000000000000000000000000000000000000000000002aea540000000000000000000000000000000000000000000000000000001d1a94a20000000000000000000000000000000000000000000000000000001c6bf526340000000000000000000000000000000000000000000000000000001bda703f0a000000000000000000000000000000000000000000000000000000000012a05f20000000000000000000000000000000000000000000000000000000000000002580000000000000000000000000000000000000000000006e514c561b9fec00000000000000000000000000000000000000000000000000069eff91234645c0000","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":0,"SwarmSource":""}]}