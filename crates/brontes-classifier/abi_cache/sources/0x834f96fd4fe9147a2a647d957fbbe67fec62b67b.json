{"expiry":1699588099,"data":[{"SourceCode":{"language":"Solidity","sources":{"@openzeppelin/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"contracts/tax/ITaxHandler.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.11;\r\n\r\n/**\r\n * @title Tax handler interface\r\n * @dev Any class that implements this interface can be used for protocol-specific tax calculations.\r\n */\r\ninterface ITaxHandler {\r\n    /**\r\n     * @notice Get number of tokens to pay as tax.\r\n     * @param benefactor Address of the benefactor.\r\n     * @param beneficiary Address of the beneficiary.\r\n     * @param amount Number of tokens in the transfer.\r\n     * @return Number of tokens to pay as tax.\r\n     */\r\n    function getTax(\r\n        address benefactor,\r\n        address beneficiary,\r\n        uint256 amount\r\n    ) external view returns (uint256);\r\n}\r\n"},"@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"contracts/utils/ExchangePoolProcessor.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\n\r\n/**\r\n * @title Exchange pool processor abstract contract.\r\n * @dev Keeps an enumerable set of designated exchange addresses as well as a single primary pool address.\r\n */\r\nabstract contract ExchangePoolProcessor is Ownable {\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    /// @dev Set of exchange pool addresses.\r\n    EnumerableSet.AddressSet internal _exchangePools;\r\n\r\n    /// @notice Primary exchange pool address.\r\n    address public primaryPool;\r\n\r\n    /// @notice Emitted when an exchange pool address is added to the set of tracked pool addresses.\r\n    event ExchangePoolAdded(address exchangePool);\r\n\r\n    /// @notice Emitted when an exchange pool address is removed from the set of tracked pool addresses.\r\n    event ExchangePoolRemoved(address exchangePool);\r\n\r\n    /// @notice Emitted when the primary pool address is updated.\r\n    event PrimaryPoolUpdated(address oldPrimaryPool, address newPrimaryPool);\r\n\r\n    /**\r\n     * @notice Get list of addresses designated as exchange pools.\r\n     * @return An array of exchange pool addresses.\r\n     */\r\n    function getExchangePoolAddresses() external view returns (address[] memory) {\r\n        return _exchangePools.values();\r\n    }\r\n\r\n    /**\r\n     * @notice Add an address to the set of exchange pool addresses.\r\n     * @dev Nothing happens if the pool already exists in the set.\r\n     * @param exchangePool Address of exchange pool to add.\r\n     */\r\n    function addExchangePool(address exchangePool) external onlyOwner {\r\n        if (_exchangePools.add(exchangePool)) {\r\n            emit ExchangePoolAdded(exchangePool);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Remove an address from the set of exchange pool addresses.\r\n     * @dev Nothing happens if the pool doesn't exist in the set..\r\n     * @param exchangePool Address of exchange pool to remove.\r\n     */\r\n    function removeExchangePool(address exchangePool) external onlyOwner {\r\n        if (_exchangePools.remove(exchangePool)) {\r\n            emit ExchangePoolRemoved(exchangePool);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Set exchange pool address as primary pool.\r\n     * @dev To prevent issues, only addresses inside the set of exchange pool addresses can be selected as primary pool.\r\n     * @param exchangePool Address of exchange pool to set as primary pool.\r\n     */\r\n    function setPrimaryPool(address exchangePool) external onlyOwner {\r\n        require(\r\n            _exchangePools.contains(exchangePool),\r\n            \"ExchangePoolProcessor:setPrimaryPool:INVALID_POOL: Given address is not registered as exchange pool.\"\r\n        );\r\n        require(\r\n            primaryPool != exchangePool,\r\n            \"ExchangePoolProcessor:setPrimaryPool:ALREADY_SET: This address is already the primary pool address.\"\r\n        );\r\n\r\n        address oldPrimaryPool = primaryPool;\r\n        primaryPool = exchangePool;\r\n\r\n        emit PrimaryPoolUpdated(oldPrimaryPool, exchangePool);\r\n    }\r\n}\r\n"},"contracts/tax/DynamicTaxHandler.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\n\r\nimport \"./ITaxHandler.sol\";\r\nimport \"../utils/ExchangePoolProcessor.sol\";\r\n\r\n/**\r\n * @title Dynamic tax handler\r\n * @notice Processes tax for a given token transfer. Checks for the following:\r\n * - Is the address on the static blacklist? If so, it can only transfer to the\r\n *   `receiver` address. In all other cases, the transfer will fail.\r\n * - Is the address exempt from taxes, if so, the number of taxed tokens is\r\n *   always zero.\r\n * - Is it a transfer between \"regular\" users? This means they are not on the\r\n *   list of either blacklisted or exempt addresses, nor are they an address\r\n *   designated as an exchange pool.\r\n * - Is it a transfer towards or from an exchange pool? If so, the transaction\r\n *   is taxed according to its relative size to the exchange pool.\r\n */\r\ncontract DynamicTaxHandler is ITaxHandler, ExchangePoolProcessor {\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    struct TaxCheckpoint {\r\n        uint256 threshold;\r\n        uint256 basisPoints;\r\n    }\r\n\r\n    /// @notice The default buy tax in basis points.\r\n    uint256 public baseBuyTaxBasisPoints;\r\n\r\n    /// @notice The default sell tax in basis points.\r\n    uint256 public baseSellTaxBasisPoints;\r\n\r\n    /// @dev The registry of buy tax checkpoints. Used to keep track of the\r\n    /// correct number of tokens to deduct as tax when buying.\r\n    mapping(uint256 => TaxCheckpoint) private _buyTaxBasisPoints;\r\n\r\n    /// @dev The number of buy tax checkpoints in the registry.\r\n    uint256 private _buyTaxPoints;\r\n\r\n    /// @dev The registry of sell tax checkpoints. Used to keep track of the\r\n    /// correct number of tokens to deduct as tax when selling.\r\n    mapping(uint256 => TaxCheckpoint) private _sellTaxBasisPoints;\r\n\r\n    /// @dev The number of sell tax checkpoints in the registry.\r\n    uint256 private _sellTaxPoints;\r\n\r\n    /// @notice Registry of blacklisted addresses.\r\n    mapping (address => bool) public isBlacklisted;\r\n\r\n    /// @notice The only address the blacklisted addresses can still transfer tokens to.\r\n    address public immutable receiver;\r\n\r\n    /// @dev The set of addresses exempt from tax.\r\n    EnumerableSet.AddressSet private _exempted;\r\n\r\n    /// @notice The token to account for.\r\n    IERC20 public token;\r\n\r\n    /// @notice Emitted whenever the base buy tax basis points value is changed.\r\n    event BaseBuyTaxBasisPointsChanged(uint256 previousValue, uint256 newValue);\r\n\r\n    /// @notice Emitted whenever the base sell tax basis points value is changed.\r\n    event BaseSellTaxBasisPointsChanged(uint256 previousValue, uint256 newValue);\r\n\r\n    /// @notice Emitted whenever a buy tax checkpoint is added.\r\n    event BuyTaxCheckpointAdded(uint256 threshold, uint256 basisPoints);\r\n\r\n    /// @notice Emitted whenever a buy tax checkpoint is removed.\r\n    event BuyTaxCheckpointRemoved(uint256 threshold, uint256 basisPoints);\r\n\r\n    /// @notice Emitted whenever a sell tax checkpoint is added.\r\n    event SellTaxCheckpointAdded(uint256 threshold, uint256 basisPoints);\r\n\r\n    /// @notice Emitted whenever a sell tax checkpoint is removed.\r\n    event SellTaxCheckpointRemoved(uint256 threshold, uint256 basisPoints);\r\n\r\n    /// @notice Emitted when an address is added to or removed from the exempted addresses set.\r\n    event TaxExemptionUpdated(address indexed wallet, bool exempted);\r\n\r\n    /**\r\n     * @param tokenAddress Address of the token to account for when interacting\r\n     * with exchange pools.\r\n     * @param receiverAddress The only address the blacklisted addresses can\r\n     * send tokens to.\r\n     * @param blacklistedAddresses The list of addresses that are banned from\r\n     * performing transfers. They can still receive tokens however.\r\n     */\r\n    constructor(\r\n        address tokenAddress,\r\n        address receiverAddress,\r\n        address[] memory blacklistedAddresses\r\n    ) {\r\n        token = IERC20(tokenAddress);\r\n        receiver = receiverAddress;\r\n\r\n        for (uint256 i = 0; i < blacklistedAddresses.length; i++) {\r\n            isBlacklisted[blacklistedAddresses[i]] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get number of tokens to pay as tax.\r\n     * @dev There is no easy way to differentiate between a user swapping\r\n     * tokens and a user adding or removing liquidity to the pool. In both\r\n     * cases tokens are transferred to or from the pool. This is an unfortunate\r\n     * case where users have to accept being taxed on liquidity additions and\r\n     * removal. To get around this issue a separate liquidity addition contract\r\n     * can be deployed. This contract could be exempt from taxes if its\r\n     * functionality is verified to only add and remove liquidity.\r\n     * @param benefactor Address of the benefactor.\r\n     * @param beneficiary Address of the beneficiary.\r\n     * @param amount Number of tokens in the transfer.\r\n     * @return Number of tokens to pay as tax.\r\n     */\r\n    function getTax(\r\n        address benefactor,\r\n        address beneficiary,\r\n        uint256 amount\r\n    ) external view returns (uint256) {\r\n        // Blacklisted addresses are only allowed to transfer to the receiver.\r\n        if (isBlacklisted[benefactor]) {\r\n            if (beneficiary == receiver) {\r\n                return 0;\r\n            } else {\r\n                revert(\"DynamicTaxHandler:getTax:BLACKLISTED: Benefactor has been blacklisted\");\r\n            }\r\n        }\r\n\r\n        // Exempted addresses don't pay tax.\r\n        if (_exempted.contains(benefactor) || _exempted.contains(beneficiary)) {\r\n            return 0;\r\n        }\r\n\r\n        // Transactions between regular users (this includes contracts) aren't taxed.\r\n        if (!_exchangePools.contains(benefactor) && !_exchangePools.contains(beneficiary)) {\r\n            return 0;\r\n        }\r\n\r\n        // Transactions between pools aren't taxed.\r\n        if (_exchangePools.contains(benefactor) && _exchangePools.contains(beneficiary)) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 poolBalance = token.balanceOf(primaryPool);\r\n        uint256 basisPoints;\r\n\r\n        // If the benefactor is found in the set of exchange pools, then it's a buy transactions, otherwise a sell\r\n        // transactions, because the other use cases have already been checked above.\r\n        if (_exchangePools.contains(benefactor)) {\r\n            basisPoints = _getBuyTaxBasisPoints(amount, poolBalance);\r\n        } else {\r\n            basisPoints = _getSellTaxBasisPoints(amount, poolBalance);\r\n        }\r\n\r\n        return (amount * basisPoints) / 10000;\r\n    }\r\n\r\n    /**\r\n     * @notice Set buy tax basis points value.\r\n     * @param basisPoints The new buy tax basis points base value.\r\n     */\r\n    function setBaseBuyTaxBasisPoints(uint256 basisPoints) external onlyOwner {\r\n        uint256 previousBuyTaxBasisPoints = baseBuyTaxBasisPoints;\r\n        baseBuyTaxBasisPoints = basisPoints;\r\n\r\n        emit BaseBuyTaxBasisPointsChanged(previousBuyTaxBasisPoints, basisPoints);\r\n    }\r\n\r\n    /**\r\n     * @notice Set base sell tax basis points value.\r\n     * @param basisPoints The new sell tax basis points base value.\r\n     */\r\n    function setBaseSellTaxBasisPoints(uint256 basisPoints) external onlyOwner {\r\n        uint256 previousSellTaxBasisPoints = baseSellTaxBasisPoints;\r\n        baseSellTaxBasisPoints = basisPoints;\r\n\r\n        emit BaseSellTaxBasisPointsChanged(previousSellTaxBasisPoints, basisPoints);\r\n    }\r\n\r\n    /**\r\n     * @notice Set buy tax checkpoints\r\n     * @param thresholds Array containing the threshold values of the buy tax checkpoints.\r\n     * @param basisPoints Array containing the basis points values of the buy tax checkpoints.\r\n     */\r\n    function setBuyTaxCheckpoints(uint256[] memory thresholds, uint256[] memory basisPoints) external onlyOwner {\r\n        require(\r\n            thresholds.length == basisPoints.length,\r\n            \"DynamicTaxHandler:setBuyTaxBasisPoints:UNEQUAL_LENGTHS: Array lengths should be equal.\"\r\n        );\r\n\r\n        // Reset previous points\r\n        for (uint256 i = 0; i < _buyTaxPoints; i++) {\r\n            emit BuyTaxCheckpointRemoved(_buyTaxBasisPoints[i].threshold, _buyTaxBasisPoints[i].basisPoints);\r\n\r\n            _buyTaxBasisPoints[i].basisPoints = 0;\r\n            _buyTaxBasisPoints[i].threshold = 0;\r\n        }\r\n\r\n        _buyTaxPoints = thresholds.length;\r\n        for (uint256 i = 0; i < thresholds.length; i++) {\r\n            _buyTaxBasisPoints[i] = TaxCheckpoint({ basisPoints: basisPoints[i], threshold: thresholds[i] });\r\n\r\n            emit BuyTaxCheckpointAdded(_buyTaxBasisPoints[i].threshold, _buyTaxBasisPoints[i].basisPoints);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Set sell tax checkpoints\r\n     * @param thresholds Array containing the threshold values of the sell tax checkpoints.\r\n     * @param basisPoints Array containing the basis points values of the sell tax checkpoints.\r\n     */\r\n    function setSellTaxCheckpoints(uint256[] memory thresholds, uint256[] memory basisPoints) external onlyOwner {\r\n        require(\r\n            thresholds.length == basisPoints.length,\r\n            \"DynamicTaxHandler:setSellTaxBasisPoints:UNEQUAL_LENGTHS: Array lengths should be equal.\"\r\n        );\r\n\r\n        // Reset previous points\r\n        for (uint256 i = 0; i < _sellTaxPoints; i++) {\r\n            emit SellTaxCheckpointRemoved(_sellTaxBasisPoints[i].threshold, _sellTaxBasisPoints[i].basisPoints);\r\n\r\n            _sellTaxBasisPoints[i].basisPoints = 0;\r\n            _sellTaxBasisPoints[i].threshold = 0;\r\n        }\r\n\r\n        _sellTaxPoints = thresholds.length;\r\n        for (uint256 i = 0; i < thresholds.length; i++) {\r\n            _sellTaxBasisPoints[i] = TaxCheckpoint({ basisPoints: basisPoints[i], threshold: thresholds[i] });\r\n\r\n            emit SellTaxCheckpointAdded(_sellTaxBasisPoints[i].threshold, _sellTaxBasisPoints[i].basisPoints);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Add address to set of tax-exempted addresses.\r\n     * @param exemption Address to add to set of tax-exempted addresses.\r\n     */\r\n    function addExemption(address exemption) external onlyOwner {\r\n        if (_exempted.add(exemption)) {\r\n            emit TaxExemptionUpdated(exemption, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Remove address from set of tax-exempted addresses.\r\n     * @param exemption Address to remove from set of tax-exempted addresses.\r\n     */\r\n    function removeExemption(address exemption) external onlyOwner {\r\n        if (_exempted.remove(exemption)) {\r\n            emit TaxExemptionUpdated(exemption, false);\r\n        }\r\n    }\r\n\r\n    function _getBuyTaxBasisPoints(uint256 amount, uint256 poolBalance) private view returns (uint256 taxBasisPoints) {\r\n        taxBasisPoints = baseBuyTaxBasisPoints;\r\n        uint256 basisPoints = (amount * 10000) / poolBalance;\r\n\r\n        for (uint256 i = 0; i < _buyTaxPoints; i++) {\r\n            if (_buyTaxBasisPoints[i].threshold <= basisPoints) {\r\n                taxBasisPoints = _buyTaxBasisPoints[i].basisPoints;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _getSellTaxBasisPoints(uint256 amount, uint256 poolBalance) private view returns (uint256 taxBasisPoints) {\r\n        taxBasisPoints = baseSellTaxBasisPoints;\r\n        uint256 basisPoints = (amount * 10000) / poolBalance;\r\n\r\n        for (uint256 i = 0; i < _sellTaxPoints; i++) {\r\n            if (_sellTaxBasisPoints[i].threshold <= basisPoints) {\r\n                taxBasisPoints = _sellTaxBasisPoints[i].basisPoints;\r\n            }\r\n        }\r\n    }\r\n}\r\n"},"@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"@openzeppelin/contracts/utils/structs/EnumerableSet.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"}},"settings":{"libraries":{},"metadata":{"bytecodeHash":"none"},"optimizer":{"enabled":true,"runs":888},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}}},"ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiverAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"blacklistedAddresses\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"BaseBuyTaxBasisPointsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"BaseSellTaxBasisPointsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"basisPoints\",\"type\":\"uint256\"}],\"name\":\"BuyTaxCheckpointAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"basisPoints\",\"type\":\"uint256\"}],\"name\":\"BuyTaxCheckpointRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"exchangePool\",\"type\":\"address\"}],\"name\":\"ExchangePoolAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"exchangePool\",\"type\":\"address\"}],\"name\":\"ExchangePoolRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldPrimaryPool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newPrimaryPool\",\"type\":\"address\"}],\"name\":\"PrimaryPoolUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"basisPoints\",\"type\":\"uint256\"}],\"name\":\"SellTaxCheckpointAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"basisPoints\",\"type\":\"uint256\"}],\"name\":\"SellTaxCheckpointRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"exempted\",\"type\":\"bool\"}],\"name\":\"TaxExemptionUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchangePool\",\"type\":\"address\"}],\"name\":\"addExchangePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exemption\",\"type\":\"address\"}],\"name\":\"addExemption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseBuyTaxBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseSellTaxBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getExchangePoolAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"benefactor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"primaryPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchangePool\",\"type\":\"address\"}],\"name\":\"removeExchangePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exemption\",\"type\":\"address\"}],\"name\":\"removeExemption\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"basisPoints\",\"type\":\"uint256\"}],\"name\":\"setBaseBuyTaxBasisPoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"basisPoints\",\"type\":\"uint256\"}],\"name\":\"setBaseSellTaxBasisPoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"thresholds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"basisPoints\",\"type\":\"uint256[]\"}],\"name\":\"setBuyTaxCheckpoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchangePool\",\"type\":\"address\"}],\"name\":\"setPrimaryPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"thresholds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"basisPoints\",\"type\":\"uint256[]\"}],\"name\":\"setSellTaxCheckpoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"DynamicTaxHandler","CompilerVersion":"v0.8.11+commit.d7f03943","OptimizationUsed":1,"Runs":888,"ConstructorArguments":"0x000000000000000000000000cf0c122c6b73ff809c693db761e7baebe62b6a2e0000000000000000000000002b9d5c7f2ead1a221d771fb6bb5e35df04d60ab00000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000004f000000000000000000000000c566449675c2c2886c45261f68da919de078f6bc000000000000000000000000de5ad475057482fec82136e5e698ecd8b57615e9000000000000000000000000f681069fc9792a95a77b5ecba443a77d5d49df1f000000000000000000000000a6e2839e73e623ef3853a6bd28d6f02a127a43070000000000000000000000006eaa9db4ac9def1297365e1b79b965058f641f69000000000000000000000000b28a293278a51a1c42aeb0b1e5de080fd99c998b00000000000000000000000041a14a3905a6827964a1ed9359e686ef768e2996000000000000000000000000f81d4e193661af0cc52091d4d90271d800ca326d000000000000000000000000e139962e5d7b07a9378f159a4a1b7cabe9df1d6e000000000000000000000000b20bf6d7f60059dd5de46f3f0f32665a259ea6c0000000000000000000000000ca1f85ca6e502287c489d373938eb55c9b832c0f000000000000000000000000376a369146e71337943fd52e5d9d30ee8cd9e482000000000000000000000000cb30818397d781e05a8e04102fccdcb431d709c20000000000000000000000003c6288d1c8d1cdb9a08216347b394a2d9727b9c4000000000000000000000000256568c0f9079f5ae96add3d49517e6f13b7ea6c000000000000000000000000189bd808ba7284a4e875886330587021ea1886630000000000000000000000001d9b521c3c504dd7c3fb6ce906cd22830e3819e2000000000000000000000000c697be0b5b82284391a878b226e2f9afc6b947100000000000000000000000006ecd5e7a81dcbb37c86744110402b01d8e1f60440000000000000000000000003b31c4ae1dbd80dba70f45f29d289216810c07c7000000000000000000000000904441ebc002dba9a927b35baf55dc98e6b5c8c6000000000000000000000000aaefa74e6d545f3487beec39a3f78c49dd3ffb5d000000000000000000000000000759119ceaba5dc3d41c8a003c743f99f998470000000000000000000000001f30f1a1cde7b88b211ec3711f71a36c282b2b6c000000000000000000000000c17519a680ba2bbef1018c16cbc0fc34da5969ba000000000000000000000000dd4b68c06f62a7cebe791917c85b83a9573272b8000000000000000000000000a28602f18eb877b0b929caaae94faed4ff40292900000000000000000000000049d65ff0f419be0746a9ecf58d85c0e9dc170958000000000000000000000000b184af95391b0ed1d92652d39c0291e9e7cc90600000000000000000000000000d952e9b83c91e5bccdeefa15329d21071da5678000000000000000000000000defd15b2d7030909fd210a525f8158fd9e5b8bbb0000000000000000000000003301d3494478feb56bb6038edc7e55aa9ace25c40000000000000000000000006392b539f3dabfdd6dacf81e5786b981888927b6000000000000000000000000be23cbb62064b8b1550ae5ada59c39d45b1e2081000000000000000000000000124d9bf2fecbc16b54ec4accdb14d44c2144f012000000000000000000000000b85a8e652e10f9d9caf564f5c96ca4270091bc820000000000000000000000008271267cec8c994418776862d7ef30fb05d20ff10000000000000000000000009f144812058a1d9bff7baaeb4bf2e4286efa46ad0000000000000000000000008fad3e862c203ec9fc36832e9d0d13fe057a6ff100000000000000000000000040bb488401f104714478ed262f4ed177c24cbb82000000000000000000000000bdc8542fe776f8712afc70b2bd147fdd0115ad54000000000000000000000000c933ee4a90dc542b820ca674160922fb440b2ec4000000000000000000000000be496d6e541344d7bdb91055cdb5fc260c73d5a80000000000000000000000007acab48d2ecedd6bfd8e187f0ea520da76a04662000000000000000000000000698725516b6759a1511482846a0d27bc872e3906000000000000000000000000c1563bdf57bdb990c89070aa72cda57fe8d6913d000000000000000000000000495897ab1e68591be38f7882346bebb13fcfc6f8000000000000000000000000cd38dcd8d69cc69bd057a38960f5ed7f0d003cf800000000000000000000000055d79fa93e01bb5d24315cd4f17aa15c3f588dc7000000000000000000000000690c7f5b32bb7e38be41b0b0160799a2f8e7b0730000000000000000000000002efc41a2f72f85da7a9aa773d8b9d3a21c015c380000000000000000000000001a9472443a990bed5d03c1370de48f54d6a538cd00000000000000000000000055e09387cf083f558ec8e41ad29079f1f34a7346000000000000000000000000e3e4f084db6434d3030a6e8392c6e819ae7578e2000000000000000000000000a594c6ec7447eb4dc1aa9e7fc5cd692f2edf87ae0000000000000000000000005fc771d35b0615d79c76c04c2cbe8496472411800000000000000000000000003feb264a1d50c55a2aa30bbbb49d25fcc6016b2c00000000000000000000000086ca33d8b15ac2a7764e38ac57e7066202191d1e000000000000000000000000fafa5c581ce8dc4188179b9787f58d4e82285005000000000000000000000000bca844c6cf9e65897805a0630fc7895d5d9c244f000000000000000000000000abafa5438f3b39f5248fabf9103b082649f8288e000000000000000000000000edc0d61e5fcdc8949294df3f5c13497643be2b3e00000000000000000000000088baf72dd5539b3da71bfce86c486a6cf89836f50000000000000000000000001cb09ae8a2f720b723c8c67a3268a3c053f03e690000000000000000000000004d7724803b068b289a223ba3506661f0d44ea9570000000000000000000000005778bc9f6b80a05bddb43cf7ed3356d83a84043d000000000000000000000000e63a714a5fd70320f17c54f5ac5287579fb12b6f000000000000000000000000984a88e2695f30ecfab9ba5dff9df9915b435f3b0000000000000000000000005fc132b0a7027773da9d825728d1a2dc59137165000000000000000000000000d713fa41f57b42433b77c0de9a226639b66b3a59000000000000000000000000b8f9e33fe0a4a21e6e0f70d88d6904fe8137a7fe000000000000000000000000593f37f7fae9292fd615bcbe363b87c631ad80d20000000000000000000000005590577c62498f2e60ff82ae447a55b72d01a6d40000000000000000000000005fa8b510d3116547d9eb299859fc0c927c000a03000000000000000000000000ee011ab70b1f269b711c88f9d18ab306149ebcbb0000000000000000000000005c634603c58468a189c999c5ee7df5696fb319e10000000000000000000000008c3170b00b17015fde3123b5e84dd2d28acc3c05000000000000000000000000a9627c74264f081fe18b98786b46df06d8191a870000000000000000000000002f0c47a2217582b0744cdc51e32596b81c1e1531","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}