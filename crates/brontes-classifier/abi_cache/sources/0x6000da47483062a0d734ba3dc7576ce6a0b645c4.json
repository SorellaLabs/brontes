{"expiry":1699580670,"data":[{"SourceCode":{"language":"Solidity","sources":{"src/interfaces/IReactor.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {ResolvedOrder, SignedOrder} from \"../base/ReactorStructs.sol\";\nimport {IReactorCallback} from \"./IReactorCallback.sol\";\n\n/// @notice Interface for order execution reactors\ninterface IReactor {\n    /// @notice Execute a single order\n    /// @param order The order definition and valid signature to execute\n    function execute(SignedOrder calldata order) external payable;\n\n    /// @notice Execute a single order using the given callback data\n    /// @param order The order definition and valid signature to execute\n    function executeWithCallback(SignedOrder calldata order, bytes calldata callbackData) external payable;\n\n    /// @notice Execute the given orders at once\n    /// @param orders The order definitions and valid signatures to execute\n    function executeBatch(SignedOrder[] calldata orders) external payable;\n\n    /// @notice Execute the given orders at once using a callback with the given callback data\n    /// @param orders The order definitions and valid signatures to execute\n    /// @param callbackData The callbackData to pass to the callback\n    function executeBatchWithCallback(SignedOrder[] calldata orders, bytes calldata callbackData) external payable;\n}\n"},"lib/permit2/src/interfaces/ISignatureTransfer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title SignatureTransfer\n/// @notice Handles ERC20 token transfers through signature based actions\n/// @dev Requires user's token approval on the Permit2 contract\ninterface ISignatureTransfer is IEIP712 {\n    /// @notice Thrown when the requested amount for a transfer is larger than the permissioned amount\n    /// @param maxAmount The maximum amount a spender can request to transfer\n    error InvalidAmount(uint256 maxAmount);\n\n    /// @notice Thrown when the number of tokens permissioned to a spender does not match the number of tokens being transferred\n    /// @dev If the spender does not need to transfer the number of tokens permitted, the spender can request amount 0 to be transferred\n    error LengthMismatch();\n\n    /// @notice Emits an event when the owner successfully invalidates an unordered nonce.\n    event UnorderedNonceInvalidation(address indexed owner, uint256 word, uint256 mask);\n\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\n    struct TokenPermissions {\n        // ERC20 token address\n        address token;\n        // the maximum amount that can be spent\n        uint256 amount;\n    }\n\n    /// @notice The signed permit message for a single token transfer\n    struct PermitTransferFrom {\n        TokenPermissions permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice Specifies the recipient address and amount for batched transfers.\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\n    struct SignatureTransferDetails {\n        // recipient address\n        address to;\n        // spender requested amount\n        uint256 requestedAmount;\n    }\n\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\n    /// @dev Note that a user still signs over a spender address\n    struct PermitBatchTransferFrom {\n        // the tokens and corresponding amounts permitted for a transfer\n        TokenPermissions[] permitted;\n        // a unique value for every token owner's signature to prevent signature replays\n        uint256 nonce;\n        // deadline on the permit signature\n        uint256 deadline;\n    }\n\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\n    /// @dev It returns a uint256 bitmap\n    /// @dev The index, or wordPosition is capped at type(uint248).max\n    function nonceBitmap(address, uint256) external view returns (uint256);\n\n    /// @notice Transfers a token using a signed permit message\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers a token using a signed permit message\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails The spender's requested transfer details for the permitted token\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitTransferFrom memory permit,\n        SignatureTransferDetails calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param signature The signature to verify\n    function permitTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Transfers multiple tokens using a signed permit message\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\n    /// @notice Includes extra data provided by the caller to verify signature over\n    /// @param permit The permit data signed over by the owner\n    /// @param owner The owner of the tokens to transfer\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\n    /// @param witness Extra data to include when checking the user signature\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\n    /// @param signature The signature to verify\n    function permitWitnessTransferFrom(\n        PermitBatchTransferFrom memory permit,\n        SignatureTransferDetails[] calldata transferDetails,\n        address owner,\n        bytes32 witness,\n        string calldata witnessTypeString,\n        bytes calldata signature\n    ) external;\n\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\n    /// @dev The wordPos is maxed at type(uint248).max\n    /// @param wordPos A number to index the nonceBitmap at\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\n}\n"},"lib/solmate/src/utils/SafeTransferLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Append and mask the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument. Masking not required as it's a full 32 byte type.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"},"src/reactors/BaseReactor.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {SafeTransferLib} from \"solmate/src/utils/SafeTransferLib.sol\";\nimport {ReentrancyGuard} from \"openzeppelin-contracts/security/ReentrancyGuard.sol\";\nimport {IPermit2} from \"permit2/src/interfaces/IPermit2.sol\";\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {ReactorEvents} from \"../base/ReactorEvents.sol\";\nimport {ResolvedOrderLib} from \"../lib/ResolvedOrderLib.sol\";\nimport {CurrencyLibrary, NATIVE} from \"../lib/CurrencyLibrary.sol\";\nimport {IReactorCallback} from \"../interfaces/IReactorCallback.sol\";\nimport {IReactor} from \"../interfaces/IReactor.sol\";\nimport {ProtocolFees} from \"../base/ProtocolFees.sol\";\nimport {SignedOrder, ResolvedOrder, OutputToken} from \"../base/ReactorStructs.sol\";\n\n/// @notice Generic reactor logic for settling off-chain signed orders\n///     using arbitrary fill methods specified by a filler\nabstract contract BaseReactor is IReactor, ReactorEvents, ProtocolFees, ReentrancyGuard {\n    using SafeTransferLib for ERC20;\n    using ResolvedOrderLib for ResolvedOrder;\n    using CurrencyLibrary for address;\n\n    // Occurs when an output = ETH and the reactor does contain enough ETH but\n    // the direct filler did not include enough ETH in their call to execute/executeBatch\n    error InsufficientEth();\n\n    /// @notice permit2 address used for token transfers and signature verification\n    IPermit2 public immutable permit2;\n\n    constructor(IPermit2 _permit2, address _protocolFeeOwner) ProtocolFees(_protocolFeeOwner) {\n        permit2 = _permit2;\n    }\n\n    /// @inheritdoc IReactor\n    function execute(SignedOrder calldata order) external payable override nonReentrant {\n        ResolvedOrder[] memory resolvedOrders = new ResolvedOrder[](1);\n        resolvedOrders[0] = resolve(order);\n\n        _prepare(resolvedOrders);\n        _fill(resolvedOrders);\n    }\n\n    /// @inheritdoc IReactor\n    function executeWithCallback(SignedOrder calldata order, bytes calldata callbackData)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        ResolvedOrder[] memory resolvedOrders = new ResolvedOrder[](1);\n        resolvedOrders[0] = resolve(order);\n\n        _prepare(resolvedOrders);\n        IReactorCallback(msg.sender).reactorCallback(resolvedOrders, callbackData);\n        _fill(resolvedOrders);\n    }\n\n    /// @inheritdoc IReactor\n    function executeBatch(SignedOrder[] calldata orders) external payable override nonReentrant {\n        uint256 ordersLength = orders.length;\n        ResolvedOrder[] memory resolvedOrders = new ResolvedOrder[](ordersLength);\n\n        unchecked {\n            for (uint256 i = 0; i < ordersLength; i++) {\n                resolvedOrders[i] = resolve(orders[i]);\n            }\n        }\n\n        _prepare(resolvedOrders);\n        _fill(resolvedOrders);\n    }\n\n    /// @inheritdoc IReactor\n    function executeBatchWithCallback(SignedOrder[] calldata orders, bytes calldata callbackData)\n        external\n        payable\n        override\n        nonReentrant\n    {\n        uint256 ordersLength = orders.length;\n        ResolvedOrder[] memory resolvedOrders = new ResolvedOrder[](ordersLength);\n\n        unchecked {\n            for (uint256 i = 0; i < ordersLength; i++) {\n                resolvedOrders[i] = resolve(orders[i]);\n            }\n        }\n\n        _prepare(resolvedOrders);\n        IReactorCallback(msg.sender).reactorCallback(resolvedOrders, callbackData);\n        _fill(resolvedOrders);\n    }\n\n    /// @notice validates, injects fees, and transfers input tokens in preparation for order fill\n    /// @param orders The orders to prepare\n    function _prepare(ResolvedOrder[] memory orders) internal {\n        uint256 ordersLength = orders.length;\n        unchecked {\n            for (uint256 i = 0; i < ordersLength; i++) {\n                ResolvedOrder memory order = orders[i];\n                _injectFees(order);\n                order.validate(msg.sender);\n                transferInputTokens(order, msg.sender);\n            }\n        }\n    }\n\n    /// @notice fills a list of orders, ensuring all outputs are satisfied\n    /// @param orders The orders to fill\n    function _fill(ResolvedOrder[] memory orders) internal {\n        uint256 ordersLength = orders.length;\n        // attempt to transfer all currencies to all recipients\n        unchecked {\n            // transfer output tokens to their respective recipients\n            for (uint256 i = 0; i < ordersLength; i++) {\n                ResolvedOrder memory resolvedOrder = orders[i];\n                uint256 outputsLength = resolvedOrder.outputs.length;\n                for (uint256 j = 0; j < outputsLength; j++) {\n                    OutputToken memory output = resolvedOrder.outputs[j];\n                    output.token.transferFill(output.recipient, output.amount);\n                }\n\n                emit Fill(orders[i].hash, msg.sender, resolvedOrder.info.swapper, resolvedOrder.info.nonce);\n            }\n        }\n\n        // refund any remaining ETH to the filler. Only occurs when filler sends more ETH than required to\n        // `execute()` or `executeBatch()`, or when there is excess contract balance remaining from others\n        // incorrectly calling execute/executeBatch without direct filler method but with a msg.value\n        if (address(this).balance > 0) {\n            CurrencyLibrary.transferNative(msg.sender, address(this).balance);\n        }\n    }\n\n    receive() external payable {\n        // receive native asset to support native output\n    }\n\n    /// @notice Resolve order-type specific requirements into a generic order with the final inputs and outputs.\n    /// @param order The encoded order to resolve\n    /// @return resolvedOrder generic resolved order of inputs and outputs\n    /// @dev should revert on any order-type-specific validation errors\n    function resolve(SignedOrder calldata order) internal view virtual returns (ResolvedOrder memory resolvedOrder);\n\n    /// @notice Transfers tokens to the fillContract\n    /// @param order The encoded order to transfer tokens for\n    /// @param to The address to transfer tokens to\n    function transferInputTokens(ResolvedOrder memory order, address to) internal virtual;\n}\n"},"src/base/ReactorEvents.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\n/// @notice standardized events that should be emitted by all reactors\n/// @dev collated into one library to help with forge expectEmit integration\n/// @dev and for reactors which dont use base\ninterface ReactorEvents {\n    /// @notice emitted when an order is filled\n    /// @param orderHash The hash of the order that was filled\n    /// @param filler The address which executed the fill\n    /// @param nonce The nonce of the filled order\n    /// @param swapper The swapper of the filled order\n    event Fill(bytes32 indexed orderHash, address indexed filler, address indexed swapper, uint256 nonce);\n}\n"},"src/lib/ResolvedOrderLib.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {ResolvedOrder} from \"../base/ReactorStructs.sol\";\nimport {IValidationCallback} from \"../interfaces/IValidationCallback.sol\";\n\nlibrary ResolvedOrderLib {\n    /// @notice thrown when the order targets a different reactor\n    error InvalidReactor();\n\n    /// @notice thrown if the order has expired\n    error DeadlinePassed();\n\n    /// @notice Validates a resolved order, reverting if invalid\n    /// @param filler The filler of the order\n    function validate(ResolvedOrder memory resolvedOrder, address filler) internal view {\n        if (address(this) != address(resolvedOrder.info.reactor)) {\n            revert InvalidReactor();\n        }\n\n        if (block.timestamp > resolvedOrder.info.deadline) {\n            revert DeadlinePassed();\n        }\n\n        if (address(resolvedOrder.info.additionalValidationContract) != address(0)) {\n            resolvedOrder.info.additionalValidationContract.validate(filler, resolvedOrder);\n        }\n    }\n}\n"},"lib/solmate/src/utils/FixedPointMathLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    SIMPLIFIED FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal constant MAX_UINT256 = 2**256 - 1;\n\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\n    }\n\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\n    }\n\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\n    }\n\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // Divide x * y by the denominator.\n            z := div(mul(x, y), denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to require(denominator != 0 && (y == 0 || x <= type(uint256).max / y))\n            if iszero(mul(denominator, iszero(mul(y, gt(x, div(MAX_UINT256, y)))))) {\n                revert(0, 0)\n            }\n\n            // If x * y modulo the denominator is strictly greater than 0,\n            // 1 is added to round up the division of x * y by the denominator.\n            z := add(gt(mod(mul(x, y), denominator), 0), div(mul(x, y), denominator))\n        }\n    }\n\n    function rpow(\n        uint256 x,\n        uint256 n,\n        uint256 scalar\n    ) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            switch x\n            case 0 {\n                switch n\n                case 0 {\n                    // 0 ** 0 = 1\n                    z := scalar\n                }\n                default {\n                    // 0 ** n = 0\n                    z := 0\n                }\n            }\n            default {\n                switch mod(n, 2)\n                case 0 {\n                    // If n is even, store scalar in z for now.\n                    z := scalar\n                }\n                default {\n                    // If n is odd, store x in z for now.\n                    z := x\n                }\n\n                // Shifting right by 1 is like dividing by 2.\n                let half := shr(1, scalar)\n\n                for {\n                    // Shift n right by 1 before looping to halve it.\n                    n := shr(1, n)\n                } n {\n                    // Shift n right by 1 each iteration to halve it.\n                    n := shr(1, n)\n                } {\n                    // Revert immediately if x ** 2 would overflow.\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\n                    if shr(128, x) {\n                        revert(0, 0)\n                    }\n\n                    // Store x squared.\n                    let xx := mul(x, x)\n\n                    // Round to the nearest number.\n                    let xxRound := add(xx, half)\n\n                    // Revert if xx + half overflowed.\n                    if lt(xxRound, xx) {\n                        revert(0, 0)\n                    }\n\n                    // Set x to scaled xxRound.\n                    x := div(xxRound, scalar)\n\n                    // If n is even:\n                    if mod(n, 2) {\n                        // Compute z * x.\n                        let zx := mul(z, x)\n\n                        // If z * x overflowed:\n                        if iszero(eq(div(zx, x), z)) {\n                            // Revert if x is non-zero.\n                            if iszero(iszero(x)) {\n                                revert(0, 0)\n                            }\n                        }\n\n                        // Round to the nearest number.\n                        let zxRound := add(zx, half)\n\n                        // Revert if zx + half overflowed.\n                        if lt(zxRound, zx) {\n                            revert(0, 0)\n                        }\n\n                        // Return properly scaled zxRound.\n                        z := div(zxRound, scalar)\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        GENERAL NUMBER UTILITIES\n    //////////////////////////////////////////////////////////////*/\n\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let y := x // We start y at x, which will help us make our initial estimate.\n\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // We check y >= 2^(k + 8) but shift right by k bits\n            // each branch to ensure that if x >= 256, then y >= 256.\n            if iszero(lt(y, 0x10000000000000000000000000000000000)) {\n                y := shr(128, y)\n                z := shl(64, z)\n            }\n            if iszero(lt(y, 0x1000000000000000000)) {\n                y := shr(64, y)\n                z := shl(32, z)\n            }\n            if iszero(lt(y, 0x10000000000)) {\n                y := shr(32, y)\n                z := shl(16, z)\n            }\n            if iszero(lt(y, 0x1000000)) {\n                y := shr(16, y)\n                z := shl(8, z)\n            }\n\n            // Goal was to get z*z*y within a small factor of x. More iterations could\n            // get y in a tighter range. Currently, we will have y in [256, 256*2^16).\n            // We ensured y >= 256 so that the relative difference between y and y+1 is small.\n            // That's not possible if x < 256 but we can just verify those cases exhaustively.\n\n            // Now, z*z*y <= x < z*z*(y+1), and y <= 2^(16+8), and either y >= 256, or x < 256.\n            // Correctness can be checked exhaustively for x < 256, so we assume y >= 256.\n            // Then z*sqrt(y) is within sqrt(257)/sqrt(256) of sqrt(x), or about 20bps.\n\n            // For s in the range [1/256, 256], the estimate f(s) = (181/1024) * (s+1) is in the range\n            // (1/2.84 * sqrt(s), 2.84 * sqrt(s)), with largest error when s = 1 and when s = 256 or 1/256.\n\n            // Since y is in [256, 256*2^16), let a = y/65536, so that a is in [1/256, 256). Then we can estimate\n            // sqrt(y) using sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2^18.\n\n            // There is no overflow risk here since y < 2^136 after the first branch above.\n            z := shr(18, mul(z, add(y, 65536))) // A mul() is saved from starting z at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If x+1 is a perfect square, the Babylonian method cycles between\n            // floor(sqrt(x)) and ceil(sqrt(x)). This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\n            z := sub(z, lt(div(x, z), z))\n        }\n    }\n\n    function unsafeMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Mod x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            z := mod(x, y)\n        }\n    }\n\n    function unsafeDiv(uint256 x, uint256 y) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Divide x by y. Note this will return\n            // 0 instead of reverting if y is zero.\n            r := div(x, y)\n        }\n    }\n\n    function unsafeDivUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Add 1 to x * y if x % y > 0. Note this will\n            // return 0 instead of reverting if y is zero.\n            z := add(gt(mod(x, y), 0), div(x, y))\n        }\n    }\n}\n"},"src/lib/DutchOrderLib.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {OrderInfo} from \"../base/ReactorStructs.sol\";\nimport {OrderInfoLib} from \"./OrderInfoLib.sol\";\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\n\n/// @dev An amount of output tokens that decreases linearly over time\nstruct DutchOutput {\n    // The ERC20 token address (or native ETH address)\n    address token;\n    // The amount of tokens at the start of the time period\n    uint256 startAmount;\n    // The amount of tokens at the end of the time period\n    uint256 endAmount;\n    // The address who must receive the tokens to satisfy the order\n    address recipient;\n}\n\n/// @dev An amount of input tokens that increases linearly over time\nstruct DutchInput {\n    // The ERC20 token address\n    ERC20 token;\n    // The amount of tokens at the start of the time period\n    uint256 startAmount;\n    // The amount of tokens at the end of the time period\n    uint256 endAmount;\n}\n\nstruct DutchOrder {\n    // generic order information\n    OrderInfo info;\n    // The time at which the DutchOutputs start decaying\n    uint256 decayStartTime;\n    // The time at which price becomes static\n    uint256 decayEndTime;\n    // The tokens that the swapper will provide when settling the order\n    DutchInput input;\n    // The tokens that must be received to satisfy the order\n    DutchOutput[] outputs;\n}\n\n/// @notice helpers for handling dutch order objects\nlibrary DutchOrderLib {\n    using OrderInfoLib for OrderInfo;\n\n    bytes internal constant DUTCH_OUTPUT_TYPE =\n        \"DutchOutput(address token,uint256 startAmount,uint256 endAmount,address recipient)\";\n    bytes32 internal constant DUTCH_OUTPUT_TYPE_HASH = keccak256(DUTCH_OUTPUT_TYPE);\n\n    bytes internal constant DUTCH_LIMIT_ORDER_TYPE = abi.encodePacked(\n        \"DutchOrder(\",\n        \"OrderInfo info,\",\n        \"uint256 decayStartTime,\",\n        \"uint256 decayEndTime,\",\n        \"address inputToken,\",\n        \"uint256 inputStartAmount,\",\n        \"uint256 inputEndAmount,\",\n        \"DutchOutput[] outputs)\"\n    );\n\n    /// @dev Note that sub-structs have to be defined in alphabetical order in the EIP-712 spec\n    bytes internal constant ORDER_TYPE =\n        abi.encodePacked(DUTCH_LIMIT_ORDER_TYPE, DUTCH_OUTPUT_TYPE, OrderInfoLib.ORDER_INFO_TYPE);\n    bytes32 internal constant ORDER_TYPE_HASH = keccak256(ORDER_TYPE);\n\n    string internal constant TOKEN_PERMISSIONS_TYPE = \"TokenPermissions(address token,uint256 amount)\";\n    string internal constant PERMIT2_ORDER_TYPE =\n        string(abi.encodePacked(\"DutchOrder witness)\", ORDER_TYPE, TOKEN_PERMISSIONS_TYPE));\n\n    /// @notice hash the given output\n    /// @param output the output to hash\n    /// @return the eip-712 output hash\n    function hash(DutchOutput memory output) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(DUTCH_OUTPUT_TYPE_HASH, output.token, output.startAmount, output.endAmount, output.recipient)\n        );\n    }\n\n    /// @notice hash the given outputs\n    /// @param outputs the outputs to hash\n    /// @return the eip-712 outputs hash\n    function hash(DutchOutput[] memory outputs) internal pure returns (bytes32) {\n        unchecked {\n            bytes memory packedHashes = new bytes(32 * outputs.length);\n\n            for (uint256 i = 0; i < outputs.length; i++) {\n                bytes32 outputHash = hash(outputs[i]);\n                assembly {\n                    mstore(add(add(packedHashes, 0x20), mul(i, 0x20)), outputHash)\n                }\n            }\n\n            return keccak256(packedHashes);\n        }\n    }\n\n    /// @notice hash the given order\n    /// @param order the order to hash\n    /// @return the eip-712 order hash\n    function hash(DutchOrder memory order) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                ORDER_TYPE_HASH,\n                order.info.hash(),\n                order.decayStartTime,\n                order.decayEndTime,\n                order.input.token,\n                order.input.startAmount,\n                order.input.endAmount,\n                hash(order.outputs)\n            )\n        );\n    }\n}\n"},"src/interfaces/IValidationCallback.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {OrderInfo, ResolvedOrder} from \"../base/ReactorStructs.sol\";\n\n/// @notice Callback to validate an order\ninterface IValidationCallback {\n    /// @notice Called by the reactor for custom validation of an order. Will revert if validation fails\n    /// @param filler The filler of the order\n    /// @param resolvedOrder The resolved order to fill\n    function validate(address filler, ResolvedOrder calldata resolvedOrder) external view;\n}\n"},"lib/openzeppelin-contracts/contracts/utils/math/SafeCast.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"},"src/lib/Permit2Lib.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {ISignatureTransfer} from \"permit2/src/interfaces/ISignatureTransfer.sol\";\nimport {ResolvedOrder} from \"../base/ReactorStructs.sol\";\n\n/// @notice handling some permit2-specific encoding\nlibrary Permit2Lib {\n    /// @notice returns a ResolvedOrder into a permit object\n    function toPermit(ResolvedOrder memory order)\n        internal\n        pure\n        returns (ISignatureTransfer.PermitTransferFrom memory)\n    {\n        return ISignatureTransfer.PermitTransferFrom({\n            permitted: ISignatureTransfer.TokenPermissions({\n                token: address(order.input.token),\n                amount: order.input.maxAmount\n            }),\n            nonce: order.info.nonce,\n            deadline: order.info.deadline\n        });\n    }\n\n    /// @notice returns a ResolvedOrder into a permit object\n    function transferDetails(ResolvedOrder memory order, address to)\n        internal\n        pure\n        returns (ISignatureTransfer.SignatureTransferDetails memory)\n    {\n        return ISignatureTransfer.SignatureTransferDetails({to: to, requestedAmount: order.input.amount});\n    }\n}\n"},"lib/permit2/src/interfaces/IPermit2.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ISignatureTransfer} from \"./ISignatureTransfer.sol\";\nimport {IAllowanceTransfer} from \"./IAllowanceTransfer.sol\";\n\n/// @notice Permit2 handles signature-based transfers in SignatureTransfer and allowance-based transfers in AllowanceTransfer.\n/// @dev Users must approve Permit2 before calling any of the transfer functions.\ninterface IPermit2 is ISignatureTransfer, IAllowanceTransfer {\n// IPermit2 unifies the two interfaces so users have maximal flexibility with their approval.\n}\n"},"src/base/ProtocolFees.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {Owned} from \"solmate/src/auth/Owned.sol\";\nimport {SafeTransferLib} from \"solmate/src/utils/SafeTransferLib.sol\";\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {IProtocolFeeController} from \"../interfaces/IProtocolFeeController.sol\";\nimport {CurrencyLibrary} from \"../lib/CurrencyLibrary.sol\";\nimport {ResolvedOrder, OutputToken} from \"../base/ReactorStructs.sol\";\n\n/// @notice Handling for protocol fees\nabstract contract ProtocolFees is Owned {\n    using SafeTransferLib for ERC20;\n    using FixedPointMathLib for uint256;\n    using CurrencyLibrary for address;\n\n    /// @notice thrown if two fee outputs have the same token\n    error DuplicateFeeOutput(address duplicateToken);\n    /// @notice thrown if a given fee output is greater than MAX_FEE_BPS of the order outputs\n    error FeeTooLarge(address token, uint256 amount, address recipient);\n    /// @notice thrown if a fee output token does not have a corresponding non-fee output\n    error InvalidFeeToken(address feeToken);\n\n    event ProtocolFeeControllerSet(address oldFeeController, address newFeeController);\n\n    uint256 private constant BPS = 10_000;\n    uint256 private constant MAX_FEE_BPS = 5;\n\n    /// @dev The address of the fee controller\n    IProtocolFeeController public feeController;\n\n    // @notice Required to customize owner from constructor of BaseReactor.sol\n    constructor(address _owner) Owned(_owner) {}\n\n    /// @notice Injects fees into an order\n    /// @dev modifies the orders to include protocol fee outputs\n    /// @param order The encoded order to inject fees into\n    function _injectFees(ResolvedOrder memory order) internal view {\n        if (address(feeController) == address(0)) {\n            return;\n        }\n\n        OutputToken[] memory feeOutputs = feeController.getFeeOutputs(order);\n        uint256 outputsLength = order.outputs.length;\n        uint256 feeOutputsLength = feeOutputs.length;\n\n        // apply fee outputs\n        // fill new outputs with old outputs\n        OutputToken[] memory newOutputs = new OutputToken[](\n            outputsLength + feeOutputsLength\n        );\n\n        unchecked {\n            for (uint256 i = 0; i < outputsLength; i++) {\n                newOutputs[i] = order.outputs[i];\n            }\n        }\n\n        for (uint256 i = 0; i < feeOutputsLength;) {\n            OutputToken memory feeOutput = feeOutputs[i];\n            // assert no duplicates\n            unchecked {\n                for (uint256 j = 0; j < i; j++) {\n                    if (feeOutput.token == feeOutputs[j].token) {\n                        revert DuplicateFeeOutput(feeOutput.token);\n                    }\n                }\n            }\n\n            // assert not greater than MAX_FEE_BPS\n            uint256 tokenValue;\n            for (uint256 j = 0; j < outputsLength;) {\n                OutputToken memory output = order.outputs[j];\n                if (output.token == feeOutput.token) {\n                    tokenValue += output.amount;\n                }\n                unchecked {\n                    j++;\n                }\n            }\n\n            // allow fee on input token as well\n            if (address(order.input.token) == feeOutput.token) {\n                tokenValue += order.input.amount;\n            }\n\n            if (tokenValue == 0) revert InvalidFeeToken(feeOutput.token);\n\n            if (feeOutput.amount > tokenValue.mulDivDown(MAX_FEE_BPS, BPS)) {\n                revert FeeTooLarge(feeOutput.token, feeOutput.amount, feeOutput.recipient);\n            }\n            newOutputs[outputsLength + i] = feeOutput;\n\n            unchecked {\n                i++;\n            }\n        }\n\n        order.outputs = newOutputs;\n    }\n\n    /// @notice sets the protocol fee controller\n    /// @dev only callable by the owner\n    /// @param _newFeeController the new fee controller\n    function setProtocolFeeController(address _newFeeController) external onlyOwner {\n        address oldFeeController = address(feeController);\n        feeController = IProtocolFeeController(_newFeeController);\n        emit ProtocolFeeControllerSet(oldFeeController, _newFeeController);\n    }\n}\n"},"lib/permit2/src/interfaces/IEIP712.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\ninterface IEIP712 {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"},"src/base/ReactorStructs.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {IReactor} from \"../interfaces/IReactor.sol\";\nimport {IValidationCallback} from \"../interfaces/IValidationCallback.sol\";\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\n\n/// @dev generic order information\n///  should be included as the first field in any concrete order types\nstruct OrderInfo {\n    // The address of the reactor that this order is targeting\n    // Note that this must be included in every order so the swapper\n    // signature commits to the specific reactor that they trust to fill their order properly\n    IReactor reactor;\n    // The address of the user which created the order\n    // Note that this must be included so that order hashes are unique by swapper\n    address swapper;\n    // The nonce of the order, allowing for signature replay protection and cancellation\n    uint256 nonce;\n    // The timestamp after which this order is no longer valid\n    uint256 deadline;\n    // Custom validation contract\n    IValidationCallback additionalValidationContract;\n    // Encoded validation params for additionalValidationContract\n    bytes additionalValidationData;\n}\n\n/// @dev tokens that need to be sent from the swapper in order to satisfy an order\nstruct InputToken {\n    ERC20 token;\n    uint256 amount;\n    // Needed for dutch decaying inputs\n    uint256 maxAmount;\n}\n\n/// @dev tokens that need to be received by the recipient in order to satisfy an order\nstruct OutputToken {\n    address token;\n    uint256 amount;\n    address recipient;\n}\n\n/// @dev generic concrete order that specifies exact tokens which need to be sent and received\nstruct ResolvedOrder {\n    OrderInfo info;\n    InputToken input;\n    OutputToken[] outputs;\n    bytes sig;\n    bytes32 hash;\n}\n\n/// @dev external struct including a generic encoded order and swapper signature\n///  The order bytes will be parsed and mapped to a ResolvedOrder in the concrete reactor contract\nstruct SignedOrder {\n    bytes order;\n    bytes sig;\n}\n"},"lib/permit2/src/interfaces/IAllowanceTransfer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {IEIP712} from \"./IEIP712.sol\";\n\n/// @title AllowanceTransfer\n/// @notice Handles ERC20 token permissions through signature based allowance setting and ERC20 token transfers by checking allowed amounts\n/// @dev Requires user's token approval on the Permit2 contract\ninterface IAllowanceTransfer is IEIP712 {\n    /// @notice Thrown when an allowance on a token has expired.\n    /// @param deadline The timestamp at which the allowed amount is no longer valid\n    error AllowanceExpired(uint256 deadline);\n\n    /// @notice Thrown when an allowance on a token has been depleted.\n    /// @param amount The maximum amount allowed\n    error InsufficientAllowance(uint256 amount);\n\n    /// @notice Thrown when too many nonces are invalidated.\n    error ExcessiveInvalidation();\n\n    /// @notice Emits an event when the owner successfully invalidates an ordered nonce.\n    event NonceInvalidation(\n        address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions on a token for the spender.\n    event Approval(\n        address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration\n    );\n\n    /// @notice Emits an event when the owner successfully sets permissions using a permit signature on a token for the spender.\n    event Permit(\n        address indexed owner,\n        address indexed token,\n        address indexed spender,\n        uint160 amount,\n        uint48 expiration,\n        uint48 nonce\n    );\n\n    /// @notice Emits an event when the owner sets the allowance back to 0 with the lockdown function.\n    event Lockdown(address indexed owner, address token, address spender);\n\n    /// @notice The permit data for a token\n    struct PermitDetails {\n        // ERC20 token address\n        address token;\n        // the maximum amount allowed to spend\n        uint160 amount;\n        // timestamp at which a spender's token allowances become invalid\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice The permit message signed for a single token allownce\n    struct PermitSingle {\n        // the permit data for a single token alownce\n        PermitDetails details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The permit message signed for multiple token allowances\n    struct PermitBatch {\n        // the permit data for multiple token allowances\n        PermitDetails[] details;\n        // address permissioned on the allowed tokens\n        address spender;\n        // deadline on the permit signature\n        uint256 sigDeadline;\n    }\n\n    /// @notice The saved permissions\n    /// @dev This info is saved per owner, per token, per spender and all signed over in the permit message\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    struct PackedAllowance {\n        // amount allowed\n        uint160 amount;\n        // permission expiry\n        uint48 expiration;\n        // an incrementing value indexed per owner,token,and spender for each signature\n        uint48 nonce;\n    }\n\n    /// @notice A token spender pair.\n    struct TokenSpenderPair {\n        // the token the spender is approved\n        address token;\n        // the spender address\n        address spender;\n    }\n\n    /// @notice Details for a token transfer.\n    struct AllowanceTransferDetails {\n        // the owner of the token\n        address from;\n        // the recipient of the token\n        address to;\n        // the amount of the token\n        uint160 amount;\n        // the token to be transferred\n        address token;\n    }\n\n    /// @notice A mapping from owner address to token address to spender address to PackedAllowance struct, which contains details and conditions of the approval.\n    /// @notice The mapping is indexed in the above order see: allowance[ownerAddress][tokenAddress][spenderAddress]\n    /// @dev The packed slot holds the allowed amount, expiration at which the allowed amount is no longer valid, and current nonce thats updated on any signature based approvals.\n    function allowance(address user, address token, address spender)\n        external\n        view\n        returns (uint160 amount, uint48 expiration, uint48 nonce);\n\n    /// @notice Approves the spender to use up to amount of the specified token up until the expiration\n    /// @param token The token to approve\n    /// @param spender The spender address to approve\n    /// @param amount The approved amount of the token\n    /// @param expiration The timestamp at which the approval is no longer valid\n    /// @dev The packed allowance also holds a nonce, which will stay unchanged in approve\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\n\n    /// @notice Permit a spender to a given amount of the owners token via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitSingle Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\n\n    /// @notice Permit a spender to the signed amounts of the owners tokens via the owner's EIP-712 signature\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\n    /// @param owner The owner of the tokens being approved\n    /// @param permitBatch Data signed over by the owner specifying the terms of approval\n    /// @param signature The owner's signature over the permit data\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\n\n    /// @notice Transfer approved tokens from one address to another\n    /// @param from The address to transfer from\n    /// @param to The address of the recipient\n    /// @param amount The amount of the token to transfer\n    /// @param token The token address to transfer\n    /// @dev Requires the from address to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(address from, address to, uint160 amount, address token) external;\n\n    /// @notice Transfer approved tokens in a batch\n    /// @param transferDetails Array of owners, recipients, amounts, and tokens for the transfers\n    /// @dev Requires the from addresses to have approved at least the desired amount\n    /// of tokens to msg.sender.\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\n\n    /// @notice Enables performing a \"lockdown\" of the sender's Permit2 identity\n    /// by batch revoking approvals\n    /// @param approvals Array of approvals to revoke.\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\n\n    /// @notice Invalidate nonces for a given (token, spender) pair\n    /// @param token The token to invalidate nonces for\n    /// @param spender The spender to invalidate nonces for\n    /// @param newNonce The new nonce to set. Invalidates all nonces less than it.\n    /// @dev Can't invalidate more than 2**16 nonces per transaction.\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\n}\n"},"src/lib/ExclusivityOverrideLib.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\nimport {ResolvedOrder, OutputToken} from \"../base/ReactorStructs.sol\";\n\n/// @title ExclusiveOverride\n/// @dev This library handles order exclusivity\n///  giving the configured filler exclusive rights to fill the order before exclusivityEndTime\n///  or enforcing an override price improvement by non-exclusive fillers\nlibrary ExclusivityOverrideLib {\n    using FixedPointMathLib for uint256;\n\n    /// @notice thrown when an order has strict exclusivity and the filler does not have it\n    error NoExclusiveOverride();\n\n    uint256 private constant STRICT_EXCLUSIVITY = 0;\n    uint256 private constant BPS = 10_000;\n\n    /// @notice Applies exclusivity override to the resolved order if necessary\n    /// @param order The order to apply exclusivity override to\n    /// @param exclusive The exclusive address\n    /// @param exclusivityEndTime The exclusivity end time\n    /// @param exclusivityOverrideBps The exclusivity override BPS\n    function handleOverride(\n        ResolvedOrder memory order,\n        address exclusive,\n        uint256 exclusivityEndTime,\n        uint256 exclusivityOverrideBps\n    ) internal view {\n        // if the filler has fill right, we proceed with the order as-is\n        if (checkExclusivity(exclusive, exclusivityEndTime)) {\n            return;\n        }\n\n        // if override is 0, then assume strict exclusivity so the order cannot be filled\n        if (exclusivityOverrideBps == STRICT_EXCLUSIVITY) {\n            revert NoExclusiveOverride();\n        }\n\n        // scale outputs by override amount\n        OutputToken[] memory outputs = order.outputs;\n        for (uint256 i = 0; i < outputs.length;) {\n            OutputToken memory output = outputs[i];\n            output.amount = output.amount.mulDivDown(BPS + exclusivityOverrideBps, BPS);\n\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @notice checks if the order currently passes the exclusivity check\n    /// @dev if the order has no exclusivity, always returns true\n    /// @dev if the order has exclusivity and the current filler is the exclusive address, returns true\n    /// @dev if the order has exclusivity and the current filler is not the exclusive address, returns false\n    function checkExclusivity(address exclusive, uint256 exclusivityEndTime) internal view returns (bool pass) {\n        return exclusive == address(0) || block.timestamp > exclusivityEndTime || exclusive == msg.sender;\n    }\n}\n"},"src/lib/DutchDecayLib.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {OutputToken, InputToken} from \"../base/ReactorStructs.sol\";\nimport {DutchOutput, DutchInput} from \"../lib/DutchOrderLib.sol\";\nimport {FixedPointMathLib} from \"solmate/src/utils/FixedPointMathLib.sol\";\n\n/// @notice helpers for handling dutch order objects\nlibrary DutchDecayLib {\n    using FixedPointMathLib for uint256;\n\n    /// @notice thrown if the decay direction is incorrect\n    /// - for DutchInput, startAmount must be less than or equal toendAmount\n    /// - for DutchOutput, startAmount must be greater than or equal to endAmount\n    error IncorrectAmounts();\n\n    /// @notice thrown if the endTime of an order is before startTime\n    error EndTimeBeforeStartTime();\n\n    /// @notice calculates an amount using linear decay over time from decayStartTime to decayEndTime\n    /// @dev handles both positive and negative decay depending on startAmount and endAmount\n    /// @param startAmount The amount of tokens at decayStartTime\n    /// @param endAmount The amount of tokens at decayEndTime\n    /// @param decayStartTime The time to start decaying linearly\n    /// @param decayEndTime The time to stop decaying linearly\n    function decay(uint256 startAmount, uint256 endAmount, uint256 decayStartTime, uint256 decayEndTime)\n        internal\n        view\n        returns (uint256 decayedAmount)\n    {\n        if (decayEndTime < decayStartTime) {\n            revert EndTimeBeforeStartTime();\n        } else if (decayEndTime <= block.timestamp) {\n            decayedAmount = endAmount;\n        } else if (decayStartTime >= block.timestamp) {\n            decayedAmount = startAmount;\n        } else {\n            unchecked {\n                uint256 elapsed = block.timestamp - decayStartTime;\n                uint256 duration = decayEndTime - decayStartTime;\n                if (endAmount < startAmount) {\n                    decayedAmount = startAmount - (startAmount - endAmount).mulDivDown(elapsed, duration);\n                } else {\n                    decayedAmount = startAmount + (endAmount - startAmount).mulDivDown(elapsed, duration);\n                }\n            }\n        }\n    }\n\n    /// @notice returns a decayed output using the given dutch spec and times\n    /// @param output The output to decay\n    /// @param decayStartTime The time to start decaying\n    /// @param decayEndTime The time to end decaying\n    /// @return result a decayed output\n    function decay(DutchOutput memory output, uint256 decayStartTime, uint256 decayEndTime)\n        internal\n        view\n        returns (OutputToken memory result)\n    {\n        if (output.startAmount < output.endAmount) {\n            revert IncorrectAmounts();\n        }\n\n        uint256 decayedOutput = DutchDecayLib.decay(output.startAmount, output.endAmount, decayStartTime, decayEndTime);\n        result = OutputToken(output.token, decayedOutput, output.recipient);\n    }\n\n    /// @notice returns a decayed output array using the given dutch spec and times\n    /// @param outputs The output array to decay\n    /// @param decayStartTime The time to start decaying\n    /// @param decayEndTime The time to end decaying\n    /// @return result a decayed output array\n    function decay(DutchOutput[] memory outputs, uint256 decayStartTime, uint256 decayEndTime)\n        internal\n        view\n        returns (OutputToken[] memory result)\n    {\n        uint256 outputLength = outputs.length;\n        result = new OutputToken[](outputLength);\n        unchecked {\n            for (uint256 i = 0; i < outputLength; i++) {\n                result[i] = decay(outputs[i], decayStartTime, decayEndTime);\n            }\n        }\n    }\n\n    /// @notice returns a decayed input using the given dutch spec and times\n    /// @param input The input to decay\n    /// @param decayStartTime The time to start decaying\n    /// @param decayEndTime The time to end decaying\n    /// @return result a decayed input\n    function decay(DutchInput memory input, uint256 decayStartTime, uint256 decayEndTime)\n        internal\n        view\n        returns (InputToken memory result)\n    {\n        if (input.startAmount > input.endAmount) {\n            revert IncorrectAmounts();\n        }\n\n        uint256 decayedInput = DutchDecayLib.decay(input.startAmount, input.endAmount, decayStartTime, decayEndTime);\n        result = InputToken(input.token, decayedInput, input.endAmount);\n    }\n}\n"},"src/lib/OrderInfoLib.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {OrderInfo} from \"../base/ReactorStructs.sol\";\n\n/// @notice helpers for handling OrderInfo objects\nlibrary OrderInfoLib {\n    bytes internal constant ORDER_INFO_TYPE =\n        \"OrderInfo(address reactor,address swapper,uint256 nonce,uint256 deadline,address additionalValidationContract,bytes additionalValidationData)\";\n    bytes32 internal constant ORDER_INFO_TYPE_HASH = keccak256(ORDER_INFO_TYPE);\n\n    /// @notice hash an OrderInfo object\n    /// @param info The OrderInfo object to hash\n    function hash(OrderInfo memory info) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                ORDER_INFO_TYPE_HASH,\n                info.reactor,\n                info.swapper,\n                info.nonce,\n                info.deadline,\n                info.additionalValidationContract,\n                keccak256(info.additionalValidationData)\n            )\n        );\n    }\n}\n"},"src/reactors/ExclusiveDutchOrderReactor.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {BaseReactor} from \"./BaseReactor.sol\";\nimport {IPermit2} from \"permit2/src/interfaces/IPermit2.sol\";\nimport {ExclusivityOverrideLib} from \"../lib/ExclusivityOverrideLib.sol\";\nimport {Permit2Lib} from \"../lib/Permit2Lib.sol\";\nimport {DutchDecayLib} from \"../lib/DutchDecayLib.sol\";\nimport {ExclusiveDutchOrderLib, ExclusiveDutchOrder, DutchOutput, DutchInput} from \"../lib/ExclusiveDutchOrderLib.sol\";\nimport {SignedOrder, ResolvedOrder, OrderInfo} from \"../base/ReactorStructs.sol\";\n\n/// @notice Reactor for exclusive dutch orders\ncontract ExclusiveDutchOrderReactor is BaseReactor {\n    using Permit2Lib for ResolvedOrder;\n    using ExclusiveDutchOrderLib for ExclusiveDutchOrder;\n    using DutchDecayLib for DutchOutput[];\n    using DutchDecayLib for DutchInput;\n    using ExclusivityOverrideLib for ResolvedOrder;\n\n    /// @notice thrown when an order's deadline is before its end time\n    error DeadlineBeforeEndTime();\n\n    /// @notice thrown when an order's end time is before its start time\n    error OrderEndTimeBeforeStartTime();\n\n    /// @notice thrown when an order's inputs and outputs both decay\n    error InputAndOutputDecay();\n\n    constructor(IPermit2 _permit2, address _protocolFeeOwner) BaseReactor(_permit2, _protocolFeeOwner) {}\n\n    /// @inheritdoc BaseReactor\n    function resolve(SignedOrder calldata signedOrder)\n        internal\n        view\n        virtual\n        override\n        returns (ResolvedOrder memory resolvedOrder)\n    {\n        ExclusiveDutchOrder memory order = abi.decode(signedOrder.order, (ExclusiveDutchOrder));\n        _validateOrder(order);\n\n        resolvedOrder = ResolvedOrder({\n            info: order.info,\n            input: order.input.decay(order.decayStartTime, order.decayEndTime),\n            outputs: order.outputs.decay(order.decayStartTime, order.decayEndTime),\n            sig: signedOrder.sig,\n            hash: order.hash()\n        });\n        resolvedOrder.handleOverride(order.exclusiveFiller, order.decayStartTime, order.exclusivityOverrideBps);\n    }\n\n    /// @inheritdoc BaseReactor\n    function transferInputTokens(ResolvedOrder memory order, address to) internal override {\n        permit2.permitWitnessTransferFrom(\n            order.toPermit(),\n            order.transferDetails(to),\n            order.info.swapper,\n            order.hash,\n            ExclusiveDutchOrderLib.PERMIT2_ORDER_TYPE,\n            order.sig\n        );\n    }\n\n    /// @notice validate the dutch order fields\n    /// - deadline must be greater than or equal than decayEndTime\n    /// - decayEndTime must be greater than or equal to decayStartTime\n    /// - if there's input decay, outputs must not decay\n    /// - for input decay, startAmount must < endAmount\n    /// @dev Throws if the order is invalid\n    function _validateOrder(ExclusiveDutchOrder memory order) internal pure {\n        if (order.info.deadline < order.decayEndTime) {\n            revert DeadlineBeforeEndTime();\n        }\n\n        if (order.decayEndTime < order.decayStartTime) {\n            revert OrderEndTimeBeforeStartTime();\n        }\n\n        if (order.input.startAmount != order.input.endAmount) {\n            unchecked {\n                for (uint256 i = 0; i < order.outputs.length; i++) {\n                    if (order.outputs[i].startAmount != order.outputs[i].endAmount) {\n                        revert InputAndOutputDecay();\n                    }\n                }\n            }\n        }\n    }\n}\n"},"src/lib/CurrencyLibrary.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {ERC20} from \"solmate/src/tokens/ERC20.sol\";\nimport {IPermit2} from \"permit2/src/interfaces/IPermit2.sol\";\nimport {SafeCast} from \"openzeppelin-contracts/utils/math/SafeCast.sol\";\nimport {SafeTransferLib} from \"solmate/src/utils/SafeTransferLib.sol\";\n\naddress constant NATIVE = 0x0000000000000000000000000000000000000000;\nuint256 constant TRANSFER_NATIVE_GAS_LIMIT = 6900;\n\n/// @title CurrencyLibrary\n/// @dev This library allows for transferring native ETH and ERC20s via direct filler OR fill contract.\nlibrary CurrencyLibrary {\n    using SafeTransferLib for ERC20;\n\n    /// @notice Thrown when a native transfer fails\n    error NativeTransferFailed();\n\n    /// @notice Get the balance of a currency for addr\n    /// @param currency The currency to get the balance of\n    /// @param addr The address to get the balance of\n    /// @return balance The balance of the currency for addr\n    function balanceOf(address currency, address addr) internal view returns (uint256 balance) {\n        if (isNative(currency)) {\n            balance = addr.balance;\n        } else {\n            balance = ERC20(currency).balanceOf(addr);\n        }\n    }\n\n    /// @notice Transfer currency from the caller to recipient\n    /// @dev for native outputs we will already have the currency in local balance\n    /// @param currency The currency to transfer\n    /// @param recipient The recipient of the currency\n    /// @param amount The amount of currency to transfer\n    function transferFill(address currency, address recipient, uint256 amount) internal {\n        if (isNative(currency)) {\n            // we will have received native assets directly so can directly transfer\n            transferNative(recipient, amount);\n        } else {\n            // else the caller must have approved the token for the fill\n            ERC20(currency).safeTransferFrom(msg.sender, recipient, amount);\n        }\n    }\n\n    /// @notice Transfer native currency to recipient\n    /// @param recipient The recipient of the currency\n    /// @param amount The amount of currency to transfer\n    function transferNative(address recipient, uint256 amount) internal {\n        (bool success,) = recipient.call{value: amount, gas: TRANSFER_NATIVE_GAS_LIMIT}(\"\");\n        if (!success) revert NativeTransferFailed();\n    }\n\n    /// @notice returns true if currency is native\n    /// @param currency The currency to check\n    /// @return true if currency is native\n    function isNative(address currency) internal pure returns (bool) {\n        return currency == NATIVE;\n    }\n}\n"},"src/interfaces/IReactorCallback.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {ResolvedOrder} from \"../base/ReactorStructs.sol\";\n\n/// @notice Callback for executing orders through a reactor.\ninterface IReactorCallback {\n    /// @notice Called by the reactor during the execution of an order\n    /// @param resolvedOrders Has inputs and outputs\n    /// @param callbackData The callbackData specified for an order execution\n    /// @dev Must have approved each token and amount in outputs to the msg.sender\n    function reactorCallback(ResolvedOrder[] memory resolvedOrders, bytes memory callbackData) external;\n}\n"},"src/interfaces/IProtocolFeeController.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {ResolvedOrder, OutputToken} from \"../base/ReactorStructs.sol\";\n\n/// @notice Interface for getting fee outputs\ninterface IProtocolFeeController {\n    /// @notice Get fee outputs for the given orders\n    /// @param order The orders to get fee outputs for\n    /// @return List of fee outputs to append for each provided order\n    function getFeeOutputs(ResolvedOrder memory order) external view returns (OutputToken[] memory);\n}\n"},"lib/solmate/src/auth/Owned.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"},"src/lib/ExclusiveDutchOrderLib.sol":{"content":"// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {OrderInfo} from \"../base/ReactorStructs.sol\";\nimport {DutchOutput, DutchInput, DutchOrderLib} from \"./DutchOrderLib.sol\";\nimport {OrderInfoLib} from \"./OrderInfoLib.sol\";\n\nstruct ExclusiveDutchOrder {\n    // generic order information\n    OrderInfo info;\n    // The time at which the DutchOutputs start decaying\n    uint256 decayStartTime;\n    // The time at which price becomes static\n    uint256 decayEndTime;\n    // The address who has exclusive rights to the order until decayStartTime\n    address exclusiveFiller;\n    // The amount in bps that a non-exclusive filler needs to improve the outputs by to be able to fill the order\n    uint256 exclusivityOverrideBps;\n    // The tokens that the swapper will provide when settling the order\n    DutchInput input;\n    // The tokens that must be received to satisfy the order\n    DutchOutput[] outputs;\n}\n\n/// @notice helpers for handling dutch order objects\nlibrary ExclusiveDutchOrderLib {\n    using DutchOrderLib for DutchOutput[];\n    using OrderInfoLib for OrderInfo;\n\n    bytes internal constant EXCLUSIVE_DUTCH_LIMIT_ORDER_TYPE = abi.encodePacked(\n        \"ExclusiveDutchOrder(\",\n        \"OrderInfo info,\",\n        \"uint256 decayStartTime,\",\n        \"uint256 decayEndTime,\",\n        \"address exclusiveFiller,\",\n        \"uint256 exclusivityOverrideBps,\",\n        \"address inputToken,\",\n        \"uint256 inputStartAmount,\",\n        \"uint256 inputEndAmount,\",\n        \"DutchOutput[] outputs)\"\n    );\n\n    bytes internal constant ORDER_TYPE = abi.encodePacked(\n        EXCLUSIVE_DUTCH_LIMIT_ORDER_TYPE, DutchOrderLib.DUTCH_OUTPUT_TYPE, OrderInfoLib.ORDER_INFO_TYPE\n    );\n    bytes32 internal constant ORDER_TYPE_HASH = keccak256(ORDER_TYPE);\n\n    /// @dev Note that sub-structs have to be defined in alphabetical order in the EIP-712 spec\n    string internal constant PERMIT2_ORDER_TYPE = string(\n        abi.encodePacked(\n            \"ExclusiveDutchOrder witness)\",\n            DutchOrderLib.DUTCH_OUTPUT_TYPE,\n            EXCLUSIVE_DUTCH_LIMIT_ORDER_TYPE,\n            OrderInfoLib.ORDER_INFO_TYPE,\n            DutchOrderLib.TOKEN_PERMISSIONS_TYPE\n        )\n    );\n\n    /// @notice hash the given order\n    /// @param order the order to hash\n    /// @return the eip-712 order hash\n    function hash(ExclusiveDutchOrder memory order) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                ORDER_TYPE_HASH,\n                order.info.hash(),\n                order.decayStartTime,\n                order.decayEndTime,\n                order.exclusiveFiller,\n                order.exclusivityOverrideBps,\n                order.input.token,\n                order.input.startAmount,\n                order.input.endAmount,\n                order.outputs.hash()\n            )\n        );\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"},"lib/solmate/src/tokens/ERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"}},"settings":{"evmVersion":"paris","libraries":{},"metadata":{"appendCBOR":true,"bytecodeHash":"ipfs"},"optimizer":{"enabled":true,"runs":1000000},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}},"remappings":["ds-test/=lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-gas-snapshot/=lib/forge-gas-snapshot/src/","forge-std/=lib/forge-std/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/","openzeppelin/=lib/openzeppelin-contracts/contracts/","permit2/=lib/permit2/","solmate/=lib/solmate/"]}},"ABI":"[{\"inputs\":[{\"internalType\":\"contract IPermit2\",\"name\":\"_permit2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_protocolFeeOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DeadlineBeforeEndTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DeadlinePassed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"duplicateToken\",\"type\":\"address\"}],\"name\":\"DuplicateFeeOutput\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"EndTimeBeforeStartTime\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"FeeTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectAmounts\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InputAndOutputDecay\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientEth\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeToken\",\"type\":\"address\"}],\"name\":\"InvalidFeeToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidReactor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NativeTransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoExclusiveOverride\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OrderEndTimeBeforeStartTime\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"filler\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"swapper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"Fill\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldFeeController\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFeeController\",\"type\":\"address\"}],\"name\":\"ProtocolFeeControllerSet\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"order\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"internalType\":\"struct SignedOrder\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"order\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"internalType\":\"struct SignedOrder[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"executeBatch\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"order\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"internalType\":\"struct SignedOrder[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"callbackData\",\"type\":\"bytes\"}],\"name\":\"executeBatchWithCallback\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"order\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"internalType\":\"struct SignedOrder\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"callbackData\",\"type\":\"bytes\"}],\"name\":\"executeWithCallback\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeController\",\"outputs\":[{\"internalType\":\"contract IProtocolFeeController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permit2\",\"outputs\":[{\"internalType\":\"contract IPermit2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newFeeController\",\"type\":\"address\"}],\"name\":\"setProtocolFeeController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ExclusiveDutchOrderReactor","CompilerVersion":"v0.8.19+commit.7dd6d404","OptimizationUsed":1,"Runs":1000000,"ConstructorArguments":"0x000000000000000000000000000000000022d473030f116ddee9f6b43ac78ba30000000000000000000000001a9c8182c09f50c8318d769245bea52c32be35bc","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}