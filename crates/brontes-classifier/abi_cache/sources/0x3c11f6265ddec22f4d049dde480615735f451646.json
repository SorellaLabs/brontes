{"expiry":1699584941,"data":[{"SourceCode":{"language":"Solidity","sources":{"@mimic-fi/v2-smart-vaults-base/contracts/actions/TokenThresholdAction.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\n\nimport './BaseAction.sol';\n\n/**\n * @title TokenThresholdAction\n * @dev Action that offers a token threshold limit. It can be used for minimum swap amounts, or minimum withdrawal\n * amounts, etc. This type of action does not require any specific permission on the Smart Vault.\n */\nabstract contract TokenThresholdAction is BaseAction {\n    using FixedPoint for uint256;\n\n    address public thresholdToken;\n    uint256 public thresholdAmount;\n\n    event ThresholdSet(address indexed token, uint256 amount);\n\n    /**\n     * @dev Sets a new threshold configuration. Sender must be authorized.\n     * @param token New token threshold to be set\n     * @param amount New amount threshold to be set\n     */\n    function setThreshold(address token, uint256 amount) external auth {\n        thresholdToken = token;\n        thresholdAmount = amount;\n        emit ThresholdSet(token, amount);\n    }\n\n    /**\n     * @dev Internal function to check the set threshold\n     * @param token Token address of the given amount to evaluate the threshold\n     * @param amount Amount of tokens to validate the threshold\n     */\n    function _passesThreshold(address token, uint256 amount) internal view returns (bool) {\n        uint256 price = smartVault.getPrice(_wrappedIfNative(token), thresholdToken);\n        return _passesThreshold(amount, price);\n    }\n\n    /**\n     * @dev Internal function to check the set threshold\n     * @param amount Amount of tokens to validate the threshold\n     * @param price Price of the given token amount quoted in the threshold token\n     */\n    function _passesThreshold(uint256 amount, uint256 price) internal view returns (bool) {\n        // Result balance is rounded down to make sure we always match at least the threshold\n        return amount.mulDown(price) >= thresholdAmount;\n    }\n\n    /**\n     * @dev Internal function to validate the set threshold\n     * @param token Token address of the given amount to evaluate the threshold\n     * @param amount Amount of tokens to validate the threshold\n     */\n    function _validateThreshold(address token, uint256 amount) internal view {\n        require(_passesThreshold(token, amount), 'MIN_THRESHOLD_NOT_MET');\n    }\n\n    /**\n     * @dev Internal function to validate the set threshold\n     * @param amount Amount of tokens to validate the threshold\n     * @param price Price of the given token amount quoted in the threshold token\n     */\n    function _validateThreshold(uint256 amount, uint256 price) internal view {\n        require(_passesThreshold(amount, price), 'MIN_THRESHOLD_NOT_MET');\n    }\n}\n"},"@mimic-fi/v2-smart-vaults-base/contracts/permissions/Arrays.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol';\n\n/**\n * @title Arrays\n * @dev Helper methods to operate arrays\n */\nlibrary Arrays {\n    using UncheckedMath for uint256;\n\n    /**\n     * @dev Builds an array of addresses based on the given ones\n     */\n    function concat(address[] memory a, address[] memory b) internal pure returns (address[] memory r) {\n        // No need for checked math since we are simply adding two memory array's length\n        r = new address[](a.length.uncheckedAdd(b.length));\n\n        // No need for checked math since we are using it to compute indexes manually, always within boundaries\n        for (uint256 i = 0; i < a.length; i = i.uncheckedAdd(1)) {\n            r[i] = a[i];\n        }\n\n        // No need for checked math since we are using it to compute indexes manually, always within boundaries\n        for (uint256 i = 0; i < b.length; i = i.uncheckedAdd(1)) {\n            r[a.length.uncheckedAdd(i)] = b[i];\n        }\n    }\n\n    /**\n     * @dev Builds an array of addresses based on the given ones\n     */\n    function from(address a, address[] memory b, address[] memory c) internal pure returns (address[] memory result) {\n        // No need for checked math since we are simply adding two memory array's length\n        result = new address[](b.length.uncheckedAdd(c.length).uncheckedAdd(1));\n        result[0] = a;\n\n        // No need for checked math since we are using it to compute indexes manually, always within boundaries\n        for (uint256 i = 0; i < b.length; i = i.uncheckedAdd(1)) {\n            result[i.uncheckedAdd(1)] = b[i];\n        }\n\n        // No need for checked math since we are using it to compute indexes manually, always within boundaries\n        for (uint256 i = 0; i < c.length; i = i.uncheckedAdd(1)) {\n            result[b.length.uncheckedAdd(1).uncheckedAdd(i)] = c[i];\n        }\n    }\n\n    // Address helpers\n\n    function from(address a) internal pure returns (address[] memory r) {\n        r = new address[](1);\n        r[0] = a;\n    }\n\n    function from(address a, address b) internal pure returns (address[] memory r) {\n        r = new address[](2);\n        r[0] = a;\n        r[1] = b;\n    }\n\n    function from(address a, address b, address c) internal pure returns (address[] memory r) {\n        r = new address[](3);\n        r[0] = a;\n        r[1] = b;\n        r[2] = c;\n    }\n\n    function from(address a, address b, address c, address d) internal pure returns (address[] memory r) {\n        r = new address[](4);\n        r[0] = a;\n        r[1] = b;\n        r[2] = c;\n        r[3] = d;\n    }\n\n    function from(address a, address b, address c, address d, address e) internal pure returns (address[] memory r) {\n        r = new address[](5);\n        r[0] = a;\n        r[1] = b;\n        r[2] = c;\n        r[3] = d;\n        r[4] = e;\n    }\n\n    // Bytes4 helpers\n\n    function from(bytes4 a) internal pure returns (bytes4[] memory r) {\n        r = new bytes4[](1);\n        r[0] = a;\n    }\n\n    function from(bytes4 a, bytes4 b) internal pure returns (bytes4[] memory r) {\n        r = new bytes4[](2);\n        r[0] = a;\n        r[1] = b;\n    }\n\n    function from(bytes4 a, bytes4 b, bytes4 c) internal pure returns (bytes4[] memory r) {\n        r = new bytes4[](3);\n        r[0] = a;\n        r[1] = b;\n        r[2] = c;\n    }\n\n    function from(bytes4 a, bytes4 b, bytes4 c, bytes4 d) internal pure returns (bytes4[] memory r) {\n        r = new bytes4[](4);\n        r[0] = a;\n        r[1] = b;\n        r[2] = c;\n        r[3] = d;\n    }\n\n    function from(bytes4 a, bytes4 b, bytes4 c, bytes4 d, bytes4 e) internal pure returns (bytes4[] memory r) {\n        r = new bytes4[](5);\n        r[0] = a;\n        r[1] = b;\n        r[2] = c;\n        r[3] = d;\n        r[4] = e;\n    }\n}\n"},"@mimic-fi/v2-smart-vaults-base/contracts/permissions/PermissionsHelpers.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol';\n\nimport './Arrays.sol';\nimport './PermissionsManager.sol';\nimport { Permission, PermissionChange, PermissionChangeRequest } from './PermissionsData.sol';\n\nlibrary PermissionsHelpers {\n    /**\n     * @dev Builds a permission object\n     * @param who Address to be referred\n     * @param what Function selector to be referred\n     */\n    function permission(address who, bytes4 what) internal pure returns (Permission memory) {\n        return Permission(what, who);\n    }\n\n    /**\n     * @dev Builds a permission change object\n     * @param grant Whether the permission should be granted or revoked\n     * @param who Address to be referred\n     * @param what Function selector to be referred\n     */\n    function change(bool grant, address who, bytes4 what) internal pure returns (PermissionChange memory) {\n        return PermissionChange(grant, permission(who, what));\n    }\n\n    /**\n     * @dev Grants permission to `who` to perform `what` in `where` through the permissions manager `self`\n     * @param self Permissions manager to be used\n     * @param where Address of the contract where the permission will be granted\n     * @param who Address of the account that will be authorized\n     * @param what Function selector to be authorized\n     */\n    function authorize(PermissionsManager self, IAuthorizer where, address who, bytes4 what) internal {\n        authorize(self, where, Arrays.from(who), Arrays.from(what));\n    }\n\n    /**\n     * @dev Revokes permission from `who` to perform `what` in `where` through the permissions manager `self`\n     * @param self Permissions manager to be used\n     * @param where Address of the contract where the permission will be revoked\n     * @param who Address of the account that will be unauthorized\n     * @param what Function selector to be unauthorized\n     */\n    function unauthorize(PermissionsManager self, IAuthorizer where, address who, bytes4 what) internal {\n        unauthorize(self, where, Arrays.from(who), Arrays.from(what));\n    }\n\n    /**\n     * @dev Grants permission to `whos` to perform `what` in `where` through the permissions manager `self`\n     * @param self Permissions manager to be used\n     * @param where Address of the contract where the permission will be granted\n     * @param whos List of addresses of the accounts that will be authorized\n     * @param what Function selector to be authorized\n     */\n    function authorize(PermissionsManager self, IAuthorizer where, address[] memory whos, bytes4 what) internal {\n        authorize(self, where, whos, Arrays.from(what));\n    }\n\n    /**\n     * @dev Revokes permission from `whos` to perform `what` in `where` through the permissions manager `self`\n     * @param self Permissions manager to be used\n     * @param where Address of the contract where the permission will be revoked\n     * @param whos List of addresses of the accounts that will be unauthorized\n     * @param what Function selector to be unauthorized\n     */\n    function unauthorize(PermissionsManager self, IAuthorizer where, address[] memory whos, bytes4 what) internal {\n        unauthorize(self, where, whos, Arrays.from(what));\n    }\n\n    /**\n     * @dev Grants permissions to `who` to perform `whats` in `where` through the permissions manager `self`\n     * @param self Permissions manager to be used\n     * @param where Address of the contract where the permission will be granted\n     * @param who Address of the account that will be authorized\n     * @param whats List of function selectors to be authorized\n     */\n    function authorize(PermissionsManager self, IAuthorizer where, address who, bytes4[] memory whats) internal {\n        authorize(self, where, Arrays.from(who), whats);\n    }\n\n    /**\n     * @dev Revokes permissions from `who` to perform `whats` in `where` through the permissions manager `self`\n     * @param self Permissions manager to be used\n     * @param where Address of the contract where the permission will be revoked\n     * @param who Address of the account that will be unauthorized\n     * @param whats List of function selectors to be unauthorized\n     */\n    function unauthorize(PermissionsManager self, IAuthorizer where, address who, bytes4[] memory whats) internal {\n        unauthorize(self, where, Arrays.from(who), whats);\n    }\n\n    /**\n     * @dev Grants permissions to `whos` to perform `whats` in `where` through the permissions manager `self`\n     * @param self Permissions manager to be used\n     * @param where Address of the contract where the permission will be granted\n     * @param whos List of addresses of the accounts that will be authorized\n     * @param whats List of function selectors to be authorized\n     */\n    function authorize(PermissionsManager self, IAuthorizer where, address[] memory whos, bytes4[] memory whats)\n        internal\n    {\n        execute(self, where, whos, whats, true);\n    }\n\n    /**\n     * @dev Revokes permissions from `whos` to perform `whats` in `where` through the permissions manager `self`\n     * @param self Permissions manager to be used\n     * @param where Address of the contract where the permission will be revoked\n     * @param whos List of addresses of the accounts that will be unauthorized\n     * @param whats List of function selectors to be unauthorized\n     */\n    function unauthorize(PermissionsManager self, IAuthorizer where, address[] memory whos, bytes4[] memory whats)\n        internal\n    {\n        execute(self, where, whos, whats, false);\n    }\n\n    /**\n     * @dev Executes a list of permission changes\n     * @param self Permissions manager to be used\n     * @param where Address of the contract where the permission change will be executed\n     * @param whos List of addresses of the accounts that will be affected\n     * @param whats List of function selectors to be affected\n     * @param grant Whether the permissions should be granted or revoked\n     */\n    function execute(\n        PermissionsManager self,\n        IAuthorizer where,\n        address[] memory whos,\n        bytes4[] memory whats,\n        bool grant\n    ) private {\n        PermissionChangeRequest[] memory requests = new PermissionChangeRequest[](1);\n        requests[0].target = where;\n        requests[0].changes = new PermissionChange[](whos.length * whats.length);\n\n        for (uint256 i = 0; i < whos.length; i++) {\n            for (uint256 j = 0; j < whats.length; j++) {\n                uint256 index = (i * whats.length) + j;\n                requests[0].changes[index] = change(grant, whos[i], whats[j]);\n            }\n        }\n\n        self.execute(requests);\n    }\n}\n"},"@mimic-fi/v2-smart-vaults-base/contracts/permissions/PermissionsData.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol';\n\n/**\n * @dev Permission\n * @param what Function selector to be referred\n * @param who Address to be referred\n */\nstruct Permission {\n    bytes4 what;\n    address who;\n}\n\n/**\n * @dev Permission change\n * @param grant Whether the permission should be granted (authorize) or revoked (unauthorize)\n * @param permissions Permission to be changed\n */\nstruct PermissionChange {\n    bool grant;\n    Permission permission;\n}\n\n/**\n * @dev Permission change request\n * @param target Address of the contract to be affected\n * @param changes List of permission changes to be performed\n */\nstruct PermissionChangeRequest {\n    IAuthorizer target;\n    PermissionChange[] changes;\n}\n"},"@openzeppelin/contracts/utils/math/Math.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)` â†’ `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"},"@mimic-fi/v2-smart-vaults-base/contracts/actions/BaseAction.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n\nimport '@mimic-fi/v2-smart-vault/contracts/ISmartVault.sol';\nimport '@mimic-fi/v2-helpers/contracts/auth/Authorizer.sol';\nimport '@mimic-fi/v2-helpers/contracts/utils/Denominations.sol';\nimport '@mimic-fi/v2-helpers/contracts/utils/ERC20Helpers.sol';\nimport '@mimic-fi/v2-registry/contracts/implementations/BaseAuthorizedImplementation.sol';\n\nimport './IAction.sol';\n\n/**\n * @title BaseAction\n * @dev Simple action implementation with a Smart Vault reference and using the Authorizer mixin\n */\ncontract BaseAction is IAction, BaseAuthorizedImplementation, ReentrancyGuard {\n    bytes32 public constant override NAMESPACE = keccak256('ACTION');\n\n    // Smart Vault reference\n    ISmartVault public override smartVault;\n\n    /**\n     * @dev Emitted every time a new smart vault is set\n     */\n    event SmartVaultSet(address indexed smartVault);\n\n    /**\n     * @dev Creates a new BaseAction\n     * @param admin Address to be granted authorize and unauthorize permissions\n     * @param registry Address of the Mimic Registry\n     */\n    constructor(address admin, address registry) BaseAuthorizedImplementation(admin, registry) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Sets the Smart Vault tied to the Action. Sender must be authorized. It can be set only once.\n     * @param newSmartVault Address of the smart vault to be set\n     */\n    function setSmartVault(address newSmartVault) external auth {\n        require(address(smartVault) == address(0), 'SMART_VAULT_ALREADY_SET');\n        smartVault = ISmartVault(newSmartVault);\n        emit SmartVaultSet(newSmartVault);\n    }\n\n    /**\n     * @dev Tells the balance of the Smart Vault for a given token\n     * @param token Address of the token querying the balance of\n     * @notice Denominations.NATIVE_TOKEN_ADDRESS can be used to query the native token balance\n     */\n    function _balanceOf(address token) internal view returns (uint256) {\n        return ERC20Helpers.balanceOf(token, address(smartVault));\n    }\n\n    /**\n     * @dev Tells the wrapped native token address if the given address is the native token\n     * @param token Address of the token to be checked\n     */\n    function _wrappedIfNative(address token) internal view returns (address) {\n        return Denominations.isNativeToken(token) ? smartVault.wrappedNativeToken() : token;\n    }\n\n    /**\n     * @dev Tells whether the given token is either the native or wrapped native token\n     * @param token Address of the token being queried\n     */\n    function _isWrappedOrNativeToken(address token) internal view returns (bool) {\n        return Denominations.isNativeToken(token) || token == smartVault.wrappedNativeToken();\n    }\n}\n"},"@mimic-fi/v2-registry/contracts/registry/IRegistry.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\nimport '@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol';\n\n/**\n * @title IRegistry\n * @dev Registry interface, it must follow the IAuthorizer interface.\n */\ninterface IRegistry is IAuthorizer {\n    /**\n     * @dev Emitted every time a new implementation is registered\n     */\n    event Registered(bytes32 indexed namespace, address indexed implementation, bool stateless);\n\n    /**\n     * @dev Emitted every time an implementation is deprecated\n     */\n    event Deprecated(bytes32 indexed namespace, address indexed implementation);\n\n    /**\n     * @dev Tells the data of an implementation:\n     * @param implementation Address of the implementation to request it's data\n     */\n    function implementationData(address implementation)\n        external\n        view\n        returns (bool stateless, bool deprecated, bytes32 namespace);\n\n    /**\n     * @dev Tells if a specific implementation is registered under a certain namespace and it's not deprecated\n     * @param namespace Namespace asking for\n     * @param implementation Address of the implementation to be checked\n     */\n    function isActive(bytes32 namespace, address implementation) external view returns (bool);\n\n    /**\n     * @dev Registers a new implementation for a given namespace\n     * @param namespace Namespace to be used for the implementation\n     * @param implementation Address of the implementation to be registered\n     * @param stateless Whether the implementation is stateless or not\n     */\n    function register(bytes32 namespace, address implementation, bool stateless) external;\n\n    /**\n     * @dev Deprecates a registered implementation\n     * @param implementation Address of the implementation to be deprecated\n     */\n    function deprecate(address implementation) external;\n}\n"},"@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"@mimic-fi/v2-helpers/contracts/auth/Authorizer.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport './IAuthorizer.sol';\n\n/**\n * @title Authorizer\n * @dev Authorization module to be used by contracts that need to implement permissions for their methods.\n * It provides a permissions model to list who is allowed to call what function in a contract. And only accounts\n * authorized to manage those permissions are the ones that are allowed to authorize or unauthorize accounts.\n */\ncontract Authorizer is IAuthorizer {\n    // Constant used to denote that a permission is open to anyone\n    address public constant ANY_ADDRESS = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\n\n    // Internal mapping to tell who is allowed to do what indexed by (account, function selector)\n    mapping (address => mapping (bytes4 => bool)) private authorized;\n\n    /**\n     * @dev Modifier that should be used to tag protected functions\n     */\n    modifier auth() {\n        _authenticate(msg.sender, msg.sig);\n        _;\n    }\n\n    /**\n     * @dev Tells whether someone is allowed to call a function or not. It returns true if it's allowed to anyone.\n     * @param who Address asking permission for\n     * @param what Function selector asking permission for\n     */\n    function isAuthorized(address who, bytes4 what) public view override returns (bool) {\n        return authorized[ANY_ADDRESS][what] || authorized[who][what];\n    }\n\n    /**\n     * @dev Authorizes someone to call a function. Sender must be authorize to do so.\n     * @param who Address to be authorized\n     * @param what Function selector to be granted\n     */\n    function authorize(address who, bytes4 what) external override auth {\n        _authorize(who, what);\n    }\n\n    /**\n     * @dev Unauthorizes someone to call a function. Sender must be authorize to do so.\n     * @param who Address to be unauthorized\n     * @param what Function selector to be revoked\n     */\n    function unauthorize(address who, bytes4 what) external override auth {\n        _unauthorize(who, what);\n    }\n\n    /**\n     * @dev Internal function to authenticate someone over a function.\n     * It reverts if the given account is not authorized to call the requested function.\n     * @param who Address to be authenticated\n     * @param what Function selector to be authenticated\n     */\n    function _authenticate(address who, bytes4 what) internal view {\n        require(isAuthorized(who, what), 'AUTH_SENDER_NOT_ALLOWED');\n    }\n\n    /**\n     * @dev Internal function to authorize someone to call a function\n     * @param who Address to be authorized\n     * @param what Function selector to be granted\n     */\n    function _authorize(address who, bytes4 what) internal {\n        authorized[who][what] = true;\n        emit Authorized(who, what);\n    }\n\n    /**\n     * @dev Internal function to unauthorize someone to call a function\n     * @param who Address to be unauthorized\n     * @param what Function selector to be revoked\n     */\n    function _unauthorize(address who, bytes4 what) internal {\n        authorized[who][what] = false;\n        emit Unauthorized(who, what);\n    }\n}\n"},"@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\n// solhint-disable func-name-mixedcase\n\n/**\n * @title IImplementation\n * @dev Implementation interface that must be followed for implementations to be registered in the Mimic Registry\n */\ninterface IImplementation {\n    /**\n     * @dev Tells the namespace under which the implementation is registered in the Mimic Registry\n     */\n    function NAMESPACE() external view returns (bytes32);\n\n    /**\n     * @dev Tells the address of the Mimic Registry\n     */\n    function registry() external view returns (address);\n}\n"},"@mimic-fi/v2-helpers/contracts/utils/Denominations.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\n/**\n * @title Denominations\n * @dev Provides a list of ground denominations for those tokens that cannot be represented by an ERC20.\n * For now, the only needed is the native token that could be ETH, MATIC, or other depending on the layer being operated.\n */\nlibrary Denominations {\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    // Fiat currencies follow https://en.wikipedia.org/wiki/ISO_4217\n    address internal constant USD = address(840);\n\n    function isNativeToken(address token) internal pure returns (bool) {\n        return token == NATIVE_TOKEN;\n    }\n}\n"},"@mimic-fi/v2-smart-vaults-base/contracts/actions/RelayedAction.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\nimport '@mimic-fi/v2-helpers/contracts/utils/Denominations.sol';\n\nimport './BaseAction.sol';\n\n/**\n * @title RelayedAction\n * @dev Action that offers a relayed mechanism to allow reimbursing tx costs after execution in any ERC20 token.\n * This type of action at least require having withdraw permissions from the Smart Vault tied to it.\n */\nabstract contract RelayedAction is BaseAction {\n    using FixedPoint for uint256;\n\n    // Base gas amount charged to cover default amounts\n    // solhint-disable-next-line func-name-mixedcase\n    function BASE_GAS() external view virtual returns (uint256);\n\n    // Note to be used to mark tx cost payments\n    bytes private constant REDEEM_GAS_NOTE = bytes('RELAYER');\n\n    // Internal variable used to allow a better developer experience to reimburse tx gas cost\n    uint256 private _initialGas;\n\n    // Gas price limit expressed in the native token, if surpassed it wont relay the transaction\n    uint256 public gasPriceLimit;\n\n    // Total transaction cost limit expressed in the native token, if surpassed it wont relay the transaction\n    uint256 public txCostLimit;\n\n    // List of allowed relayers indexed by address\n    mapping (address => bool) public isRelayer;\n\n    /**\n     * @dev Emitted every time the relayers list is changed\n     */\n    event RelayerSet(address indexed relayer, bool allowed);\n\n    /**\n     * @dev Emitted every time the relayer limits are set\n     */\n    event LimitsSet(uint256 gasPriceLimit, uint256 txCostLimit);\n\n    /**\n     * @dev Modifier that can be used to reimburse the gas cost of the tagged function paying in a specific token\n     */\n    modifier redeemGas(address token) {\n        _initRelayedTx();\n        _;\n        _payRelayedTx(token);\n    }\n\n    /**\n     * @dev Sets a relayer address. Sender must be authorized.\n     * @param relayer Address of the relayer to be set\n     * @param allowed Whether it should be allowed or not\n     */\n    function setRelayer(address relayer, bool allowed) external auth {\n        isRelayer[relayer] = allowed;\n        emit RelayerSet(relayer, allowed);\n    }\n\n    /**\n     * @dev Sets the relayer limits. Sender must be authorized.\n     * @param _gasPriceLimit New gas price limit to be set\n     * @param _txCostLimit New total cost limit to be set\n     */\n    function setLimits(uint256 _gasPriceLimit, uint256 _txCostLimit) external auth {\n        gasPriceLimit = _gasPriceLimit;\n        txCostLimit = _txCostLimit;\n        emit LimitsSet(_gasPriceLimit, _txCostLimit);\n    }\n\n    /**\n     * @dev Internal init hook used for relayed txs. It checks tx limit validations only when the sender is a relayer.\n     */\n    function _initRelayedTx() internal {\n        if (!isRelayer[msg.sender]) return;\n        _initialGas = gasleft();\n        uint256 limit = gasPriceLimit;\n        require(limit == 0 || tx.gasprice <= limit, 'GAS_PRICE_ABOVE_LIMIT');\n    }\n\n    /**\n     * @dev Internal function to pay for a relayed tx. Only when the sender is marked as a relayer.\n     * @param token Address of the token to use in order to pay the tx cost\n     * @return Amount of tokens paid to reimburse the tx cost\n     */\n    function _payRelayedTx(address token) internal returns (uint256) {\n        (bool success, uint256 price) = _tryGetNativeTokenPriceIn(token);\n        if (success) return _payRelayedTx(token, price);\n        delete _initialGas;\n        return 0;\n    }\n\n    /**\n     * @dev Internal after call hook where tx cost is reimbursed. Only when the sender is marked as a relayer.\n     * @param token Address of the token to use in order to pay the tx cost\n     * @param price Price of the native token expressed in the given token quote\n     * @return Amount of tokens paid to reimburse the tx cost\n     */\n    function _payRelayedTx(address token, uint256 price) internal returns (uint256) {\n        if (!isRelayer[msg.sender]) return 0;\n        require(_initialGas > 0, 'RELAYED_TX_NOT_INITIALIZED');\n\n        uint256 limit = txCostLimit;\n        uint256 totalGas = _initialGas - gasleft();\n        uint256 totalCostNative = (totalGas + RelayedAction(this).BASE_GAS()) * tx.gasprice;\n        require(limit == 0 || totalCostNative <= limit, 'TX_COST_ABOVE_LIMIT');\n\n        // Total cost is rounded down to make sure we always match at least the threshold\n        uint256 totalCostToken = totalCostNative.mulDown(price);\n        smartVault.withdraw(token, totalCostToken, smartVault.feeCollector(), REDEEM_GAS_NOTE);\n\n        delete _initialGas;\n        return totalCostToken;\n    }\n\n    /**\n     * @dev Tries getting the price of the native token quoted in a another token\n     * @param token Address of the token to quote the native token in\n     * @return success Whether the price query to the smart vault succeeded or not\n     * @return price The price fetched or zero if the query didn't succeed\n     */\n    function _tryGetNativeTokenPriceIn(address token) internal view virtual returns (bool success, uint256 price) {\n        if (_isWrappedOrNativeToken(token)) return (true, FixedPoint.ONE);\n        try smartVault.getPrice(smartVault.wrappedNativeToken(), token) returns (uint256 result) {\n            return (true, result);\n        } catch {\n            return (false, 0);\n        }\n    }\n}\n"},"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"},"contracts/Swapper.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport { Pausable } from '@openzeppelin/contracts/security/Pausable.sol';\nimport { IERC20 } from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport { Address } from '@openzeppelin/contracts/utils/Address.sol';\nimport { EnumerableSet } from '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\nimport { Denominations } from '@mimic-fi/v2-helpers/contracts/utils/Denominations.sol';\nimport { ISmartVault } from '@mimic-fi/v2-smart-vault/contracts/ISmartVault.sol';\nimport { BaseAction } from '@mimic-fi/v2-smart-vaults-base/contracts/actions/BaseAction.sol';\n\n/**\n * @title Swapper\n * @dev Public swapper action. This action allows any user to leverage a public smart vault to perform arbitray swaps.\n */\ncontract Swapper is BaseAction, Pausable {\n    using Address for address payable;\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    // Empty bytes array constant\n    bytes private constant NO_DATA = new bytes(0);\n\n    // Enumerable set of allowed sources\n    EnumerableSet.UintSet private sources;\n\n    /**\n     * @dev Emitted every time a source is allowed or disallowed\n     */\n    event SourceSet(uint256 indexed source, bool allowed);\n\n    /**\n     * @dev Creates a new swapper action\n     * @param admin Address that will be granted with admin permissions\n     * @param registry Address of the Mimic Registry\n     */\n    constructor(address admin, address registry) BaseAction(admin, registry) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Tells the list of allowed sources\n     */\n    function getAllowedSources() external view returns (uint256[] memory) {\n        return sources.values();\n    }\n\n    /**\n     * @dev Tells whether a source is allowed or not\n     * @param source Number identifying the source being queried\n     */\n    function isSourceAllowed(uint256 source) public view returns (bool) {\n        return sources.contains(source);\n    }\n\n    /**\n     * @dev Change a source allowance. Sender must be authorized.\n     * @param source Number identifying the source to be set\n     * @param allowed Whether the source should be allowed or not\n     * @return success True if the source was actually added or removed from the list of allowed sources\n     */\n    function setSource(uint256 source, bool allowed) external auth returns (bool success) {\n        require(source <= type(uint8).max, 'SWAPPER_INVALID_SOURCE_ID');\n        success = allowed ? sources.add(source) : sources.remove(source);\n        if (success) emit SourceSet(source, allowed);\n    }\n\n    /**\n     * @dev Pause the swap action. Sender must be authorized.\n     */\n    function pause() external auth {\n        _pause();\n    }\n\n    /**\n     * @dev Unpause the swap action. Sender must be authorized.\n     */\n    function unpause() external auth {\n        _unpause();\n    }\n\n    /**\n     * @dev Swaps two tokens\n     * @param source Source where the swap will be executed.\n     * @param tokenIn Token being sent\n     * @param tokenOut Token being received\n     * @param amountIn Amount of tokenIn being swapped\n     * @param minAmountOut Minimum amount of tokenOut expected to be received\n     * @param data Extra data that may enable or not different behaviors depending on the source picked\n     */\n    function call(\n        uint8 source,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        bytes memory data\n    ) external payable nonReentrant whenNotPaused {\n        require(isSourceAllowed(source), 'SWAPPER_SOURCE_NOT_ALLOWED');\n        require(tokenIn != tokenOut, 'SWAPPER_SAME_TOKENS');\n        require(tokenIn != address(0), 'SWAPPER_TOKEN_IN_ZERO');\n        require(tokenOut != address(0), 'SWAPPER_TOKEN_OUT_ZERO');\n        require(amountIn > 0, 'SWAPPER_AMOUNT_IN_ZERO');\n        require(minAmountOut > 0, 'SWAPPER_MIN_AMOUNT_OUT_ZERO');\n\n        // Final swap amount in is either the wrapped amount in case token in is the native token,\n        // or the amount collected by the smart vault in case it is another ERC20 token\n        uint256 swapAmountIn;\n        if (Denominations.isNativeToken(tokenIn)) {\n            require(msg.value == amountIn, 'SWAPPER_UNEXPECTED_VALUE');\n            payable(address(smartVault)).sendValue(amountIn);\n            swapAmountIn = smartVault.wrap(amountIn, NO_DATA);\n        } else {\n            require(msg.value == 0, 'SWAPPER_VALUE_GT_ZERO');\n            require(IERC20(tokenIn).allowance(msg.sender, address(smartVault)) >= amountIn, 'SWAPPER_BAD_ALLOWANCE');\n            swapAmountIn = smartVault.collect(tokenIn, msg.sender, amountIn, NO_DATA);\n        }\n\n        // Note that the swap should only be executed if this is not actually a wrap/unwrap only action\n        // In that case, the action is already covered by the wrap (above) or unwrap (below)\n        uint256 amountOut;\n        address swapTokenIn = _wrappedIfNative(tokenIn);\n        address swapTokenOut = _wrappedIfNative(tokenOut);\n        if (swapTokenIn == swapTokenOut) {\n            amountOut = swapAmountIn;\n            require(amountOut >= minAmountOut, 'SWAPPER_WRAP_MIN_AMOUNT_OUT');\n        } else {\n            amountOut = smartVault.swap(\n                source,\n                swapTokenIn,\n                swapTokenOut,\n                swapAmountIn,\n                ISmartVault.SwapLimit.MinAmountOut,\n                minAmountOut,\n                data\n            );\n        }\n\n        // Finally unwrap if necessary and withdraw token out as requested to the sender\n        uint256 toWithdraw = Denominations.isNativeToken(tokenOut) ? smartVault.unwrap(amountOut, NO_DATA) : amountOut;\n        smartVault.withdraw(tokenOut, toWithdraw, msg.sender, NO_DATA);\n        emit Executed();\n    }\n}\n"},"@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\n/**\n * @title UncheckedMath\n * @dev Math library to perform unchecked operations\n */\nlibrary UncheckedMath {\n    /**\n     * @dev Unsafely adds two unsigned integers\n     */\n    function uncheckedAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return a + b;\n        }\n    }\n\n    /**\n     * @dev Unsafely subtracts two unsigned integers\n     */\n    function uncheckedSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Unsafely multiplies two unsigned integers\n     */\n    function uncheckedMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return a * b;\n        }\n    }\n\n    /**\n     * @dev Unsafely multiplies two signed integers\n     */\n    function uncheckedMul(int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            return a * b;\n        }\n    }\n\n    /**\n     * @dev Unsafely divides two unsigned integers\n     */\n    function uncheckedDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return a / b;\n        }\n    }\n}\n"},"@mimic-fi/v2-registry/contracts/implementations/BaseImplementation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/proxy/utils/Initializable.sol';\n\nimport './IImplementation.sol';\nimport '../registry/IRegistry.sol';\n\n/**\n * @title BaseImplementation\n * @dev This implementation contract comes with an immutable reference to an implementations registry where it should\n * be registered as well (checked during initialization). It allows requesting new instances of other registered\n * implementations to as another safety check to make sure valid instances are referenced in case it's needed.\n */\nabstract contract BaseImplementation is IImplementation {\n    // Immutable implementations registry reference\n    address public immutable override registry;\n\n    /**\n     * @dev Creates a new BaseImplementation\n     * @param _registry Address of the Mimic Registry where dependencies will be validated against\n     */\n    constructor(address _registry) {\n        registry = _registry;\n    }\n\n    /**\n     * @dev Internal function to validate a new dependency that must be registered as stateless.\n     * It checks the new dependency is registered, not deprecated, and stateless.\n     * @param dependency New stateless dependency to be set\n     */\n    function _validateStatelessDependency(address dependency) internal view {\n        require(_validateDependency(dependency), 'DEPENDENCY_NOT_STATELESS');\n    }\n\n    /**\n     * @dev Internal function to validate a new dependency that cannot be registered as stateless.\n     * It checks the new dependency is registered, not deprecated, and not stateful.\n     * @param dependency New stateful dependency to be set\n     */\n    function _validateStatefulDependency(address dependency) internal view {\n        require(!_validateDependency(dependency), 'DEPENDENCY_NOT_STATEFUL');\n    }\n\n    /**\n     * @dev Internal function to validate a new dependency. It checks the dependency is registered and not deprecated.\n     * @param dependency New dependency to be set\n     * @return Whether the dependency is stateless or not\n     */\n    function _validateDependency(address dependency) private view returns (bool) {\n        (bool stateless, bool deprecated, bytes32 namespace) = IRegistry(registry).implementationData(dependency);\n        require(namespace != bytes32(0), 'DEPENDENCY_NOT_REGISTERED');\n        require(!deprecated, 'DEPENDENCY_DEPRECATED');\n        return stateless;\n    }\n}\n"},"@mimic-fi/v2-smart-vault/contracts/SmartVault.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/utils/math/Math.sol';\n\nimport '@mimic-fi/v2-bridge-connector/contracts/IBridgeConnector.sol';\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\nimport '@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol';\nimport '@mimic-fi/v2-helpers/contracts/utils/Denominations.sol';\nimport '@mimic-fi/v2-helpers/contracts/utils/IWrappedNativeToken.sol';\nimport '@mimic-fi/v2-price-oracle/contracts/oracle/IPriceOracle.sol';\nimport '@mimic-fi/v2-price-oracle/contracts/feeds/PriceFeedProvider.sol';\nimport '@mimic-fi/v2-strategies/contracts/IStrategy.sol';\nimport '@mimic-fi/v2-swap-connector/contracts/ISwapConnector.sol';\nimport '@mimic-fi/v2-registry/contracts/implementations/InitializableAuthorizedImplementation.sol';\n\nimport './ISmartVault.sol';\nimport './helpers/StrategyLib.sol';\nimport './helpers/SwapConnectorLib.sol';\nimport './helpers/BridgeConnectorLib.sol';\n\n/**\n * @title Smart Vault\n * @dev Smart Vault contract where funds are being held offering a bunch of primitives to allow users model any\n * type of action to manage them, these are: collector, withdraw, swap, bridge, join, exit, bridge, wrap, and unwrap.\n *\n * It inherits from InitializableAuthorizedImplementation which means it's implementation can be cloned\n * from the Mimic Registry and should be initialized depending on each case.\n */\ncontract SmartVault is ISmartVault, PriceFeedProvider, InitializableAuthorizedImplementation {\n    using SafeERC20 for IERC20;\n    using FixedPoint for uint256;\n    using UncheckedMath for uint256;\n    using StrategyLib for address;\n    using SwapConnectorLib for address;\n    using BridgeConnectorLib for address;\n\n    // Namespace under which the Smart Vault is registered in the Mimic Registry\n    bytes32 public constant override NAMESPACE = keccak256('SMART_VAULT');\n\n    /**\n     * @dev Fee configuration parameters\n     * @param pct Percentage expressed using 16 decimals (1e18 = 100%)\n     * @param cap Maximum amount of fees to be charged per period\n     * @param token Address of the token to express the cap amount\n     * @param period Period length in seconds\n     * @param totalCharged Total amount of fees charged in the current period\n     * @param nextResetTime Current cap period end date\n     */\n    struct Fee {\n        uint256 pct;\n        uint256 cap;\n        address token;\n        uint256 period;\n        uint256 totalCharged;\n        uint256 nextResetTime;\n    }\n\n    // Price oracle reference\n    address public override priceOracle;\n\n    // Swap connector reference\n    address public override swapConnector;\n\n    // Bridge connector reference\n    address public override bridgeConnector;\n\n    // List of allowed strategies indexed by strategy address\n    mapping (address => bool) public override isStrategyAllowed;\n\n    // List of invested values indexed by strategy address\n    mapping (address => uint256) public override investedValue;\n\n    // Fee collector address where fees will be deposited\n    address public override feeCollector;\n\n    // Withdraw fee configuration\n    Fee public override withdrawFee;\n\n    // Performance fee configuration\n    Fee public override performanceFee;\n\n    // Swap fee configuration\n    Fee public override swapFee;\n\n    // Bridge fee configuration\n    Fee public override bridgeFee;\n\n    // Wrapped native token reference\n    address public immutable override wrappedNativeToken;\n\n    /**\n     * @dev Creates a new Smart Vault implementation with references that should be shared among all implementations\n     * @param _wrappedNativeToken Address of the wrapped native token to be used\n     * @param _registry Address of the Mimic Registry to be referenced\n     */\n    constructor(address _wrappedNativeToken, address _registry) InitializableAuthorizedImplementation(_registry) {\n        wrappedNativeToken = _wrappedNativeToken;\n    }\n\n    /**\n     * @dev Initializes the Smart Vault instance\n     * @param admin Address that will be granted with admin rights\n     */\n    function initialize(address admin) external initializer {\n        _initialize(admin);\n    }\n\n    /**\n     * @dev It allows receiving native token transfers\n     */\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Sets a new strategy as allowed or not for a Smart Vault. Sender must be authorized.\n     * @param strategy Address of the strategy to be set\n     * @param allowed Whether the strategy is allowed or not\n     */\n    function setStrategy(address strategy, bool allowed) external override auth {\n        _setStrategy(strategy, allowed);\n    }\n\n    /**\n     * @dev Sets a new price oracle to a Smart Vault. Sender must be authorized.\n     * @param newPriceOracle Address of the new price oracle to be set\n     */\n    function setPriceOracle(address newPriceOracle) external override auth {\n        _setPriceOracle(newPriceOracle);\n    }\n\n    /**\n     * @dev Sets a new swap connector to a Smart Vault. Sender must be authorized.\n     * @param newSwapConnector Address of the new swap connector to be set\n     */\n    function setSwapConnector(address newSwapConnector) external override auth {\n        _setSwapConnector(newSwapConnector);\n    }\n\n    /**\n     * @dev Sets a new bridge connector to a Smart Vault. Sender must be authorized.\n     * @param newBridgeConnector Address of the new bridge connector to be set\n     */\n    function setBridgeConnector(address newBridgeConnector) external override auth {\n        _setBridgeConnector(newBridgeConnector);\n    }\n\n    /**\n     * @dev Sets a new fee collector. Sender must be authorized.\n     * @param newFeeCollector Address of the new fee collector to be set\n     */\n    function setFeeCollector(address newFeeCollector) external override auth {\n        _setFeeCollector(newFeeCollector);\n    }\n\n    /**\n     * @dev Sets a new withdraw fee. Sender must be authorized.\n     * @param pct Withdraw fee percentage to be set\n     * @param cap New maximum amount of withdraw fees to be charged per period\n     * @param token Address of the token cap to be set\n     * @param period New cap period length in seconds for the withdraw fee\n     */\n    function setWithdrawFee(uint256 pct, uint256 cap, address token, uint256 period) external override auth {\n        _setFeeConfiguration(withdrawFee, pct, cap, token, period);\n        emit WithdrawFeeSet(pct, cap, token, period);\n    }\n\n    /**\n     * @dev Sets a new performance fee. Sender must be authorized.\n     * @param pct Performance fee percentage to be set\n     * @param cap New maximum amount of performance fees to be charged per period\n     * @param token Address of the token cap to be set\n     * @param period New cap period length in seconds for the performance fee\n     */\n    function setPerformanceFee(uint256 pct, uint256 cap, address token, uint256 period) external override auth {\n        _setFeeConfiguration(performanceFee, pct, cap, token, period);\n        emit PerformanceFeeSet(pct, cap, token, period);\n    }\n\n    /**\n     * @dev Sets a new swap fee. Sender must be authorized.\n     * @param pct New swap fee percentage to be set\n     * @param cap New maximum amount of swap fees to be charged per period\n     * @param token Address of the token cap to be set\n     * @param period New cap period length in seconds for the swap fee\n     */\n    function setSwapFee(uint256 pct, uint256 cap, address token, uint256 period) external override auth {\n        _setFeeConfiguration(swapFee, pct, cap, token, period);\n        emit SwapFeeSet(pct, cap, token, period);\n    }\n\n    /**\n     * @dev Sets a new bridge fee. Sender must be authorized.\n     * @param pct New bridge fee percentage to be set\n     * @param cap New maximum amount of bridge fees to be charged per period\n     * @param token Address of the token cap to be set\n     * @param period New cap period length in seconds for the bridge fee\n     */\n    function setBridgeFee(uint256 pct, uint256 cap, address token, uint256 period) external override auth {\n        _setFeeConfiguration(bridgeFee, pct, cap, token, period);\n        emit BridgeFeeSet(pct, cap, token, period);\n    }\n\n    /**\n     * @dev Sets a of price feed\n     * @param base Token base to be set\n     * @param quote Token quote to be set\n     * @param feed Price feed to be set\n     */\n    function setPriceFeed(address base, address quote, address feed)\n        public\n        override(IPriceFeedProvider, PriceFeedProvider)\n        auth\n    {\n        super.setPriceFeed(base, quote, feed);\n    }\n\n    /**\n     * @dev Tells the price of a token (base) in a given quote\n     * @param base Token to rate\n     * @param quote Token used for the price rate\n     */\n    function getPrice(address base, address quote) public view override returns (uint256) {\n        return IPriceOracle(priceOracle).getPrice(address(this), base, quote);\n    }\n\n    /**\n     * @dev Tells the last value accrued for a strategy. Note this value can be outdated.\n     * @param strategy Address of the strategy querying the last value of\n     */\n    function lastValue(address strategy) public view override returns (uint256) {\n        return IStrategy(strategy).lastValue(address(this));\n    }\n\n    /**\n     * @dev Execute an arbitrary call from a Smart Vault. Sender must be authorized.\n     * @param target Address where the call will be sent\n     * @param data Calldata to be used for the call\n     * @param value Value in wei that will be attached to the call\n     * @return result Call response if it was successful, otherwise it reverts\n     */\n    function call(address target, bytes memory callData, uint256 value, bytes memory data)\n        external\n        override\n        auth\n        returns (bytes memory result)\n    {\n        result = Address.functionCallWithValue(target, callData, value, 'SMART_VAULT_ARBITRARY_CALL_FAIL');\n        emit Call(target, callData, value, result, data);\n    }\n\n    /**\n     * @dev Collect tokens from an external account to a Smart Vault. Sender must be authorized.\n     * @param token Address of the token to be collected\n     * @param from Address where the tokens will be transfer from\n     * @param amount Amount of tokens to be transferred\n     * @param data Extra data only logged\n     * @return collected Amount of tokens collected\n     */\n    function collect(address token, address from, uint256 amount, bytes memory data)\n        external\n        override\n        auth\n        returns (uint256 collected)\n    {\n        require(amount > 0, 'COLLECT_AMOUNT_ZERO');\n\n        uint256 previousBalance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(from, address(this), amount);\n        uint256 currentBalance = IERC20(token).balanceOf(address(this));\n\n        collected = currentBalance - previousBalance;\n        emit Collect(token, from, collected, data);\n    }\n\n    /**\n     * @dev Withdraw tokens to an external account. Sender must be authorized.\n     * @param token Address of the token to be withdrawn\n     * @param amount Amount of tokens to withdraw\n     * @param recipient Address where the tokens will be transferred to\n     * @param data Extra data only logged\n     * @return withdrawn Amount of tokens transferred to the recipient address\n     */\n    function withdraw(address token, uint256 amount, address recipient, bytes memory data)\n        external\n        override\n        auth\n        returns (uint256 withdrawn)\n    {\n        require(amount > 0, 'WITHDRAW_AMOUNT_ZERO');\n        require(recipient != address(0), 'RECIPIENT_ZERO');\n\n        uint256 withdrawFeeAmount = recipient == feeCollector ? 0 : _payFee(token, amount, withdrawFee);\n        withdrawn = amount - withdrawFeeAmount;\n        _safeTransfer(token, recipient, withdrawn);\n        emit Withdraw(token, recipient, withdrawn, withdrawFeeAmount, data);\n    }\n\n    /**\n     * @dev Wrap an amount of native tokens to the wrapped ERC20 version of it. Sender must be authorized.\n     * @param amount Amount of native tokens to be wrapped\n     * @param data Extra data only logged\n     * @return wrapped Amount of tokens wrapped\n     */\n    function wrap(uint256 amount, bytes memory data) external override auth returns (uint256 wrapped) {\n        require(amount > 0, 'WRAP_AMOUNT_ZERO');\n        require(address(this).balance >= amount, 'WRAP_INSUFFICIENT_AMOUNT');\n\n        IWrappedNativeToken wrappedToken = IWrappedNativeToken(wrappedNativeToken);\n        uint256 previousBalance = wrappedToken.balanceOf(address(this));\n        wrappedToken.deposit{ value: amount }();\n        uint256 currentBalance = wrappedToken.balanceOf(address(this));\n\n        wrapped = currentBalance - previousBalance;\n        emit Wrap(amount, wrapped, data);\n    }\n\n    /**\n     * @dev Unwrap an amount of wrapped native tokens. Sender must be authorized.\n     * @param amount Amount of wrapped native tokens to unwrapped\n     * @param data Extra data only logged\n     * @return unwrapped Amount of tokens unwrapped\n     */\n    function unwrap(uint256 amount, bytes memory data) external override auth returns (uint256 unwrapped) {\n        require(amount > 0, 'UNWRAP_AMOUNT_ZERO');\n\n        uint256 previousBalance = address(this).balance;\n        IWrappedNativeToken(wrappedNativeToken).withdraw(amount);\n        uint256 currentBalance = address(this).balance;\n\n        unwrapped = currentBalance - previousBalance;\n        emit Unwrap(amount, unwrapped, data);\n    }\n\n    /**\n     * @dev Claim strategy rewards. Sender must be authorized.\n     * @param strategy Address of the strategy to claim rewards\n     * @param data Extra data passed to the strategy and logged\n     * @return tokens Addresses of the tokens received as rewards\n     * @return amounts Amounts of the tokens received as rewards\n     */\n    function claim(address strategy, bytes memory data)\n        external\n        override\n        auth\n        returns (address[] memory tokens, uint256[] memory amounts)\n    {\n        require(isStrategyAllowed[strategy], 'STRATEGY_NOT_ALLOWED');\n        (tokens, amounts) = strategy.claim(data);\n        emit Claim(strategy, tokens, amounts, data);\n    }\n\n    /**\n     * @dev Join a strategy with an amount of tokens. Sender must be authorized.\n     * @param strategy Address of the strategy to join\n     * @param tokensIn List of token addresses to join with\n     * @param amountsIn List of token amounts to join with\n     * @param slippage Slippage that will be used to compute the join\n     * @param data Extra data passed to the strategy and logged\n     * @return tokensOut List of token addresses received after the join\n     * @return amountsOut List of token amounts received after the join\n     */\n    function join(\n        address strategy,\n        address[] memory tokensIn,\n        uint256[] memory amountsIn,\n        uint256 slippage,\n        bytes memory data\n    ) external override auth returns (address[] memory tokensOut, uint256[] memory amountsOut) {\n        require(isStrategyAllowed[strategy], 'STRATEGY_NOT_ALLOWED');\n        require(slippage <= FixedPoint.ONE, 'JOIN_SLIPPAGE_ABOVE_ONE');\n        require(tokensIn.length == amountsIn.length, 'JOIN_INPUT_INVALID_LENGTH');\n\n        uint256 value;\n        (tokensOut, amountsOut, value) = strategy.join(tokensIn, amountsIn, slippage, data);\n        require(tokensOut.length == amountsOut.length, 'JOIN_OUTPUT_INVALID_LENGTH');\n\n        investedValue[strategy] = investedValue[strategy] + value;\n        emit Join(strategy, tokensIn, amountsIn, tokensOut, amountsOut, value, slippage, data);\n    }\n\n    /**\n     * @dev Exit a strategy. Sender must be authorized.\n     * @param strategy Address of the strategy to exit\n     * @param tokensIn List of token addresses to exit with\n     * @param amountsIn List of token amounts to exit with\n     * @param slippage Slippage that will be used to compute the exit\n     * @param data Extra data passed to the strategy and logged\n     * @return tokensOut List of token addresses received after the exit\n     * @return amountsOut List of token amounts received after the exit\n     */\n    function exit(\n        address strategy,\n        address[] memory tokensIn,\n        uint256[] memory amountsIn,\n        uint256 slippage,\n        bytes memory data\n    ) external override auth returns (address[] memory tokensOut, uint256[] memory amountsOut) {\n        require(isStrategyAllowed[strategy], 'STRATEGY_NOT_ALLOWED');\n        require(investedValue[strategy] > 0, 'EXIT_NO_INVESTED_VALUE');\n        require(slippage <= FixedPoint.ONE, 'EXIT_SLIPPAGE_ABOVE_ONE');\n        require(tokensIn.length == amountsIn.length, 'EXIT_INPUT_INVALID_LENGTH');\n\n        uint256 value;\n        (tokensOut, amountsOut, value) = strategy.exit(tokensIn, amountsIn, slippage, data);\n        require(tokensOut.length == amountsOut.length, 'EXIT_OUTPUT_INVALID_LENGTH');\n        uint256[] memory performanceFeeAmounts = new uint256[](amountsOut.length);\n\n        // It can rely on the last updated value since we have just exited, no need to compute current value\n        uint256 valueBeforeExit = lastValue(strategy) + value;\n        if (valueBeforeExit <= investedValue[strategy]) {\n            // There were losses, invested value is simply reduced using the exited ratio compared to the value\n            // before exit. Invested value is round up to avoid interpreting losses due to rounding errors\n            investedValue[strategy] -= investedValue[strategy].mulUp(value).divUp(valueBeforeExit);\n        } else {\n            // If value gains are greater than the exit value, it means only gains are being withdrawn. In that case\n            // the taxable amount is the entire exited amount, otherwise it should be the equivalent gains ratio of it.\n            uint256 valueGains = valueBeforeExit.uncheckedSub(investedValue[strategy]);\n            bool onlyGains = valueGains >= value;\n\n            // If the exit value is greater than the value gains, the invested value should be reduced by the portion\n            // of the invested value being exited. Otherwise, it's still the same, only gains are being withdrawn.\n            // No need for checked math as we are checking it manually beforehand\n            uint256 decrement = onlyGains ? 0 : value.uncheckedSub(valueGains);\n            investedValue[strategy] = investedValue[strategy] - decrement;\n\n            // Compute performance fees per token out\n            for (uint256 i = 0; i < tokensOut.length; i = i.uncheckedAdd(1)) {\n                address token = tokensOut[i];\n                uint256 amount = amountsOut[i];\n                uint256 taxableAmount = onlyGains ? amount : ((amount * valueGains) / value);\n                uint256 feeAmount = _payFee(token, taxableAmount, performanceFee);\n                amountsOut[i] = amount - feeAmount;\n                performanceFeeAmounts[i] = feeAmount;\n            }\n        }\n\n        emit Exit(strategy, tokensIn, amountsIn, tokensOut, amountsOut, value, performanceFeeAmounts, slippage, data);\n    }\n\n    /**\n     * @dev Swaps two tokens. Sender must be authorized.\n     * @param source Source to request the swap: Uniswap V2, Uniswap V3, Balancer V2, or Paraswap V5.\n     * @param tokenIn Token being sent\n     * @param tokenOut Token being received\n     * @param amountIn Amount of tokenIn being swapped\n     * @param limitType Swap limit to be applied: slippage or min amount out\n     * @param limitAmount Amount of the swap limit to be applied depending on limitType\n     * @param data Encoded data to specify different swap parameters depending on the source picked\n     * @return amountOut Received amount of tokens out\n     */\n    function swap(\n        uint8 source,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        SwapLimit limitType,\n        uint256 limitAmount,\n        bytes memory data\n    ) external override auth returns (uint256 amountOut) {\n        require(tokenIn != tokenOut, 'SWAP_SAME_TOKEN');\n        require(swapConnector != address(0), 'SWAP_CONNECTOR_NOT_SET');\n\n        uint256 minAmountOut;\n        if (limitType == SwapLimit.MinAmountOut) {\n            minAmountOut = limitAmount;\n        } else if (limitType == SwapLimit.Slippage) {\n            require(limitAmount <= FixedPoint.ONE, 'SWAP_SLIPPAGE_ABOVE_ONE');\n            uint256 price = getPrice(tokenIn, tokenOut);\n            // No need for checked math as we are checking it manually beforehand\n            // Always round up the expected min amount out. Limit amount is slippage.\n            minAmountOut = amountIn.mulUp(price).mulUp(FixedPoint.ONE.uncheckedSub(limitAmount));\n        } else {\n            revert('SWAP_INVALID_LIMIT_TYPE');\n        }\n\n        uint256 preBalanceIn = IERC20(tokenIn).balanceOf(address(this));\n        uint256 preBalanceOut = IERC20(tokenOut).balanceOf(address(this));\n        swapConnector.swap(source, tokenIn, tokenOut, amountIn, minAmountOut, data);\n\n        uint256 postBalanceIn = IERC20(tokenIn).balanceOf(address(this));\n        require(postBalanceIn >= preBalanceIn - amountIn, 'SWAP_BAD_TOKEN_IN_BALANCE');\n\n        uint256 amountOutBeforeFees = IERC20(tokenOut).balanceOf(address(this)) - preBalanceOut;\n        require(amountOutBeforeFees >= minAmountOut, 'SWAP_MIN_AMOUNT');\n\n        uint256 swapFeeAmount = _payFee(tokenOut, amountOutBeforeFees, swapFee);\n        amountOut = amountOutBeforeFees - swapFeeAmount;\n        emit Swap(source, tokenIn, tokenOut, amountIn, amountOut, minAmountOut, swapFeeAmount, data);\n    }\n\n    /**\n     * @dev Bridge assets to another chain\n     * @param source Source to request the bridge. It depends on the Bridge Connector attached to a Smart Vault.\n     * @param chainId ID of the destination chain\n     * @param token Address of the token to be bridged\n     * @param amount Amount of tokens to be bridged\n     * @param limitType Bridge limit to be applied: slippage or min amount out\n     * @param limitAmount Amount of the swap limit to be applied depending on limitType\n     * @param recipient Address that will receive the tokens on the destination chain\n     * @param data Encoded data to specify different bridge parameters depending on the source picked\n     * @return bridged Amount requested to be bridged after fees\n     */\n    function bridge(\n        uint8 source,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        BridgeLimit limitType,\n        uint256 limitAmount,\n        address recipient,\n        bytes memory data\n    ) external override auth returns (uint256 bridged) {\n        require(block.chainid != chainId, 'BRIDGE_SAME_CHAIN');\n        require(recipient != address(0), 'BRIDGE_RECIPIENT_ZERO');\n        require(bridgeConnector != address(0), 'BRIDGE_CONNECTOR_NOT_SET');\n\n        uint256 bridgeFeeAmount = _payFee(token, amount, bridgeFee);\n        bridged = amount - bridgeFeeAmount;\n\n        uint256 minAmountOut;\n        if (limitType == BridgeLimit.MinAmountOut) {\n            minAmountOut = limitAmount;\n        } else if (limitType == BridgeLimit.Slippage) {\n            require(limitAmount <= FixedPoint.ONE, 'BRIDGE_SLIPPAGE_ABOVE_ONE');\n            // No need for checked math as we are checking it manually beforehand\n            // Always round up the expected min amount out. Limit amount is slippage.\n            minAmountOut = bridged.mulUp(FixedPoint.ONE.uncheckedSub(limitAmount));\n        } else {\n            revert('BRIDGE_INVALID_LIMIT_TYPE');\n        }\n\n        uint256 preBalanceIn = IERC20(token).balanceOf(address(this));\n        bridgeConnector.bridge(source, chainId, token, bridged, minAmountOut, recipient, data);\n        uint256 postBalanceIn = IERC20(token).balanceOf(address(this));\n        require(postBalanceIn >= preBalanceIn - bridged, 'BRIDGE_BAD_TOKEN_IN_BALANCE');\n\n        emit Bridge(source, chainId, token, bridged, minAmountOut, bridgeFeeAmount, recipient, data);\n    }\n\n    /**\n     * @dev Internal function to pay the amount of fees to be charged based on a fee configuration to the fee collector\n     * @param token Token being charged\n     * @param amount Token amount to be taxed with fees\n     * @param fee Fee configuration to be applied\n     * @return paidAmount Amount of fees paid to the fee collector\n     */\n    function _payFee(address token, uint256 amount, Fee storage fee) internal returns (uint256 paidAmount) {\n        // Fee amounts are always rounded down\n        uint256 feeAmount = amount.mulDown(fee.pct);\n\n        // If cap amount or cap period are not set, charge the entire amount\n        if (fee.token == address(0) || fee.cap == 0 || fee.period == 0) {\n            _safeTransfer(token, feeCollector, feeAmount);\n            return feeAmount;\n        }\n\n        // Reset cap totalizator if necessary\n        if (block.timestamp >= fee.nextResetTime) {\n            fee.totalCharged = 0;\n            fee.nextResetTime = block.timestamp + fee.period;\n        }\n\n        // Calc fee amount in the fee token used for the cap\n        uint256 feeTokenPrice = getPrice(token, fee.token);\n        uint256 feeAmountInFeeToken = feeAmount.mulDown(feeTokenPrice);\n\n        // Compute fee amount picking the minimum between the chargeable amount and the remaining part for the cap\n        if (fee.totalCharged + feeAmountInFeeToken <= fee.cap) {\n            paidAmount = feeAmount;\n            fee.totalCharged += feeAmountInFeeToken;\n        } else if (fee.totalCharged < fee.cap) {\n            paidAmount = (fee.cap.uncheckedSub(fee.totalCharged) * feeAmount) / feeAmountInFeeToken;\n            fee.totalCharged = fee.cap;\n        } else {\n            // This case is when the total charged amount is already greater than the cap amount. It could happen if\n            // the cap amounts is decreased or if the cap token is changed. In this case the total charged amount is\n            // not updated, and the amount to paid is zero.\n            paidAmount = 0;\n        }\n\n        // Pay fee amount to the fee collector\n        _safeTransfer(token, feeCollector, paidAmount);\n    }\n\n    /**\n     * @dev Internal method to transfer ERC20 or native tokens from a Smart Vault\n     * @param token Address of the ERC20 token to transfer\n     * @param to Address transferring the tokens to\n     * @param amount Amount of tokens to transfer\n     */\n    function _safeTransfer(address token, address to, uint256 amount) internal {\n        if (amount == 0) return;\n        if (Denominations.isNativeToken(token)) Address.sendValue(payable(to), amount);\n        else IERC20(token).safeTransfer(to, amount);\n    }\n\n    /**\n     * @dev Sets a new strategy as allowed or not\n     * @param strategy Address of the strategy to be set\n     * @param allowed Whether the strategy is allowed or not\n     */\n    function _setStrategy(address strategy, bool allowed) internal {\n        if (allowed) _validateStatelessDependency(strategy);\n        isStrategyAllowed[strategy] = allowed;\n        emit StrategySet(strategy, allowed);\n    }\n\n    /**\n     * @dev Sets a new price oracle\n     * @param newPriceOracle New price oracle to be set\n     */\n    function _setPriceOracle(address newPriceOracle) internal {\n        _validateStatelessDependency(newPriceOracle);\n        priceOracle = newPriceOracle;\n        emit PriceOracleSet(newPriceOracle);\n    }\n\n    /**\n     * @dev Sets a new swap connector\n     * @param newSwapConnector New swap connector to be set\n     */\n    function _setSwapConnector(address newSwapConnector) internal {\n        _validateStatelessDependency(newSwapConnector);\n        swapConnector = newSwapConnector;\n        emit SwapConnectorSet(newSwapConnector);\n    }\n\n    /**\n     * @dev Sets a new bridge connector\n     * @param newBridgeConnector New bridge connector to be set\n     */\n    function _setBridgeConnector(address newBridgeConnector) internal {\n        _validateStatelessDependency(newBridgeConnector);\n        bridgeConnector = newBridgeConnector;\n        emit BridgeConnectorSet(newBridgeConnector);\n    }\n\n    /**\n     * @dev Internal method to set the fee collector\n     * @param newFeeCollector New fee collector to be set\n     */\n    function _setFeeCollector(address newFeeCollector) internal {\n        require(newFeeCollector != address(0), 'FEE_COLLECTOR_ZERO');\n        feeCollector = newFeeCollector;\n        emit FeeCollectorSet(newFeeCollector);\n    }\n\n    /**\n     * @dev Internal method to set a new fee cap configuration\n     * @param fee Fee configuration to be updated\n     * @param pct Fee percentage to be set\n     * @param cap New maximum amount of fees to be charged per period\n     * @param token Address of the token cap to be set\n     * @param period New cap period length in seconds\n     */\n    function _setFeeConfiguration(Fee storage fee, uint256 pct, uint256 cap, address token, uint256 period) internal {\n        require(pct <= FixedPoint.ONE, 'FEE_PCT_ABOVE_ONE');\n\n        // If there is no fee percentage, there must not be a fee cap\n        bool isZeroCap = token == address(0) && cap == 0 && period == 0;\n        require(pct != 0 || isZeroCap, 'INVALID_CAP_WITH_FEE_ZERO');\n\n        // If there is a cap, all values must be non-zero\n        bool isNonZeroCap = token != address(0) && cap != 0 && period != 0;\n        require(isZeroCap || isNonZeroCap, 'INCONSISTENT_CAP_VALUES');\n\n        // Changing the fee percentage does not affect the totalizator at all, it only affects future fee charges\n        fee.pct = pct;\n\n        // Changing the fee cap amount does not affect the totalizator, it only applies when changing the for the total\n        // charged amount. Note that it can happen that the cap amount is lower than the total charged amount if the\n        // cap amount is lowered. However, there shouldn't be any accounting issues with that.\n        fee.cap = cap;\n\n        // Changing the cap period only affects the end time of the next period, but not the end date of the current one\n        fee.period = period;\n\n        // Therefore, only clean the totalizators if the cap is being removed\n        if (isZeroCap) {\n            fee.totalCharged = 0;\n            fee.nextResetTime = 0;\n        } else {\n            // If cap values are not zero, set the next reset time if it wasn't set already\n            // Otherwise, if the cap token is being changed the total charged amount must be updated accordingly\n            if (fee.nextResetTime == 0) {\n                fee.nextResetTime = block.timestamp + period;\n            } else if (fee.token != token) {\n                uint256 newTokenPrice = getPrice(fee.token, token);\n                fee.totalCharged = fee.totalCharged.mulDown(newTokenPrice);\n            }\n        }\n\n        // Finally simply set the new requested token\n        fee.token = token;\n    }\n}\n"},"@mimic-fi/v2-smart-vaults-base/contracts/actions/ReceiverAction.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\n\nimport './BaseAction.sol';\n\nabstract contract ReceiverAction is BaseAction {\n    using SafeERC20 for IERC20;\n\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function transferToSmartVault(address token, uint256 amount) external auth {\n        _transferToSmartVault(token, amount);\n    }\n\n    function _transferToSmartVault(address token, uint256 amount) internal {\n        ERC20Helpers.transfer(token, address(smartVault), amount);\n    }\n}\n"},"@mimic-fi/v2-smart-vaults-base/contracts/deploy/Deployer.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@mimic-fi/v2-smart-vault/contracts/SmartVault.sol';\nimport '@mimic-fi/v2-smart-vault/contracts/ISmartVaultsFactory.sol';\nimport '@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol';\nimport '@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol';\nimport '@mimic-fi/v2-registry/contracts/registry/IRegistry.sol';\n\nimport '../actions/ReceiverAction.sol';\nimport '../actions/RelayedAction.sol';\nimport '../actions/TimeLockedAction.sol';\nimport '../actions/TokenThresholdAction.sol';\nimport '../actions/WithdrawalAction.sol';\nimport '../permissions/PermissionsManager.sol';\nimport '../permissions/PermissionsHelpers.sol';\n\n/**\n * @title Deployer\n * @dev Deployer library offering a bunch of set-up methods to deploy and customize smart vaults\n */\nlibrary Deployer {\n    using UncheckedMath for uint256;\n    using PermissionsHelpers for PermissionsManager;\n\n    // Namespace to use by this deployer to fetch ISmartVaultFactory implementations from the Mimic Registry\n    bytes32 private constant SMART_VAULT_FACTORY_NAMESPACE = keccak256('SMART_VAULTS_FACTORY');\n\n    // Namespace to use by this deployer to fetch ISmartVault implementations from the Mimic Registry\n    bytes32 private constant SMART_VAULT_NAMESPACE = keccak256('SMART_VAULT');\n\n    // Namespace to use by this deployer to fetch IStrategy implementations from the Mimic Registry\n    bytes32 private constant STRATEGY_NAMESPACE = keccak256('STRATEGY');\n\n    // Namespace to use by this deployer to fetch IPriceOracle implementations from the Mimic Registry\n    bytes32 private constant PRICE_ORACLE_NAMESPACE = keccak256('PRICE_ORACLE');\n\n    // Namespace to use by this deployer to fetch ISwapConnector implementations from the Mimic Registry\n    bytes32 private constant SWAP_CONNECTOR_NAMESPACE = keccak256('SWAP_CONNECTOR');\n\n    // Namespace to use by this deployer to fetch IBridgeConnector implementations from the Mimic Registry\n    bytes32 private constant BRIDGE_CONNECTOR_NAMESPACE = keccak256('BRIDGE_CONNECTOR');\n\n    /**\n     * @dev Smart vault params\n     * @param factory Address of the factory that will be used to deploy an instance of the Smart Vault implementation\n     * @param impl Address of the Smart Vault implementation to be used\n     * @param salt Salt bytes to derivate the address of the new Smart Vault instance\n     * @param admin Address that will be granted with admin rights for the deployed Smart Vault\n     * @param bridgeConnector Optional Bridge Connector to set for the Smart Vault\n     * @param swapConnector Optional Swap Connector to set for the Smart Vault\n     * @param strategies List of strategies to be allowed for the Smart Vault\n     * @param priceOracle Optional Price Oracle to set for the Smart Vault\n     * @param priceFeedParams List of price feeds to be set for the Smart Vault\n     * @param feeCollector Address to be set as the fee collector\n     * @param swapFee Swap fee params\n     * @param bridgeFee Bridge fee params\n     * @param withdrawFee Withdraw fee params\n     * @param performanceFee Performance fee params\n     */\n    struct SmartVaultParams {\n        address factory;\n        address impl;\n        bytes32 salt;\n        address admin;\n        address[] strategies;\n        address bridgeConnector;\n        address swapConnector;\n        address priceOracle;\n        PriceFeedParams[] priceFeedParams;\n        address feeCollector;\n        address feeCollectorAdmin;\n        SmartVaultFeeParams swapFee;\n        SmartVaultFeeParams bridgeFee;\n        SmartVaultFeeParams withdrawFee;\n        SmartVaultFeeParams performanceFee;\n    }\n\n    /**\n     * @dev Smart Vault price feed params\n     * @param base Base token of the price feed\n     * @param quote Quote token of the price feed\n     * @param feed Address of the price feed\n     */\n    struct PriceFeedParams {\n        address base;\n        address quote;\n        address feed;\n    }\n\n    /**\n     * @dev Smart Vault fee configuration parameters\n     * @param pct Percentage expressed using 16 decimals (1e18 = 100%)\n     * @param cap Maximum amount of fees to be charged per period\n     * @param token Address of the token to express the cap amount\n     * @param period Period length in seconds\n     */\n    struct SmartVaultFeeParams {\n        uint256 pct;\n        uint256 cap;\n        address token;\n        uint256 period;\n    }\n\n    /**\n     * @dev Relayed action params\n     * @param relayers List of addresses to be marked as allowed executors and in particular as authorized relayers\n     * @param gasPriceLimit Gas price limit to be used for the relayed action\n     * @param txCostLimit Total transaction cost limit to be used for the relayed action\n     */\n    struct RelayedActionParams {\n        address[] relayers;\n        uint256 gasPriceLimit;\n        uint256 txCostLimit;\n    }\n\n    /**\n     * @dev Token threshold action params\n     * @param token Address of the token of the threshold\n     * @param amount Amount of tokens of the threshold\n     */\n    struct TokenThresholdActionParams {\n        address token;\n        uint256 amount;\n    }\n\n    /**\n     * @dev Time-locked action params\n     * @param period Period in seconds to be set for the time lock\n     */\n    struct TimeLockedActionParams {\n        uint256 period;\n    }\n\n    /**\n     * @dev Withdrawal action params\n     * @param recipient Address that will receive the funds from the withdraw action\n     */\n    struct WithdrawalActionParams {\n        address recipient;\n    }\n\n    /**\n     * @dev Transfer Permission Manager control to a list of owners\n     * @param manager Permissions manager that will control the entire Smart Vault and its actions\n     * @param owners Addresses that will be able to call the permission manager\n     */\n    function transferPermissionManagerControl(PermissionsManager manager, address[] memory owners) external {\n        manager.authorize(manager, owners, manager.execute.selector);\n        manager.unauthorize(manager, address(this), manager.execute.selector);\n    }\n\n    /**\n     * @dev Create a new Smart Vault instance\n     * @param registry Address of the registry to validate the Smart Vault implementation\n     * @param manager Permissions manager that will control the entire Smart Vault and its actions\n     * @param params Params to customize the Smart Vault to be deployed\n     * creating the Smart Vault. Sometimes this is not desired if further customization might take in place.\n     */\n    function createSmartVault(IRegistry registry, PermissionsManager manager, SmartVaultParams memory params)\n        external\n        returns (SmartVault smartVault)\n    {\n        require(params.admin != address(0), 'SMART_VAULT_ADMIN_ZERO');\n        require(params.feeCollectorAdmin != address(0), 'SMART_VAULT_FEE_ADMIN_ZERO');\n\n        // Clone requested Smart Vault implementation and initialize\n        require(registry.isActive(SMART_VAULT_FACTORY_NAMESPACE, params.factory), 'BAD_SMART_VAULT_FACTORY_IMPL');\n        ISmartVaultsFactory factory = ISmartVaultsFactory(params.factory);\n\n        bytes memory initializeData = abi.encodeWithSelector(SmartVault.initialize.selector, address(manager));\n        bytes32 senderSalt = keccak256(abi.encodePacked(msg.sender, params.salt));\n        smartVault = SmartVault(payable(factory.create(senderSalt, params.impl, initializeData)));\n\n        // Authorize admin to perform any action except from fee collector setter\n        bytes4[] memory whats = new bytes4[](19);\n        whats[0] = smartVault.collect.selector;\n        whats[1] = smartVault.withdraw.selector;\n        whats[2] = smartVault.wrap.selector;\n        whats[3] = smartVault.unwrap.selector;\n        whats[4] = smartVault.claim.selector;\n        whats[5] = smartVault.join.selector;\n        whats[6] = smartVault.exit.selector;\n        whats[7] = smartVault.swap.selector;\n        whats[8] = smartVault.bridge.selector;\n        whats[9] = smartVault.setStrategy.selector;\n        whats[10] = smartVault.setPriceFeed.selector;\n        whats[11] = smartVault.setPriceFeeds.selector;\n        whats[12] = smartVault.setPriceOracle.selector;\n        whats[13] = smartVault.setSwapConnector.selector;\n        whats[14] = smartVault.setBridgeConnector.selector;\n        whats[15] = smartVault.setWithdrawFee.selector;\n        whats[16] = smartVault.setPerformanceFee.selector;\n        whats[17] = smartVault.setSwapFee.selector;\n        whats[18] = smartVault.setBridgeFee.selector;\n        manager.authorize(smartVault, params.admin, whats);\n\n        // Set price feeds if any\n        if (params.priceFeedParams.length > 0) {\n            manager.authorize(smartVault, address(this), smartVault.setPriceFeed.selector);\n            for (uint256 i = 0; i < params.priceFeedParams.length; i = i.uncheckedAdd(1)) {\n                PriceFeedParams memory feedParams = params.priceFeedParams[i];\n                smartVault.setPriceFeed(feedParams.base, feedParams.quote, feedParams.feed);\n            }\n            manager.unauthorize(smartVault, address(this), smartVault.setPriceFeed.selector);\n        }\n\n        // Set price oracle if given\n        if (params.priceOracle != address(0)) {\n            require(registry.isActive(PRICE_ORACLE_NAMESPACE, params.priceOracle), 'BAD_PRICE_ORACLE_DEPENDENCY');\n            manager.authorize(smartVault, address(this), smartVault.setPriceOracle.selector);\n            smartVault.setPriceOracle(params.priceOracle);\n            manager.unauthorize(smartVault, address(this), smartVault.setPriceOracle.selector);\n        }\n\n        // Set strategies if any\n        if (params.strategies.length > 0) {\n            manager.authorize(smartVault, address(this), smartVault.setStrategy.selector);\n            for (uint256 i = 0; i < params.strategies.length; i = i.uncheckedAdd(1)) {\n                require(registry.isActive(STRATEGY_NAMESPACE, params.strategies[i]), 'BAD_STRATEGY_DEPENDENCY');\n                smartVault.setStrategy(params.strategies[i], true);\n            }\n            manager.unauthorize(smartVault, address(this), smartVault.setStrategy.selector);\n        }\n\n        // Set swap connector if given\n        if (params.swapConnector != address(0)) {\n            require(registry.isActive(SWAP_CONNECTOR_NAMESPACE, params.swapConnector), 'BAD_SWAP_CONNECTOR_DEPENDENCY');\n            manager.authorize(smartVault, address(this), smartVault.setSwapConnector.selector);\n            smartVault.setSwapConnector(params.swapConnector);\n            manager.unauthorize(smartVault, address(this), smartVault.setSwapConnector.selector);\n        }\n\n        // Set bridge connector if given\n        if (params.bridgeConnector != address(0)) {\n            bool isActive = registry.isActive(BRIDGE_CONNECTOR_NAMESPACE, params.bridgeConnector);\n            require(isActive, 'BAD_BRIDGE_CONNECTOR_DEPENDENCY');\n            manager.authorize(smartVault, address(this), smartVault.setBridgeConnector.selector);\n            smartVault.setBridgeConnector(params.bridgeConnector);\n            manager.unauthorize(smartVault, address(this), smartVault.setBridgeConnector.selector);\n        }\n\n        // If no fee collector is given, make sure no fee amounts are requested too\n        manager.authorize(smartVault, params.feeCollectorAdmin, smartVault.setFeeCollector.selector);\n        if (params.feeCollector != address(0)) {\n            manager.authorize(smartVault, address(this), smartVault.setFeeCollector.selector);\n            smartVault.setFeeCollector(params.feeCollector);\n            manager.unauthorize(smartVault, address(this), smartVault.setFeeCollector.selector);\n        } else {\n            bool noFees = params.withdrawFee.pct == 0 &&\n                params.swapFee.pct == 0 &&\n                params.bridgeFee.pct == 0 &&\n                params.performanceFee.pct == 0;\n            require(noFees, 'SMART_VAULT_FEES_NO_COLLECTOR');\n        }\n\n        // Set withdraw fee if not zero\n        SmartVaultFeeParams memory withdrawFee = params.withdrawFee;\n        if (withdrawFee.pct != 0) {\n            manager.authorize(smartVault, address(this), smartVault.setWithdrawFee.selector);\n            smartVault.setWithdrawFee(withdrawFee.pct, withdrawFee.cap, withdrawFee.token, withdrawFee.period);\n            manager.unauthorize(smartVault, address(this), smartVault.setWithdrawFee.selector);\n        }\n\n        // Set swap fee if not zero\n        SmartVaultFeeParams memory swapFee = params.swapFee;\n        if (swapFee.pct != 0) {\n            manager.authorize(smartVault, address(this), smartVault.setSwapFee.selector);\n            smartVault.setSwapFee(swapFee.pct, swapFee.cap, swapFee.token, swapFee.period);\n            manager.unauthorize(smartVault, address(this), smartVault.setSwapFee.selector);\n        }\n\n        // Set bridge fee if not zero\n        SmartVaultFeeParams memory bridgeFee = params.bridgeFee;\n        if (bridgeFee.pct != 0) {\n            manager.authorize(smartVault, address(this), smartVault.setBridgeFee.selector);\n            smartVault.setBridgeFee(bridgeFee.pct, bridgeFee.cap, bridgeFee.token, bridgeFee.period);\n            manager.unauthorize(smartVault, address(this), smartVault.setBridgeFee.selector);\n        }\n\n        // Set performance fee if not zero\n        SmartVaultFeeParams memory perfFee = params.performanceFee;\n        if (perfFee.pct != 0) {\n            manager.authorize(smartVault, address(this), smartVault.setPerformanceFee.selector);\n            smartVault.setPerformanceFee(perfFee.pct, perfFee.cap, perfFee.token, perfFee.period);\n            manager.unauthorize(smartVault, address(this), smartVault.setPerformanceFee.selector);\n        }\n    }\n\n    /**\n     * @dev Set up a base action\n     * @param action Base action to be set up\n     * @param manager Permissions manager that will control the entire Smart Vault and its actions\n     * @param admin Address that will be granted with admin rights for the Base Action\n     * @param smartVault Address of the Smart Vault to be set in the Base Action\n     */\n    function setupBaseAction(BaseAction action, PermissionsManager manager, address admin, address smartVault)\n        external\n    {\n        require(admin != address(0), 'BASE_ACTION_ADMIN_ZERO');\n\n        manager.authorize(action, Arrays.from(admin, address(this)), action.setSmartVault.selector);\n        action.setSmartVault(smartVault);\n        manager.unauthorize(action, address(this), action.setSmartVault.selector);\n    }\n\n    /**\n     * @dev Set up a list of executors for a given action\n     * @param action Action whose executors are being allowed\n     * @param manager Permissions manager that will control the entire Smart Vault and its actions\n     * @param executors List of addresses to be allowed to call the given action\n     * @param callSelector Selector of the function to allow the list of executors\n     */\n    function setupActionExecutors(\n        BaseAction action,\n        PermissionsManager manager,\n        address[] memory executors,\n        bytes4 callSelector\n    ) external {\n        manager.authorize(action, executors, callSelector);\n    }\n\n    /**\n     * @dev Set up a Relayed action\n     * @param action Relayed action to be configured\n     * @param manager Permissions manager that will control the entire Smart Vault and its actions\n     * @param admin Address that will be granted with admin rights for the Relayed action\n     * @param params Params to customize the Relayed action\n     */\n    function setupRelayedAction(\n        RelayedAction action,\n        PermissionsManager manager,\n        address admin,\n        RelayedActionParams memory params\n    ) external {\n        // Authorize admin to set relayers and txs limits\n        require(admin != address(0), 'RELAYED_ACTION_ADMIN_ZERO');\n\n        address[] memory whos = Arrays.from(admin, address(this));\n        bytes4[] memory whats = Arrays.from(action.setLimits.selector, action.setRelayer.selector);\n\n        manager.authorize(action, whos, whats);\n\n        action.setLimits(params.gasPriceLimit, params.txCostLimit);\n        for (uint256 i = 0; i < params.relayers.length; i = i.uncheckedAdd(1)) {\n            action.setRelayer(params.relayers[i], true);\n        }\n\n        manager.unauthorize(action, address(this), whats);\n    }\n\n    /**\n     * @dev Set up a Token Threshold action\n     * @param action Token threshold action to be configured\n     * @param manager Permissions manager that will control the entire Smart Vault and its actions\n     * @param admin Address that will be granted with admin rights for the Token Threshold action\n     * @param params Params to customize the Token Threshold action\n     */\n    function setupTokenThresholdAction(\n        TokenThresholdAction action,\n        PermissionsManager manager,\n        address admin,\n        TokenThresholdActionParams memory params\n    ) external {\n        require(admin != address(0), 'TOKEN_THRESHOLD_ADMIN_ZERO');\n        manager.authorize(action, Arrays.from(admin, address(this)), action.setThreshold.selector);\n        action.setThreshold(params.token, params.amount);\n        manager.unauthorize(action, address(this), action.setThreshold.selector);\n    }\n\n    /**\n     * @dev Set up a Time-locked action\n     * @param action Time-locked action to be configured\n     * @param manager Permissions manager that will control the entire Smart Vault and its actions\n     * @param admin Address that will be granted with admin rights for the Time-locked action\n     * @param params Params to customize the Time-locked action\n     */\n    function setupTimeLockedAction(\n        TimeLockedAction action,\n        PermissionsManager manager,\n        address admin,\n        TimeLockedActionParams memory params\n    ) external {\n        require(admin != address(0), 'TIME_LOCKED_ACTION_ADMIN_ZERO');\n        manager.authorize(action, Arrays.from(admin, address(this)), action.setTimeLock.selector);\n        action.setTimeLock(params.period);\n        manager.unauthorize(action, address(this), action.setTimeLock.selector);\n    }\n\n    /**\n     * @dev Set up a Withdrawal action\n     * @param action Relayed action to be configured\n     * @param manager Permissions manager that will control the entire Smart Vault and its actions\n     * @param admin Address that will be granted with admin rights for the Withdrawal action\n     * @param params Params to customize the Withdrawal action\n     */\n    function setupWithdrawalAction(\n        WithdrawalAction action,\n        PermissionsManager manager,\n        address admin,\n        WithdrawalActionParams memory params\n    ) external {\n        require(admin != address(0), 'WITHDRAWAL_ACTION_ADMIN_ZERO');\n        manager.authorize(action, Arrays.from(admin, address(this)), action.setRecipient.selector);\n        action.setRecipient(params.recipient);\n        manager.unauthorize(action, address(this), action.setRecipient.selector);\n    }\n\n    /**\n     * @dev Set up a Receiver action\n     * @param action Relayed action to be configured\n     * @param manager Permissions manager that will control the entire Smart Vault and its actions\n     * @param admin Address that will be granted with admin rights for the Receiver action\n     */\n    function setupReceiverAction(ReceiverAction action, PermissionsManager manager, address admin) external {\n        require(admin != address(0), 'RECEIVER_ACTION_ADMIN_ZERO');\n        manager.authorize(action, admin, action.transferToSmartVault.selector);\n    }\n}\n"},"@mimic-fi/v2-smart-vaults-base/contracts/permissions/PermissionsManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@mimic-fi/v2-helpers/contracts/auth/Authorizer.sol';\nimport '@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol';\n\nimport { Permission, PermissionChange, PermissionChangeRequest } from './PermissionsData.sol';\n\n/**\n * @title PermissionsManager\n * @dev This implementation is meant to be used as a proxy in order to control many `IAuthorizer` implementations.\n * It allows to implement a layout of permissions over a group of `IAuthorizer` implementations, otherwise in order\n * to connect a big number of `IAuthorizer` implementations between each other, admins would had to perform many\n * transactions manually.\n */\ncontract PermissionsManager is Authorizer {\n    /**\n     * @dev Creates a new permission manager, allowing itself to authorize and unauthorize its own permissions\n     * @param admin Address that will be allowed to execute permissions changes through the permissions manager\n     */\n    constructor(address admin) {\n        _authorize(admin, PermissionsManager.execute.selector);\n        _authorize(admin, PermissionsManager.execute.selector);\n        _authorize(address(this), Authorizer.authorize.selector);\n        _authorize(address(this), Authorizer.unauthorize.selector);\n    }\n\n    /**\n     * @dev Executes a list of permissions change requests. Sender must be authorized.\n     * @param requests List of requests to be executed\n     */\n    function execute(PermissionChangeRequest[] memory requests) external auth {\n        for (uint256 i = 0; i < requests.length; i++) _execute(requests[i]);\n    }\n\n    /**\n     * @dev Executes a single permissions change request\n     * @param request Request to be executed\n     */\n    function _execute(PermissionChangeRequest memory request) private {\n        IAuthorizer target = request.target;\n        for (uint256 i = 0; i < request.changes.length; i++) {\n            PermissionChange memory change = request.changes[i];\n            (change.grant ? target.authorize : target.unauthorize)(change.permission.who, change.permission.what);\n        }\n    }\n}\n"},"@mimic-fi/v2-registry/contracts/implementations/BaseAuthorizedImplementation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@mimic-fi/v2-helpers/contracts/auth/Authorizer.sol';\n\nimport './BaseImplementation.sol';\n\n/**\n * @title BaseAuthorizedImplementation\n * @dev BaseImplementation using the Authorizer mixin. Base implementations that want to use the Authorizer\n * permissions mechanism should inherit from this contract instead.\n */\nabstract contract BaseAuthorizedImplementation is BaseImplementation, Authorizer {\n    /**\n     * @dev Creates a new BaseAuthorizedImplementation\n     * @param admin Address to be granted authorize and unauthorize permissions\n     * @param registry Address of the Mimic Registry\n     */\n    constructor(address admin, address registry) BaseImplementation(registry) {\n        _authorize(admin, Authorizer.authorize.selector);\n        _authorize(admin, Authorizer.unauthorize.selector);\n    }\n}\n"},"@mimic-fi/v2-bridge-connector/contracts/IBridgeConnector.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\n\n/**\n * @title IBridgeConnector\n * @dev Bridge Connector interface to bridge tokens between different chains. It must follow IImplementation interface.\n */\ninterface IBridgeConnector is IImplementation {\n    /**\n     * @dev Enum identifying the sources proposed: Hop only for now.\n     */\n    enum Source {\n        Hop\n    }\n\n    /**\n     * @dev Bridge assets to a different chain\n     * @param source Source to execute the requested bridge op\n     * @param chainId ID of the destination chain\n     * @param token Address of the token to be bridged\n     * @param amountIn Amount of tokens to be bridged\n     * @param minAmountOut Minimum amount of tokens willing to receive on the destination chain\n     * @param recipient Address that will receive the tokens on the destination chain\n     * @param data ABI encoded data that will depend on the requested source\n     */\n    function bridge(\n        uint8 source,\n        uint256 chainId,\n        address token,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address recipient,\n        bytes memory data\n    ) external;\n}\n"},"@mimic-fi/v2-strategies/contracts/IStrategy.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\n\n/**\n * @title IStrategy\n * @dev Strategy interface required by Mimic Smart Vaults. It must follow the IImplementation interface.\n */\ninterface IStrategy is IImplementation {\n    /**\n     * @dev Tokens accepted to join the strategy\n     */\n    function joinTokens() external view returns (address[] memory);\n\n    /**\n     * @dev Tokens accepted to exit the strategy\n     */\n    function exitTokens() external view returns (address[] memory);\n\n    /**\n     * @dev Tells how much a value unit means expressed in the asset token.\n     * For example, if a strategy has a value of 100 in T0, and then it has a value of 120 in T1,\n     * and the value rate is 1.5, it means the strategy has earned 30 strategy tokens between T0 and T1.\n     */\n    function valueRate() external view returns (uint256);\n\n    /**\n     * @dev Tells the last value an account has over time. Note this value can be outdated: there could be rewards to\n     * be claimed that will affect the accrued value. For example, if an account has a value of 100 in T0, and then it\n     * has a value of 120 in T1, it means it gained a 20% between T0 and T1.\n     * @param account Address of the account querying the last value of\n     */\n    function lastValue(address account) external view returns (uint256);\n\n    /**\n     * @dev Claim any existing rewards\n     * @param data Arbitrary extra data\n     * @return tokens Addresses of the tokens received as rewards\n     * @return amounts Amounts of the tokens received as rewards\n     */\n    function claim(bytes memory data) external returns (address[] memory tokens, uint256[] memory amounts);\n\n    /**\n     * @dev Join the interfaced DeFi protocol\n     * @param tokensIn List of token addresses to join with\n     * @param amountsIn List of token amounts to join with\n     * @param slippage Slippage value to join with\n     * @param data Arbitrary extra data\n     * @return tokensOut List of token addresses received after the join\n     * @return amountsOut List of token amounts received after the join\n     * @return value Value represented by the joined amount\n     */\n    function join(address[] memory tokensIn, uint256[] memory amountsIn, uint256 slippage, bytes memory data)\n        external\n        returns (address[] memory tokensOut, uint256[] memory amountsOut, uint256 value);\n\n    /**\n     * @dev Exit the interfaced DeFi protocol\n     * @param tokensIn List of token addresses to exit with\n     * @param amountsIn List of token amounts to exit with\n     * @param slippage Slippage value to exit with\n     * @param data Arbitrary extra data\n     * @return tokensOut List of token addresses received after the exit\n     * @return amountsOut List of token amounts received after the exit\n     * @return value Value represented by the exited amount\n     */\n    function exit(address[] memory tokensIn, uint256[] memory amountsIn, uint256 slippage, bytes memory data)\n        external\n        returns (address[] memory tokensOut, uint256[] memory amountsOut, uint256 value);\n}\n"},"@mimic-fi/v2-swap-connector/contracts/ISwapConnector.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\n\n/**\n * @title ISwapConnector\n * @dev Swap Connector interface to perform token swaps. It must follow the IImplementation interface.\n */\ninterface ISwapConnector is IImplementation {\n    /**\n     * @dev Enum identifying the sources proposed: Uniswap V2, Uniswap V3, Balancer V2, Paraswap V5, 1inch V5, and Hop.\n     */\n    enum Source {\n        UniswapV2,\n        UniswapV3,\n        BalancerV2,\n        ParaswapV5,\n        OneInchV5,\n        Hop\n    }\n\n    /**\n     * @dev Swaps two tokens\n     * @param source Source to execute the requested swap\n     * @param tokenIn Token being sent\n     * @param tokenOut Token being received\n     * @param amountIn Amount of tokenIn being swapped\n     * @param minAmountOut Minimum amount of tokenOut willing to receive\n     * @param data Encoded data to specify different swap parameters depending on the source picked\n     */\n    function swap(\n        uint8 source,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        bytes memory data\n    ) external returns (uint256 amountOut);\n}\n"},"@mimic-fi/v2-price-oracle/contracts/oracle/IPriceOracle.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\n\n/**\n * @title IPriceOracle\n * @dev Oracle that interfaces with external feeds to provide quotes for tokens based on any other token.\n * It must support also `IImplementation`.\n */\ninterface IPriceOracle is IImplementation {\n    /**\n     * @dev Tells the price of a token (base) in a given quote. The response is expressed using the corresponding\n     * number of decimals so that when performing a fixed point product of it by a `base` amount it results in\n     * a value expressed in `quote` decimals. For example, if `base` is ETH and `quote` is USDC, then the returned\n     * value is expected to be expressed using 6 decimals:\n     *\n     * FixedPoint.mul(X[ETH], price[USDC/ETH]) = FixedPoint.mul(X[18], price[6]) = X * price [6]\n     *\n     * @param provider Contract providing the price feeds to use by the oracle\n     * @param base Token to rate\n     * @param quote Token used for the price rate\n     */\n    function getPrice(address provider, address base, address quote) external view returns (uint256);\n}\n"},"@openzeppelin/contracts/proxy/utils/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"},"@openzeppelin/contracts/security/ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"},"@mimic-fi/v2-smart-vault/contracts/helpers/StrategyLib.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/utils/Address.sol';\n\nimport '@mimic-fi/v2-strategies/contracts/IStrategy.sol';\n\n/**\n * @title StrategyLib\n * @dev Library used to delegate-call to strategy and decode return data correctly\n */\nlibrary StrategyLib {\n    /**\n     * @dev Delegate-calls a claim to a strategy and decodes de expected data\n     * IMPORTANT! This helper method does not check any of the given params, these should be checked beforehand.\n     */\n    function claim(address strategy, bytes memory data) internal returns (address[] memory, uint256[] memory) {\n        bytes memory claimData = abi.encodeWithSelector(IStrategy.claim.selector, data);\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = strategy.delegatecall(claimData);\n        Address.verifyCallResult(success, returndata, 'CLAIM_CALL_REVERTED');\n        return abi.decode(returndata, (address[], uint256[]));\n    }\n\n    /**\n     * @dev Delegate-calls a join to a strategy and decodes de expected data\n     * IMPORTANT! This helper method does not check any of the given params, these should be checked beforehand.\n     */\n    function join(\n        address strategy,\n        address[] memory tokensIn,\n        uint256[] memory amountsIn,\n        uint256 slippage,\n        bytes memory data\n    ) internal returns (address[] memory tokensOut, uint256[] memory amountsOut, uint256 value) {\n        bytes memory joinData = abi.encodeWithSelector(IStrategy.join.selector, tokensIn, amountsIn, slippage, data);\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = strategy.delegatecall(joinData);\n        Address.verifyCallResult(success, returndata, 'JOIN_CALL_REVERTED');\n        return abi.decode(returndata, (address[], uint256[], uint256));\n    }\n\n    /**\n     * @dev Delegate-calls a exit to a strategy and decodes de expected data\n     * IMPORTANT! This helper method does not check any of the given params, these should be checked beforehand.\n     */\n    function exit(\n        address strategy,\n        address[] memory tokensIn,\n        uint256[] memory amountsIn,\n        uint256 slippage,\n        bytes memory data\n    ) internal returns (address[] memory tokensOut, uint256[] memory amountsOut, uint256 value) {\n        bytes memory exitData = abi.encodeWithSelector(IStrategy.exit.selector, tokensIn, amountsIn, slippage, data);\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = strategy.delegatecall(exitData);\n        Address.verifyCallResult(success, returndata, 'EXIT_CALL_REVERTED');\n        return abi.decode(returndata, (address[], uint256[], uint256));\n    }\n}\n"},"contracts/SmartVaultDeployer.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport { Ownable } from '@openzeppelin/contracts/access/Ownable.sol';\n\nimport { UncheckedMath } from '@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol';\nimport { IRegistry } from '@mimic-fi/v2-registry/contracts/registry/IRegistry.sol';\nimport { SmartVault } from '@mimic-fi/v2-smart-vault/contracts/SmartVault.sol';\nimport { Deployer } from '@mimic-fi/v2-smart-vaults-base/contracts/deploy/Deployer.sol';\nimport { Arrays } from '@mimic-fi/v2-smart-vaults-base/contracts/permissions/Arrays.sol';\nimport { PermissionsHelpers } from '@mimic-fi/v2-smart-vaults-base/contracts/permissions/PermissionsHelpers.sol';\nimport { PermissionsManager } from '@mimic-fi/v2-smart-vaults-base/contracts/permissions/PermissionsManager.sol';\n\nimport { Swapper } from './Swapper.sol';\n\ncontract SmartVaultDeployer is Ownable {\n    using PermissionsHelpers for PermissionsManager;\n\n    struct Params {\n        address[] owners;\n        IRegistry registry;\n        PermissionsManager manager;\n        SwapperActionParams swapperActionParams;\n        Deployer.SmartVaultParams smartVaultParams;\n    }\n\n    struct SwapperActionParams {\n        address impl;\n        address admin;\n        uint8[] sources;\n    }\n\n    constructor(address owner) {\n        _transferOwnership(owner);\n    }\n\n    function deploy(Params memory params) external {\n        SmartVault smartVault = Deployer.createSmartVault(params.registry, params.manager, params.smartVaultParams);\n        _setupSwapperAction(smartVault, params.manager, params.swapperActionParams);\n        Deployer.transferPermissionManagerControl(params.manager, params.owners);\n    }\n\n    function _setupSwapperAction(SmartVault smartVault, PermissionsManager manager, SwapperActionParams memory params)\n        internal\n    {\n        // Create and setup action\n        Swapper swapper = Swapper(params.impl);\n        Deployer.setupBaseAction(swapper, manager, params.admin, address(smartVault));\n\n        // Set up allowed sources\n        manager.authorize(swapper, Arrays.from(params.admin, address(this)), swapper.setSource.selector);\n        for (uint256 i = 0; i < params.sources.length; i++) swapper.setSource(params.sources[i], true);\n        manager.unauthorize(swapper, address(this), swapper.setSource.selector);\n\n        // Set up pause permissions\n        manager.authorize(swapper, params.admin, Arrays.from(swapper.pause.selector, swapper.unpause.selector));\n\n        // Authorize action to collect, swap, wrap, unwrap, and withdraw\n        manager.authorize(\n            smartVault,\n            address(swapper),\n            Arrays.from(\n                smartVault.collect.selector,\n                smartVault.swap.selector,\n                smartVault.wrap.selector,\n                smartVault.unwrap.selector,\n                smartVault.withdraw.selector\n            )\n        );\n    }\n}\n"},"@openzeppelin/contracts/utils/structs/EnumerableSet.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"},"@openzeppelin/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"@mimic-fi/v2-price-oracle/contracts/feeds/PriceFeedProvider.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol';\n\nimport './IPriceFeedProvider.sol';\n\n/**\n * @title IPriceFeedProvider\n * @dev Contract providing price feed references for (base, quote) token pairs\n */\ncontract PriceFeedProvider is IPriceFeedProvider {\n    using UncheckedMath for uint256;\n\n    // Mapping of price feeds from \"token A\" to \"token B\"\n    mapping (address => mapping (address => address)) private _priceFeeds;\n\n    /**\n     * @dev Tells the price feed address for (base, quote) pair. It returns the zero address if there is no one set.\n     * @param base Token to be rated\n     * @param quote Token used for the price rate\n     */\n    function getPriceFeed(address base, address quote) external view override returns (address) {\n        return _priceFeeds[base][quote];\n    }\n\n    /**\n     * @dev Sets a of price feed\n     * @param base Token base to be set\n     * @param quote Token quote to be set\n     * @param feed Price feed to be set\n     */\n    function setPriceFeed(address base, address quote, address feed) public virtual override {\n        _priceFeeds[base][quote] = feed;\n        emit PriceFeedSet(base, quote, feed);\n    }\n\n    /**\n     * @dev Sets a list of price feeds. Sender must be authorized.\n     * @param bases List of token bases to be set\n     * @param quotes List of token quotes to be set\n     * @param feeds List of price feeds to be set\n     */\n    function setPriceFeeds(address[] memory bases, address[] memory quotes, address[] memory feeds)\n        public\n        virtual\n        override\n    {\n        require(bases.length == quotes.length, 'SET_FEEDS_INVALID_QUOTES_LENGTH');\n        require(bases.length == feeds.length, 'SET_FEEDS_INVALID_FEEDS_LENGTH');\n        for (uint256 i = 0; i < bases.length; i = i.uncheckedAdd(1)) setPriceFeed(bases[i], quotes[i], feeds[i]);\n    }\n}\n"},"@mimic-fi/v2-helpers/contracts/utils/IWrappedNativeToken.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\n/**\n * @title IWrappedNativeToken\n */\ninterface IWrappedNativeToken is IERC20 {\n    /**\n     * @dev Wraps msg.value into the wrapped-native token\n     */\n    function deposit() external payable;\n\n    /**\n     * @dev Unwraps requested amount to the native token\n     */\n    function withdraw(uint256 amount) external;\n}\n"},"@mimic-fi/v2-helpers/contracts/utils/ERC20Helpers.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nimport './Denominations.sol';\n\n/**\n * @title ERC20Helpers\n * @dev Provides a list of ERC20 helper methods\n */\nlibrary ERC20Helpers {\n    function approve(address token, address to, uint256 amount) internal {\n        SafeERC20.safeApprove(IERC20(token), to, 0);\n        SafeERC20.safeApprove(IERC20(token), to, amount);\n    }\n\n    function transfer(address token, address to, uint256 amount) internal {\n        if (Denominations.isNativeToken(token)) Address.sendValue(payable(to), amount);\n        else SafeERC20.safeTransfer(IERC20(token), to, amount);\n    }\n\n    function balanceOf(address token, address account) internal view returns (uint256) {\n        if (Denominations.isNativeToken(token)) return address(account).balance;\n        else return IERC20(token).balanceOf(address(account));\n    }\n}\n"},"@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\n/**\n * @title IAuthorizer\n */\ninterface IAuthorizer {\n    /**\n     * @dev Emitted when an account is authorized to call a function\n     */\n    event Authorized(address indexed who, bytes4 what);\n\n    /**\n     * @dev Emitted when an account is unauthorized to call a function\n     */\n    event Unauthorized(address indexed who, bytes4 what);\n\n    /**\n     * @dev Authorizes someone to call a function. Sender must be authorize to do so.\n     * @param who Address to be authorized\n     * @param what Function selector to be granted\n     */\n    function authorize(address who, bytes4 what) external;\n\n    /**\n     * @dev Unauthorizes someone to call a function. Sender must be authorize to do so.\n     * @param who Address to be unauthorized\n     * @param what Function selector to be revoked\n     */\n    function unauthorize(address who, bytes4 what) external;\n\n    /**\n     * @dev Tells whether someone is allowed to call a function or not. It returns true if it's allowed to anyone.\n     * @param who Address asking permission for\n     * @param what Function selector asking permission for\n     */\n    function isAuthorized(address who, bytes4 what) external view returns (bool);\n}\n"},"@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\n/**\n * @title FixedPoint\n * @dev Math library to operate with fixed point values with 18 decimals\n */\nlibrary FixedPoint {\n    // 1 in fixed point value: 18 decimal places\n    uint256 internal constant ONE = 1e18;\n\n    /**\n     * @dev Multiplies two fixed point numbers rounding down\n     */\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            uint256 product = a * b;\n            require(a == 0 || product / a == b, 'MUL_OVERFLOW');\n            return product / ONE;\n        }\n    }\n\n    /**\n     * @dev Multiplies two fixed point numbers rounding up\n     */\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            uint256 product = a * b;\n            require(a == 0 || product / a == b, 'MUL_OVERFLOW');\n            return product == 0 ? 0 : (((product - 1) / ONE) + 1);\n        }\n    }\n\n    /**\n     * @dev Divides two fixed point numbers rounding down\n     */\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            require(b != 0, 'ZERO_DIVISION');\n            if (a == 0) return 0;\n            uint256 aInflated = a * ONE;\n            require(aInflated / a == ONE, 'DIV_INTERNAL');\n            return aInflated / b;\n        }\n    }\n\n    /**\n     * @dev Divides two fixed point numbers rounding up\n     */\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            require(b != 0, 'ZERO_DIVISION');\n            if (a == 0) return 0;\n            uint256 aInflated = a * ONE;\n            require(aInflated / a == ONE, 'DIV_INTERNAL');\n            return ((aInflated - 1) / b) + 1;\n        }\n    }\n}\n"},"@mimic-fi/v2-price-oracle/contracts/feeds/IPriceFeedProvider.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\n/**\n * @title IPriceFeedProvider\n * @dev Contract providing price feed references for (base, quote) token pairs\n */\ninterface IPriceFeedProvider {\n    /**\n     * @dev Emitted every time a price feed is set for (base, quote) pair\n     */\n    event PriceFeedSet(address indexed base, address indexed quote, address feed);\n\n    /**\n     * @dev Tells the price feed address for (base, quote) pair. It returns the zero address if there is no one set.\n     * @param base Token to be rated\n     * @param quote Token used for the price rate\n     */\n    function getPriceFeed(address base, address quote) external view returns (address);\n\n    /**\n     * @dev Sets a of price feed\n     * @param base Token base to be set\n     * @param quote Token quote to be set\n     * @param feed Price feed to be set\n     */\n    function setPriceFeed(address base, address quote, address feed) external;\n\n    /**\n     * @dev Sets a list of price feeds\n     * @param bases List of token bases to be set\n     * @param quotes List of token quotes to be set\n     * @param feeds List of price feeds to be set\n     */\n    function setPriceFeeds(address[] memory bases, address[] memory quotes, address[] memory feeds) external;\n}\n"},"@mimic-fi/v2-registry/contracts/implementations/InitializableImplementation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/proxy/utils/Initializable.sol';\n\nimport './BaseImplementation.sol';\n\n/**\n * @title InitializableImplementation\n * @dev Implementation contract to be used through proxies. Inheriting contracts are meant to be initialized through\n * initialization functions instead of constructor functions. It allows re-using the same logic contract while making\n * deployments cheaper.\n */\nabstract contract InitializableImplementation is BaseImplementation, Initializable {\n    /**\n     * @dev Creates a new BaseImplementation. Note that initializers are disabled at creation time.\n     */\n    constructor(address registry) BaseImplementation(registry) {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initialization function.\n     * Note this function can only be called from a function marked with the `initializer` modifier.\n     */\n    function _initialize() internal view onlyInitializing {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n}\n"},"@mimic-fi/v2-smart-vault/contracts/helpers/BridgeConnectorLib.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/utils/Address.sol';\n\nimport '@mimic-fi/v2-bridge-connector/contracts/IBridgeConnector.sol';\n\n/**\n * @title BridgeConnectorLib\n * @dev Library used to delegate-call bridge ops and decode return data correctly\n */\nlibrary BridgeConnectorLib {\n    /**\n     * @dev Delegate-calls a bridge to the bridge connector and decodes de expected data\n     * IMPORTANT! This helper method does not check any of the given params, these should be checked beforehand.\n     */\n    function bridge(\n        address connector,\n        uint8 source,\n        uint256 chainId,\n        address token,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address recipient,\n        bytes memory data\n    ) internal {\n        bytes memory bridgeData = abi.encodeWithSelector(\n            IBridgeConnector.bridge.selector,\n            source,\n            chainId,\n            token,\n            amountIn,\n            minAmountOut,\n            recipient,\n            data\n        );\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = connector.delegatecall(bridgeData);\n        Address.verifyCallResult(success, returndata, 'BRIDGE_CALL_REVERTED');\n    }\n}\n"},"@mimic-fi/v2-smart-vault/contracts/ISmartVault.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol';\nimport '@mimic-fi/v2-price-oracle/contracts/feeds/IPriceFeedProvider.sol';\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\n\n/**\n * @title ISmartVault\n * @dev Mimic Smart Vault interface to manage assets. It must support also `IImplementation` and `IAuthorizer`\n */\ninterface ISmartVault is IPriceFeedProvider, IImplementation, IAuthorizer {\n    enum SwapLimit {\n        Slippage,\n        MinAmountOut\n    }\n\n    enum BridgeLimit {\n        Slippage,\n        MinAmountOut\n    }\n\n    /**\n     * @dev Emitted every time a new strategy is set for the Smart Vault\n     */\n    event StrategySet(address indexed strategy, bool allowed);\n\n    /**\n     * @dev Emitted every time a new price oracle is set for the Smart Vault\n     */\n    event PriceOracleSet(address indexed priceOracle);\n\n    /**\n     * @dev Emitted every time a new swap connector is set for the Smart Vault\n     */\n    event SwapConnectorSet(address indexed swapConnector);\n\n    /**\n     * @dev Emitted every time a new bridge connector is set for the Smart Vault\n     */\n    event BridgeConnectorSet(address indexed bridgeConnector);\n\n    /**\n     * @dev Emitted every time a new fee collector is set\n     */\n    event FeeCollectorSet(address indexed feeCollector);\n\n    /**\n     * @dev Emitted every time the withdraw fee percentage is set\n     */\n    event WithdrawFeeSet(uint256 pct, uint256 cap, address token, uint256 period);\n\n    /**\n     * @dev Emitted every time the performance fee percentage is set\n     */\n    event PerformanceFeeSet(uint256 pct, uint256 cap, address token, uint256 period);\n\n    /**\n     * @dev Emitted every time the swap fee percentage is set\n     */\n    event SwapFeeSet(uint256 pct, uint256 cap, address token, uint256 period);\n\n    /**\n     * @dev Emitted every time the bridge fee percentage is set\n     */\n    event BridgeFeeSet(uint256 pct, uint256 cap, address token, uint256 period);\n\n    /**\n     * @dev Emitted every time `call` is called\n     */\n    event Call(address indexed target, bytes callData, uint256 value, bytes result, bytes data);\n\n    /**\n     * @dev Emitted every time `collect` is called\n     */\n    event Collect(address indexed token, address indexed from, uint256 collected, bytes data);\n\n    /**\n     * @dev Emitted every time `withdraw` is called\n     */\n    event Withdraw(address indexed token, address indexed recipient, uint256 withdrawn, uint256 fee, bytes data);\n\n    /**\n     * @dev Emitted every time `wrap` is called\n     */\n    event Wrap(uint256 amount, uint256 wrapped, bytes data);\n\n    /**\n     * @dev Emitted every time `unwrap` is called\n     */\n    event Unwrap(uint256 amount, uint256 unwrapped, bytes data);\n\n    /**\n     * @dev Emitted every time `claim` is called\n     */\n    event Claim(address indexed strategy, address[] tokens, uint256[] amounts, bytes data);\n\n    /**\n     * @dev Emitted every time `join` is called\n     */\n    event Join(\n        address indexed strategy,\n        address[] tokensIn,\n        uint256[] amountsIn,\n        address[] tokensOut,\n        uint256[] amountsOut,\n        uint256 value,\n        uint256 slippage,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted every time `exit` is called\n     */\n    event Exit(\n        address indexed strategy,\n        address[] tokensIn,\n        uint256[] amountsIn,\n        address[] tokensOut,\n        uint256[] amountsOut,\n        uint256 value,\n        uint256[] fees,\n        uint256 slippage,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted every time `swap` is called\n     */\n    event Swap(\n        uint8 indexed source,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 minAmountOut,\n        uint256 fee,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted every time `bridge` is called\n     */\n    event Bridge(\n        uint8 indexed source,\n        uint256 indexed chainId,\n        address indexed token,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        uint256 fee,\n        address recipient,\n        bytes data\n    );\n\n    /**\n     * @dev Tells a strategy is allowed or not\n     * @param strategy Address of the strategy being queried\n     */\n    function isStrategyAllowed(address strategy) external view returns (bool);\n\n    /**\n     * @dev Tells the invested value for a strategy\n     * @param strategy Address of the strategy querying the invested value of\n     */\n    function investedValue(address strategy) external view returns (uint256);\n\n    /**\n     * @dev Tells the last value accrued for a strategy. Note this value can be outdated.\n     * @param strategy Address of the strategy querying the last value of\n     */\n    function lastValue(address strategy) external view returns (uint256);\n\n    /**\n     * @dev Tells the price oracle associated to a Smart Vault\n     */\n    function priceOracle() external view returns (address);\n\n    /**\n     * @dev Tells the swap connector associated to a Smart Vault\n     */\n    function swapConnector() external view returns (address);\n\n    /**\n     * @dev Tells the bridge connector associated to a Smart Vault\n     */\n    function bridgeConnector() external view returns (address);\n\n    /**\n     * @dev Tells the address where fees will be deposited\n     */\n    function feeCollector() external view returns (address);\n\n    /**\n     * @dev Tells the withdraw fee configuration\n     */\n    function withdrawFee()\n        external\n        view\n        returns (uint256 pct, uint256 cap, address token, uint256 period, uint256 totalCharged, uint256 nextResetTime);\n\n    /**\n     * @dev Tells the performance fee configuration\n     */\n    function performanceFee()\n        external\n        view\n        returns (uint256 pct, uint256 cap, address token, uint256 period, uint256 totalCharged, uint256 nextResetTime);\n\n    /**\n     * @dev Tells the swap fee configuration\n     */\n    function swapFee()\n        external\n        view\n        returns (uint256 pct, uint256 cap, address token, uint256 period, uint256 totalCharged, uint256 nextResetTime);\n\n    /**\n     * @dev Tells the bridge fee configuration\n     */\n    function bridgeFee()\n        external\n        view\n        returns (uint256 pct, uint256 cap, address token, uint256 period, uint256 totalCharged, uint256 nextResetTime);\n\n    /**\n     * @dev Tells the address of the wrapped native token\n     */\n    function wrappedNativeToken() external view returns (address);\n\n    /**\n     * @dev Sets a new strategy as allowed or not for a Smart Vault\n     * @param strategy Address of the strategy to be set\n     * @param allowed Whether the strategy is allowed or not\n     */\n    function setStrategy(address strategy, bool allowed) external;\n\n    /**\n     * @dev Sets a new price oracle to a Smart Vault\n     * @param newPriceOracle Address of the new price oracle to be set\n     */\n    function setPriceOracle(address newPriceOracle) external;\n\n    /**\n     * @dev Sets a new swap connector to a Smart Vault\n     * @param newSwapConnector Address of the new swap connector to be set\n     */\n    function setSwapConnector(address newSwapConnector) external;\n\n    /**\n     * @dev Sets a new bridge connector to a Smart Vault\n     * @param newBridgeConnector Address of the new bridge connector to be set\n     */\n    function setBridgeConnector(address newBridgeConnector) external;\n\n    /**\n     * @dev Sets a new fee collector\n     * @param newFeeCollector Address of the new fee collector to be set\n     */\n    function setFeeCollector(address newFeeCollector) external;\n\n    /**\n     * @dev Sets a new withdraw fee configuration\n     * @param pct Withdraw fee percentage to be set\n     * @param cap New maximum amount of withdraw fees to be charged per period\n     * @param token Address of the token cap to be set\n     * @param period New cap period length in seconds for the withdraw fee\n     */\n    function setWithdrawFee(uint256 pct, uint256 cap, address token, uint256 period) external;\n\n    /**\n     * @dev Sets a new performance fee configuration\n     * @param pct Performance fee percentage to be set\n     * @param cap New maximum amount of performance fees to be charged per period\n     * @param token Address of the token cap to be set\n     * @param period New cap period length in seconds for the performance fee\n     */\n    function setPerformanceFee(uint256 pct, uint256 cap, address token, uint256 period) external;\n\n    /**\n     * @dev Sets a new swap fee configuration\n     * @param pct Swap fee percentage to be set\n     * @param cap New maximum amount of swap fees to be charged per period\n     * @param token Address of the token cap to be set\n     * @param period New cap period length in seconds for the swap fee\n     */\n    function setSwapFee(uint256 pct, uint256 cap, address token, uint256 period) external;\n\n    /**\n     * @dev Sets a new bridge fee configuration\n     * @param pct Bridge fee percentage to be set\n     * @param cap New maximum amount of bridge fees to be charged per period\n     * @param token Address of the token cap to be set\n     * @param period New cap period length in seconds for the bridge fee\n     */\n    function setBridgeFee(uint256 pct, uint256 cap, address token, uint256 period) external;\n\n    /**\n     * @dev Tells the price of a token (base) in a given quote\n     * @param base Token to rate\n     * @param quote Token used for the price rate\n     */\n    function getPrice(address base, address quote) external view returns (uint256);\n\n    /**\n     * @dev Execute an arbitrary call from a Smart Vault\n     * @param target Address where the call will be sent\n     * @param callData Calldata to be used for the call\n     * @param value Value in wei that will be attached to the call\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return result Call response if it was successful, otherwise it reverts\n     */\n    function call(address target, bytes memory callData, uint256 value, bytes memory data)\n        external\n        returns (bytes memory result);\n\n    /**\n     * @dev Collect tokens from a sender to a Smart Vault\n     * @param token Address of the token to be collected\n     * @param from Address where the tokens will be transfer from\n     * @param amount Amount of tokens to be transferred\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return collected Amount of tokens assigned to the Smart Vault\n     */\n    function collect(address token, address from, uint256 amount, bytes memory data)\n        external\n        returns (uint256 collected);\n\n    /**\n     * @dev Withdraw tokens to an external account\n     * @param token Address of the token to be withdrawn\n     * @param amount Amount of tokens to withdraw\n     * @param recipient Address where the tokens will be transferred to\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return withdrawn Amount of tokens transferred to the recipient address\n     */\n    function withdraw(address token, uint256 amount, address recipient, bytes memory data)\n        external\n        returns (uint256 withdrawn);\n\n    /**\n     * @dev Wrap an amount of native tokens to the wrapped ERC20 version of it\n     * @param amount Amount of native tokens to be wrapped\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return wrapped Amount of tokens wrapped\n     */\n    function wrap(uint256 amount, bytes memory data) external returns (uint256 wrapped);\n\n    /**\n     * @dev Unwrap an amount of wrapped native tokens\n     * @param amount Amount of wrapped native tokens to unwrapped\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return unwrapped Amount of tokens unwrapped\n     */\n    function unwrap(uint256 amount, bytes memory data) external returns (uint256 unwrapped);\n\n    /**\n     * @dev Claim strategy rewards\n     * @param strategy Address of the strategy to claim rewards\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return tokens Addresses of the tokens received as rewards\n     * @return amounts Amounts of the tokens received as rewards\n     */\n    function claim(address strategy, bytes memory data)\n        external\n        returns (address[] memory tokens, uint256[] memory amounts);\n\n    /**\n     * @dev Join a strategy with an amount of tokens\n     * @param strategy Address of the strategy to join\n     * @param tokensIn List of token addresses to join with\n     * @param amountsIn List of token amounts to join with\n     * @param slippage Slippage that will be used to compute the join\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return tokensOut List of token addresses received after the join\n     * @return amountsOut List of token amounts received after the join\n     */\n    function join(\n        address strategy,\n        address[] memory tokensIn,\n        uint256[] memory amountsIn,\n        uint256 slippage,\n        bytes memory data\n    ) external returns (address[] memory tokensOut, uint256[] memory amountsOut);\n\n    /**\n     * @dev Exit a strategy\n     * @param strategy Address of the strategy to exit\n     * @param tokensIn List of token addresses to exit with\n     * @param amountsIn List of token amounts to exit with\n     * @param slippage Slippage that will be used to compute the exit\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return tokensOut List of token addresses received after the exit\n     * @return amountsOut List of token amounts received after the exit\n     */\n    function exit(\n        address strategy,\n        address[] memory tokensIn,\n        uint256[] memory amountsIn,\n        uint256 slippage,\n        bytes memory data\n    ) external returns (address[] memory tokensOut, uint256[] memory amountsOut);\n\n    /**\n     * @dev Swaps two tokens\n     * @param source Source to request the swap. It depends on the Swap Connector attached to a Smart Vault.\n     * @param tokenIn Token being sent\n     * @param tokenOut Token being received\n     * @param amountIn Amount of tokenIn being swapped\n     * @param limitType Swap limit to be applied: slippage or min amount out\n     * @param limitAmount Amount of the swap limit to be applied depending on limitType\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return amountOut Received amount of tokens out\n     */\n    function swap(\n        uint8 source,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        SwapLimit limitType,\n        uint256 limitAmount,\n        bytes memory data\n    ) external returns (uint256 amountOut);\n\n    /**\n     * @dev Bridge assets to another chain\n     * @param source Source to request the bridge. It depends on the Bridge Connector attached to a Smart Vault.\n     * @param chainId ID of the destination chain\n     * @param token Address of the token to be bridged\n     * @param amount Amount of tokens to be bridged\n     * @param limitType Swap limit to be applied: slippage or min amount out\n     * @param limitAmount Amount of the swap limit to be applied depending on limitType\n     * @param recipient Address that will receive the tokens on the destination chain\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return bridged Amount requested to be bridged after fees\n     */\n    function bridge(\n        uint8 source,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        BridgeLimit limitType,\n        uint256 limitAmount,\n        address recipient,\n        bytes memory data\n    ) external returns (uint256 bridged);\n}\n"},"@mimic-fi/v2-smart-vault/contracts/ISmartVaultsFactory.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\n\n/**\n * @title ISmartVaultsFactory\n * @dev Smart Vaults Factory interface, it must follow the IImplementation interface.\n */\ninterface ISmartVaultsFactory is IImplementation {\n    /**\n     * @dev Emitted every time a new Smart Vault instance is created\n     */\n    event Created(address indexed implementation, address indexed instance, bytes initializeResult);\n\n    /**\n     * @dev Tells the implementation associated to a contract instance\n     * @param instance Address of the instance to request it's implementation\n     */\n    function implementationOf(address instance) external view returns (address);\n\n    /**\n     * @dev Creates a new Smart Vault pointing to a registered implementation\n     * @param salt Salt bytes to derivate the address of the new instance\n     * @param implementation Address of the implementation to be instanced\n     * @param initializeData Arbitrary data to be sent after deployment\n     * @return instance Address of the new instance created\n     */\n    function create(bytes32 salt, address implementation, bytes memory initializeData) external returns (address);\n}\n"},"@mimic-fi/v2-smart-vaults-base/contracts/actions/WithdrawalAction.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport './BaseAction.sol';\n\n/**\n * @title Withdrawal action\n * @dev Action that offers a recipient address where funds can be withdrawn. This type of action at least require\n * having withdraw permissions from the Smart Vault tied to it.\n */\nabstract contract WithdrawalAction is BaseAction {\n    // Address where tokens will be transferred to\n    address public recipient;\n\n    /**\n     * @dev Emitted every time the recipient is set\n     */\n    event RecipientSet(address indexed recipient);\n\n    /**\n     * @dev Sets the recipient address. Sender must be authorized.\n     * @param newRecipient Address of the new recipient to be set\n     */\n    function setRecipient(address newRecipient) external auth {\n        require(newRecipient != address(0), 'RECIPIENT_ZERO');\n        recipient = newRecipient;\n        emit RecipientSet(newRecipient);\n    }\n\n    /**\n     * @dev Internal function to withdraw all the available balance of a token from the Smart Vault to the recipient\n     * @param token Address of the token to be withdrawn\n     */\n    function _withdraw(address token) internal {\n        uint256 balance = _balanceOf(token);\n        _withdraw(token, balance);\n    }\n\n    /**\n     * @dev Internal function to withdraw a specific amount of a token from the Smart Vault to the recipient\n     * @param token Address of the token to be withdrawn\n     * @param amount Amount of tokens to be withdrawn\n     */\n    function _withdraw(address token, uint256 amount) internal {\n        smartVault.withdraw(token, amount, recipient, new bytes(0));\n    }\n}\n"},"@mimic-fi/v2-smart-vaults-base/contracts/actions/TimeLockedAction.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport './BaseAction.sol';\n\n/**\n * @title Time-locked action\n * @dev Action that offers a time-lock mechanism to allow executing it only once during a set period of time\n */\nabstract contract TimeLockedAction is BaseAction {\n    // Period in seconds\n    uint256 public period;\n\n    // Next timestamp in the future when the action can be executed again\n    uint256 public nextResetTime;\n\n    /**\n     * @dev Emitted every time a time-lock is set\n     */\n    event TimeLockSet(uint256 period);\n\n    /**\n     * @dev Creates a new time-locked action\n     */\n    constructor() {\n        nextResetTime = block.timestamp;\n    }\n\n    /**\n     * @dev Sets a new period for the time-locked action\n     * @param newPeriod New period to be set\n     */\n    function setTimeLock(uint256 newPeriod) external auth {\n        period = newPeriod;\n        emit TimeLockSet(newPeriod);\n    }\n\n    /**\n     * @dev Internal function to tell whether the current time-lock has passed\n     */\n    function _passesTimeLock() internal view returns (bool) {\n        return block.timestamp >= nextResetTime;\n    }\n\n    /**\n     * @dev Internal function to validate the time-locked action\n     */\n    function _validateTimeLock() internal {\n        require(_passesTimeLock(), 'TIME_LOCK_NOT_EXPIRED');\n        nextResetTime = block.timestamp + period;\n    }\n}\n"},"@mimic-fi/v2-registry/contracts/implementations/InitializableAuthorizedImplementation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@mimic-fi/v2-helpers/contracts/auth/Authorizer.sol';\n\nimport './InitializableImplementation.sol';\n\n/**\n * @title InitializableAuthorizedImplementation\n * @dev InitializableImplementation using the Authorizer mixin. Initializable implementations that want to use the\n * Authorizer permissions mechanism should inherit from this contract instead.\n */\nabstract contract InitializableAuthorizedImplementation is InitializableImplementation, Authorizer {\n    /**\n     * @dev Creates a new InitializableAuthorizedImplementation\n     * @param registry Address of the Mimic Registry\n     */\n    constructor(address registry) InitializableImplementation(registry) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Initialization function that authorizes an admin account to authorize and unauthorize accounts.\n     * Note this function can only be called from a function marked with the `initializer` modifier.\n     * @param admin Address to be granted authorize and unauthorize permissions\n     */\n    function _initialize(address admin) internal onlyInitializing {\n        _initialize();\n        _authorize(admin, Authorizer.authorize.selector);\n        _authorize(admin, Authorizer.unauthorize.selector);\n    }\n}\n"},"@mimic-fi/v2-smart-vault/contracts/helpers/SwapConnectorLib.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/utils/Address.sol';\n\nimport '@mimic-fi/v2-swap-connector/contracts/ISwapConnector.sol';\n\n/**\n * @title SwapConnectorLib\n * @dev Library used to delegate-call swaps and decode return data correctly\n */\nlibrary SwapConnectorLib {\n    /**\n     * @dev Delegate-calls a swap to the swap connector and decodes de expected data\n     * IMPORTANT! This helper method does not check any of the given params, these should be checked beforehand.\n     */\n    function swap(\n        address connector,\n        uint8 source,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        bytes memory data\n    ) internal returns (uint256 amountOut) {\n        bytes memory swapData = abi.encodeWithSelector(\n            ISwapConnector.swap.selector,\n            source,\n            tokenIn,\n            tokenOut,\n            amountIn,\n            minAmountOut,\n            data\n        );\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = connector.delegatecall(swapData);\n        Address.verifyCallResult(success, returndata, 'SWAP_CALL_REVERTED');\n        return abi.decode(returndata, (uint256));\n    }\n}\n"},"@openzeppelin/contracts/security/Pausable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"},"@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"},"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"@openzeppelin/contracts/utils/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"@mimic-fi/v2-smart-vaults-base/contracts/actions/IAction.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\nimport '@mimic-fi/v2-smart-vault/contracts/ISmartVault.sol';\nimport '@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol';\n\n/**\n * @title IAction\n * @dev Action interface it must follow the IAuthorizer interface\n */\ninterface IAction is IAuthorizer {\n    /**\n     * @dev Emitted every time an action is executed\n     */\n    event Executed();\n\n    /**\n     * @dev Tells the address of the Smart Vault tied to it, it cannot be changed\n     */\n    function smartVault() external view returns (ISmartVault);\n}\n"}},"settings":{"libraries":{},"optimizer":{"enabled":true,"runs":10000},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}}},"ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"what\",\"type\":\"bytes4\"}],\"name\":\"Authorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"smartVault\",\"type\":\"address\"}],\"name\":\"SmartVaultSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"source\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"SourceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"what\",\"type\":\"bytes4\"}],\"name\":\"Unauthorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ANY_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAMESPACE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"what\",\"type\":\"bytes4\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"source\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"call\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllowedSources\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"what\",\"type\":\"bytes4\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"source\",\"type\":\"uint256\"}],\"name\":\"isSourceAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSmartVault\",\"type\":\"address\"}],\"name\":\"setSmartVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"source\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setSource\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"smartVault\",\"outputs\":[{\"internalType\":\"contract ISmartVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"what\",\"type\":\"bytes4\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Swapper","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":1,"Runs":10000,"ConstructorArguments":"0x000000000000000000000000028dbdc93fd8c9294ba61bf145f8384cd4385c7b000000000000000000000000de6d4872c0c8167fb4f405c7854fd2fed7edca21","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}