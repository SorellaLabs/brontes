{"expiry":1699567508,"data":[{"SourceCode":{"language":"Solidity","sources":{"contracts/interfaces/ConduitInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\n// prettier-ignore\nimport {\n    ConduitTransfer,\n    ConduitBatch1155Transfer\n} from \"../conduit/lib/ConduitStructs.sol\";\n\n/**\n * @title ConduitInterface\n * @author 0age\n * @notice ConduitInterface contains all external function interfaces, events,\n *         and errors for conduit contracts.\n */\ninterface ConduitInterface {\n    /**\n     * @dev Revert with an error when attempting to execute transfers using a\n     *      caller that does not have an open channel.\n     */\n    error ChannelClosed(address channel);\n\n    /**\n     * @dev Revert with an error when attempting to update a channel to the\n     *      current status of that channel.\n     */\n    error ChannelStatusAlreadySet(address channel, bool isOpen);\n\n    /**\n     * @dev Revert with an error when attempting to execute a transfer for an\n     *      item that does not have an ERC20/721/1155 item type.\n     */\n    error InvalidItemType();\n\n    /**\n     * @dev Revert with an error when attempting to update the status of a\n     *      channel from a caller that is not the conduit controller.\n     */\n    error InvalidController();\n\n    /**\n     * @dev Emit an event whenever a channel is opened or closed.\n     *\n     * @param channel The channel that has been updated.\n     * @param open    A boolean indicating whether the conduit is open or not.\n     */\n    event ChannelUpdated(address indexed channel, bool open);\n\n    /**\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\n     *         with an open channel can call this function.\n     *\n     * @param transfers The ERC20/721/1155 transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function execute(ConduitTransfer[] calldata transfers)\n        external\n        returns (bytes4 magicValue);\n\n    /**\n     * @notice Execute a sequence of batch 1155 transfers. Only a caller with an\n     *         open channel can call this function.\n     *\n     * @param batch1155Transfers The 1155 batch transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function executeBatch1155(\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\n    ) external returns (bytes4 magicValue);\n\n    /**\n     * @notice Execute a sequence of transfers, both single and batch 1155. Only\n     *         a caller with an open channel can call this function.\n     *\n     * @param standardTransfers  The ERC20/721/1155 transfers to perform.\n     * @param batch1155Transfers The 1155 batch transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function executeWithBatch1155(\n        ConduitTransfer[] calldata standardTransfers,\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\n    ) external returns (bytes4 magicValue);\n\n    /**\n     * @notice Open or close a given channel. Only callable by the controller.\n     *\n     * @param channel The channel to open or close.\n     * @param isOpen  The status of the channel (either open or closed).\n     */\n    function updateChannel(address channel, bool isOpen) external;\n}\n"},"contracts/interfaces/TokenTransferrerErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\n/**\n * @title TokenTransferrerErrors\n */\ninterface TokenTransferrerErrors {\n    /**\n     * @dev Revert with an error when an ERC721 transfer with amount other than\n     *      one is attempted.\n     */\n    error InvalidERC721TransferAmount();\n\n    /**\n     * @dev Revert with an error when attempting to fulfill an order where an\n     *      item has an amount of zero.\n     */\n    error MissingItemAmount();\n\n    /**\n     * @dev Revert with an error when attempting to fulfill an order where an\n     *      item has unused parameters. This includes both the token and the\n     *      identifier parameters for native transfers as well as the identifier\n     *      parameter for ERC20 transfers. Note that the conduit does not\n     *      perform this check, leaving it up to the calling channel to enforce\n     *      when desired.\n     */\n    error UnusedItemParameters();\n\n    /**\n     * @dev Revert with an error when an ERC20, ERC721, or ERC1155 token\n     *      transfer reverts.\n     *\n     * @param token      The token for which the transfer was attempted.\n     * @param from       The source of the attempted transfer.\n     * @param to         The recipient of the attempted transfer.\n     * @param identifier The identifier for the attempted transfer.\n     * @param amount     The amount for the attempted transfer.\n     */\n    error TokenTransferGenericFailure(\n        address token,\n        address from,\n        address to,\n        uint256 identifier,\n        uint256 amount\n    );\n\n    /**\n     * @dev Revert with an error when a batch ERC1155 token transfer reverts.\n     *\n     * @param token       The token for which the transfer was attempted.\n     * @param from        The source of the attempted transfer.\n     * @param to          The recipient of the attempted transfer.\n     * @param identifiers The identifiers for the attempted transfer.\n     * @param amounts     The amounts for the attempted transfer.\n     */\n    error ERC1155BatchTransferGenericFailure(\n        address token,\n        address from,\n        address to,\n        uint256[] identifiers,\n        uint256[] amounts\n    );\n\n    /**\n     * @dev Revert with an error when an ERC20 token transfer returns a falsey\n     *      value.\n     *\n     * @param token      The token for which the ERC20 transfer was attempted.\n     * @param from       The source of the attempted ERC20 transfer.\n     * @param to         The recipient of the attempted ERC20 transfer.\n     * @param amount     The amount for the attempted ERC20 transfer.\n     */\n    error BadReturnValueFromERC20OnTransfer(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    );\n\n    /**\n     * @dev Revert with an error when an account being called as an assumed\n     *      contract does not have code and returns no data.\n     *\n     * @param account The account that should contain code.\n     */\n    error NoContract(address account);\n\n    /**\n     * @dev Revert with an error when attempting to execute an 1155 batch\n     *      transfer using calldata not produced by default ABI encoding or with\n     *      different lengths for ids and amounts arrays.\n     */\n    error Invalid1155BatchTransferEncoding();\n}\n"},"contracts/lib/TokenTransferrer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\nimport \"./TokenTransferrerConstants.sol\";\n\n// prettier-ignore\nimport {\n    TokenTransferrerErrors\n} from \"../interfaces/TokenTransferrerErrors.sol\";\n\nimport { ConduitBatch1155Transfer } from \"../conduit/lib/ConduitStructs.sol\";\n\n/**\n * @title TokenTransferrer\n * @author 0age\n * @custom:coauthor d1ll0n\n * @custom:coauthor transmissions11\n * @notice TokenTransferrer is a library for performing optimized ERC20, ERC721,\n *         ERC1155, and batch ERC1155 transfers, used by both Seaport as well as\n *         by conduits deployed by the ConduitController. Use great caution when\n *         considering these functions for use in other codebases, as there are\n *         significant side effects and edge cases that need to be thoroughly\n *         understood and carefully addressed.\n */\ncontract TokenTransferrer is TokenTransferrerErrors {\n    /**\n     * @dev Internal function to transfer ERC20 tokens from a given originator\n     *      to a given recipient. Sufficient approvals must be set on the\n     *      contract performing the transfer.\n     *\n     * @param token      The ERC20 token to transfer.\n     * @param from       The originator of the transfer.\n     * @param to         The recipient of the transfer.\n     * @param amount     The amount to transfer.\n     */\n    function _performERC20Transfer(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        // Utilize assembly to perform an optimized ERC20 token transfer.\n        assembly {\n            // The free memory pointer memory slot will be used when populating\n            // call data for the transfer; read the value and restore it later.\n            let memPointer := mload(FreeMemoryPointerSlot)\n\n            // Write call data into memory, starting with function selector.\n            mstore(ERC20_transferFrom_sig_ptr, ERC20_transferFrom_signature)\n            mstore(ERC20_transferFrom_from_ptr, from)\n            mstore(ERC20_transferFrom_to_ptr, to)\n            mstore(ERC20_transferFrom_amount_ptr, amount)\n\n            // Make call & copy up to 32 bytes of return data to scratch space.\n            // Scratch space does not need to be cleared ahead of time, as the\n            // subsequent check will ensure that either at least a full word of\n            // return data is received (in which case it will be overwritten) or\n            // that no data is received (in which case scratch space will be\n            // ignored) on a successful call to the given token.\n            let callStatus := call(\n                gas(),\n                token,\n                0,\n                ERC20_transferFrom_sig_ptr,\n                ERC20_transferFrom_length,\n                0,\n                OneWord\n            )\n\n            // Determine whether transfer was successful using status & result.\n            let success := and(\n                // Set success to whether the call reverted, if not check it\n                // either returned exactly 1 (can't just be non-zero data), or\n                // had no return data.\n                or(\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\n                    iszero(returndatasize())\n                ),\n                callStatus\n            )\n\n            // Handle cases where either the transfer failed or no data was\n            // returned. Group these, as most transfers will succeed with data.\n            // Equivalent to `or(iszero(success), iszero(returndatasize()))`\n            // but after it's inverted for JUMPI this expression is cheaper.\n            if iszero(and(success, iszero(iszero(returndatasize())))) {\n                // If the token has no code or the transfer failed: Equivalent\n                // to `or(iszero(success), iszero(extcodesize(token)))` but\n                // after it's inverted for JUMPI this expression is cheaper.\n                if iszero(and(iszero(iszero(extcodesize(token))), success)) {\n                    // If the transfer failed:\n                    if iszero(success) {\n                        // If it was due to a revert:\n                        if iszero(callStatus) {\n                            // If it returned a message, bubble it up as long as\n                            // sufficient gas remains to do so:\n                            if returndatasize() {\n                                // Ensure that sufficient gas is available to\n                                // copy returndata while expanding memory where\n                                // necessary. Start by computing the word size\n                                // of returndata and allocated memory. Round up\n                                // to the nearest full word.\n                                let returnDataWords := div(\n                                    add(returndatasize(), AlmostOneWord),\n                                    OneWord\n                                )\n\n                                // Note: use the free memory pointer in place of\n                                // msize() to work around a Yul warning that\n                                // prevents accessing msize directly when the IR\n                                // pipeline is activated.\n                                let msizeWords := div(memPointer, OneWord)\n\n                                // Next, compute the cost of the returndatacopy.\n                                let cost := mul(CostPerWord, returnDataWords)\n\n                                // Then, compute cost of new memory allocation.\n                                if gt(returnDataWords, msizeWords) {\n                                    cost := add(\n                                        cost,\n                                        add(\n                                            mul(\n                                                sub(\n                                                    returnDataWords,\n                                                    msizeWords\n                                                ),\n                                                CostPerWord\n                                            ),\n                                            div(\n                                                sub(\n                                                    mul(\n                                                        returnDataWords,\n                                                        returnDataWords\n                                                    ),\n                                                    mul(msizeWords, msizeWords)\n                                                ),\n                                                MemoryExpansionCoefficient\n                                            )\n                                        )\n                                    )\n                                }\n\n                                // Finally, add a small constant and compare to\n                                // gas remaining; bubble up the revert data if\n                                // enough gas is still available.\n                                if lt(add(cost, ExtraGasBuffer), gas()) {\n                                    // Copy returndata to memory; overwrite\n                                    // existing memory.\n                                    returndatacopy(0, 0, returndatasize())\n\n                                    // Revert, specifying memory region with\n                                    // copied returndata.\n                                    revert(0, returndatasize())\n                                }\n                            }\n\n                            // Otherwise revert with a generic error message.\n                            mstore(\n                                TokenTransferGenericFailure_error_sig_ptr,\n                                TokenTransferGenericFailure_error_signature\n                            )\n                            mstore(\n                                TokenTransferGenericFailure_error_token_ptr,\n                                token\n                            )\n                            mstore(\n                                TokenTransferGenericFailure_error_from_ptr,\n                                from\n                            )\n                            mstore(TokenTransferGenericFailure_error_to_ptr, to)\n                            mstore(TokenTransferGenericFailure_error_id_ptr, 0)\n                            mstore(\n                                TokenTransferGenericFailure_error_amount_ptr,\n                                amount\n                            )\n                            revert(\n                                TokenTransferGenericFailure_error_sig_ptr,\n                                TokenTransferGenericFailure_error_length\n                            )\n                        }\n\n                        // Otherwise revert with a message about the token\n                        // returning false or non-compliant return values.\n                        mstore(\n                            BadReturnValueFromERC20OnTransfer_error_sig_ptr,\n                            BadReturnValueFromERC20OnTransfer_error_signature\n                        )\n                        mstore(\n                            BadReturnValueFromERC20OnTransfer_error_token_ptr,\n                            token\n                        )\n                        mstore(\n                            BadReturnValueFromERC20OnTransfer_error_from_ptr,\n                            from\n                        )\n                        mstore(\n                            BadReturnValueFromERC20OnTransfer_error_to_ptr,\n                            to\n                        )\n                        mstore(\n                            BadReturnValueFromERC20OnTransfer_error_amount_ptr,\n                            amount\n                        )\n                        revert(\n                            BadReturnValueFromERC20OnTransfer_error_sig_ptr,\n                            BadReturnValueFromERC20OnTransfer_error_length\n                        )\n                    }\n\n                    // Otherwise, revert with error about token not having code:\n                    mstore(NoContract_error_sig_ptr, NoContract_error_signature)\n                    mstore(NoContract_error_token_ptr, token)\n                    revert(NoContract_error_sig_ptr, NoContract_error_length)\n                }\n\n                // Otherwise, the token just returned no data despite the call\n                // having succeeded; no need to optimize for this as it's not\n                // technically ERC20 compliant.\n            }\n\n            // Restore the original free memory pointer.\n            mstore(FreeMemoryPointerSlot, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZeroSlot, 0)\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer an ERC721 token from a given\n     *      originator to a given recipient. Sufficient approvals must be set on\n     *      the contract performing the transfer. Note that this function does\n     *      not check whether the receiver can accept the ERC721 token (i.e. it\n     *      does not use `safeTransferFrom`).\n     *\n     * @param token      The ERC721 token to transfer.\n     * @param from       The originator of the transfer.\n     * @param to         The recipient of the transfer.\n     * @param identifier The tokenId to transfer.\n     */\n    function _performERC721Transfer(\n        address token,\n        address from,\n        address to,\n        uint256 identifier\n    ) internal {\n        // Utilize assembly to perform an optimized ERC721 token transfer.\n        assembly {\n            // If the token has no code, revert.\n            if iszero(extcodesize(token)) {\n                mstore(NoContract_error_sig_ptr, NoContract_error_signature)\n                mstore(NoContract_error_token_ptr, token)\n                revert(NoContract_error_sig_ptr, NoContract_error_length)\n            }\n\n            // The free memory pointer memory slot will be used when populating\n            // call data for the transfer; read the value and restore it later.\n            let memPointer := mload(FreeMemoryPointerSlot)\n\n            // Write call data to memory starting with function selector.\n            mstore(ERC721_transferFrom_sig_ptr, ERC721_transferFrom_signature)\n            mstore(ERC721_transferFrom_from_ptr, from)\n            mstore(ERC721_transferFrom_to_ptr, to)\n            mstore(ERC721_transferFrom_id_ptr, identifier)\n\n            // Perform the call, ignoring return data.\n            let success := call(\n                gas(),\n                token,\n                0,\n                ERC721_transferFrom_sig_ptr,\n                ERC721_transferFrom_length,\n                0,\n                0\n            )\n\n            // If the transfer reverted:\n            if iszero(success) {\n                // If it returned a message, bubble it up as long as sufficient\n                // gas remains to do so:\n                if returndatasize() {\n                    // Ensure that sufficient gas is available to copy\n                    // returndata while expanding memory where necessary. Start\n                    // by computing word size of returndata & allocated memory.\n                    // Round up to the nearest full word.\n                    let returnDataWords := div(\n                        add(returndatasize(), AlmostOneWord),\n                        OneWord\n                    )\n\n                    // Note: use the free memory pointer in place of msize() to\n                    // work around a Yul warning that prevents accessing msize\n                    // directly when the IR pipeline is activated.\n                    let msizeWords := div(memPointer, OneWord)\n\n                    // Next, compute the cost of the returndatacopy.\n                    let cost := mul(CostPerWord, returnDataWords)\n\n                    // Then, compute cost of new memory allocation.\n                    if gt(returnDataWords, msizeWords) {\n                        cost := add(\n                            cost,\n                            add(\n                                mul(\n                                    sub(returnDataWords, msizeWords),\n                                    CostPerWord\n                                ),\n                                div(\n                                    sub(\n                                        mul(returnDataWords, returnDataWords),\n                                        mul(msizeWords, msizeWords)\n                                    ),\n                                    MemoryExpansionCoefficient\n                                )\n                            )\n                        )\n                    }\n\n                    // Finally, add a small constant and compare to gas\n                    // remaining; bubble up the revert data if enough gas is\n                    // still available.\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\n                        // Copy returndata to memory; overwrite existing memory.\n                        returndatacopy(0, 0, returndatasize())\n\n                        // Revert, giving memory region with copied returndata.\n                        revert(0, returndatasize())\n                    }\n                }\n\n                // Otherwise revert with a generic error message.\n                mstore(\n                    TokenTransferGenericFailure_error_sig_ptr,\n                    TokenTransferGenericFailure_error_signature\n                )\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\n                mstore(TokenTransferGenericFailure_error_id_ptr, identifier)\n                mstore(TokenTransferGenericFailure_error_amount_ptr, 1)\n                revert(\n                    TokenTransferGenericFailure_error_sig_ptr,\n                    TokenTransferGenericFailure_error_length\n                )\n            }\n\n            // Restore the original free memory pointer.\n            mstore(FreeMemoryPointerSlot, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZeroSlot, 0)\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer ERC1155 tokens from a given\n     *      originator to a given recipient. Sufficient approvals must be set on\n     *      the contract performing the transfer and contract recipients must\n     *      implement the ERC1155TokenReceiver interface to indicate that they\n     *      are willing to accept the transfer.\n     *\n     * @param token      The ERC1155 token to transfer.\n     * @param from       The originator of the transfer.\n     * @param to         The recipient of the transfer.\n     * @param identifier The id to transfer.\n     * @param amount     The amount to transfer.\n     */\n    function _performERC1155Transfer(\n        address token,\n        address from,\n        address to,\n        uint256 identifier,\n        uint256 amount\n    ) internal {\n        // Utilize assembly to perform an optimized ERC1155 token transfer.\n        assembly {\n            // If the token has no code, revert.\n            if iszero(extcodesize(token)) {\n                mstore(NoContract_error_sig_ptr, NoContract_error_signature)\n                mstore(NoContract_error_token_ptr, token)\n                revert(NoContract_error_sig_ptr, NoContract_error_length)\n            }\n\n            // The following memory slots will be used when populating call data\n            // for the transfer; read the values and restore them later.\n            let memPointer := mload(FreeMemoryPointerSlot)\n            let slot0x80 := mload(Slot0x80)\n            let slot0xA0 := mload(Slot0xA0)\n            let slot0xC0 := mload(Slot0xC0)\n\n            // Write call data into memory, beginning with function selector.\n            mstore(\n                ERC1155_safeTransferFrom_sig_ptr,\n                ERC1155_safeTransferFrom_signature\n            )\n            mstore(ERC1155_safeTransferFrom_from_ptr, from)\n            mstore(ERC1155_safeTransferFrom_to_ptr, to)\n            mstore(ERC1155_safeTransferFrom_id_ptr, identifier)\n            mstore(ERC1155_safeTransferFrom_amount_ptr, amount)\n            mstore(\n                ERC1155_safeTransferFrom_data_offset_ptr,\n                ERC1155_safeTransferFrom_data_length_offset\n            )\n            mstore(ERC1155_safeTransferFrom_data_length_ptr, 0)\n\n            // Perform the call, ignoring return data.\n            let success := call(\n                gas(),\n                token,\n                0,\n                ERC1155_safeTransferFrom_sig_ptr,\n                ERC1155_safeTransferFrom_length,\n                0,\n                0\n            )\n\n            // If the transfer reverted:\n            if iszero(success) {\n                // If it returned a message, bubble it up as long as sufficient\n                // gas remains to do so:\n                if returndatasize() {\n                    // Ensure that sufficient gas is available to copy\n                    // returndata while expanding memory where necessary. Start\n                    // by computing word size of returndata & allocated memory.\n                    // Round up to the nearest full word.\n                    let returnDataWords := div(\n                        add(returndatasize(), AlmostOneWord),\n                        OneWord\n                    )\n\n                    // Note: use the free memory pointer in place of msize() to\n                    // work around a Yul warning that prevents accessing msize\n                    // directly when the IR pipeline is activated.\n                    let msizeWords := div(memPointer, OneWord)\n\n                    // Next, compute the cost of the returndatacopy.\n                    let cost := mul(CostPerWord, returnDataWords)\n\n                    // Then, compute cost of new memory allocation.\n                    if gt(returnDataWords, msizeWords) {\n                        cost := add(\n                            cost,\n                            add(\n                                mul(\n                                    sub(returnDataWords, msizeWords),\n                                    CostPerWord\n                                ),\n                                div(\n                                    sub(\n                                        mul(returnDataWords, returnDataWords),\n                                        mul(msizeWords, msizeWords)\n                                    ),\n                                    MemoryExpansionCoefficient\n                                )\n                            )\n                        )\n                    }\n\n                    // Finally, add a small constant and compare to gas\n                    // remaining; bubble up the revert data if enough gas is\n                    // still available.\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\n                        // Copy returndata to memory; overwrite existing memory.\n                        returndatacopy(0, 0, returndatasize())\n\n                        // Revert, giving memory region with copied returndata.\n                        revert(0, returndatasize())\n                    }\n                }\n\n                // Otherwise revert with a generic error message.\n                mstore(\n                    TokenTransferGenericFailure_error_sig_ptr,\n                    TokenTransferGenericFailure_error_signature\n                )\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\n                mstore(TokenTransferGenericFailure_error_id_ptr, identifier)\n                mstore(TokenTransferGenericFailure_error_amount_ptr, amount)\n                revert(\n                    TokenTransferGenericFailure_error_sig_ptr,\n                    TokenTransferGenericFailure_error_length\n                )\n            }\n\n            mstore(Slot0x80, slot0x80) // Restore slot 0x80.\n            mstore(Slot0xA0, slot0xA0) // Restore slot 0xA0.\n            mstore(Slot0xC0, slot0xC0) // Restore slot 0xC0.\n\n            // Restore the original free memory pointer.\n            mstore(FreeMemoryPointerSlot, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZeroSlot, 0)\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer ERC1155 tokens from a given\n     *      originator to a given recipient. Sufficient approvals must be set on\n     *      the contract performing the transfer and contract recipients must\n     *      implement the ERC1155TokenReceiver interface to indicate that they\n     *      are willing to accept the transfer. NOTE: this function is not\n     *      memory-safe; it will overwrite existing memory, restore the free\n     *      memory pointer to the default value, and overwrite the zero slot.\n     *      This function should only be called once memory is no longer\n     *      required and when uninitialized arrays are not utilized, and memory\n     *      should be considered fully corrupted (aside from the existence of a\n     *      default-value free memory pointer) after calling this function.\n     *\n     * @param batchTransfers The group of 1155 batch transfers to perform.\n     */\n    function _performERC1155BatchTransfers(\n        ConduitBatch1155Transfer[] calldata batchTransfers\n    ) internal {\n        // Utilize assembly to perform optimized batch 1155 transfers.\n        assembly {\n            let len := batchTransfers.length\n            // Pointer to first head in the array, which is offset to the struct\n            // at each index. This gets incremented after each loop to avoid\n            // multiplying by 32 to get the offset for each element.\n            let nextElementHeadPtr := batchTransfers.offset\n\n            // Pointer to beginning of the head of the array. This is the\n            // reference position each offset references. It's held static to\n            // let each loop calculate the data position for an element.\n            let arrayHeadPtr := nextElementHeadPtr\n\n            // Write the function selector, which will be reused for each call:\n            // safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\n            mstore(\n                ConduitBatch1155Transfer_from_offset,\n                ERC1155_safeBatchTransferFrom_signature\n            )\n\n            // Iterate over each batch transfer.\n            for {\n                let i := 0\n            } lt(i, len) {\n                i := add(i, 1)\n            } {\n                // Read the offset to the beginning of the element and add\n                // it to pointer to the beginning of the array head to get\n                // the absolute position of the element in calldata.\n                let elementPtr := add(\n                    arrayHeadPtr,\n                    calldataload(nextElementHeadPtr)\n                )\n\n                // Retrieve the token from calldata.\n                let token := calldataload(elementPtr)\n\n                // If the token has no code, revert.\n                if iszero(extcodesize(token)) {\n                    mstore(NoContract_error_sig_ptr, NoContract_error_signature)\n                    mstore(NoContract_error_token_ptr, token)\n                    revert(NoContract_error_sig_ptr, NoContract_error_length)\n                }\n\n                // Get the total number of supplied ids.\n                let idsLength := calldataload(\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset)\n                )\n\n                // Determine the expected offset for the amounts array.\n                let expectedAmountsOffset := add(\n                    ConduitBatch1155Transfer_amounts_length_baseOffset,\n                    mul(idsLength, OneWord)\n                )\n\n                // Validate struct encoding.\n                let invalidEncoding := iszero(\n                    and(\n                        // ids.length == amounts.length\n                        eq(\n                            idsLength,\n                            calldataload(add(elementPtr, expectedAmountsOffset))\n                        ),\n                        and(\n                            // ids_offset == 0xa0\n                            eq(\n                                calldataload(\n                                    add(\n                                        elementPtr,\n                                        ConduitBatch1155Transfer_ids_head_offset\n                                    )\n                                ),\n                                ConduitBatch1155Transfer_ids_length_offset\n                            ),\n                            // amounts_offset == 0xc0 + ids.length*32\n                            eq(\n                                calldataload(\n                                    add(\n                                        elementPtr,\n                                        ConduitBatchTransfer_amounts_head_offset\n                                    )\n                                ),\n                                expectedAmountsOffset\n                            )\n                        )\n                    )\n                )\n\n                // Revert with an error if the encoding is not valid.\n                if invalidEncoding {\n                    mstore(\n                        Invalid1155BatchTransferEncoding_ptr,\n                        Invalid1155BatchTransferEncoding_selector\n                    )\n                    revert(\n                        Invalid1155BatchTransferEncoding_ptr,\n                        Invalid1155BatchTransferEncoding_length\n                    )\n                }\n\n                // Update the offset position for the next loop\n                nextElementHeadPtr := add(nextElementHeadPtr, OneWord)\n\n                // Copy the first section of calldata (before dynamic values).\n                calldatacopy(\n                    BatchTransfer1155Params_ptr,\n                    add(elementPtr, ConduitBatch1155Transfer_from_offset),\n                    ConduitBatch1155Transfer_usable_head_size\n                )\n\n                // Determine size of calldata required for ids and amounts. Note\n                // that the size includes both lengths as well as the data.\n                let idsAndAmountsSize := add(TwoWords, mul(idsLength, TwoWords))\n\n                // Update the offset for the data array in memory.\n                mstore(\n                    BatchTransfer1155Params_data_head_ptr,\n                    add(\n                        BatchTransfer1155Params_ids_length_offset,\n                        idsAndAmountsSize\n                    )\n                )\n\n                // Set the length of the data array in memory to zero.\n                mstore(\n                    add(\n                        BatchTransfer1155Params_data_length_basePtr,\n                        idsAndAmountsSize\n                    ),\n                    0\n                )\n\n                // Determine the total calldata size for the call to transfer.\n                let transferDataSize := add(\n                    BatchTransfer1155Params_calldata_baseSize,\n                    idsAndAmountsSize\n                )\n\n                // Copy second section of calldata (including dynamic values).\n                calldatacopy(\n                    BatchTransfer1155Params_ids_length_ptr,\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset),\n                    idsAndAmountsSize\n                )\n\n                // Perform the call to transfer 1155 tokens.\n                let success := call(\n                    gas(),\n                    token,\n                    0,\n                    ConduitBatch1155Transfer_from_offset, // Data portion start.\n                    transferDataSize, // Location of the length of callData.\n                    0,\n                    0\n                )\n\n                // If the transfer reverted:\n                if iszero(success) {\n                    // If it returned a message, bubble it up as long as\n                    // sufficient gas remains to do so:\n                    if returndatasize() {\n                        // Ensure that sufficient gas is available to copy\n                        // returndata while expanding memory where necessary.\n                        // Start by computing word size of returndata and\n                        // allocated memory. Round up to the nearest full word.\n                        let returnDataWords := div(\n                            add(returndatasize(), AlmostOneWord),\n                            OneWord\n                        )\n\n                        // Note: use transferDataSize in place of msize() to\n                        // work around a Yul warning that prevents accessing\n                        // msize directly when the IR pipeline is activated.\n                        // The free memory pointer is not used here because\n                        // this function does almost all memory management\n                        // manually and does not update it, and transferDataSize\n                        // should be the largest memory value used (unless a\n                        // previous batch was larger).\n                        let msizeWords := div(transferDataSize, OneWord)\n\n                        // Next, compute the cost of the returndatacopy.\n                        let cost := mul(CostPerWord, returnDataWords)\n\n                        // Then, compute cost of new memory allocation.\n                        if gt(returnDataWords, msizeWords) {\n                            cost := add(\n                                cost,\n                                add(\n                                    mul(\n                                        sub(returnDataWords, msizeWords),\n                                        CostPerWord\n                                    ),\n                                    div(\n                                        sub(\n                                            mul(\n                                                returnDataWords,\n                                                returnDataWords\n                                            ),\n                                            mul(msizeWords, msizeWords)\n                                        ),\n                                        MemoryExpansionCoefficient\n                                    )\n                                )\n                            )\n                        }\n\n                        // Finally, add a small constant and compare to gas\n                        // remaining; bubble up the revert data if enough gas is\n                        // still available.\n                        if lt(add(cost, ExtraGasBuffer), gas()) {\n                            // Copy returndata to memory; overwrite existing.\n                            returndatacopy(0, 0, returndatasize())\n\n                            // Revert with memory region containing returndata.\n                            revert(0, returndatasize())\n                        }\n                    }\n\n                    // Set the error signature.\n                    mstore(\n                        0,\n                        ERC1155BatchTransferGenericFailure_error_signature\n                    )\n\n                    // Write the token.\n                    mstore(ERC1155BatchTransferGenericFailure_token_ptr, token)\n\n                    // Increase the offset to ids by 32.\n                    mstore(\n                        BatchTransfer1155Params_ids_head_ptr,\n                        ERC1155BatchTransferGenericFailure_ids_offset\n                    )\n\n                    // Increase the offset to amounts by 32.\n                    mstore(\n                        BatchTransfer1155Params_amounts_head_ptr,\n                        add(\n                            OneWord,\n                            mload(BatchTransfer1155Params_amounts_head_ptr)\n                        )\n                    )\n\n                    // Return modified region. The total size stays the same as\n                    // `token` uses the same number of bytes as `data.length`.\n                    revert(0, transferDataSize)\n                }\n            }\n\n            // Reset the free memory pointer to the default value; memory must\n            // be assumed to be dirtied and not reused from this point forward.\n            // Also note that the zero slot is not reset to zero, meaning empty\n            // arrays cannot be safely created or utilized until it is restored.\n            mstore(FreeMemoryPointerSlot, DefaultFreeMemoryPointer)\n        }\n    }\n}\n"},"contracts/conduit/Conduit.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\nimport { ConduitInterface } from \"../interfaces/ConduitInterface.sol\";\n\nimport { ConduitItemType } from \"./lib/ConduitEnums.sol\";\n\nimport { TokenTransferrer } from \"../lib/TokenTransferrer.sol\";\n\n// prettier-ignore\nimport {\n    ConduitTransfer,\n    ConduitBatch1155Transfer\n} from \"./lib/ConduitStructs.sol\";\n\nimport \"./lib/ConduitConstants.sol\";\n\n/**\n * @title Conduit\n * @author 0age\n * @notice This contract serves as an originator for \"proxied\" transfers. Each\n *         conduit is deployed and controlled by a \"conduit controller\" that can\n *         add and remove \"channels\" or contracts that can instruct the conduit\n *         to transfer approved ERC20/721/1155 tokens. *IMPORTANT NOTE: each\n *         conduit has an owner that can arbitrarily add or remove channels, and\n *         a malicious or negligent owner can add a channel that allows for any\n *         approved ERC20/721/1155 tokens to be taken immediately — be extremely\n *         cautious with what conduits you give token approvals to!*\n */\ncontract Conduit is ConduitInterface, TokenTransferrer {\n    // Set deployer as an immutable controller that can update channel statuses.\n    address private immutable _controller;\n\n    // Track the status of each channel.\n    mapping(address => bool) private _channels;\n\n    /**\n     * @notice Ensure that the caller is currently registered as an open channel\n     *         on the conduit.\n     */\n    modifier onlyOpenChannel() {\n        // Utilize assembly to access channel storage mapping directly.\n        assembly {\n            // Write the caller to scratch space.\n            mstore(ChannelKey_channel_ptr, caller())\n\n            // Write the storage slot for _channels to scratch space.\n            mstore(ChannelKey_slot_ptr, _channels.slot)\n\n            // Derive the position in storage of _channels[msg.sender]\n            // and check if the stored value is zero.\n            if iszero(\n                sload(keccak256(ChannelKey_channel_ptr, ChannelKey_length))\n            ) {\n                // The caller is not an open channel; revert with\n                // ChannelClosed(caller). First, set error signature in memory.\n                mstore(ChannelClosed_error_ptr, ChannelClosed_error_signature)\n\n                // Next, set the caller as the argument.\n                mstore(ChannelClosed_channel_ptr, caller())\n\n                // Finally, revert, returning full custom error with argument.\n                revert(ChannelClosed_error_ptr, ChannelClosed_error_length)\n            }\n        }\n\n        // Continue with function execution.\n        _;\n    }\n\n    /**\n     * @notice In the constructor, set the deployer as the controller.\n     */\n    constructor() {\n        // Set the deployer as the controller.\n        _controller = msg.sender;\n    }\n\n    /**\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\n     *         with an open channel can call this function. Note that channels\n     *         are expected to implement reentrancy protection if desired, and\n     *         that cross-channel reentrancy may be possible if the conduit has\n     *         multiple open channels at once. Also note that channels are\n     *         expected to implement checks against transferring any zero-amount\n     *         items if that constraint is desired.\n     *\n     * @param transfers The ERC20/721/1155 transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function execute(ConduitTransfer[] calldata transfers)\n        external\n        override\n        onlyOpenChannel\n        returns (bytes4 magicValue)\n    {\n        // Retrieve the total number of transfers and place on the stack.\n        uint256 totalStandardTransfers = transfers.length;\n\n        // Iterate over each transfer.\n        for (uint256 i = 0; i < totalStandardTransfers; ) {\n            // Retrieve the transfer in question and perform the transfer.\n            _transfer(transfers[i]);\n\n            // Skip overflow check as for loop is indexed starting at zero.\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Return a magic value indicating that the transfers were performed.\n        magicValue = this.execute.selector;\n    }\n\n    /**\n     * @notice Execute a sequence of batch 1155 item transfers. Only a caller\n     *         with an open channel can call this function. Note that channels\n     *         are expected to implement reentrancy protection if desired, and\n     *         that cross-channel reentrancy may be possible if the conduit has\n     *         multiple open channels at once. Also note that channels are\n     *         expected to implement checks against transferring any zero-amount\n     *         items if that constraint is desired.\n     *\n     * @param batchTransfers The 1155 batch item transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the item transfers were\n     *                    performed successfully.\n     */\n    function executeBatch1155(\n        ConduitBatch1155Transfer[] calldata batchTransfers\n    ) external override onlyOpenChannel returns (bytes4 magicValue) {\n        // Perform 1155 batch transfers. Note that memory should be considered\n        // entirely corrupted from this point forward.\n        _performERC1155BatchTransfers(batchTransfers);\n\n        // Return a magic value indicating that the transfers were performed.\n        magicValue = this.executeBatch1155.selector;\n    }\n\n    /**\n     * @notice Execute a sequence of transfers, both single ERC20/721/1155 item\n     *         transfers as well as batch 1155 item transfers. Only a caller\n     *         with an open channel can call this function. Note that channels\n     *         are expected to implement reentrancy protection if desired, and\n     *         that cross-channel reentrancy may be possible if the conduit has\n     *         multiple open channels at once. Also note that channels are\n     *         expected to implement checks against transferring any zero-amount\n     *         items if that constraint is desired.\n     *\n     * @param standardTransfers The ERC20/721/1155 item transfers to perform.\n     * @param batchTransfers    The 1155 batch item transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the item transfers were\n     *                    performed successfully.\n     */\n    function executeWithBatch1155(\n        ConduitTransfer[] calldata standardTransfers,\n        ConduitBatch1155Transfer[] calldata batchTransfers\n    ) external override onlyOpenChannel returns (bytes4 magicValue) {\n        // Retrieve the total number of transfers and place on the stack.\n        uint256 totalStandardTransfers = standardTransfers.length;\n\n        // Iterate over each standard transfer.\n        for (uint256 i = 0; i < totalStandardTransfers; ) {\n            // Retrieve the transfer in question and perform the transfer.\n            _transfer(standardTransfers[i]);\n\n            // Skip overflow check as for loop is indexed starting at zero.\n            unchecked {\n                ++i;\n            }\n        }\n\n        // Perform 1155 batch transfers. Note that memory should be considered\n        // entirely corrupted from this point forward aside from the free memory\n        // pointer having the default value.\n        _performERC1155BatchTransfers(batchTransfers);\n\n        // Return a magic value indicating that the transfers were performed.\n        magicValue = this.executeWithBatch1155.selector;\n    }\n\n    /**\n     * @notice Open or close a given channel. Only callable by the controller.\n     *\n     * @param channel The channel to open or close.\n     * @param isOpen  The status of the channel (either open or closed).\n     */\n    function updateChannel(address channel, bool isOpen) external override {\n        // Ensure that the caller is the controller of this contract.\n        if (msg.sender != _controller) {\n            revert InvalidController();\n        }\n\n        // Ensure that the channel does not already have the indicated status.\n        if (_channels[channel] == isOpen) {\n            revert ChannelStatusAlreadySet(channel, isOpen);\n        }\n\n        // Update the status of the channel.\n        _channels[channel] = isOpen;\n\n        // Emit a corresponding event.\n        emit ChannelUpdated(channel, isOpen);\n    }\n\n    /**\n     * @dev Internal function to transfer a given ERC20/721/1155 item. Note that\n     *      channels are expected to implement checks against transferring any\n     *      zero-amount items if that constraint is desired.\n     *\n     * @param item The ERC20/721/1155 item to transfer.\n     */\n    function _transfer(ConduitTransfer calldata item) internal {\n        // Determine the transfer method based on the respective item type.\n        if (item.itemType == ConduitItemType.ERC20) {\n            // Transfer ERC20 token. Note that item.identifier is ignored and\n            // therefore ERC20 transfer items are potentially malleable — this\n            // check should be performed by the calling channel if a constraint\n            // on item malleability is desired.\n            _performERC20Transfer(item.token, item.from, item.to, item.amount);\n        } else if (item.itemType == ConduitItemType.ERC721) {\n            // Ensure that exactly one 721 item is being transferred.\n            if (item.amount != 1) {\n                revert InvalidERC721TransferAmount();\n            }\n\n            // Transfer ERC721 token.\n            _performERC721Transfer(\n                item.token,\n                item.from,\n                item.to,\n                item.identifier\n            );\n        } else if (item.itemType == ConduitItemType.ERC1155) {\n            // Transfer ERC1155 token.\n            _performERC1155Transfer(\n                item.token,\n                item.from,\n                item.to,\n                item.identifier,\n                item.amount\n            );\n        } else {\n            // Throw with an error.\n            revert InvalidItemType();\n        }\n    }\n}\n"},"contracts/conduit/lib/ConduitConstants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\n// error ChannelClosed(address channel)\nuint256 constant ChannelClosed_error_signature = (\n    0x93daadf200000000000000000000000000000000000000000000000000000000\n);\nuint256 constant ChannelClosed_error_ptr = 0x00;\nuint256 constant ChannelClosed_channel_ptr = 0x4;\nuint256 constant ChannelClosed_error_length = 0x24;\n\n// For the mapping:\n// mapping(address => bool) channels\n// The position in storage for a particular account is:\n// keccak256(abi.encode(account, channels.slot))\nuint256 constant ChannelKey_channel_ptr = 0x00;\nuint256 constant ChannelKey_slot_ptr = 0x20;\nuint256 constant ChannelKey_length = 0x40;\n"},"contracts/conduit/lib/ConduitEnums.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\nenum ConduitItemType {\n    NATIVE, // unused\n    ERC20,\n    ERC721,\n    ERC1155\n}\n"},"contracts/lib/TokenTransferrerConstants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\n/*\n * -------------------------- Disambiguation & Other Notes ---------------------\n *    - The term \"head\" is used as it is in the documentation for ABI encoding,\n *      but only in reference to dynamic types, i.e. it always refers to the\n *      offset or pointer to the body of a dynamic type. In calldata, the head\n *      is always an offset (relative to the parent object), while in memory,\n *      the head is always the pointer to the body. More information found here:\n *      https://docs.soliditylang.org/en/v0.8.14/abi-spec.html#argument-encoding\n *        - Note that the length of an array is separate from and precedes the\n *          head of the array.\n *\n *    - The term \"body\" is used in place of the term \"head\" used in the ABI\n *      documentation. It refers to the start of the data for a dynamic type,\n *      e.g. the first word of a struct or the first word of the first element\n *      in an array.\n *\n *    - The term \"pointer\" is used to describe the absolute position of a value\n *      and never an offset relative to another value.\n *        - The suffix \"_ptr\" refers to a memory pointer.\n *        - The suffix \"_cdPtr\" refers to a calldata pointer.\n *\n *    - The term \"offset\" is used to describe the position of a value relative\n *      to some parent value. For example, OrderParameters_conduit_offset is the\n *      offset to the \"conduit\" value in the OrderParameters struct relative to\n *      the start of the body.\n *        - Note: Offsets are used to derive pointers.\n *\n *    - Some structs have pointers defined for all of their fields in this file.\n *      Lines which are commented out are fields that are not used in the\n *      codebase but have been left in for readability.\n */\n\nuint256 constant AlmostOneWord = 0x1f;\nuint256 constant OneWord = 0x20;\nuint256 constant TwoWords = 0x40;\nuint256 constant ThreeWords = 0x60;\n\nuint256 constant FreeMemoryPointerSlot = 0x40;\nuint256 constant ZeroSlot = 0x60;\nuint256 constant DefaultFreeMemoryPointer = 0x80;\n\nuint256 constant Slot0x80 = 0x80;\nuint256 constant Slot0xA0 = 0xa0;\nuint256 constant Slot0xC0 = 0xc0;\n\n// abi.encodeWithSignature(\"transferFrom(address,address,uint256)\")\nuint256 constant ERC20_transferFrom_signature = (\n    0x23b872dd00000000000000000000000000000000000000000000000000000000\n);\nuint256 constant ERC20_transferFrom_sig_ptr = 0x0;\nuint256 constant ERC20_transferFrom_from_ptr = 0x04;\nuint256 constant ERC20_transferFrom_to_ptr = 0x24;\nuint256 constant ERC20_transferFrom_amount_ptr = 0x44;\nuint256 constant ERC20_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\n\n// abi.encodeWithSignature(\n//     \"safeTransferFrom(address,address,uint256,uint256,bytes)\"\n// )\nuint256 constant ERC1155_safeTransferFrom_signature = (\n    0xf242432a00000000000000000000000000000000000000000000000000000000\n);\nuint256 constant ERC1155_safeTransferFrom_sig_ptr = 0x0;\nuint256 constant ERC1155_safeTransferFrom_from_ptr = 0x04;\nuint256 constant ERC1155_safeTransferFrom_to_ptr = 0x24;\nuint256 constant ERC1155_safeTransferFrom_id_ptr = 0x44;\nuint256 constant ERC1155_safeTransferFrom_amount_ptr = 0x64;\nuint256 constant ERC1155_safeTransferFrom_data_offset_ptr = 0x84;\nuint256 constant ERC1155_safeTransferFrom_data_length_ptr = 0xa4;\nuint256 constant ERC1155_safeTransferFrom_length = 0xc4; // 4 + 32 * 6 == 196\nuint256 constant ERC1155_safeTransferFrom_data_length_offset = 0xa0;\n\n// abi.encodeWithSignature(\n//     \"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\"\n// )\nuint256 constant ERC1155_safeBatchTransferFrom_signature = (\n    0x2eb2c2d600000000000000000000000000000000000000000000000000000000\n);\n\nbytes4 constant ERC1155_safeBatchTransferFrom_selector = bytes4(\n    bytes32(ERC1155_safeBatchTransferFrom_signature)\n);\n\nuint256 constant ERC721_transferFrom_signature = ERC20_transferFrom_signature;\nuint256 constant ERC721_transferFrom_sig_ptr = 0x0;\nuint256 constant ERC721_transferFrom_from_ptr = 0x04;\nuint256 constant ERC721_transferFrom_to_ptr = 0x24;\nuint256 constant ERC721_transferFrom_id_ptr = 0x44;\nuint256 constant ERC721_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\n\n// abi.encodeWithSignature(\"NoContract(address)\")\nuint256 constant NoContract_error_signature = (\n    0x5f15d67200000000000000000000000000000000000000000000000000000000\n);\nuint256 constant NoContract_error_sig_ptr = 0x0;\nuint256 constant NoContract_error_token_ptr = 0x4;\nuint256 constant NoContract_error_length = 0x24; // 4 + 32 == 36\n\n// abi.encodeWithSignature(\n//     \"TokenTransferGenericFailure(address,address,address,uint256,uint256)\"\n// )\nuint256 constant TokenTransferGenericFailure_error_signature = (\n    0xf486bc8700000000000000000000000000000000000000000000000000000000\n);\nuint256 constant TokenTransferGenericFailure_error_sig_ptr = 0x0;\nuint256 constant TokenTransferGenericFailure_error_token_ptr = 0x4;\nuint256 constant TokenTransferGenericFailure_error_from_ptr = 0x24;\nuint256 constant TokenTransferGenericFailure_error_to_ptr = 0x44;\nuint256 constant TokenTransferGenericFailure_error_id_ptr = 0x64;\nuint256 constant TokenTransferGenericFailure_error_amount_ptr = 0x84;\n\n// 4 + 32 * 5 == 164\nuint256 constant TokenTransferGenericFailure_error_length = 0xa4;\n\n// abi.encodeWithSignature(\n//     \"BadReturnValueFromERC20OnTransfer(address,address,address,uint256)\"\n// )\nuint256 constant BadReturnValueFromERC20OnTransfer_error_signature = (\n    0x9889192300000000000000000000000000000000000000000000000000000000\n);\nuint256 constant BadReturnValueFromERC20OnTransfer_error_sig_ptr = 0x0;\nuint256 constant BadReturnValueFromERC20OnTransfer_error_token_ptr = 0x4;\nuint256 constant BadReturnValueFromERC20OnTransfer_error_from_ptr = 0x24;\nuint256 constant BadReturnValueFromERC20OnTransfer_error_to_ptr = 0x44;\nuint256 constant BadReturnValueFromERC20OnTransfer_error_amount_ptr = 0x64;\n\n// 4 + 32 * 4 == 132\nuint256 constant BadReturnValueFromERC20OnTransfer_error_length = 0x84;\n\nuint256 constant ExtraGasBuffer = 0x20;\nuint256 constant CostPerWord = 3;\nuint256 constant MemoryExpansionCoefficient = 0x200;\n\n// Values are offset by 32 bytes in order to write the token to the beginning\n// in the event of a revert\nuint256 constant BatchTransfer1155Params_ptr = 0x24;\nuint256 constant BatchTransfer1155Params_ids_head_ptr = 0x64;\nuint256 constant BatchTransfer1155Params_amounts_head_ptr = 0x84;\nuint256 constant BatchTransfer1155Params_data_head_ptr = 0xa4;\nuint256 constant BatchTransfer1155Params_data_length_basePtr = 0xc4;\nuint256 constant BatchTransfer1155Params_calldata_baseSize = 0xc4;\n\nuint256 constant BatchTransfer1155Params_ids_length_ptr = 0xc4;\n\nuint256 constant BatchTransfer1155Params_ids_length_offset = 0xa0;\nuint256 constant BatchTransfer1155Params_amounts_length_baseOffset = 0xc0;\nuint256 constant BatchTransfer1155Params_data_length_baseOffset = 0xe0;\n\nuint256 constant ConduitBatch1155Transfer_usable_head_size = 0x80;\n\nuint256 constant ConduitBatch1155Transfer_from_offset = 0x20;\nuint256 constant ConduitBatch1155Transfer_ids_head_offset = 0x60;\nuint256 constant ConduitBatch1155Transfer_amounts_head_offset = 0x80;\nuint256 constant ConduitBatch1155Transfer_ids_length_offset = 0xa0;\nuint256 constant ConduitBatch1155Transfer_amounts_length_baseOffset = 0xc0;\nuint256 constant ConduitBatch1155Transfer_calldata_baseSize = 0xc0;\n\n// Note: abbreviated version of above constant to adhere to line length limit.\nuint256 constant ConduitBatchTransfer_amounts_head_offset = 0x80;\n\nuint256 constant Invalid1155BatchTransferEncoding_ptr = 0x00;\nuint256 constant Invalid1155BatchTransferEncoding_length = 0x04;\nuint256 constant Invalid1155BatchTransferEncoding_selector = (\n    0xeba2084c00000000000000000000000000000000000000000000000000000000\n);\n\nuint256 constant ERC1155BatchTransferGenericFailure_error_signature = (\n    0xafc445e200000000000000000000000000000000000000000000000000000000\n);\nuint256 constant ERC1155BatchTransferGenericFailure_token_ptr = 0x04;\nuint256 constant ERC1155BatchTransferGenericFailure_ids_offset = 0xc0;\n"},"contracts/conduit/lib/ConduitStructs.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.7;\n\nimport { ConduitItemType } from \"./ConduitEnums.sol\";\n\nstruct ConduitTransfer {\n    ConduitItemType itemType;\n    address token;\n    address from;\n    address to;\n    uint256 identifier;\n    uint256 amount;\n}\n\nstruct ConduitBatch1155Transfer {\n    address token;\n    address from;\n    address to;\n    uint256[] ids;\n    uint256[] amounts;\n}\n"}},"settings":{"libraries":{},"optimizer":{"enabled":true,"runs":1000000},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}},"viaIR":true}},"ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BadReturnValueFromERC20OnTransfer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"channel\",\"type\":\"address\"}],\"name\":\"ChannelClosed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"channel\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"name\":\"ChannelStatusAlreadySet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"identifiers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"ERC1155BatchTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Invalid1155BatchTransferEncoding\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidController\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidERC721TransferAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidItemType\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingItemAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NoContract\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnusedItemParameters\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"channel\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"open\",\"type\":\"bool\"}],\"name\":\"ChannelUpdated\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum ConduitItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ConduitTransfer[]\",\"name\":\"transfers\",\"type\":\"tuple[]\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"magicValue\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct ConduitBatch1155Transfer[]\",\"name\":\"batchTransfers\",\"type\":\"tuple[]\"}],\"name\":\"executeBatch1155\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"magicValue\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum ConduitItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ConduitTransfer[]\",\"name\":\"standardTransfers\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct ConduitBatch1155Transfer[]\",\"name\":\"batchTransfers\",\"type\":\"tuple[]\"}],\"name\":\"executeWithBatch1155\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"magicValue\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"channel\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"name\":\"updateChannel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Conduit","CompilerVersion":"v0.8.14+commit.80d49f37","OptimizationUsed":1,"Runs":1000000,"ConstructorArguments":"0x","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}