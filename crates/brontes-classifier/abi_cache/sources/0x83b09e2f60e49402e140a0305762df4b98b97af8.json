{"expiry":1699580149,"data":[{"SourceCode":{"language":"Solidity","sources":{"lib/solmate/src/auth/Owned.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\nabstract contract Owned {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\n\n    /*//////////////////////////////////////////////////////////////\n                            OWNERSHIP STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    address public owner;\n\n    modifier onlyOwner() virtual {\n        require(msg.sender == owner, \"UNAUTHORIZED\");\n\n        _;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _owner) {\n        owner = _owner;\n\n        emit OwnershipTransferred(address(0), _owner);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             OWNERSHIP LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        owner = newOwner;\n\n        emit OwnershipTransferred(msg.sender, newOwner);\n    }\n}\n"},"src/KekotronSwapV2.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"./interfaces/IWETH.sol\";\nimport \"./interfaces/IPoolV2.sol\";\nimport \"./KekotronLib.sol\";\nimport \"./KekotronErrors.sol\";\n\ncontract KekotronSwapV2 {\n    address private immutable WETH;\n\n    constructor(address weth) {\n        WETH = weth;\n    }\n\n    struct SwapV2 {\n        address pool;\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        uint256 amountOut;\n    }\n\n    function _getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut) private pure returns (uint256) {\n        if (amountIn == 0) { \n            revert(\"KekotronErrors.InsufficientInputAmount\"); \n        }\n        if (reserveIn == 0 || reserveOut == 0) { \n            revert(\"KekotronErrors.InsufficientLiquidity\"); \n        }\n\n        uint256 amountInWithFee = amountIn * 997;\n        uint256 numerator = amountInWithFee * reserveOut;\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\n\n        return numerator / denominator;\n    }\n\n    function _swapV2(SwapV2 memory param, address to) private returns(uint256) {\n        bool zeroForOne = param.tokenIn < param.tokenOut;\n\n        uint256 amountOut;\n        {\n            (uint256 reserve0, uint256 reserve1, ) = IPoolV2(param.pool).getReserves();\n            (uint256 reserveInput, uint256 reserveOutput) = zeroForOne ? (reserve0, reserve1) : (reserve1, reserve0);\n            amountOut = _getAmountOut(IERC20(param.tokenIn).balanceOf(param.pool) - reserveInput, reserveInput, reserveOutput);\n        }\n\n        (uint256 amount0Out, uint256 amount1Out) = zeroForOne ? (uint256(0), amountOut) : (amountOut, uint256(0));\n\n        uint256 balanceBefore = IERC20(param.tokenOut).balanceOf(to);\n        IPoolV2(param.pool).swap(amount0Out, amount1Out, to, new bytes(0));\n        uint256 balanceAfter = IERC20(param.tokenOut).balanceOf(to);\n\n        return balanceAfter - balanceBefore;\n    }\n\n    function _swapExactEthForTokensV2(\n        SwapV2 memory param,\n        address feeReceiver,\n        uint8 fee,\n        uint8 feeOn\n    ) private {      \n        (bool feeIn, bool feeOut) = fee > 0 ? (feeOn == 0, feeOn == 1) : (false, false);\n        uint256 amountFee;\n\n        if (feeIn) {\n            amountFee = param.amountIn * fee / 10_000;\n            KekotronLib.safeTransferETH(feeReceiver, amountFee);\n            param.amountIn -= amountFee;\n            amountFee = 0;\n        }\n\n        KekotronLib.depositWETH(WETH, param.amountIn);\n        KekotronLib.safeTransfer(WETH, param.pool, param.amountIn);\n\n        uint256 amountOut = _swapV2(param, feeOut ? address(this) : msg.sender);\n\n        if (feeOut) {\n            amountFee = amountOut * fee / 10_000;\n            amountOut = amountOut - amountFee;\n        }\n\n        if (amountOut < param.amountOut) { \n            revert(\"KekotronErrors.TooLittleReceived\"); \n        }\n\n        if (amountFee > 0) {\n            KekotronLib.safeTransfer(param.tokenOut, feeReceiver, amountFee);\n        }\n\n        if (feeOut) {\n            KekotronLib.safeTransfer(param.tokenOut, msg.sender, amountOut);\n        }\n    }\n\n    function _swapExactTokensForEthV2(\n        SwapV2 memory param,\n        address feeReceiver,\n        uint8 fee,\n        uint8 feeOn\n    ) private {\n        (bool feeIn, bool feeOut) = fee > 0 ? (feeOn == 0, feeOn == 1) : (false, false);\n        uint256 amountFee;\n\n        if (feeIn) {\n            amountFee = param.amountIn * fee / 10_000;\n            KekotronLib.safeTransferFrom(param.tokenIn, msg.sender, feeReceiver, amountFee);\n            param.amountIn -= amountFee;\n            amountFee = 0;\n        } \n\n        KekotronLib.safeTransferFrom(param.tokenIn, msg.sender, param.pool, param.amountIn);\n\n        uint256 amountOut = _swapV2(param, address(this));\n\n        KekotronLib.withdrawWETH(WETH, amountOut);\n\n        if (feeOut) {\n            amountFee = amountOut * fee / 10_000;\n            amountOut = amountOut - amountFee;\n        }\n\n        if (amountOut < param.amountOut) { \n            revert(\"KekotronErrors.TooLittleReceived\"); \n        }\n\n        if (amountFee > 0) {\n            KekotronLib.safeTransferETH(feeReceiver, amountFee);\n        }\n\n        KekotronLib.safeTransferETH(msg.sender, amountOut);\n    }\n    \n    function _swapExactTokensForTokensV2(\n        SwapV2 memory param,\n        address feeReceiver,\n        uint8 fee,\n        uint8 feeOn\n    ) private {\n        (bool feeIn, bool feeOut) = fee > 0 ? (feeOn == 0, feeOn == 1) : (false, false);\n        uint256 amountFee;\n\n        if (feeIn) {\n            amountFee = param.amountIn * fee / 10_000;\n            KekotronLib.safeTransferFrom(param.tokenIn, msg.sender, feeReceiver, amountFee);\n            param.amountIn -= amountFee;\n            amountFee = 0;\n        } \n\n        KekotronLib.safeTransferFrom(param.tokenIn, msg.sender, param.pool, param.amountIn);\n\n        uint256 amountOut = _swapV2(param, feeOut ? address(this) : msg.sender);\n\n        if (feeOut) {\n            amountFee = amountOut * fee / 10_000;\n            amountOut = amountOut - amountFee;\n        }\n\n        if (amountOut < param.amountOut) { \n            revert(\"KekotronErrors.TooLittleReceived\"); \n        }\n\n        if (amountFee > 0) {\n            KekotronLib.safeTransfer(param.tokenOut, feeReceiver, amountFee);\n        }\n\n        if (feeOut) {\n            KekotronLib.safeTransfer(param.tokenOut, msg.sender, amountOut);\n        }\n    }\n\n    function _swapExactInputV2(\n        SwapV2 memory param,\n        address feeReceiver,\n        uint8 fee,\n        uint8 feeOn\n    ) internal {\n        if (param.tokenIn == address(0)) {\n            param.tokenIn = WETH;\n            return _swapExactEthForTokensV2(param, feeReceiver, fee, feeOn);\n        }\n\n        if (param.tokenOut == address(0)) {\n            param.tokenOut = WETH;\n            return _swapExactTokensForEthV2(param, feeReceiver, fee, feeOn);\n        }\n\n        return _swapExactTokensForTokensV2(param, feeReceiver, fee, feeOn);\n    }\n\n    function _callbackV2(\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) internal {}\n}"},"src/KekotronLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"src/interfaces/IERC20.sol\";\nimport \"src/interfaces/IWETH.sol\";\nimport \"./KekotronErrors.sol\";\n\nlibrary KekotronLib {\n    function safeTransfer(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        if (!(success && (data.length == 0 || abi.decode(data, (bool))))) { \n            revert(\"KekotronErrors.TokenTransfer\"); \n        }\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        if (!(success && (data.length == 0 || abi.decode(data, (bool))))) { \n            revert(\"KekotronErrors.TokenTransferFrom\"); \n        }\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success,) = to.call{value: value}(new bytes(0));\n        if (!success) { \n            revert(\"KekotronErrors.EthTransfer\"); \n        }\n    }\n\n    function depositWETH(address weth, uint256 value) internal {\n        (bool success, ) = weth.call{value: value}(new bytes(0));\n        if (!success) { \n            revert(\"KekotronErrors.WethDeposit\"); \n        }\n    }\n\n    function withdrawWETH(address weth, uint256 value) internal {\n        (bool success, ) = weth.call(abi.encodeWithSelector(IWETH.withdraw.selector, value));\n        if (!success) { \n            revert(\"KekotronErrors.WethWithdraw\"); \n        }\n    }\n}"},"src/KekotronErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ncontract KekotronErrors {\n    /*\n    error OnlyOwner();\n\n    error WethDeposit();\n    error WethWithdraw();\n    error EthTransfer();\n    error TokenTransfer();\n    error TokenTransferFrom();\n\n    error TooLittleReceived();\n    error InsufficientInputAmount();\n    error InsufficientOutputAmount();\n    error InsufficientLiquidity();\n    error InvalidCallbackPool();\n\n    error InvalidVersion();\n    */\n}"},"src/KekotronRouterV1.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"solmate/auth/Owned.sol\";\nimport \"./KekotronSwapV2.sol\";\nimport \"./KekotronSwapV3.sol\";\nimport \"./KekotronErrors.sol\";\n\ncontract KekotronRouterV1 is Owned, KekotronSwapV2, KekotronSwapV3 {\n\n    uint8 public fee = 100; // 1%\n    address public feeReceiver;\n\n    constructor(address owner, address receiver, address weth) Owned(owner) KekotronSwapV2(weth) KekotronSwapV3(weth) {\n        feeReceiver = receiver;\n    }\n\n    function _requireIsOwner() internal view {\n        if (msg.sender != owner) { \n            revert(\"KekotronErrors.OnlyOwner\"); \n        }\n    }\n\n    function updateFee(uint8 newFee) external {\n        _requireIsOwner();\n        fee = newFee;\n    }\n\n    function updateFeeReceiver(address newFeeReceiver) external {\n        _requireIsOwner();\n        feeReceiver = newFeeReceiver;\n    }\n\n    fallback() payable external {\n\n        bytes4 selector = bytes4(msg.data[:4]);\n\n        if (selector == 0x10d1e85c) {\n            (address sender, uint256 amount0, uint256 amount1, bytes memory data) = abi.decode(msg.data[4:], (address, uint256, uint256, bytes));\n            return _callbackV2(sender, amount0, amount1, data);\n        }\n\n        if (selector == 0xfa461e33) {\n            (int256 amount0Delta, int256 amount1Delta, bytes memory data) = abi.decode(msg.data[4:], (int256, int256, bytes));\n            return _callbackV3(amount0Delta, amount1Delta, data);\n        }\n        \n        uint8 version;\n        uint8 feeOn;\n\n        assembly {\n            version := byte(0, calldataload(0))\n            feeOn := byte(1, calldataload(0))\n        }\n\n        if (version == 0) { // v2\n            SwapV2 memory swapV2;\n\n            assembly {\n                let offset := 0x02\n                calldatacopy(add(swapV2, 0x0c), offset, 0x14)               // pool\n                calldatacopy(add(swapV2, 0x2c), add(offset, 0x14), 0x14)    // tokenIn\n                calldatacopy(add(swapV2, 0x4c), add(offset, 0x28), 0x14)    // tokenIn\n                calldatacopy(add(swapV2, 0x70), add(offset, 0x3c), 0x10)    // amountIn\n                calldatacopy(add(swapV2, 0x90), add(offset, 0x4c), 0x20)    // amountOut\n            }\n\n            return _swapExactInputV2(swapV2, feeReceiver, fee, feeOn);\n        }\n\n        if (version == 1) { // v3 \n            SwapV3 memory swapV3;\n\n            assembly {\n                let offset := 0x02\n                calldatacopy(add(swapV3, 0x0c), offset, 0x14)               // pool\n                calldatacopy(add(swapV3, 0x2c), add(offset, 0x14), 0x14)    // tokenIn\n                calldatacopy(add(swapV3, 0x4c), add(offset, 0x28), 0x14)    // tokenIn\n                calldatacopy(add(swapV3, 0x70), add(offset, 0x3c), 0x10)    // amountIn\n                calldatacopy(add(swapV3, 0x90), add(offset, 0x4c), 0x20)    // amountOut\n            }\n\n            return _swapExactInputV3(swapV3, feeReceiver, fee, feeOn);\n        }\n\n        revert(\"KekotronErrors.InvalidVersion\");\n    }\n\n    receive() payable external {}\n}"},"src/interfaces/IPoolV3.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IPoolV3 {\n    function fee() external view returns (uint24);\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n}"},"src/interfaces/IPoolV2.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IPoolV2 {\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n}"},"src/KekotronSwapV3.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\nimport \"./interfaces/IWETH.sol\";\nimport \"./interfaces/IPoolV3.sol\";\nimport \"./KekotronLib.sol\";\nimport \"./KekotronErrors.sol\";\n\ncontract KekotronSwapV3 {\n    address private immutable WETH;\n\n    address private constant FACTORY = 0x1F98431c8aD98523631AE4a59f267346ea31F984;\n    bytes32 private constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n\n    constructor(address weth) {\n        WETH = weth;\n    }\n\n    struct SwapV3 {\n        address pool;\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        uint256 amountOut;\n    }\n\n    function _computePool(address tokenIn, address tokenOut, uint24 fee) private pure returns(address) {\n        address tokenA;\n        address tokenB;\n\n        if (tokenIn < tokenOut) {\n            tokenA = tokenIn;\n            tokenB = tokenOut;\n        } else {\n            tokenA = tokenOut;\n            tokenB = tokenIn;\n        }\n\n        address pool = address(uint160(uint256(\n            keccak256(\n                abi.encodePacked(\n                    hex'ff',\n                    FACTORY,\n                    keccak256(abi.encode(tokenA, tokenB, fee)),\n                    POOL_INIT_CODE_HASH\n                )\n            )\n        )));\n\n        return pool;\n    }\n\n    function _deriveData(SwapV3 memory param, address payer) private view returns(bool, int256, uint160, bytes memory) {\n        bool zeroForOne = param.tokenIn < param.tokenOut;\n\n        int256 amountSpecified = int256(param.amountIn);\n        uint160 sqrtPriceLimitX96 = (zeroForOne ? 4295128749 : 1461446703485210103287273052203988822378723970341);\n        bytes memory data = abi.encode(param.tokenIn, param.tokenOut, IPoolV3(param.pool).fee(), param.amountOut, payer);\n\n        return (zeroForOne, amountSpecified, sqrtPriceLimitX96, data);\n    }\n\n    function _swapV3(SwapV3 memory param, address to, address payer) private returns(uint256) {\n        (\n            bool zeroForOne, \n            int256 amountSpecified, \n            uint160 sqrtPriceLimitX96, \n            bytes memory data\n        ) = _deriveData(param, payer);\n\n        (int256 amount0, int256 amount1) = IPoolV3(param.pool).swap(to, zeroForOne, amountSpecified, sqrtPriceLimitX96, data);\n        uint256 amountOut = uint256(-(zeroForOne ? amount1 : amount0));\n\n        return amountOut;\n    }\n\n    function _swapExactEthForTokensV3(\n        SwapV3 memory param,\n        address feeReceiver,\n        uint8 fee,\n        uint8 feeOn\n    ) private {   \n        (bool feeIn, bool feeOut) = fee > 0 ? (feeOn == 0, feeOn == 1) : (false, false);\n        uint256 amountFee;\n\n        if (feeIn) {\n            amountFee = param.amountIn * fee / 10_000;\n            KekotronLib.safeTransferETH(feeReceiver, amountFee);\n            param.amountIn -= amountFee;\n            amountFee = 0;\n        }\n\n        KekotronLib.depositWETH(WETH, param.amountIn);\n\n        uint256 amountOut = _swapV3(param, feeOut ? address(this) : msg.sender, address(this));\n\n        if (feeOut) {\n            amountFee = amountOut * fee / 10_000;\n            amountOut = amountOut - amountFee;\n        }\n\n        if (amountOut < param.amountOut) { \n            revert(\"KekotronErrors.TooLittleReceived\"); \n        }\n\n        if (amountFee > 0) {\n            KekotronLib.safeTransfer(param.tokenOut, feeReceiver, amountFee);\n        }\n\n        if (feeOut) {\n            KekotronLib.safeTransfer(param.tokenOut, msg.sender, amountOut);\n        }\n    }\n\n    function _swapExactTokensForEthV3(\n        SwapV3 memory param,\n        address feeReceiver,\n        uint8 fee,\n        uint8 feeOn\n    ) private {\n        (bool feeIn, bool feeOut) = fee > 0 ? (feeOn == 0, feeOn == 1) : (false, false);\n        uint256 amountFee;\n\n        if (feeIn) {\n            amountFee= param.amountIn * fee / 10_000;\n            KekotronLib.safeTransferFrom(param.tokenIn, msg.sender, feeReceiver, amountFee);\n            param.amountIn -= amountFee;\n            amountFee = 0;\n        } \n \n        uint256 amountOut = _swapV3(param, address(this), msg.sender);\n        \n        KekotronLib.withdrawWETH(WETH, amountOut);\n        \n        if (feeOut) {\n            amountFee = amountOut * fee / 10_000;\n            amountOut = amountOut - amountFee;\n        }\n\n        if (amountOut < param.amountOut) { \n            revert(\"KekotronErrors.TooLittleReceived\"); \n        }\n\n        if (amountFee > 0) {\n            KekotronLib.safeTransferETH(feeReceiver, amountFee);\n        }\n\n        KekotronLib.safeTransferETH(msg.sender, amountOut);\n    }\n\n    function _swapExactTokensForTokensV3(\n        SwapV3 memory param,\n        address feeReceiver,\n        uint8 fee,\n        uint8 feeOn\n    ) private {\n        (bool feeIn, bool feeOut) = fee > 0 ? (feeOn == 0, feeOn == 1) : (false, false);\n        uint256 amountFee;\n\n        if (feeIn) {\n            amountFee = param.amountIn * fee / 10_000;\n            KekotronLib.safeTransferFrom(param.tokenIn, msg.sender, feeReceiver, amountFee);\n            param.amountIn -= amountFee;\n            amountFee = 0;\n        } \n\n        uint256 amountOut = _swapV3(param, feeOut ? address(this) : msg.sender, msg.sender);\n\n        if (feeOut) {\n            amountFee = amountOut * fee / 10_000;\n            amountOut = amountOut - amountFee;\n        }\n\n        if (amountOut < param.amountOut) { \n            revert(\"KekotronErrors.TooLittleReceived\"); \n        }\n\n        if (amountFee > 0) {\n            KekotronLib.safeTransfer(param.tokenOut, feeReceiver, amountFee);\n        }\n\n        if (feeOut) {\n            KekotronLib.safeTransfer(param.tokenOut, msg.sender, amountOut);\n        }\n    }\n\n    function _swapExactInputV3(\n        SwapV3 memory param,\n        address feeReceiver,\n        uint8 fee,\n        uint8 feeOn\n    ) internal {\n        if (param.tokenIn == address(0)) {\n            param.tokenIn = WETH;\n            return _swapExactEthForTokensV3(param, feeReceiver, fee, feeOn);\n        }\n\n        if (param.tokenOut == address(0)) {\n            param.tokenOut = WETH;\n            return _swapExactTokensForEthV3(param, feeReceiver, fee, feeOn);\n        }\n\n        return _swapExactTokensForTokensV3(param, feeReceiver, fee, feeOn);\n    }\n\n    function _callbackV3(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes memory data\n    ) internal {\n        if (amount0Delta == 0 && amount1Delta == 0) {\n            revert(\"KekotronErrors.InsufficientLiquidity\");\n        }\n\n        (\n            address tokenIn,\n            address tokenOut,\n            uint24 fee,\n            uint256 limit,\n            address payer\n        ) = abi.decode(data, (address, address, uint24, uint256, address));\n\n        if (msg.sender != _computePool(tokenIn, tokenOut, fee)) {\n            revert(\"KekotronErrors.InvalidCallbackPool\");\n        }\n\n        bool zeroForOne = tokenIn < tokenOut;\n\n        if(uint256(-(zeroForOne ? amount1Delta : amount0Delta)) < limit) {\n            revert(\"KekotronErrors.TooLittleReceived\");\n        }\n\n        if (payer == address(this)) {\n            KekotronLib.safeTransfer(tokenIn, msg.sender, uint256(zeroForOne ? amount0Delta : amount1Delta));\n        } else {\n            KekotronLib.safeTransferFrom(tokenIn, payer, msg.sender, uint256(zeroForOne ? amount0Delta : amount1Delta));\n        }\n    }\n}\n"},"src/interfaces/IWETH.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IWETH {\n    function deposit() external payable;\n    function withdraw(uint256 amount) external;\n}"},"src/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.19;\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n}"}},"settings":{"evmVersion":"paris","libraries":{},"metadata":{"appendCBOR":true,"bytecodeHash":"ipfs","useLiteralContent":false},"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}},"remappings":["ds-test/=lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","foundry-huff/=lib/foundry-huff/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/","solady/=lib/solady/src/","solidity-stringutils/=lib/foundry-huff/lib/solidity-stringutils/","solmate/=lib/solmate/src/","lib/forge-std:ds-test/=lib/forge-std/lib/ds-test/src/","lib/foundry-huff:ds-test/=lib/foundry-huff/lib/forge-std/lib/ds-test/src/","lib/foundry-huff:forge-std/=lib/foundry-huff/lib/forge-std/src/","lib/foundry-huff:solidity-stringutils/=lib/foundry-huff/lib/solidity-stringutils/","lib/foundry-huff:stringutils/=lib/foundry-huff/lib/solidity-stringutils/","lib/openzeppelin-contracts:ds-test/=lib/openzeppelin-contracts/lib/forge-std/lib/ds-test/src/","lib/openzeppelin-contracts:erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","lib/openzeppelin-contracts:forge-std/=lib/openzeppelin-contracts/lib/forge-std/src/","lib/openzeppelin-contracts:openzeppelin/=lib/openzeppelin-contracts/contracts/","lib/solady:ds-test/=lib/solady/lib/ds-test/src/","lib/solady:forge-std/=lib/solady/test/utils/forge-std/","lib/solmate:ds-test/=lib/solmate/lib/ds-test/src/"]}},"ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"weth\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newFee\",\"type\":\"uint8\"}],\"name\":\"updateFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeReceiver\",\"type\":\"address\"}],\"name\":\"updateFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"KekotronRouterV1","CompilerVersion":"v0.8.19+commit.7dd6d404","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x000000000000000000000000ae010a324281de301d1bfb2611ef8873d8843622000000000000000000000000ad26f18dbf0752303395685ddbaaff5bcae7c673000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2","EVMVersion":"paris","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}