{"expiry":1699577719,"data":[{"SourceCode":"# @version 0.2.12\r\n# (c) Curve.Fi, 2021\r\n# Math for crypto pools\r\n#\r\n# Unless otherwise agreed on, only contracts owned by Curve DAO or\r\n# Swiss Stake GmbH are allowed to call this contract.\r\n\r\nN_COINS: constant(int128) = 3  # <- change\r\nA_MULTIPLIER: constant(uint256) = 10000\r\n\r\nMIN_GAMMA: constant(uint256) = 10**10\r\nMAX_GAMMA: constant(uint256) = 5 * 10**16\r\n\r\nMIN_A: constant(uint256) = N_COINS**N_COINS * A_MULTIPLIER / 100\r\nMAX_A: constant(uint256) = N_COINS**N_COINS * A_MULTIPLIER * 1000\r\n\r\n\r\n@internal\r\n@pure\r\ndef sort(A0: uint256[N_COINS]) -> uint256[N_COINS]:\r\n    \"\"\"\r\n    Insertion sort from high to low\r\n    \"\"\"\r\n    A: uint256[N_COINS] = A0\r\n    for i in range(1, N_COINS):\r\n        x: uint256 = A[i]\r\n        cur: uint256 = i\r\n        for j in range(N_COINS):\r\n            y: uint256 = A[cur-1]\r\n            if y > x:\r\n                break\r\n            A[cur] = y\r\n            cur -= 1\r\n            if cur == 0:\r\n                break\r\n        A[cur] = x\r\n    return A\r\n\r\n\r\n@internal\r\n@view\r\ndef _geometric_mean(unsorted_x: uint256[N_COINS], sort: bool = True) -> uint256:\r\n    \"\"\"\r\n    (x[0] * x[1] * ...) ** (1/N)\r\n    \"\"\"\r\n    x: uint256[N_COINS] = unsorted_x\r\n    if sort:\r\n        x = self.sort(x)\r\n    D: uint256 = x[0]\r\n    diff: uint256 = 0\r\n    for i in range(255):\r\n        D_prev: uint256 = D\r\n        tmp: uint256 = 10**18\r\n        for _x in x:\r\n            tmp = tmp * _x / D\r\n        D = D * ((N_COINS - 1) * 10**18 + tmp) / (N_COINS * 10**18)\r\n        if D > D_prev:\r\n            diff = D - D_prev\r\n        else:\r\n            diff = D_prev - D\r\n        if diff <= 1 or diff * 10**18 < D:\r\n            return D\r\n    raise \"Did not converge\"\r\n\r\n\r\n@external\r\n@view\r\ndef geometric_mean(unsorted_x: uint256[N_COINS], sort: bool = True) -> uint256:\r\n    return self._geometric_mean(unsorted_x, sort)\r\n\r\n\r\n@external\r\n@view\r\ndef reduction_coefficient(x: uint256[N_COINS], fee_gamma: uint256) -> uint256:\r\n    \"\"\"\r\n    fee_gamma / (fee_gamma + (1 - K))\r\n    where\r\n    K = prod(x) / (sum(x) / N)**N\r\n    (all normalized to 1e18)\r\n    \"\"\"\r\n    K: uint256 = 10**18\r\n    S: uint256 = 0\r\n    for x_i in x:\r\n        S += x_i\r\n    # Could be good to pre-sort x, but it is used only for dynamic fee,\r\n    # so that is not so important\r\n    for x_i in x:\r\n        K = K * N_COINS * x_i / S\r\n    if fee_gamma > 0:\r\n        K = fee_gamma * 10**18 / (fee_gamma + 10**18 - K)\r\n    return K\r\n\r\n\r\n@external\r\n@view\r\ndef newton_D(ANN: uint256, gamma: uint256, x_unsorted: uint256[N_COINS]) -> uint256:\r\n    \"\"\"\r\n    Finding the invariant using Newton method.\r\n    ANN is higher by the factor A_MULTIPLIER\r\n    ANN is already A * N**N\r\n\r\n    Currently uses 60k gas\r\n    \"\"\"\r\n    # Safety checks\r\n    assert ANN > MIN_A - 1 and ANN < MAX_A + 1  # dev: unsafe values A\r\n    assert gamma > MIN_GAMMA - 1 and gamma < MAX_GAMMA + 1  # dev: unsafe values gamma\r\n\r\n    # Initial value of invariant D is that for constant-product invariant\r\n    x: uint256[N_COINS] = self.sort(x_unsorted)\r\n\r\n    assert x[0] > 10**9 - 1 and x[0] < 10**15 * 10**18 + 1  # dev: unsafe values x[0]\r\n    for i in range(1, N_COINS):\r\n        frac: uint256 = x[i] * 10**18 / x[0]\r\n        assert frac > 10**11-1  # dev: unsafe values x[i]\r\n\r\n    D: uint256 = N_COINS * self._geometric_mean(x, False)\r\n    S: uint256 = 0\r\n    for x_i in x:\r\n        S += x_i\r\n\r\n    for i in range(255):\r\n        D_prev: uint256 = D\r\n\r\n        K0: uint256 = 10**18\r\n        for _x in x:\r\n            K0 = K0 * _x * N_COINS / D\r\n\r\n        _g1k0: uint256 = gamma + 10**18\r\n        if _g1k0 > K0:\r\n            _g1k0 = _g1k0 - K0 + 1\r\n        else:\r\n            _g1k0 = K0 - _g1k0 + 1\r\n\r\n        # D / (A * N**N) * _g1k0**2 / gamma**2\r\n        mul1: uint256 = 10**18 * D / gamma * _g1k0 / gamma * _g1k0 * A_MULTIPLIER / ANN\r\n\r\n        # 2*N*K0 / _g1k0\r\n        mul2: uint256 = (2 * 10**18) * N_COINS * K0 / _g1k0\r\n\r\n        neg_fprime: uint256 = (S + S * mul2 / 10**18) + mul1 * N_COINS / K0 - mul2 * D / 10**18\r\n\r\n        # D -= f / fprime\r\n        D_plus: uint256 = D * (neg_fprime + S) / neg_fprime\r\n        D_minus: uint256 = D*D / neg_fprime\r\n        if 10**18 > K0:\r\n            D_minus += D * (mul1 / neg_fprime) / 10**18 * (10**18 - K0) / K0\r\n        else:\r\n            D_minus -= D * (mul1 / neg_fprime) / 10**18 * (K0 - 10**18) / K0\r\n\r\n        if D_plus > D_minus:\r\n            D = D_plus - D_minus\r\n        else:\r\n            D = (D_minus - D_plus) / 2\r\n\r\n        diff: uint256 = 0\r\n        if D > D_prev:\r\n            diff = D - D_prev\r\n        else:\r\n            diff = D_prev - D\r\n        if diff * 10**14 < max(10**16, D):  # Could reduce precision for gas efficiency here\r\n            # Test that we are safe with the next newton_y\r\n            for _x in x:\r\n                frac: uint256 = _x * 10**18 / D\r\n                assert (frac > 10**16 - 1) and (frac < 10**20 + 1)  # dev: unsafe values x[i]\r\n            return D\r\n\r\n    raise \"Did not converge\"\r\n\r\n\r\n@external\r\n@view\r\ndef newton_y(ANN: uint256, gamma: uint256, x: uint256[N_COINS], D: uint256, i: uint256) -> uint256:\r\n    \"\"\"\r\n    Calculating x[i] given other balances x[0..N_COINS-1] and invariant D\r\n    ANN = A * N**N\r\n    \"\"\"\r\n    # Safety checks\r\n    assert ANN > MIN_A - 1 and ANN < MAX_A + 1  # dev: unsafe values A\r\n    assert gamma > MIN_GAMMA - 1 and gamma < MAX_GAMMA + 1  # dev: unsafe values gamma\r\n    assert D > 10**17 - 1 and D < 10**15 * 10**18 + 1 # dev: unsafe values D\r\n    for k in range(3):\r\n        if k != i:\r\n            frac: uint256 = x[k] * 10**18 / D\r\n            assert (frac > 10**16 - 1) and (frac < 10**20 + 1)  # dev: unsafe values x[i]\r\n\r\n    y: uint256 = D / N_COINS\r\n    K0_i: uint256 = 10**18\r\n    S_i: uint256 = 0\r\n\r\n    x_sorted: uint256[N_COINS] = x\r\n    x_sorted[i] = 0\r\n    x_sorted = self.sort(x_sorted)  # From high to low\r\n\r\n    convergence_limit: uint256 = max(max(x_sorted[0] / 10**14, D / 10**14), 100)\r\n    for j in range(2, N_COINS+1):\r\n        _x: uint256 = x_sorted[N_COINS-j]\r\n        y = y * D / (_x * N_COINS)  # Small _x first\r\n        S_i += _x\r\n    for j in range(N_COINS-1):\r\n        K0_i = K0_i * x_sorted[j] * N_COINS / D  # Large _x first\r\n\r\n    for j in range(255):\r\n        y_prev: uint256 = y\r\n\r\n        K0: uint256 = K0_i * y * N_COINS / D\r\n        S: uint256 = S_i + y\r\n\r\n        _g1k0: uint256 = gamma + 10**18\r\n        if _g1k0 > K0:\r\n            _g1k0 = _g1k0 - K0 + 1\r\n        else:\r\n            _g1k0 = K0 - _g1k0 + 1\r\n\r\n        # D / (A * N**N) * _g1k0**2 / gamma**2\r\n        mul1: uint256 = 10**18 * D / gamma * _g1k0 / gamma * _g1k0 * A_MULTIPLIER / ANN\r\n\r\n        # 2*K0 / _g1k0\r\n        mul2: uint256 = 10**18 + (2 * 10**18) * K0 / _g1k0\r\n\r\n        yfprime: uint256 = 10**18 * y + S * mul2 + mul1\r\n        _dyfprime: uint256 = D * mul2\r\n        if yfprime < _dyfprime:\r\n            y = y_prev / 2\r\n            continue\r\n        else:\r\n            yfprime -= _dyfprime\r\n        fprime: uint256 = yfprime / y\r\n\r\n        # y -= f / f_prime;  y = (y * fprime - f) / fprime\r\n        # y = (yfprime + 10**18 * D - 10**18 * S) // fprime + mul1 // fprime * (10**18 - K0) // K0\r\n        y_minus: uint256 = mul1 / fprime\r\n        y_plus: uint256 = (yfprime + 10**18 * D) / fprime + y_minus * 10**18 / K0\r\n        y_minus += 10**18 * S / fprime\r\n\r\n        if y_plus < y_minus:\r\n            y = y_prev / 2\r\n        else:\r\n            y = y_plus - y_minus\r\n\r\n        diff: uint256 = 0\r\n        if y > y_prev:\r\n            diff = y - y_prev\r\n        else:\r\n            diff = y_prev - y\r\n        if diff < max(convergence_limit, y / 10**14):\r\n            frac: uint256 = y * 10**18 / D\r\n            assert (frac > 10**16 - 1) and (frac < 10**20 + 1)  # dev: unsafe value for y\r\n            return y\r\n\r\n    raise \"Did not converge\"\r\n\r\n\r\n@external\r\n@view\r\ndef halfpow(power: uint256, precision: uint256) -> uint256:\r\n    \"\"\"\r\n    1e18 * 0.5 ** (power/1e18)\r\n\r\n    Inspired by: https://github.com/balancer-labs/balancer-core/blob/master/contracts/BNum.sol#L128\r\n    \"\"\"\r\n    intpow: uint256 = power / 10**18\r\n    otherpow: uint256 = power - intpow * 10**18\r\n    if intpow > 59:\r\n        return 0\r\n    result: uint256 = 10**18 / (2**intpow)\r\n    if otherpow == 0:\r\n        return result\r\n\r\n    term: uint256 = 10**18\r\n    x: uint256 = 5 * 10**17\r\n    S: uint256 = 10**18\r\n    neg: bool = False\r\n\r\n    for i in range(1, 256):\r\n        K: uint256 = i * 10**18\r\n        c: uint256 = K - 10**18\r\n        if otherpow > c:\r\n            c = otherpow - c\r\n            neg = not neg\r\n        else:\r\n            c -= otherpow\r\n        term = term * (c * x / 10**18) / K\r\n        if neg:\r\n            S -= term\r\n        else:\r\n            S += term\r\n        if term < precision:\r\n            return result * S / 10**18\r\n\r\n    raise \"Did not converge\"\r\n\r\n\r\n@external\r\n@view\r\ndef sqrt_int(x: uint256) -> uint256:\r\n    \"\"\"\r\n    Originating from: https://github.com/vyperlang/vyper/issues/1266\r\n    \"\"\"\r\n\r\n    if x == 0:\r\n        return 0\r\n\r\n    z: uint256 = (x + 10**18) / 2\r\n    y: uint256 = x\r\n\r\n    for i in range(256):\r\n        if z == y:\r\n            return y\r\n        y = z\r\n        z = (x * 10**18 / z + z) / 2\r\n\r\n    raise \"Did not converge\"","ABI":"[{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"geometric_mean\",\"inputs\":[{\"name\":\"unsorted_x\",\"type\":\"uint256[3]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"geometric_mean\",\"inputs\":[{\"name\":\"unsorted_x\",\"type\":\"uint256[3]\"},{\"name\":\"sort\",\"type\":\"bool\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"reduction_coefficient\",\"inputs\":[{\"name\":\"x\",\"type\":\"uint256[3]\"},{\"name\":\"fee_gamma\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":4063},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"newton_D\",\"inputs\":[{\"name\":\"ANN\",\"type\":\"uint256\"},{\"name\":\"gamma\",\"type\":\"uint256\"},{\"name\":\"x_unsorted\",\"type\":\"uint256[3]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3318199},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"newton_y\",\"inputs\":[{\"name\":\"ANN\",\"type\":\"uint256\"},{\"name\":\"gamma\",\"type\":\"uint256\"},{\"name\":\"x\",\"type\":\"uint256[3]\"},{\"name\":\"D\",\"type\":\"uint256\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":1859387},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"halfpow\",\"inputs\":[{\"name\":\"power\",\"type\":\"uint256\"},{\"name\":\"precision\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":513767},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"sqrt_int\",\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":199003}]","ContractName":"Vyper_contract","CompilerVersion":"vyper:0.2.12","OptimizationUsed":0,"Runs":0,"ConstructorArguments":"0x","EVMVersion":"Default","Library":"","LicenseType":"None","Proxy":0,"SwarmSource":""}]}