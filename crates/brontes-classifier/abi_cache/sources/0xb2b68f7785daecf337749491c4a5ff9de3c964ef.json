{"expiry":1699579188,"data":[{"SourceCode":{"language":"Solidity","sources":{"contracts/October/MSTR.sol":{"content":"/*\n\n$$\\      $$\\  $$$$$$\\ $$$$$$$$\\ $$$$$$$\\  \n$$$\\    $$$ |$$  __$$\\\\__$$  __|$$  __$$\\ \n$$$$\\  $$$$ |$$ /  \\__|  $$ |   $$ |  $$ |\n$$\\$$\\$$ $$ |\\$$$$$$\\    $$ |   $$$$$$$  |\n$$ \\$$$  $$ | \\____$$\\   $$ |   $$  __$$< \n$$ |\\$  /$$ |$$\\   $$ |  $$ |   $$ |  $$ |\n$$ | \\_/ $$ |\\$$$$$$  |  $$ |   $$ |  $$ |\n\\__|     \\__| \\______/   \\__|   \\__|  \\__|\n                                          \n                                          \nMicroStrategy -> www.microstrategy.vip\n\n*/\n\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n */\ninterface IERC20 {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n\n/**\n * OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n\n/**\n * OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(\n        address account\n    ) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    function allowance(\n        address owner,\n        address spender\n    ) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(\n        address spender,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function increaseAllowance(\n        address spender,\n        uint256 addedValue\n    ) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(\n            currentAllowance >= subtractedValue,\n            \"ERC20: decreased allowance below zero\"\n        );\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(\n            fromBalance >= amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(\n                currentAllowance >= amount,\n                \"ERC20: insufficient allowance\"\n            );\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n\n/**\n * OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        _transferOwnership(newOwner);\n    }\n\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\ninterface IDexRouter {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\n}\n\ninterface IDexFactory {\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair);\n}\n\ncontract MicroStrategy is ERC20, Ownable {\n    uint256 public maxBuyAmount;\n    uint256 public maxSellAmount;\n    uint256 public maxWalletAmount;\n\n    IDexRouter public dexRouter;\n    address public lpPair;\n\n    bool private swapping;\n    uint256 public swapTokensAtAmount;\n\n    address taxAddress;\n\n    uint256 public tradingActiveBlock = 0;\n    uint256 public blockForPenaltyEnd;\n    mapping(address => bool) public boughtEarly;\n    uint256 public botsCaught;\n\n    bool public limitsInEffect = true;\n    bool public tradingActive = false;\n    bool public swapEnabled = false;\n    bool public swapToEth = true;\n\n    mapping(address => uint256) private _holderLastTransferTimestamp;\n    bool public transferDelayEnabled = true;\n\n    uint256 public buyTotalFees;\n    uint256 public buyTaxFee;\n\n    uint256 public sellTotalFees;\n    uint256 public sellTaxFee;\n\n    uint256 public tokensForTax;\n\n    mapping(address => bool) private _isExcludedFromFees;\n    mapping(address => bool) public _isExcludedMaxTransactionAmount;\n    mapping(address => bool) public automatedMarketMakerPairs;\n\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\n\n    event EnabledTrading();\n\n    event RemovedLimits();\n\n    event ExcludeFromFees(address indexed account, bool isExcluded);\n\n    event UpdatedMaxBuyAmount(uint256 newAmount);\n\n    event UpdatedMaxSellAmount(uint256 newAmount);\n\n    event UpdatedMaxWalletAmount(uint256 newAmount);\n\n    event MaxTransactionExclusion(address _address, bool excluded);\n\n    event OwnerForcedSwapBack(uint256 timestamp);\n\n    event CaughtEarlyBuyer(address sniper);\n\n    event SwapAndLiquify(\n        uint256 tokensSwapped,\n        uint256 ethReceived,\n        uint256 tokensIntoLiquidity\n    );\n\n    constructor() ERC20(\"MicroStrategy\", \"MSTR\") {\n        address contractOwner = msg.sender;\n\n        IDexRouter _dexRouter = IDexRouter(\n            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n        );\n        dexRouter = _dexRouter;\n\n        lpPair = IDexFactory(_dexRouter.factory()).createPair(\n            address(this),\n            _dexRouter.WETH()\n        );\n        _excludeFromMaxTransaction(address(lpPair), true);\n        _setAutomatedMarketMakerPair(address(lpPair), true);\n\n        uint256 totalSupply = 12_060_000 * 1e18;\n\n        maxBuyAmount = (totalSupply * 10) / 1000;\n        maxSellAmount = (totalSupply * 10) / 1000;\n        maxWalletAmount = (totalSupply * 10) / 1000;\n        swapTokensAtAmount = (totalSupply * 1) / 1000;\n\n        // Initial buy and sell fees to punish bots\n        buyTaxFee = 15;\n        buyTotalFees = buyTaxFee;\n\n        sellTaxFee = 25;\n        sellTotalFees = sellTaxFee;\n\n        taxAddress = msg.sender;\n\n        _excludeFromMaxTransaction(contractOwner, true);\n        _excludeFromMaxTransaction(address(this), true);\n        _excludeFromMaxTransaction(address(0xdead), true);\n        _excludeFromMaxTransaction(taxAddress, true);\n\n        excludeFromFees(contractOwner, true);\n        excludeFromFees(address(this), true);\n        excludeFromFees(address(0xdead), true);\n        excludeFromFees(taxAddress, true);\n\n        _mint(contractOwner, totalSupply);\n        transferOwnership(contractOwner);\n    }\n\n    receive() external payable {}\n\n    function enableTrading(uint256 deadBlocks) external onlyOwner {\n        require(!tradingActive, \"Cannot reenable trading\");\n        tradingActive = true;\n        swapEnabled = true;\n        tradingActiveBlock = block.number;\n        blockForPenaltyEnd = tradingActiveBlock + deadBlocks;\n        emit EnabledTrading();\n    }\n\n    function removeLimits() external onlyOwner {\n        limitsInEffect = false;\n        transferDelayEnabled = false;\n        emit RemovedLimits();\n    }\n\n    function manageBoughtEarly(address wallet, bool flag) external onlyOwner {\n        boughtEarly[wallet] = flag;\n    }\n\n    function massManageBoughtEarly(\n        address[] calldata wallets,\n        bool flag\n    ) external onlyOwner {\n        for (uint256 i = 0; i < wallets.length; i++) {\n            boughtEarly[wallets[i]] = flag;\n        }\n    }\n\n    function disableTransferDelay() external onlyOwner {\n        transferDelayEnabled = false;\n    }\n\n    function updateMaxBuyAmount(uint256 newNum) external onlyOwner {\n        require(\n            newNum >= ((totalSupply() * 2) / 1000) / 1e18,\n            \"Cannot set max buy amount lower than 0.2%\"\n        );\n        maxBuyAmount = newNum * (10 ** 18);\n        emit UpdatedMaxBuyAmount(maxBuyAmount);\n    }\n\n    function updateMaxSellAmount(uint256 newNum) external onlyOwner {\n        require(\n            newNum >= ((totalSupply() * 2) / 1000) / 1e18,\n            \"Cannot set max sell amount lower than 0.2%\"\n        );\n        maxSellAmount = newNum * (10 ** 18);\n        emit UpdatedMaxSellAmount(maxSellAmount);\n    }\n\n    function updateMaxWalletAmount(uint256 newNum) external onlyOwner {\n        require(\n            newNum >= ((totalSupply() * 3) / 1000) / 1e18,\n            \"Cannot set max wallet amount lower than 0.3%\"\n        );\n        maxWalletAmount = newNum * (10 ** 18);\n        emit UpdatedMaxWalletAmount(maxWalletAmount);\n    }\n\n    function updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner {\n        require(\n            newAmount >= (totalSupply() * 1) / 100000,\n            \"Swap amount cannot be lower than 0.001% total supply.\"\n        );\n        require(\n            newAmount <= (totalSupply() * 1) / 1000,\n            \"Swap amount cannot be higher than 0.1% total supply.\"\n        );\n        swapTokensAtAmount = newAmount;\n    }\n\n    function _excludeFromMaxTransaction(\n        address updAds,\n        bool isExcluded\n    ) private {\n        _isExcludedMaxTransactionAmount[updAds] = isExcluded;\n        emit MaxTransactionExclusion(updAds, isExcluded);\n    }\n\n    function excludeFromMaxTransaction(\n        address updAds,\n        bool isEx\n    ) external onlyOwner {\n        if (!isEx) {\n            require(\n                updAds != lpPair,\n                \"Cannot remove Uniswap pair from max txn\"\n            );\n        }\n        _isExcludedMaxTransactionAmount[updAds] = isEx;\n    }\n\n    function setAutomatedMarketMakerPair(\n        address pair,\n        bool value\n    ) external onlyOwner {\n        require(\n            pair != lpPair,\n            \"The pair cannot be removed from automatedMarketMakerPairs\"\n        );\n\n        _setAutomatedMarketMakerPair(pair, value);\n        emit SetAutomatedMarketMakerPair(pair, value);\n    }\n\n    function _setAutomatedMarketMakerPair(address pair, bool value) private {\n        automatedMarketMakerPairs[pair] = value;\n\n        _excludeFromMaxTransaction(pair, value);\n        emit SetAutomatedMarketMakerPair(pair, value);\n    }\n\n    function setSwapToEth(bool _swapToEth) public onlyOwner {\n        swapToEth = _swapToEth;\n    }\n\n    function updateBuyFees(uint256 _taxFee) external onlyOwner {\n        buyTaxFee = _taxFee;\n        buyTotalFees = buyTaxFee;\n        require(buyTotalFees <= 10, \"Must keep fees at 10% or less.\");\n    }\n\n    function updateSellFees(uint256 _taxFee) external onlyOwner {\n        sellTaxFee = _taxFee;\n        sellTotalFees = sellTaxFee;\n        require(sellTotalFees <= 10, \"Must keep fees at 10% or less.\");\n    }\n\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\n        _isExcludedFromFees[account] = excluded;\n        emit ExcludeFromFees(account, excluded);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"amount must be greater than 0\");\n\n        if (!tradingActive) {\n            require(\n                _isExcludedFromFees[from] || _isExcludedFromFees[to],\n                \"Trading is not active.\"\n            );\n        }\n\n        if (blockForPenaltyEnd > 0) {\n            require(\n                !boughtEarly[from] || to == owner() || to == address(0xdead),\n                \"Bots cannot transfer tokens in or out except to owner or dead address.\"\n            );\n        }\n\n        if (limitsInEffect) {\n            if (\n                from != owner() &&\n                to != owner() &&\n                to != address(0) &&\n                to != address(0xdead) &&\n                !_isExcludedFromFees[from] &&\n                !_isExcludedFromFees[to]\n            ) {\n                if (transferDelayEnabled) {\n                    if (to != address(dexRouter) && to != address(lpPair)) {\n                        require(\n                            _holderLastTransferTimestamp[tx.origin] <\n                                block.number - 2 &&\n                                _holderLastTransferTimestamp[to] <\n                                block.number - 2,\n                            \"_transfer:: Transfer Delay enabled.  Try again later.\"\n                        );\n                        _holderLastTransferTimestamp[tx.origin] = block.number;\n                        _holderLastTransferTimestamp[to] = block.number;\n                    }\n                }\n\n                if (\n                    automatedMarketMakerPairs[from] &&\n                    !_isExcludedMaxTransactionAmount[to]\n                ) {\n                    require(\n                        amount <= maxBuyAmount,\n                        \"Buy transfer amount exceeds the max buy.\"\n                    );\n                    require(\n                        amount + balanceOf(to) <= maxWalletAmount,\n                        \"Cannot exceed max wallet.\"\n                    );\n                } else if (\n                    automatedMarketMakerPairs[to] &&\n                    !_isExcludedMaxTransactionAmount[from]\n                ) {\n                    require(\n                        amount <= maxSellAmount,\n                        \"Sell transfer amount exceeds the max sell.\"\n                    );\n                } else if (!_isExcludedMaxTransactionAmount[to]) {\n                    require(\n                        amount + balanceOf(to) <= maxWalletAmount,\n                        \"Cannot exceed max wallet.\"\n                    );\n                }\n            }\n        }\n\n        uint256 contractTokenBalance = balanceOf(address(this));\n\n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\n\n        if (\n            canSwap &&\n            swapEnabled &&\n            !swapping &&\n            !automatedMarketMakerPairs[from] &&\n            !_isExcludedFromFees[from] &&\n            !_isExcludedFromFees[to]\n        ) {\n            swapping = true;\n\n            swapBack();\n\n            swapping = false;\n        }\n\n        bool takeFee = true;\n        if (_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\n            takeFee = false;\n        }\n\n        uint256 fees = 0;\n        if (takeFee) {\n            if (\n                earlyBuyPenaltyInEffect() &&\n                automatedMarketMakerPairs[from] &&\n                !automatedMarketMakerPairs[to] &&\n                buyTotalFees > 0\n            ) {\n                if (!boughtEarly[to]) {\n                    boughtEarly[to] = true;\n                    botsCaught += 1;\n                    emit CaughtEarlyBuyer(to);\n                }\n\n                fees = (amount * 99) / 100;\n                tokensForTax += (fees * buyTaxFee) / buyTotalFees;\n            } else if (automatedMarketMakerPairs[to] && sellTotalFees > 0) {\n                fees = (amount * sellTotalFees) / 100;\n                tokensForTax += (fees * sellTaxFee) / sellTotalFees;\n            } else if (automatedMarketMakerPairs[from] && buyTotalFees > 0) {\n                fees = (amount * buyTotalFees) / 100;\n                tokensForTax += (fees * buyTaxFee) / buyTotalFees;\n            }\n\n            if (fees > 0) {\n                super._transfer(from, address(this), fees);\n            }\n\n            amount -= fees;\n        }\n\n        super._transfer(from, to, amount);\n    }\n\n    function earlyBuyPenaltyInEffect() public view returns (bool) {\n        return block.number < blockForPenaltyEnd;\n    }\n\n    function swapTokensForEth(uint256 tokenAmount) private {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = dexRouter.WETH();\n\n        _approve(address(this), address(dexRouter), tokenAmount);\n\n        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0,\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function swapBack() private {\n        uint256 contractBalance = balanceOf(address(this));\n        uint256 totalTokensToSwap = tokensForTax;\n\n        if (contractBalance == 0 || totalTokensToSwap == 0) {\n            return;\n        }\n\n        if (contractBalance > swapTokensAtAmount * 20) {\n            contractBalance = swapTokensAtAmount * 20;\n        }\n\n        bool success;\n\n        if (swapToEth) {\n            swapTokensForEth(contractBalance);\n            tokensForTax = 0;\n            (success, ) = address(taxAddress).call{\n                value: address(this).balance\n            }(\"\");\n        }\n\n        if (!swapToEth) {\n            _transfer(address(this), taxAddress, contractBalance);\n            tokensForTax = 0;\n            success = true;\n        }\n    }\n\n    // Withdraw ETH from contract address\n    function withdrawStuckETH() external onlyOwner {\n        bool success;\n        (success, ) = address(msg.sender).call{value: address(this).balance}(\n            \"\"\n        );\n    }\n\n    function updateTaxAddress(address _taxAddress) external onlyOwner {\n        require(_taxAddress != address(0), \"_taxAddress address cannot be 0\");\n        taxAddress = payable(_taxAddress);\n    }\n\n    function forceSwapBack() external onlyOwner {\n        require(\n            balanceOf(address(this)) >= swapTokensAtAmount,\n            \"Can only swap when token amount is at or higher than restriction\"\n        );\n        swapping = true;\n        swapBack();\n        swapping = false;\n        emit OwnerForcedSwapBack(block.timestamp);\n    }\n}\n"}},"settings":{"libraries":{},"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}}},"ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sniper\",\"type\":\"address\"}],\"name\":\"CaughtEarlyBuyer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EnabledTrading\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"MaxTransactionExclusion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OwnerForcedSwapBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RemovedLimits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiquidity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatedMaxBuyAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatedMaxSellAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatedMaxWalletAmount\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedMaxTransactionAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockForPenaltyEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"botsCaught\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"boughtEarly\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTaxFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTotalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexRouter\",\"outputs\":[{\"internalType\":\"contract IDexRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableTransferDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"earlyBuyPenaltyInEffect\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deadBlocks\",\"type\":\"uint256\"}],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"updAds\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isEx\",\"type\":\"bool\"}],\"name\":\"excludeFromMaxTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forceSwapBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitsInEffect\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"manageBoughtEarly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"massManageBoughtEarly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSellAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTaxFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTotalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_swapToEth\",\"type\":\"bool\"}],\"name\":\"setSwapToEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapToEth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensForTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingActiveBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferDelayEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_taxFee\",\"type\":\"uint256\"}],\"name\":\"updateBuyFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNum\",\"type\":\"uint256\"}],\"name\":\"updateMaxBuyAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNum\",\"type\":\"uint256\"}],\"name\":\"updateMaxSellAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNum\",\"type\":\"uint256\"}],\"name\":\"updateMaxWalletAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_taxFee\",\"type\":\"uint256\"}],\"name\":\"updateSellFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"updateSwapTokensAtAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_taxAddress\",\"type\":\"address\"}],\"name\":\"updateTaxAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawStuckETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"MicroStrategy","CompilerVersion":"v0.8.21+commit.d9974bed","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}