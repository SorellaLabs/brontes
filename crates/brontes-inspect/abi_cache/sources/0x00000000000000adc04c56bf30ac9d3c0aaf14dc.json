{"expiry":1699495328,"data":[{"SourceCode":{"language":"Solidity","sources":{"contracts/helpers/PointerLibraries.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ntype CalldataPointer is uint256;\n\ntype ReturndataPointer is uint256;\n\ntype MemoryPointer is uint256;\n\nusing CalldataPointerLib for CalldataPointer global;\nusing MemoryPointerLib for MemoryPointer global;\nusing ReturndataPointerLib for ReturndataPointer global;\n\nusing CalldataReaders for CalldataPointer global;\nusing ReturndataReaders for ReturndataPointer global;\nusing MemoryReaders for MemoryPointer global;\nusing MemoryWriters for MemoryPointer global;\n\nCalldataPointer constant CalldataStart = CalldataPointer.wrap(0x04);\nMemoryPointer constant FreeMemoryPPtr = MemoryPointer.wrap(0x40);\nuint256 constant IdentityPrecompileAddress = 0x4;\nuint256 constant OffsetOrLengthMask = 0xffffffff;\nuint256 constant _OneWord = 0x20;\nuint256 constant _FreeMemoryPointerSlot = 0x40;\n\n/// @dev Allocates `size` bytes in memory by increasing the free memory pointer\n///    and returns the memory pointer to the first byte of the allocated region.\n// (Free functions cannot have visibility.)\n// solhint-disable-next-line func-visibility\nfunction malloc(uint256 size) pure returns (MemoryPointer mPtr) {\n    assembly {\n        mPtr := mload(_FreeMemoryPointerSlot)\n        mstore(_FreeMemoryPointerSlot, add(mPtr, size))\n    }\n}\n\n// (Free functions cannot have visibility.)\n// solhint-disable-next-line func-visibility\nfunction getFreeMemoryPointer() pure returns (MemoryPointer mPtr) {\n    mPtr = FreeMemoryPPtr.readMemoryPointer();\n}\n\n// (Free functions cannot have visibility.)\n// solhint-disable-next-line func-visibility\nfunction setFreeMemoryPointer(MemoryPointer mPtr) pure {\n    FreeMemoryPPtr.write(mPtr);\n}\n\nlibrary CalldataPointerLib {\n    function lt(\n        CalldataPointer a,\n        CalldataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := lt(a, b)\n        }\n    }\n\n    function gt(\n        CalldataPointer a,\n        CalldataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := gt(a, b)\n        }\n    }\n\n    function eq(\n        CalldataPointer a,\n        CalldataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := eq(a, b)\n        }\n    }\n\n    function isNull(CalldataPointer a) internal pure returns (bool b) {\n        assembly {\n            b := iszero(a)\n        }\n    }\n\n    /// @dev Resolves an offset stored at `cdPtr + headOffset` to a calldata.\n    ///      pointer `cdPtr` must point to some parent object with a dynamic\n    ///      type's head stored at `cdPtr + headOffset`.\n    function pptr(\n        CalldataPointer cdPtr,\n        uint256 headOffset\n    ) internal pure returns (CalldataPointer cdPtrChild) {\n        cdPtrChild = cdPtr.offset(\n            cdPtr.offset(headOffset).readUint256() & OffsetOrLengthMask\n        );\n    }\n\n    /// @dev Resolves an offset stored at `cdPtr` to a calldata pointer.\n    ///      `cdPtr` must point to some parent object with a dynamic type as its\n    ///      first member, e.g. `struct { bytes data; }`\n    function pptr(\n        CalldataPointer cdPtr\n    ) internal pure returns (CalldataPointer cdPtrChild) {\n        cdPtrChild = cdPtr.offset(cdPtr.readUint256() & OffsetOrLengthMask);\n    }\n\n    /// @dev Returns the calldata pointer one word after `cdPtr`.\n    function next(\n        CalldataPointer cdPtr\n    ) internal pure returns (CalldataPointer cdPtrNext) {\n        assembly {\n            cdPtrNext := add(cdPtr, _OneWord)\n        }\n    }\n\n    /// @dev Returns the calldata pointer `_offset` bytes after `cdPtr`.\n    function offset(\n        CalldataPointer cdPtr,\n        uint256 _offset\n    ) internal pure returns (CalldataPointer cdPtrNext) {\n        assembly {\n            cdPtrNext := add(cdPtr, _offset)\n        }\n    }\n\n    /// @dev Copies `size` bytes from calldata starting at `src` to memory at\n    ///      `dst`.\n    function copy(\n        CalldataPointer src,\n        MemoryPointer dst,\n        uint256 size\n    ) internal pure {\n        assembly {\n            calldatacopy(dst, src, size)\n        }\n    }\n}\n\nlibrary ReturndataPointerLib {\n    function lt(\n        ReturndataPointer a,\n        ReturndataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := lt(a, b)\n        }\n    }\n\n    function gt(\n        ReturndataPointer a,\n        ReturndataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := gt(a, b)\n        }\n    }\n\n    function eq(\n        ReturndataPointer a,\n        ReturndataPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := eq(a, b)\n        }\n    }\n\n    function isNull(ReturndataPointer a) internal pure returns (bool b) {\n        assembly {\n            b := iszero(a)\n        }\n    }\n\n    /// @dev Resolves an offset stored at `rdPtr + headOffset` to a returndata\n    ///      pointer. `rdPtr` must point to some parent object with a dynamic\n    ///      type's head stored at `rdPtr + headOffset`.\n    function pptr(\n        ReturndataPointer rdPtr,\n        uint256 headOffset\n    ) internal pure returns (ReturndataPointer rdPtrChild) {\n        rdPtrChild = rdPtr.offset(\n            rdPtr.offset(headOffset).readUint256() & OffsetOrLengthMask\n        );\n    }\n\n    /// @dev Resolves an offset stored at `rdPtr` to a returndata pointer.\n    ///    `rdPtr` must point to some parent object with a dynamic type as its\n    ///    first member, e.g. `struct { bytes data; }`\n    function pptr(\n        ReturndataPointer rdPtr\n    ) internal pure returns (ReturndataPointer rdPtrChild) {\n        rdPtrChild = rdPtr.offset(rdPtr.readUint256() & OffsetOrLengthMask);\n    }\n\n    /// @dev Returns the returndata pointer one word after `cdPtr`.\n    function next(\n        ReturndataPointer rdPtr\n    ) internal pure returns (ReturndataPointer rdPtrNext) {\n        assembly {\n            rdPtrNext := add(rdPtr, _OneWord)\n        }\n    }\n\n    /// @dev Returns the returndata pointer `_offset` bytes after `cdPtr`.\n    function offset(\n        ReturndataPointer rdPtr,\n        uint256 _offset\n    ) internal pure returns (ReturndataPointer rdPtrNext) {\n        assembly {\n            rdPtrNext := add(rdPtr, _offset)\n        }\n    }\n\n    /// @dev Copies `size` bytes from returndata starting at `src` to memory at\n    /// `dst`.\n    function copy(\n        ReturndataPointer src,\n        MemoryPointer dst,\n        uint256 size\n    ) internal pure {\n        assembly {\n            returndatacopy(dst, src, size)\n        }\n    }\n}\n\nlibrary MemoryPointerLib {\n    function copy(\n        MemoryPointer src,\n        MemoryPointer dst,\n        uint256 size\n    ) internal view {\n        assembly {\n            let success := staticcall(\n                gas(),\n                IdentityPrecompileAddress,\n                src,\n                size,\n                dst,\n                size\n            )\n            if or(iszero(returndatasize()), iszero(success)) {\n                revert(0, 0)\n            }\n        }\n    }\n\n    function lt(\n        MemoryPointer a,\n        MemoryPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := lt(a, b)\n        }\n    }\n\n    function gt(\n        MemoryPointer a,\n        MemoryPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := gt(a, b)\n        }\n    }\n\n    function eq(\n        MemoryPointer a,\n        MemoryPointer b\n    ) internal pure returns (bool c) {\n        assembly {\n            c := eq(a, b)\n        }\n    }\n\n    function isNull(MemoryPointer a) internal pure returns (bool b) {\n        assembly {\n            b := iszero(a)\n        }\n    }\n\n    function hash(\n        MemoryPointer ptr,\n        uint256 length\n    ) internal pure returns (bytes32 _hash) {\n        assembly {\n            _hash := keccak256(ptr, length)\n        }\n    }\n\n    /// @dev Returns the memory pointer one word after `mPtr`.\n    function next(\n        MemoryPointer mPtr\n    ) internal pure returns (MemoryPointer mPtrNext) {\n        assembly {\n            mPtrNext := add(mPtr, _OneWord)\n        }\n    }\n\n    /// @dev Returns the memory pointer `_offset` bytes after `mPtr`.\n    function offset(\n        MemoryPointer mPtr,\n        uint256 _offset\n    ) internal pure returns (MemoryPointer mPtrNext) {\n        assembly {\n            mPtrNext := add(mPtr, _offset)\n        }\n    }\n\n    /// @dev Resolves a pointer at `mPtr + headOffset` to a memory\n    ///    pointer. `mPtr` must point to some parent object with a dynamic\n    ///    type's pointer stored at `mPtr + headOffset`.\n    function pptr(\n        MemoryPointer mPtr,\n        uint256 headOffset\n    ) internal pure returns (MemoryPointer mPtrChild) {\n        mPtrChild = mPtr.offset(headOffset).readMemoryPointer();\n    }\n\n    /// @dev Resolves a pointer stored at `mPtr` to a memory pointer.\n    ///    `mPtr` must point to some parent object with a dynamic type as its\n    ///    first member, e.g. `struct { bytes data; }`\n    function pptr(\n        MemoryPointer mPtr\n    ) internal pure returns (MemoryPointer mPtrChild) {\n        mPtrChild = mPtr.readMemoryPointer();\n    }\n}\n\nlibrary CalldataReaders {\n    /// @dev Reads the value at `cdPtr` and applies a mask to return only the\n    ///    last 4 bytes.\n    function readMaskedUint256(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint256 value) {\n        value = cdPtr.readUint256() & OffsetOrLengthMask;\n    }\n\n    /// @dev Reads the bool at `cdPtr` in calldata.\n    function readBool(\n        CalldataPointer cdPtr\n    ) internal pure returns (bool value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the address at `cdPtr` in calldata.\n    function readAddress(\n        CalldataPointer cdPtr\n    ) internal pure returns (address value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes1 at `cdPtr` in calldata.\n    function readBytes1(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes1 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes2 at `cdPtr` in calldata.\n    function readBytes2(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes2 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes3 at `cdPtr` in calldata.\n    function readBytes3(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes3 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes4 at `cdPtr` in calldata.\n    function readBytes4(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes4 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes5 at `cdPtr` in calldata.\n    function readBytes5(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes5 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes6 at `cdPtr` in calldata.\n    function readBytes6(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes6 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes7 at `cdPtr` in calldata.\n    function readBytes7(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes7 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes8 at `cdPtr` in calldata.\n    function readBytes8(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes8 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes9 at `cdPtr` in calldata.\n    function readBytes9(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes9 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes10 at `cdPtr` in calldata.\n    function readBytes10(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes10 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes11 at `cdPtr` in calldata.\n    function readBytes11(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes11 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes12 at `cdPtr` in calldata.\n    function readBytes12(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes12 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes13 at `cdPtr` in calldata.\n    function readBytes13(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes13 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes14 at `cdPtr` in calldata.\n    function readBytes14(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes14 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes15 at `cdPtr` in calldata.\n    function readBytes15(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes15 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes16 at `cdPtr` in calldata.\n    function readBytes16(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes16 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes17 at `cdPtr` in calldata.\n    function readBytes17(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes17 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes18 at `cdPtr` in calldata.\n    function readBytes18(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes18 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes19 at `cdPtr` in calldata.\n    function readBytes19(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes19 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes20 at `cdPtr` in calldata.\n    function readBytes20(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes20 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes21 at `cdPtr` in calldata.\n    function readBytes21(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes21 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes22 at `cdPtr` in calldata.\n    function readBytes22(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes22 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes23 at `cdPtr` in calldata.\n    function readBytes23(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes23 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes24 at `cdPtr` in calldata.\n    function readBytes24(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes24 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes25 at `cdPtr` in calldata.\n    function readBytes25(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes25 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes26 at `cdPtr` in calldata.\n    function readBytes26(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes26 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes27 at `cdPtr` in calldata.\n    function readBytes27(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes27 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes28 at `cdPtr` in calldata.\n    function readBytes28(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes28 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes29 at `cdPtr` in calldata.\n    function readBytes29(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes29 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes30 at `cdPtr` in calldata.\n    function readBytes30(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes30 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes31 at `cdPtr` in calldata.\n    function readBytes31(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes31 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the bytes32 at `cdPtr` in calldata.\n    function readBytes32(\n        CalldataPointer cdPtr\n    ) internal pure returns (bytes32 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint8 at `cdPtr` in calldata.\n    function readUint8(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint8 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint16 at `cdPtr` in calldata.\n    function readUint16(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint16 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint24 at `cdPtr` in calldata.\n    function readUint24(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint24 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint32 at `cdPtr` in calldata.\n    function readUint32(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint32 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint40 at `cdPtr` in calldata.\n    function readUint40(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint40 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint48 at `cdPtr` in calldata.\n    function readUint48(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint48 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint56 at `cdPtr` in calldata.\n    function readUint56(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint56 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint64 at `cdPtr` in calldata.\n    function readUint64(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint64 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint72 at `cdPtr` in calldata.\n    function readUint72(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint72 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint80 at `cdPtr` in calldata.\n    function readUint80(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint80 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint88 at `cdPtr` in calldata.\n    function readUint88(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint88 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint96 at `cdPtr` in calldata.\n    function readUint96(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint96 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint104 at `cdPtr` in calldata.\n    function readUint104(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint104 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint112 at `cdPtr` in calldata.\n    function readUint112(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint112 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint120 at `cdPtr` in calldata.\n    function readUint120(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint120 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint128 at `cdPtr` in calldata.\n    function readUint128(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint128 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint136 at `cdPtr` in calldata.\n    function readUint136(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint136 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint144 at `cdPtr` in calldata.\n    function readUint144(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint144 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint152 at `cdPtr` in calldata.\n    function readUint152(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint152 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint160 at `cdPtr` in calldata.\n    function readUint160(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint160 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint168 at `cdPtr` in calldata.\n    function readUint168(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint168 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint176 at `cdPtr` in calldata.\n    function readUint176(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint176 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint184 at `cdPtr` in calldata.\n    function readUint184(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint184 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint192 at `cdPtr` in calldata.\n    function readUint192(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint192 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint200 at `cdPtr` in calldata.\n    function readUint200(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint200 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint208 at `cdPtr` in calldata.\n    function readUint208(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint208 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint216 at `cdPtr` in calldata.\n    function readUint216(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint216 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint224 at `cdPtr` in calldata.\n    function readUint224(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint224 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint232 at `cdPtr` in calldata.\n    function readUint232(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint232 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint240 at `cdPtr` in calldata.\n    function readUint240(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint240 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint248 at `cdPtr` in calldata.\n    function readUint248(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint248 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the uint256 at `cdPtr` in calldata.\n    function readUint256(\n        CalldataPointer cdPtr\n    ) internal pure returns (uint256 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int8 at `cdPtr` in calldata.\n    function readInt8(\n        CalldataPointer cdPtr\n    ) internal pure returns (int8 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int16 at `cdPtr` in calldata.\n    function readInt16(\n        CalldataPointer cdPtr\n    ) internal pure returns (int16 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int24 at `cdPtr` in calldata.\n    function readInt24(\n        CalldataPointer cdPtr\n    ) internal pure returns (int24 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int32 at `cdPtr` in calldata.\n    function readInt32(\n        CalldataPointer cdPtr\n    ) internal pure returns (int32 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int40 at `cdPtr` in calldata.\n    function readInt40(\n        CalldataPointer cdPtr\n    ) internal pure returns (int40 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int48 at `cdPtr` in calldata.\n    function readInt48(\n        CalldataPointer cdPtr\n    ) internal pure returns (int48 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int56 at `cdPtr` in calldata.\n    function readInt56(\n        CalldataPointer cdPtr\n    ) internal pure returns (int56 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int64 at `cdPtr` in calldata.\n    function readInt64(\n        CalldataPointer cdPtr\n    ) internal pure returns (int64 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int72 at `cdPtr` in calldata.\n    function readInt72(\n        CalldataPointer cdPtr\n    ) internal pure returns (int72 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int80 at `cdPtr` in calldata.\n    function readInt80(\n        CalldataPointer cdPtr\n    ) internal pure returns (int80 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int88 at `cdPtr` in calldata.\n    function readInt88(\n        CalldataPointer cdPtr\n    ) internal pure returns (int88 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int96 at `cdPtr` in calldata.\n    function readInt96(\n        CalldataPointer cdPtr\n    ) internal pure returns (int96 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int104 at `cdPtr` in calldata.\n    function readInt104(\n        CalldataPointer cdPtr\n    ) internal pure returns (int104 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int112 at `cdPtr` in calldata.\n    function readInt112(\n        CalldataPointer cdPtr\n    ) internal pure returns (int112 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int120 at `cdPtr` in calldata.\n    function readInt120(\n        CalldataPointer cdPtr\n    ) internal pure returns (int120 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int128 at `cdPtr` in calldata.\n    function readInt128(\n        CalldataPointer cdPtr\n    ) internal pure returns (int128 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int136 at `cdPtr` in calldata.\n    function readInt136(\n        CalldataPointer cdPtr\n    ) internal pure returns (int136 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int144 at `cdPtr` in calldata.\n    function readInt144(\n        CalldataPointer cdPtr\n    ) internal pure returns (int144 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int152 at `cdPtr` in calldata.\n    function readInt152(\n        CalldataPointer cdPtr\n    ) internal pure returns (int152 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int160 at `cdPtr` in calldata.\n    function readInt160(\n        CalldataPointer cdPtr\n    ) internal pure returns (int160 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int168 at `cdPtr` in calldata.\n    function readInt168(\n        CalldataPointer cdPtr\n    ) internal pure returns (int168 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int176 at `cdPtr` in calldata.\n    function readInt176(\n        CalldataPointer cdPtr\n    ) internal pure returns (int176 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int184 at `cdPtr` in calldata.\n    function readInt184(\n        CalldataPointer cdPtr\n    ) internal pure returns (int184 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int192 at `cdPtr` in calldata.\n    function readInt192(\n        CalldataPointer cdPtr\n    ) internal pure returns (int192 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int200 at `cdPtr` in calldata.\n    function readInt200(\n        CalldataPointer cdPtr\n    ) internal pure returns (int200 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int208 at `cdPtr` in calldata.\n    function readInt208(\n        CalldataPointer cdPtr\n    ) internal pure returns (int208 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int216 at `cdPtr` in calldata.\n    function readInt216(\n        CalldataPointer cdPtr\n    ) internal pure returns (int216 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int224 at `cdPtr` in calldata.\n    function readInt224(\n        CalldataPointer cdPtr\n    ) internal pure returns (int224 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int232 at `cdPtr` in calldata.\n    function readInt232(\n        CalldataPointer cdPtr\n    ) internal pure returns (int232 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int240 at `cdPtr` in calldata.\n    function readInt240(\n        CalldataPointer cdPtr\n    ) internal pure returns (int240 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int248 at `cdPtr` in calldata.\n    function readInt248(\n        CalldataPointer cdPtr\n    ) internal pure returns (int248 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n\n    /// @dev Reads the int256 at `cdPtr` in calldata.\n    function readInt256(\n        CalldataPointer cdPtr\n    ) internal pure returns (int256 value) {\n        assembly {\n            value := calldataload(cdPtr)\n        }\n    }\n}\n\nlibrary ReturndataReaders {\n    /// @dev Reads value at `rdPtr` & applies a mask to return only last 4 bytes\n    function readMaskedUint256(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint256 value) {\n        value = rdPtr.readUint256() & OffsetOrLengthMask;\n    }\n\n    /// @dev Reads the bool at `rdPtr` in returndata.\n    function readBool(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bool value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the address at `rdPtr` in returndata.\n    function readAddress(\n        ReturndataPointer rdPtr\n    ) internal pure returns (address value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes1 at `rdPtr` in returndata.\n    function readBytes1(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes1 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes2 at `rdPtr` in returndata.\n    function readBytes2(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes2 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes3 at `rdPtr` in returndata.\n    function readBytes3(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes3 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes4 at `rdPtr` in returndata.\n    function readBytes4(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes4 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes5 at `rdPtr` in returndata.\n    function readBytes5(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes5 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes6 at `rdPtr` in returndata.\n    function readBytes6(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes6 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes7 at `rdPtr` in returndata.\n    function readBytes7(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes7 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes8 at `rdPtr` in returndata.\n    function readBytes8(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes8 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes9 at `rdPtr` in returndata.\n    function readBytes9(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes9 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes10 at `rdPtr` in returndata.\n    function readBytes10(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes10 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes11 at `rdPtr` in returndata.\n    function readBytes11(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes11 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes12 at `rdPtr` in returndata.\n    function readBytes12(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes12 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes13 at `rdPtr` in returndata.\n    function readBytes13(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes13 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes14 at `rdPtr` in returndata.\n    function readBytes14(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes14 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes15 at `rdPtr` in returndata.\n    function readBytes15(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes15 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes16 at `rdPtr` in returndata.\n    function readBytes16(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes16 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes17 at `rdPtr` in returndata.\n    function readBytes17(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes17 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes18 at `rdPtr` in returndata.\n    function readBytes18(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes18 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes19 at `rdPtr` in returndata.\n    function readBytes19(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes19 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes20 at `rdPtr` in returndata.\n    function readBytes20(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes20 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes21 at `rdPtr` in returndata.\n    function readBytes21(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes21 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes22 at `rdPtr` in returndata.\n    function readBytes22(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes22 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes23 at `rdPtr` in returndata.\n    function readBytes23(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes23 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes24 at `rdPtr` in returndata.\n    function readBytes24(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes24 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes25 at `rdPtr` in returndata.\n    function readBytes25(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes25 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes26 at `rdPtr` in returndata.\n    function readBytes26(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes26 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes27 at `rdPtr` in returndata.\n    function readBytes27(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes27 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes28 at `rdPtr` in returndata.\n    function readBytes28(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes28 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes29 at `rdPtr` in returndata.\n    function readBytes29(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes29 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes30 at `rdPtr` in returndata.\n    function readBytes30(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes30 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes31 at `rdPtr` in returndata.\n    function readBytes31(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes31 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the bytes32 at `rdPtr` in returndata.\n    function readBytes32(\n        ReturndataPointer rdPtr\n    ) internal pure returns (bytes32 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint8 at `rdPtr` in returndata.\n    function readUint8(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint8 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint16 at `rdPtr` in returndata.\n    function readUint16(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint16 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint24 at `rdPtr` in returndata.\n    function readUint24(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint24 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint32 at `rdPtr` in returndata.\n    function readUint32(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint32 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint40 at `rdPtr` in returndata.\n    function readUint40(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint40 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint48 at `rdPtr` in returndata.\n    function readUint48(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint48 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint56 at `rdPtr` in returndata.\n    function readUint56(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint56 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint64 at `rdPtr` in returndata.\n    function readUint64(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint64 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint72 at `rdPtr` in returndata.\n    function readUint72(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint72 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint80 at `rdPtr` in returndata.\n    function readUint80(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint80 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint88 at `rdPtr` in returndata.\n    function readUint88(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint88 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint96 at `rdPtr` in returndata.\n    function readUint96(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint96 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint104 at `rdPtr` in returndata.\n    function readUint104(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint104 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint112 at `rdPtr` in returndata.\n    function readUint112(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint112 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint120 at `rdPtr` in returndata.\n    function readUint120(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint120 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint128 at `rdPtr` in returndata.\n    function readUint128(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint128 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint136 at `rdPtr` in returndata.\n    function readUint136(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint136 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint144 at `rdPtr` in returndata.\n    function readUint144(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint144 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint152 at `rdPtr` in returndata.\n    function readUint152(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint152 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint160 at `rdPtr` in returndata.\n    function readUint160(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint160 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint168 at `rdPtr` in returndata.\n    function readUint168(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint168 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint176 at `rdPtr` in returndata.\n    function readUint176(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint176 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint184 at `rdPtr` in returndata.\n    function readUint184(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint184 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint192 at `rdPtr` in returndata.\n    function readUint192(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint192 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint200 at `rdPtr` in returndata.\n    function readUint200(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint200 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint208 at `rdPtr` in returndata.\n    function readUint208(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint208 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint216 at `rdPtr` in returndata.\n    function readUint216(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint216 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint224 at `rdPtr` in returndata.\n    function readUint224(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint224 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint232 at `rdPtr` in returndata.\n    function readUint232(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint232 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint240 at `rdPtr` in returndata.\n    function readUint240(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint240 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint248 at `rdPtr` in returndata.\n    function readUint248(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint248 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the uint256 at `rdPtr` in returndata.\n    function readUint256(\n        ReturndataPointer rdPtr\n    ) internal pure returns (uint256 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int8 at `rdPtr` in returndata.\n    function readInt8(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int8 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int16 at `rdPtr` in returndata.\n    function readInt16(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int16 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int24 at `rdPtr` in returndata.\n    function readInt24(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int24 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int32 at `rdPtr` in returndata.\n    function readInt32(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int32 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int40 at `rdPtr` in returndata.\n    function readInt40(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int40 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int48 at `rdPtr` in returndata.\n    function readInt48(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int48 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int56 at `rdPtr` in returndata.\n    function readInt56(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int56 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int64 at `rdPtr` in returndata.\n    function readInt64(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int64 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int72 at `rdPtr` in returndata.\n    function readInt72(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int72 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int80 at `rdPtr` in returndata.\n    function readInt80(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int80 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int88 at `rdPtr` in returndata.\n    function readInt88(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int88 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int96 at `rdPtr` in returndata.\n    function readInt96(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int96 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int104 at `rdPtr` in returndata.\n    function readInt104(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int104 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int112 at `rdPtr` in returndata.\n    function readInt112(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int112 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int120 at `rdPtr` in returndata.\n    function readInt120(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int120 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int128 at `rdPtr` in returndata.\n    function readInt128(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int128 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int136 at `rdPtr` in returndata.\n    function readInt136(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int136 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int144 at `rdPtr` in returndata.\n    function readInt144(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int144 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int152 at `rdPtr` in returndata.\n    function readInt152(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int152 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int160 at `rdPtr` in returndata.\n    function readInt160(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int160 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int168 at `rdPtr` in returndata.\n    function readInt168(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int168 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int176 at `rdPtr` in returndata.\n    function readInt176(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int176 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int184 at `rdPtr` in returndata.\n    function readInt184(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int184 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int192 at `rdPtr` in returndata.\n    function readInt192(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int192 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int200 at `rdPtr` in returndata.\n    function readInt200(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int200 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int208 at `rdPtr` in returndata.\n    function readInt208(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int208 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int216 at `rdPtr` in returndata.\n    function readInt216(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int216 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int224 at `rdPtr` in returndata.\n    function readInt224(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int224 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int232 at `rdPtr` in returndata.\n    function readInt232(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int232 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int240 at `rdPtr` in returndata.\n    function readInt240(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int240 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int248 at `rdPtr` in returndata.\n    function readInt248(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int248 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n\n    /// @dev Reads the int256 at `rdPtr` in returndata.\n    function readInt256(\n        ReturndataPointer rdPtr\n    ) internal pure returns (int256 value) {\n        assembly {\n            returndatacopy(0, rdPtr, _OneWord)\n            value := mload(0)\n        }\n    }\n}\n\nlibrary MemoryReaders {\n    /// @dev Reads the memory pointer at `mPtr` in memory.\n    function readMemoryPointer(\n        MemoryPointer mPtr\n    ) internal pure returns (MemoryPointer value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads value at `mPtr` & applies a mask to return only last 4 bytes\n    function readMaskedUint256(\n        MemoryPointer mPtr\n    ) internal pure returns (uint256 value) {\n        value = mPtr.readUint256() & OffsetOrLengthMask;\n    }\n\n    /// @dev Reads the bool at `mPtr` in memory.\n    function readBool(MemoryPointer mPtr) internal pure returns (bool value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the address at `mPtr` in memory.\n    function readAddress(\n        MemoryPointer mPtr\n    ) internal pure returns (address value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes1 at `mPtr` in memory.\n    function readBytes1(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes1 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes2 at `mPtr` in memory.\n    function readBytes2(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes2 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes3 at `mPtr` in memory.\n    function readBytes3(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes3 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes4 at `mPtr` in memory.\n    function readBytes4(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes4 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes5 at `mPtr` in memory.\n    function readBytes5(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes5 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes6 at `mPtr` in memory.\n    function readBytes6(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes6 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes7 at `mPtr` in memory.\n    function readBytes7(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes7 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes8 at `mPtr` in memory.\n    function readBytes8(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes8 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes9 at `mPtr` in memory.\n    function readBytes9(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes9 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes10 at `mPtr` in memory.\n    function readBytes10(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes10 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes11 at `mPtr` in memory.\n    function readBytes11(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes11 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes12 at `mPtr` in memory.\n    function readBytes12(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes12 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes13 at `mPtr` in memory.\n    function readBytes13(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes13 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes14 at `mPtr` in memory.\n    function readBytes14(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes14 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes15 at `mPtr` in memory.\n    function readBytes15(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes15 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes16 at `mPtr` in memory.\n    function readBytes16(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes16 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes17 at `mPtr` in memory.\n    function readBytes17(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes17 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes18 at `mPtr` in memory.\n    function readBytes18(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes18 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes19 at `mPtr` in memory.\n    function readBytes19(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes19 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes20 at `mPtr` in memory.\n    function readBytes20(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes20 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes21 at `mPtr` in memory.\n    function readBytes21(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes21 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes22 at `mPtr` in memory.\n    function readBytes22(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes22 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes23 at `mPtr` in memory.\n    function readBytes23(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes23 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes24 at `mPtr` in memory.\n    function readBytes24(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes24 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes25 at `mPtr` in memory.\n    function readBytes25(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes25 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes26 at `mPtr` in memory.\n    function readBytes26(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes26 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes27 at `mPtr` in memory.\n    function readBytes27(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes27 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes28 at `mPtr` in memory.\n    function readBytes28(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes28 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes29 at `mPtr` in memory.\n    function readBytes29(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes29 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes30 at `mPtr` in memory.\n    function readBytes30(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes30 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes31 at `mPtr` in memory.\n    function readBytes31(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes31 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the bytes32 at `mPtr` in memory.\n    function readBytes32(\n        MemoryPointer mPtr\n    ) internal pure returns (bytes32 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint8 at `mPtr` in memory.\n    function readUint8(MemoryPointer mPtr) internal pure returns (uint8 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint16 at `mPtr` in memory.\n    function readUint16(\n        MemoryPointer mPtr\n    ) internal pure returns (uint16 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint24 at `mPtr` in memory.\n    function readUint24(\n        MemoryPointer mPtr\n    ) internal pure returns (uint24 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint32 at `mPtr` in memory.\n    function readUint32(\n        MemoryPointer mPtr\n    ) internal pure returns (uint32 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint40 at `mPtr` in memory.\n    function readUint40(\n        MemoryPointer mPtr\n    ) internal pure returns (uint40 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint48 at `mPtr` in memory.\n    function readUint48(\n        MemoryPointer mPtr\n    ) internal pure returns (uint48 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint56 at `mPtr` in memory.\n    function readUint56(\n        MemoryPointer mPtr\n    ) internal pure returns (uint56 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint64 at `mPtr` in memory.\n    function readUint64(\n        MemoryPointer mPtr\n    ) internal pure returns (uint64 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint72 at `mPtr` in memory.\n    function readUint72(\n        MemoryPointer mPtr\n    ) internal pure returns (uint72 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint80 at `mPtr` in memory.\n    function readUint80(\n        MemoryPointer mPtr\n    ) internal pure returns (uint80 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint88 at `mPtr` in memory.\n    function readUint88(\n        MemoryPointer mPtr\n    ) internal pure returns (uint88 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint96 at `mPtr` in memory.\n    function readUint96(\n        MemoryPointer mPtr\n    ) internal pure returns (uint96 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint104 at `mPtr` in memory.\n    function readUint104(\n        MemoryPointer mPtr\n    ) internal pure returns (uint104 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint112 at `mPtr` in memory.\n    function readUint112(\n        MemoryPointer mPtr\n    ) internal pure returns (uint112 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint120 at `mPtr` in memory.\n    function readUint120(\n        MemoryPointer mPtr\n    ) internal pure returns (uint120 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint128 at `mPtr` in memory.\n    function readUint128(\n        MemoryPointer mPtr\n    ) internal pure returns (uint128 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint136 at `mPtr` in memory.\n    function readUint136(\n        MemoryPointer mPtr\n    ) internal pure returns (uint136 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint144 at `mPtr` in memory.\n    function readUint144(\n        MemoryPointer mPtr\n    ) internal pure returns (uint144 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint152 at `mPtr` in memory.\n    function readUint152(\n        MemoryPointer mPtr\n    ) internal pure returns (uint152 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint160 at `mPtr` in memory.\n    function readUint160(\n        MemoryPointer mPtr\n    ) internal pure returns (uint160 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint168 at `mPtr` in memory.\n    function readUint168(\n        MemoryPointer mPtr\n    ) internal pure returns (uint168 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint176 at `mPtr` in memory.\n    function readUint176(\n        MemoryPointer mPtr\n    ) internal pure returns (uint176 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint184 at `mPtr` in memory.\n    function readUint184(\n        MemoryPointer mPtr\n    ) internal pure returns (uint184 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint192 at `mPtr` in memory.\n    function readUint192(\n        MemoryPointer mPtr\n    ) internal pure returns (uint192 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint200 at `mPtr` in memory.\n    function readUint200(\n        MemoryPointer mPtr\n    ) internal pure returns (uint200 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint208 at `mPtr` in memory.\n    function readUint208(\n        MemoryPointer mPtr\n    ) internal pure returns (uint208 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint216 at `mPtr` in memory.\n    function readUint216(\n        MemoryPointer mPtr\n    ) internal pure returns (uint216 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint224 at `mPtr` in memory.\n    function readUint224(\n        MemoryPointer mPtr\n    ) internal pure returns (uint224 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint232 at `mPtr` in memory.\n    function readUint232(\n        MemoryPointer mPtr\n    ) internal pure returns (uint232 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint240 at `mPtr` in memory.\n    function readUint240(\n        MemoryPointer mPtr\n    ) internal pure returns (uint240 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint248 at `mPtr` in memory.\n    function readUint248(\n        MemoryPointer mPtr\n    ) internal pure returns (uint248 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the uint256 at `mPtr` in memory.\n    function readUint256(\n        MemoryPointer mPtr\n    ) internal pure returns (uint256 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int8 at `mPtr` in memory.\n    function readInt8(MemoryPointer mPtr) internal pure returns (int8 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int16 at `mPtr` in memory.\n    function readInt16(MemoryPointer mPtr) internal pure returns (int16 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int24 at `mPtr` in memory.\n    function readInt24(MemoryPointer mPtr) internal pure returns (int24 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int32 at `mPtr` in memory.\n    function readInt32(MemoryPointer mPtr) internal pure returns (int32 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int40 at `mPtr` in memory.\n    function readInt40(MemoryPointer mPtr) internal pure returns (int40 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int48 at `mPtr` in memory.\n    function readInt48(MemoryPointer mPtr) internal pure returns (int48 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int56 at `mPtr` in memory.\n    function readInt56(MemoryPointer mPtr) internal pure returns (int56 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int64 at `mPtr` in memory.\n    function readInt64(MemoryPointer mPtr) internal pure returns (int64 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int72 at `mPtr` in memory.\n    function readInt72(MemoryPointer mPtr) internal pure returns (int72 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int80 at `mPtr` in memory.\n    function readInt80(MemoryPointer mPtr) internal pure returns (int80 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int88 at `mPtr` in memory.\n    function readInt88(MemoryPointer mPtr) internal pure returns (int88 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int96 at `mPtr` in memory.\n    function readInt96(MemoryPointer mPtr) internal pure returns (int96 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int104 at `mPtr` in memory.\n    function readInt104(\n        MemoryPointer mPtr\n    ) internal pure returns (int104 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int112 at `mPtr` in memory.\n    function readInt112(\n        MemoryPointer mPtr\n    ) internal pure returns (int112 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int120 at `mPtr` in memory.\n    function readInt120(\n        MemoryPointer mPtr\n    ) internal pure returns (int120 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int128 at `mPtr` in memory.\n    function readInt128(\n        MemoryPointer mPtr\n    ) internal pure returns (int128 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int136 at `mPtr` in memory.\n    function readInt136(\n        MemoryPointer mPtr\n    ) internal pure returns (int136 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int144 at `mPtr` in memory.\n    function readInt144(\n        MemoryPointer mPtr\n    ) internal pure returns (int144 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int152 at `mPtr` in memory.\n    function readInt152(\n        MemoryPointer mPtr\n    ) internal pure returns (int152 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int160 at `mPtr` in memory.\n    function readInt160(\n        MemoryPointer mPtr\n    ) internal pure returns (int160 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int168 at `mPtr` in memory.\n    function readInt168(\n        MemoryPointer mPtr\n    ) internal pure returns (int168 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int176 at `mPtr` in memory.\n    function readInt176(\n        MemoryPointer mPtr\n    ) internal pure returns (int176 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int184 at `mPtr` in memory.\n    function readInt184(\n        MemoryPointer mPtr\n    ) internal pure returns (int184 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int192 at `mPtr` in memory.\n    function readInt192(\n        MemoryPointer mPtr\n    ) internal pure returns (int192 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int200 at `mPtr` in memory.\n    function readInt200(\n        MemoryPointer mPtr\n    ) internal pure returns (int200 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int208 at `mPtr` in memory.\n    function readInt208(\n        MemoryPointer mPtr\n    ) internal pure returns (int208 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int216 at `mPtr` in memory.\n    function readInt216(\n        MemoryPointer mPtr\n    ) internal pure returns (int216 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int224 at `mPtr` in memory.\n    function readInt224(\n        MemoryPointer mPtr\n    ) internal pure returns (int224 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int232 at `mPtr` in memory.\n    function readInt232(\n        MemoryPointer mPtr\n    ) internal pure returns (int232 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int240 at `mPtr` in memory.\n    function readInt240(\n        MemoryPointer mPtr\n    ) internal pure returns (int240 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int248 at `mPtr` in memory.\n    function readInt248(\n        MemoryPointer mPtr\n    ) internal pure returns (int248 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n\n    /// @dev Reads the int256 at `mPtr` in memory.\n    function readInt256(\n        MemoryPointer mPtr\n    ) internal pure returns (int256 value) {\n        assembly {\n            value := mload(mPtr)\n        }\n    }\n}\n\nlibrary MemoryWriters {\n    /// @dev Writes `valuePtr` to memory at `mPtr`.\n    function write(MemoryPointer mPtr, MemoryPointer valuePtr) internal pure {\n        assembly {\n            mstore(mPtr, valuePtr)\n        }\n    }\n\n    /// @dev Writes a boolean `value` to `mPtr` in memory.\n    function write(MemoryPointer mPtr, bool value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n\n    /// @dev Writes an address `value` to `mPtr` in memory.\n    function write(MemoryPointer mPtr, address value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n\n    /// @dev Writes a bytes32 `value` to `mPtr` in memory.\n    /// Separate name to disambiguate literal write parameters.\n    function writeBytes32(MemoryPointer mPtr, bytes32 value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n\n    /// @dev Writes a uint256 `value` to `mPtr` in memory.\n    function write(MemoryPointer mPtr, uint256 value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n\n    /// @dev Writes an int256 `value` to `mPtr` in memory.\n    /// Separate name to disambiguate literal write parameters.\n    function writeInt(MemoryPointer mPtr, int256 value) internal pure {\n        assembly {\n            mstore(mPtr, value)\n        }\n    }\n}\n"},"contracts/lib/ConsiderationStructs.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    BasicOrderType,\n    ItemType,\n    OrderType,\n    Side\n} from \"./ConsiderationEnums.sol\";\n\nimport {\n    CalldataPointer,\n    MemoryPointer\n} from \"../helpers/PointerLibraries.sol\";\n\n/**\n * @dev An order contains eleven components: an offerer, a zone (or account that\n *      can cancel the order or restrict who can fulfill the order depending on\n *      the type), the order type (specifying partial fill support as well as\n *      restricted order status), the start and end time, a hash that will be\n *      provided to the zone when validating restricted orders, a salt, a key\n *      corresponding to a given conduit, a counter, and an arbitrary number of\n *      offer items that can be spent along with consideration items that must\n *      be received by their respective recipient.\n */\nstruct OrderComponents {\n    address offerer;\n    address zone;\n    OfferItem[] offer;\n    ConsiderationItem[] consideration;\n    OrderType orderType;\n    uint256 startTime;\n    uint256 endTime;\n    bytes32 zoneHash;\n    uint256 salt;\n    bytes32 conduitKey;\n    uint256 counter;\n}\n\n/**\n * @dev An offer item has five components: an item type (ETH or other native\n *      tokens, ERC20, ERC721, and ERC1155, as well as criteria-based ERC721 and\n *      ERC1155), a token address, a dual-purpose \"identifierOrCriteria\"\n *      component that will either represent a tokenId or a merkle root\n *      depending on the item type, and a start and end amount that support\n *      increasing or decreasing amounts over the duration of the respective\n *      order.\n */\nstruct OfferItem {\n    ItemType itemType;\n    address token;\n    uint256 identifierOrCriteria;\n    uint256 startAmount;\n    uint256 endAmount;\n}\n\n/**\n * @dev A consideration item has the same five components as an offer item and\n *      an additional sixth component designating the required recipient of the\n *      item.\n */\nstruct ConsiderationItem {\n    ItemType itemType;\n    address token;\n    uint256 identifierOrCriteria;\n    uint256 startAmount;\n    uint256 endAmount;\n    address payable recipient;\n}\n\n/**\n * @dev A spent item is translated from a utilized offer item and has four\n *      components: an item type (ETH or other native tokens, ERC20, ERC721, and\n *      ERC1155), a token address, a tokenId, and an amount.\n */\nstruct SpentItem {\n    ItemType itemType;\n    address token;\n    uint256 identifier;\n    uint256 amount;\n}\n\n/**\n * @dev A received item is translated from a utilized consideration item and has\n *      the same four components as a spent item, as well as an additional fifth\n *      component designating the required recipient of the item.\n */\nstruct ReceivedItem {\n    ItemType itemType;\n    address token;\n    uint256 identifier;\n    uint256 amount;\n    address payable recipient;\n}\n\n/**\n * @dev For basic orders involving ETH / native / ERC20 <=> ERC721 / ERC1155\n *      matching, a group of six functions may be called that only requires a\n *      subset of the usual order arguments. Note the use of a \"basicOrderType\"\n *      enum; this represents both the usual order type as well as the \"route\"\n *      of the basic order (a simple derivation function for the basic order\n *      type is `basicOrderType = orderType + (4 * basicOrderRoute)`.)\n */\nstruct BasicOrderParameters {\n    // calldata offset\n    address considerationToken; // 0x24\n    uint256 considerationIdentifier; // 0x44\n    uint256 considerationAmount; // 0x64\n    address payable offerer; // 0x84\n    address zone; // 0xa4\n    address offerToken; // 0xc4\n    uint256 offerIdentifier; // 0xe4\n    uint256 offerAmount; // 0x104\n    BasicOrderType basicOrderType; // 0x124\n    uint256 startTime; // 0x144\n    uint256 endTime; // 0x164\n    bytes32 zoneHash; // 0x184\n    uint256 salt; // 0x1a4\n    bytes32 offererConduitKey; // 0x1c4\n    bytes32 fulfillerConduitKey; // 0x1e4\n    uint256 totalOriginalAdditionalRecipients; // 0x204\n    AdditionalRecipient[] additionalRecipients; // 0x224\n    bytes signature; // 0x244\n    // Total length, excluding dynamic array data: 0x264 (580)\n}\n\n/**\n * @dev Basic orders can supply any number of additional recipients, with the\n *      implied assumption that they are supplied from the offered ETH (or other\n *      native token) or ERC20 token for the order.\n */\nstruct AdditionalRecipient {\n    uint256 amount;\n    address payable recipient;\n}\n\n/**\n * @dev The full set of order components, with the exception of the counter,\n *      must be supplied when fulfilling more sophisticated orders or groups of\n *      orders. The total number of original consideration items must also be\n *      supplied, as the caller may specify additional consideration items.\n */\nstruct OrderParameters {\n    address offerer; // 0x00\n    address zone; // 0x20\n    OfferItem[] offer; // 0x40\n    ConsiderationItem[] consideration; // 0x60\n    OrderType orderType; // 0x80\n    uint256 startTime; // 0xa0\n    uint256 endTime; // 0xc0\n    bytes32 zoneHash; // 0xe0\n    uint256 salt; // 0x100\n    bytes32 conduitKey; // 0x120\n    uint256 totalOriginalConsiderationItems; // 0x140\n    // offer.length                          // 0x160\n}\n\n/**\n * @dev Orders require a signature in addition to the other order parameters.\n */\nstruct Order {\n    OrderParameters parameters;\n    bytes signature;\n}\n\n/**\n * @dev Advanced orders include a numerator (i.e. a fraction to attempt to fill)\n *      and a denominator (the total size of the order) in addition to the\n *      signature and other order parameters. It also supports an optional field\n *      for supplying extra data; this data will be provided to the zone if the\n *      order type is restricted and the zone is not the caller, or will be\n *      provided to the offerer as context for contract order types.\n */\nstruct AdvancedOrder {\n    OrderParameters parameters;\n    uint120 numerator;\n    uint120 denominator;\n    bytes signature;\n    bytes extraData;\n}\n\n/**\n * @dev Orders can be validated (either explicitly via `validate`, or as a\n *      consequence of a full or partial fill), specifically cancelled (they can\n *      also be cancelled in bulk via incrementing a per-zone counter), and\n *      partially or fully filled (with the fraction filled represented by a\n *      numerator and denominator).\n */\nstruct OrderStatus {\n    bool isValidated;\n    bool isCancelled;\n    uint120 numerator;\n    uint120 denominator;\n}\n\n/**\n * @dev A criteria resolver specifies an order, side (offer vs. consideration),\n *      and item index. It then provides a chosen identifier (i.e. tokenId)\n *      alongside a merkle proof demonstrating the identifier meets the required\n *      criteria.\n */\nstruct CriteriaResolver {\n    uint256 orderIndex;\n    Side side;\n    uint256 index;\n    uint256 identifier;\n    bytes32[] criteriaProof;\n}\n\n/**\n * @dev A fulfillment is applied to a group of orders. It decrements a series of\n *      offer and consideration items, then generates a single execution\n *      element. A given fulfillment can be applied to as many offer and\n *      consideration items as desired, but must contain at least one offer and\n *      at least one consideration that match. The fulfillment must also remain\n *      consistent on all key parameters across all offer items (same offerer,\n *      token, type, tokenId, and conduit preference) as well as across all\n *      consideration items (token, type, tokenId, and recipient).\n */\nstruct Fulfillment {\n    FulfillmentComponent[] offerComponents;\n    FulfillmentComponent[] considerationComponents;\n}\n\n/**\n * @dev Each fulfillment component contains one index referencing a specific\n *      order and another referencing a specific offer or consideration item.\n */\nstruct FulfillmentComponent {\n    uint256 orderIndex;\n    uint256 itemIndex;\n}\n\n/**\n * @dev An execution is triggered once all consideration items have been zeroed\n *      out. It sends the item in question from the offerer to the item's\n *      recipient, optionally sourcing approvals from either this contract\n *      directly or from the offerer's chosen conduit if one is specified. An\n *      execution is not provided as an argument, but rather is derived via\n *      orders, criteria resolvers, and fulfillments (where the total number of\n *      executions will be less than or equal to the total number of indicated\n *      fulfillments) and returned as part of `matchOrders`.\n */\nstruct Execution {\n    ReceivedItem item;\n    address offerer;\n    bytes32 conduitKey;\n}\n\n/**\n * @dev Restricted orders are validated post-execution by calling validateOrder\n *      on the zone. This struct provides context about the order fulfillment\n *      and any supplied extraData, as well as all order hashes fulfilled in a\n *      call to a match or fulfillAvailable method.\n */\nstruct ZoneParameters {\n    bytes32 orderHash;\n    address fulfiller;\n    address offerer;\n    SpentItem[] offer;\n    ReceivedItem[] consideration;\n    bytes extraData;\n    bytes32[] orderHashes;\n    uint256 startTime;\n    uint256 endTime;\n    bytes32 zoneHash;\n}\n\n/**\n * @dev Zones and contract offerers can communicate which schemas they implement\n *      along with any associated metadata related to each schema.\n */\nstruct Schema {\n    uint256 id;\n    bytes metadata;\n}\n\nusing StructPointers for OrderComponents global;\nusing StructPointers for OfferItem global;\nusing StructPointers for ConsiderationItem global;\nusing StructPointers for SpentItem global;\nusing StructPointers for ReceivedItem global;\nusing StructPointers for BasicOrderParameters global;\nusing StructPointers for AdditionalRecipient global;\nusing StructPointers for OrderParameters global;\nusing StructPointers for Order global;\nusing StructPointers for AdvancedOrder global;\nusing StructPointers for OrderStatus global;\nusing StructPointers for CriteriaResolver global;\nusing StructPointers for Fulfillment global;\nusing StructPointers for FulfillmentComponent global;\nusing StructPointers for Execution global;\nusing StructPointers for ZoneParameters global;\n\n/**\n * @dev This library provides a set of functions for converting structs to\n *      pointers.\n */\nlibrary StructPointers {\n    /**\n     * @dev Get a MemoryPointer from OrderComponents.\n     *\n     * @param obj The OrderComponents object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        OrderComponents memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from OrderComponents.\n     *\n     * @param obj The OrderComponents object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        OrderComponents calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from OfferItem.\n     *\n     * @param obj The OfferItem object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        OfferItem memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from OfferItem.\n     *\n     * @param obj The OfferItem object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        OfferItem calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from ConsiderationItem.\n     *\n     * @param obj The ConsiderationItem object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        ConsiderationItem memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from ConsiderationItem.\n     *\n     * @param obj The ConsiderationItem object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        ConsiderationItem calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from SpentItem.\n     *\n     * @param obj The SpentItem object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        SpentItem memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from SpentItem.\n     *\n     * @param obj The SpentItem object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        SpentItem calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from ReceivedItem.\n     *\n     * @param obj The ReceivedItem object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        ReceivedItem memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from ReceivedItem.\n     *\n     * @param obj The ReceivedItem object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        ReceivedItem calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from BasicOrderParameters.\n     *\n     * @param obj The BasicOrderParameters object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        BasicOrderParameters memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from BasicOrderParameters.\n     *\n     * @param obj The BasicOrderParameters object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        BasicOrderParameters calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from AdditionalRecipient.\n     *\n     * @param obj The AdditionalRecipient object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        AdditionalRecipient memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from AdditionalRecipient.\n     *\n     * @param obj The AdditionalRecipient object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        AdditionalRecipient calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from OrderParameters.\n     *\n     * @param obj The OrderParameters object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        OrderParameters memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from OrderParameters.\n     *\n     * @param obj The OrderParameters object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        OrderParameters calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from Order.\n     *\n     * @param obj The Order object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        Order memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from Order.\n     *\n     * @param obj The Order object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        Order calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from AdvancedOrder.\n     *\n     * @param obj The AdvancedOrder object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        AdvancedOrder memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from AdvancedOrder.\n     *\n     * @param obj The AdvancedOrder object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        AdvancedOrder calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from OrderStatus.\n     *\n     * @param obj The OrderStatus object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        OrderStatus memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from OrderStatus.\n     *\n     * @param obj The OrderStatus object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        OrderStatus calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from CriteriaResolver.\n     *\n     * @param obj The CriteriaResolver object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        CriteriaResolver memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from CriteriaResolver.\n     *\n     * @param obj The CriteriaResolver object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        CriteriaResolver calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from Fulfillment.\n     *\n     * @param obj The Fulfillment object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        Fulfillment memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from Fulfillment.\n     *\n     * @param obj The Fulfillment object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        Fulfillment calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from FulfillmentComponent.\n     *\n     * @param obj The FulfillmentComponent object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        FulfillmentComponent memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from FulfillmentComponent.\n     *\n     * @param obj The FulfillmentComponent object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        FulfillmentComponent calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from Execution.\n     *\n     * @param obj The Execution object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        Execution memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from Execution.\n     *\n     * @param obj The Execution object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        Execution calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a MemoryPointer from ZoneParameters.\n     *\n     * @param obj The ZoneParameters object.\n     *\n     * @return ptr The MemoryPointer.\n     */\n    function toMemoryPointer(\n        ZoneParameters memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Get a CalldataPointer from ZoneParameters.\n     *\n     * @param obj The ZoneParameters object.\n     *\n     * @return ptr The CalldataPointer.\n     */\n    function toCalldataPointer(\n        ZoneParameters calldata obj\n    ) internal pure returns (CalldataPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n}\n"},"contracts/lib/ConsiderationErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { Side } from \"./ConsiderationEnums.sol\";\n\nimport {\n    BadFraction_error_length,\n    BadFraction_error_selector,\n    CannotCancelOrder_error_length,\n    CannotCancelOrder_error_selector,\n    ConsiderationLengthNotEqualToTotalOriginal_error_length,\n    ConsiderationLengthNotEqualToTotalOriginal_error_selector,\n    ConsiderationNotMet_error_considerationIndex_ptr,\n    ConsiderationNotMet_error_length,\n    ConsiderationNotMet_error_orderIndex_ptr,\n    ConsiderationNotMet_error_selector,\n    ConsiderationNotMet_error_shortfallAmount_ptr,\n    CriteriaNotEnabledForItem_error_length,\n    CriteriaNotEnabledForItem_error_selector,\n    Error_selector_offset,\n    InsufficientNativeTokensSupplied_error_length,\n    InsufficientNativeTokensSupplied_error_selector,\n    InvalidBasicOrderParameterEncoding_error_length,\n    InvalidBasicOrderParameterEncoding_error_selector,\n    InvalidCallToConduit_error_conduit_ptr,\n    InvalidCallToConduit_error_length,\n    InvalidCallToConduit_error_selector,\n    InvalidConduit_error_conduit_ptr,\n    InvalidConduit_error_conduitKey_ptr,\n    InvalidConduit_error_length,\n    InvalidConduit_error_selector,\n    InvalidContractOrder_error_length,\n    InvalidContractOrder_error_orderHash_ptr,\n    InvalidContractOrder_error_selector,\n    InvalidERC721TransferAmount_error_amount_ptr,\n    InvalidERC721TransferAmount_error_length,\n    InvalidERC721TransferAmount_error_selector,\n    InvalidMsgValue_error_length,\n    InvalidMsgValue_error_selector,\n    InvalidMsgValue_error_value_ptr,\n    InvalidNativeOfferItem_error_length,\n    InvalidNativeOfferItem_error_selector,\n    InvalidProof_error_length,\n    InvalidProof_error_selector,\n    InvalidTime_error_endTime_ptr,\n    InvalidTime_error_length,\n    InvalidTime_error_selector,\n    InvalidTime_error_startTime_ptr,\n    MismatchedOfferAndConsiderationComponents_error_idx_ptr,\n    MismatchedOfferAndConsiderationComponents_error_length,\n    MismatchedOfferAndConsiderationComponents_error_selector,\n    MissingFulfillmentComponentOnAggregation_error_length,\n    MissingFulfillmentComponentOnAggregation_error_selector,\n    MissingFulfillmentComponentOnAggregation_error_side_ptr,\n    MissingOriginalConsiderationItems_error_length,\n    MissingOriginalConsiderationItems_error_selector,\n    NoReentrantCalls_error_length,\n    NoReentrantCalls_error_selector,\n    NoSpecifiedOrdersAvailable_error_length,\n    NoSpecifiedOrdersAvailable_error_selector,\n    OfferAndConsiderationRequiredOnFulfillment_error_length,\n    OfferAndConsiderationRequiredOnFulfillment_error_selector,\n    OrderAlreadyFilled_error_length,\n    OrderAlreadyFilled_error_orderHash_ptr,\n    OrderAlreadyFilled_error_selector,\n    OrderCriteriaResolverOutOfRange_error_length,\n    OrderCriteriaResolverOutOfRange_error_selector,\n    OrderCriteriaResolverOutOfRange_error_side_ptr,\n    OrderIsCancelled_error_length,\n    OrderIsCancelled_error_orderHash_ptr,\n    OrderIsCancelled_error_selector,\n    OrderPartiallyFilled_error_length,\n    OrderPartiallyFilled_error_orderHash_ptr,\n    OrderPartiallyFilled_error_selector,\n    PartialFillsNotEnabledForOrder_error_length,\n    PartialFillsNotEnabledForOrder_error_selector,\n    UnresolvedConsiderationCriteria_error_considerationIdx_ptr,\n    UnresolvedConsiderationCriteria_error_length,\n    UnresolvedConsiderationCriteria_error_orderIndex_ptr,\n    UnresolvedConsiderationCriteria_error_selector,\n    UnresolvedOfferCriteria_error_length,\n    UnresolvedOfferCriteria_error_offerIndex_ptr,\n    UnresolvedOfferCriteria_error_orderIndex_ptr,\n    UnresolvedOfferCriteria_error_selector,\n    UnusedItemParameters_error_length,\n    UnusedItemParameters_error_selector\n} from \"./ConsiderationErrorConstants.sol\";\n\n/**\n * @dev Reverts the current transaction with a \"BadFraction\" error message.\n */\nfunction _revertBadFraction() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, BadFraction_error_selector)\n\n        // revert(abi.encodeWithSignature(\"BadFraction()\"))\n        revert(Error_selector_offset, BadFraction_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with a \"ConsiderationNotMet\" error\n *      message, including the provided order index, consideration index, and\n *      shortfall amount.\n *\n * @param orderIndex         The index of the order that did not meet the\n *                           consideration criteria.\n * @param considerationIndex The index of the consideration item that did not\n *                           meet its criteria.\n * @param shortfallAmount    The amount by which the consideration criteria were\n *                           not met.\n */\nfunction _revertConsiderationNotMet(\n    uint256 orderIndex,\n    uint256 considerationIndex,\n    uint256 shortfallAmount\n) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, ConsiderationNotMet_error_selector)\n\n        // Store arguments.\n        mstore(ConsiderationNotMet_error_orderIndex_ptr, orderIndex)\n        mstore(\n            ConsiderationNotMet_error_considerationIndex_ptr,\n            considerationIndex\n        )\n        mstore(ConsiderationNotMet_error_shortfallAmount_ptr, shortfallAmount)\n\n        // revert(abi.encodeWithSignature(\n        //     \"ConsiderationNotMet(uint256,uint256,uint256)\",\n        //     orderIndex,\n        //     considerationIndex,\n        //     shortfallAmount\n        // ))\n        revert(Error_selector_offset, ConsiderationNotMet_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with a \"CriteriaNotEnabledForItem\" error\n *      message.\n */\nfunction _revertCriteriaNotEnabledForItem() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, CriteriaNotEnabledForItem_error_selector)\n\n        // revert(abi.encodeWithSignature(\"CriteriaNotEnabledForItem()\"))\n        revert(Error_selector_offset, CriteriaNotEnabledForItem_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an\n *      \"InsufficientNativeTokensSupplied\" error message.\n */\nfunction _revertInsufficientNativeTokensSupplied() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InsufficientNativeTokensSupplied_error_selector)\n\n        // revert(abi.encodeWithSignature(\"InsufficientNativeTokensSupplied()\"))\n        revert(\n            Error_selector_offset,\n            InsufficientNativeTokensSupplied_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an\n *      \"InvalidBasicOrderParameterEncoding\" error message.\n */\nfunction _revertInvalidBasicOrderParameterEncoding() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidBasicOrderParameterEncoding_error_selector)\n\n        // revert(abi.encodeWithSignature(\n        //     \"InvalidBasicOrderParameterEncoding()\"\n        // ))\n        revert(\n            Error_selector_offset,\n            InvalidBasicOrderParameterEncoding_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidCallToConduit\" error\n *      message, including the provided address of the conduit that was called\n *      improperly.\n *\n * @param conduit The address of the conduit that was called improperly.\n */\nfunction _revertInvalidCallToConduit(address conduit) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidCallToConduit_error_selector)\n\n        // Store argument.\n        mstore(InvalidCallToConduit_error_conduit_ptr, conduit)\n\n        // revert(abi.encodeWithSignature(\n        //     \"InvalidCallToConduit(address)\",\n        //     conduit\n        // ))\n        revert(Error_selector_offset, InvalidCallToConduit_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"CannotCancelOrder\" error\n *      message.\n */\nfunction _revertCannotCancelOrder() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, CannotCancelOrder_error_selector)\n\n        // revert(abi.encodeWithSignature(\"CannotCancelOrder()\"))\n        revert(Error_selector_offset, CannotCancelOrder_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidConduit\" error message,\n *      including the provided key and address of the invalid conduit.\n *\n * @param conduitKey    The key of the invalid conduit.\n * @param conduit       The address of the invalid conduit.\n */\nfunction _revertInvalidConduit(bytes32 conduitKey, address conduit) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidConduit_error_selector)\n\n        // Store arguments.\n        mstore(InvalidConduit_error_conduitKey_ptr, conduitKey)\n        mstore(InvalidConduit_error_conduit_ptr, conduit)\n\n        // revert(abi.encodeWithSignature(\n        //     \"InvalidConduit(bytes32,address)\",\n        //     conduitKey,\n        //     conduit\n        // ))\n        revert(Error_selector_offset, InvalidConduit_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidERC721TransferAmount\"\n *      error message.\n *\n * @param amount The invalid amount.\n */\nfunction _revertInvalidERC721TransferAmount(uint256 amount) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidERC721TransferAmount_error_selector)\n\n        // Store argument.\n        mstore(InvalidERC721TransferAmount_error_amount_ptr, amount)\n\n        // revert(abi.encodeWithSignature(\n        //     \"InvalidERC721TransferAmount(uint256)\",\n        //     amount\n        // ))\n        revert(Error_selector_offset, InvalidERC721TransferAmount_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidMsgValue\" error message,\n *      including the invalid value that was sent in the transaction's\n *      `msg.value` field.\n *\n * @param value The invalid value that was sent in the transaction's `msg.value`\n *              field.\n */\nfunction _revertInvalidMsgValue(uint256 value) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidMsgValue_error_selector)\n\n        // Store argument.\n        mstore(InvalidMsgValue_error_value_ptr, value)\n\n        // revert(abi.encodeWithSignature(\"InvalidMsgValue(uint256)\", value))\n        revert(Error_selector_offset, InvalidMsgValue_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidNativeOfferItem\" error\n *      message.\n */\nfunction _revertInvalidNativeOfferItem() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidNativeOfferItem_error_selector)\n\n        // revert(abi.encodeWithSignature(\"InvalidNativeOfferItem()\"))\n        revert(Error_selector_offset, InvalidNativeOfferItem_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidProof\" error message.\n */\nfunction _revertInvalidProof() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidProof_error_selector)\n\n        // revert(abi.encodeWithSignature(\"InvalidProof()\"))\n        revert(Error_selector_offset, InvalidProof_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidContractOrder\" error\n *      message.\n *\n * @param orderHash The hash of the contract order that caused the error.\n */\nfunction _revertInvalidContractOrder(bytes32 orderHash) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidContractOrder_error_selector)\n\n        // Store arguments.\n        mstore(InvalidContractOrder_error_orderHash_ptr, orderHash)\n\n        // revert(abi.encodeWithSignature(\n        //     \"InvalidContractOrder(bytes32)\",\n        //     orderHash\n        // ))\n        revert(Error_selector_offset, InvalidContractOrder_error_length)\n    }\n}\n\n/**\n * @dev Reverts the current transaction with an \"InvalidTime\" error message.\n *\n * @param startTime       The time at which the order becomes active.\n * @param endTime         The time at which the order becomes inactive.\n */\nfunction _revertInvalidTime(uint256 startTime, uint256 endTime) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, InvalidTime_error_selector)\n\n        // Store arguments.\n        mstore(InvalidTime_error_startTime_ptr, startTime)\n        mstore(InvalidTime_error_endTime_ptr, endTime)\n\n        // revert(abi.encodeWithSignature(\n        //     \"InvalidTime(uint256,uint256)\",\n        //     startTime,\n        //     endTime\n        // ))\n        revert(Error_selector_offset, InvalidTime_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with a\n *      \"MismatchedFulfillmentOfferAndConsiderationComponents\" error message.\n *\n * @param fulfillmentIndex         The index of the fulfillment that caused the\n *                                 error.\n */\nfunction _revertMismatchedFulfillmentOfferAndConsiderationComponents(\n    uint256 fulfillmentIndex\n) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, MismatchedOfferAndConsiderationComponents_error_selector)\n\n        // Store fulfillment index argument.\n        mstore(\n            MismatchedOfferAndConsiderationComponents_error_idx_ptr,\n            fulfillmentIndex\n        )\n\n        // revert(abi.encodeWithSignature(\n        //     \"MismatchedFulfillmentOfferAndConsiderationComponents(uint256)\",\n        //     fulfillmentIndex\n        // ))\n        revert(\n            Error_selector_offset,\n            MismatchedOfferAndConsiderationComponents_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with a \"MissingFulfillmentComponentOnAggregation\"\n *       error message.\n *\n * @param side The side of the fulfillment component that is missing (0 for\n *             offer, 1 for consideration).\n *\n */\nfunction _revertMissingFulfillmentComponentOnAggregation(Side side) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, MissingFulfillmentComponentOnAggregation_error_selector)\n\n        // Store argument.\n        mstore(MissingFulfillmentComponentOnAggregation_error_side_ptr, side)\n\n        // revert(abi.encodeWithSignature(\n        //     \"MissingFulfillmentComponentOnAggregation(uint8)\",\n        //     side\n        // ))\n        revert(\n            Error_selector_offset,\n            MissingFulfillmentComponentOnAggregation_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with a \"MissingOriginalConsiderationItems\" error\n *      message.\n */\nfunction _revertMissingOriginalConsiderationItems() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, MissingOriginalConsiderationItems_error_selector)\n\n        // revert(abi.encodeWithSignature(\n        //     \"MissingOriginalConsiderationItems()\"\n        // ))\n        revert(\n            Error_selector_offset,\n            MissingOriginalConsiderationItems_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with a \"NoReentrantCalls\" error message.\n */\nfunction _revertNoReentrantCalls() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, NoReentrantCalls_error_selector)\n\n        // revert(abi.encodeWithSignature(\"NoReentrantCalls()\"))\n        revert(Error_selector_offset, NoReentrantCalls_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with a \"NoSpecifiedOrdersAvailable\" error message.\n */\nfunction _revertNoSpecifiedOrdersAvailable() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, NoSpecifiedOrdersAvailable_error_selector)\n\n        // revert(abi.encodeWithSignature(\"NoSpecifiedOrdersAvailable()\"))\n        revert(Error_selector_offset, NoSpecifiedOrdersAvailable_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with a \"OfferAndConsiderationRequiredOnFulfillment\"\n *      error message.\n */\nfunction _revertOfferAndConsiderationRequiredOnFulfillment() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, OfferAndConsiderationRequiredOnFulfillment_error_selector)\n\n        // revert(abi.encodeWithSignature(\n        //     \"OfferAndConsiderationRequiredOnFulfillment()\"\n        // ))\n        revert(\n            Error_selector_offset,\n            OfferAndConsiderationRequiredOnFulfillment_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with an \"OrderAlreadyFilled\" error message.\n *\n * @param orderHash The hash of the order that has already been filled.\n */\nfunction _revertOrderAlreadyFilled(bytes32 orderHash) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, OrderAlreadyFilled_error_selector)\n\n        // Store argument.\n        mstore(OrderAlreadyFilled_error_orderHash_ptr, orderHash)\n\n        // revert(abi.encodeWithSignature(\n        //     \"OrderAlreadyFilled(bytes32)\",\n        //     orderHash\n        // ))\n        revert(Error_selector_offset, OrderAlreadyFilled_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with an \"OrderCriteriaResolverOutOfRange\" error\n *      message.\n *\n * @param side The side of the criteria that is missing (0 for offer, 1 for\n *             consideration).\n *\n */\nfunction _revertOrderCriteriaResolverOutOfRange(Side side) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, OrderCriteriaResolverOutOfRange_error_selector)\n\n        // Store argument.\n        mstore(OrderCriteriaResolverOutOfRange_error_side_ptr, side)\n\n        // revert(abi.encodeWithSignature(\n        //     \"OrderCriteriaResolverOutOfRange(uint8)\",\n        //     side\n        // ))\n        revert(\n            Error_selector_offset,\n            OrderCriteriaResolverOutOfRange_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with an \"OrderIsCancelled\" error message.\n *\n * @param orderHash The hash of the order that has already been cancelled.\n */\nfunction _revertOrderIsCancelled(bytes32 orderHash) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, OrderIsCancelled_error_selector)\n\n        // Store argument.\n        mstore(OrderIsCancelled_error_orderHash_ptr, orderHash)\n\n        // revert(abi.encodeWithSignature(\n        //     \"OrderIsCancelled(bytes32)\",\n        //     orderHash\n        // ))\n        revert(Error_selector_offset, OrderIsCancelled_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with an \"OrderPartiallyFilled\" error message.\n *\n * @param orderHash The hash of the order that has already been partially\n *                  filled.\n */\nfunction _revertOrderPartiallyFilled(bytes32 orderHash) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, OrderPartiallyFilled_error_selector)\n\n        // Store argument.\n        mstore(OrderPartiallyFilled_error_orderHash_ptr, orderHash)\n\n        // revert(abi.encodeWithSignature(\n        //     \"OrderPartiallyFilled(bytes32)\",\n        //     orderHash\n        // ))\n        revert(Error_selector_offset, OrderPartiallyFilled_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with a \"PartialFillsNotEnabledForOrder\" error message.\n */\nfunction _revertPartialFillsNotEnabledForOrder() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, PartialFillsNotEnabledForOrder_error_selector)\n\n        // revert(abi.encodeWithSignature(\"PartialFillsNotEnabledForOrder()\"))\n        revert(\n            Error_selector_offset,\n            PartialFillsNotEnabledForOrder_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with an \"UnresolvedConsiderationCriteria\" error\n *      message.\n */\nfunction _revertUnresolvedConsiderationCriteria(\n    uint256 orderIndex,\n    uint256 considerationIndex\n) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, UnresolvedConsiderationCriteria_error_selector)\n\n        // Store orderIndex and considerationIndex arguments.\n        mstore(UnresolvedConsiderationCriteria_error_orderIndex_ptr, orderIndex)\n        mstore(\n            UnresolvedConsiderationCriteria_error_considerationIdx_ptr,\n            considerationIndex\n        )\n\n        // revert(abi.encodeWithSignature(\n        //     \"UnresolvedConsiderationCriteria(uint256, uint256)\",\n        //     orderIndex,\n        //     considerationIndex\n        // ))\n        revert(\n            Error_selector_offset,\n            UnresolvedConsiderationCriteria_error_length\n        )\n    }\n}\n\n/**\n * @dev Reverts execution with an \"UnresolvedOfferCriteria\" error message.\n */\nfunction _revertUnresolvedOfferCriteria(\n    uint256 orderIndex,\n    uint256 offerIndex\n) pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, UnresolvedOfferCriteria_error_selector)\n\n        // Store arguments.\n        mstore(UnresolvedOfferCriteria_error_orderIndex_ptr, orderIndex)\n        mstore(UnresolvedOfferCriteria_error_offerIndex_ptr, offerIndex)\n\n        // revert(abi.encodeWithSignature(\n        //     \"UnresolvedOfferCriteria(uint256, uint256)\",\n        //     orderIndex,\n        //     offerIndex\n        // ))\n        revert(Error_selector_offset, UnresolvedOfferCriteria_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with an \"UnusedItemParameters\" error message.\n */\nfunction _revertUnusedItemParameters() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, UnusedItemParameters_error_selector)\n\n        // revert(abi.encodeWithSignature(\"UnusedItemParameters()\"))\n        revert(Error_selector_offset, UnusedItemParameters_error_length)\n    }\n}\n\n/**\n * @dev Reverts execution with a \"ConsiderationLengthNotEqualToTotalOriginal\"\n *      error message.\n */\nfunction _revertConsiderationLengthNotEqualToTotalOriginal() pure {\n    assembly {\n        // Store left-padded selector with push4 (reduces bytecode),\n        // mem[28:32] = selector\n        mstore(0, ConsiderationLengthNotEqualToTotalOriginal_error_selector)\n\n        // revert(abi.encodeWithSignature(\n        //     \"ConsiderationLengthNotEqualToTotalOriginal()\"\n        // ))\n        revert(\n            Error_selector_offset,\n            ConsiderationLengthNotEqualToTotalOriginal_error_length\n        )\n    }\n}\n"},"contracts/lib/ConsiderationErrorConstants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nuint256 constant Error_selector_offset = 0x1c;\n\n/*\n *  error MissingFulfillmentComponentOnAggregation(uint8 side)\n *    - Defined in FulfillmentApplicationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: side\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant MissingFulfillmentComponentOnAggregation_error_selector = (\n    0x375c24c1\n);\nuint256 constant MissingFulfillmentComponentOnAggregation_error_side_ptr = 0x20;\nuint256 constant MissingFulfillmentComponentOnAggregation_error_length = 0x24;\n\n/*\n *  error OfferAndConsiderationRequiredOnFulfillment()\n *    - Defined in FulfillmentApplicationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant OfferAndConsiderationRequiredOnFulfillment_error_selector = (\n    0x98e9db6e\n);\nuint256 constant OfferAndConsiderationRequiredOnFulfillment_error_length = 0x04;\n\n/*\n *  error MismatchedFulfillmentOfferAndConsiderationComponents(\n *      uint256 fulfillmentIndex\n *  )\n *    - Defined in FulfillmentApplicationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: fulfillmentIndex\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant MismatchedOfferAndConsiderationComponents_error_selector = (\n    0xbced929d\n);\nuint256 constant MismatchedOfferAndConsiderationComponents_error_idx_ptr = 0x20;\nuint256 constant MismatchedOfferAndConsiderationComponents_error_length = 0x24;\n\n/*\n *  error InvalidFulfillmentComponentData()\n *    - Defined in FulfillmentApplicationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidFulfillmentComponentData_error_selector = 0x7fda7279;\nuint256 constant InvalidFulfillmentComponentData_error_length = 0x04;\n\n/*\n *  error InexactFraction()\n *    - Defined in AmountDerivationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InexactFraction_error_selector = 0xc63cf089;\nuint256 constant InexactFraction_error_length = 0x04;\n\n/*\n *  error OrderCriteriaResolverOutOfRange(uint8 side)\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: side\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant OrderCriteriaResolverOutOfRange_error_selector = 0x133c37c6;\nuint256 constant OrderCriteriaResolverOutOfRange_error_side_ptr = 0x20;\nuint256 constant OrderCriteriaResolverOutOfRange_error_length = 0x24;\n\n/*\n *  error UnresolvedOfferCriteria(uint256 orderIndex, uint256 offerIndex)\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderIndex\n *    - 0x40: offerIndex\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant UnresolvedOfferCriteria_error_selector = 0xd6929332;\nuint256 constant UnresolvedOfferCriteria_error_orderIndex_ptr = 0x20;\nuint256 constant UnresolvedOfferCriteria_error_offerIndex_ptr = 0x40;\nuint256 constant UnresolvedOfferCriteria_error_length = 0x44;\n\n/*\n *  error UnresolvedConsiderationCriteria(\n *      uint256 orderIndex,\n *      uint256 considerationIndex\n *  )\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderIndex\n *    - 0x40: considerationIndex\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant UnresolvedConsiderationCriteria_error_selector = 0xa8930e9a;\nuint256 constant UnresolvedConsiderationCriteria_error_orderIndex_ptr = 0x20;\nuint256 constant UnresolvedConsiderationCriteria_error_considerationIdx_ptr = (\n    0x40\n);\nuint256 constant UnresolvedConsiderationCriteria_error_length = 0x44;\n\n/*\n *  error OfferCriteriaResolverOutOfRange()\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant OfferCriteriaResolverOutOfRange_error_selector = 0xbfb3f8ce;\n// uint256 constant OfferCriteriaResolverOutOfRange_error_length = 0x04;\n\n/*\n *  error ConsiderationCriteriaResolverOutOfRange()\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant ConsiderationCriteriaResolverOutOfRange_error_selector = (\n    0x6088d7de\n);\nuint256 constant ConsiderationCriteriaResolverOutOfRange_err_selector = (\n    0x6088d7de\n);\n// uint256 constant ConsiderationCriteriaResolverOutOfRange_error_length = 0x04;\n\n/*\n *  error CriteriaNotEnabledForItem()\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant CriteriaNotEnabledForItem_error_selector = 0x94eb6af6;\nuint256 constant CriteriaNotEnabledForItem_error_length = 0x04;\n\n/*\n *  error InvalidProof()\n *    - Defined in CriteriaResolutionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidProof_error_selector = 0x09bde339;\nuint256 constant InvalidProof_error_length = 0x04;\n\n/*\n *  error InvalidRestrictedOrder(bytes32 orderHash)\n *    - Defined in ZoneInteractionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidRestrictedOrder_error_selector = 0xfb5014fc;\nuint256 constant InvalidRestrictedOrder_error_orderHash_ptr = 0x20;\nuint256 constant InvalidRestrictedOrder_error_length = 0x24;\n\n/*\n *  error InvalidContractOrder(bytes32 orderHash)\n *    - Defined in ZoneInteractionErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidContractOrder_error_selector = 0x93979285;\nuint256 constant InvalidContractOrder_error_orderHash_ptr = 0x20;\nuint256 constant InvalidContractOrder_error_length = 0x24;\n\n/*\n *  error BadSignatureV(uint8 v)\n *    - Defined in SignatureVerificationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: v\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant BadSignatureV_error_selector = 0x1f003d0a;\nuint256 constant BadSignatureV_error_v_ptr = 0x20;\nuint256 constant BadSignatureV_error_length = 0x24;\n\n/*\n *  error InvalidSigner()\n *    - Defined in SignatureVerificationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidSigner_error_selector = 0x815e1d64;\nuint256 constant InvalidSigner_error_length = 0x04;\n\n/*\n *  error InvalidSignature()\n *    - Defined in SignatureVerificationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidSignature_error_selector = 0x8baa579f;\nuint256 constant InvalidSignature_error_length = 0x04;\n\n/*\n *  error BadContractSignature()\n *    - Defined in SignatureVerificationErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant BadContractSignature_error_selector = 0x4f7fb80d;\nuint256 constant BadContractSignature_error_length = 0x04;\n\n/*\n *  error InvalidERC721TransferAmount(uint256 amount)\n *    - Defined in TokenTransferrerErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: amount\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidERC721TransferAmount_error_selector = 0x69f95827;\nuint256 constant InvalidERC721TransferAmount_error_amount_ptr = 0x20;\nuint256 constant InvalidERC721TransferAmount_error_length = 0x24;\n\n/*\n *  error MissingItemAmount()\n *    - Defined in TokenTransferrerErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant MissingItemAmount_error_selector = 0x91b3e514;\nuint256 constant MissingItemAmount_error_length = 0x04;\n\n/*\n *  error UnusedItemParameters()\n *    - Defined in TokenTransferrerErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant UnusedItemParameters_error_selector = 0x6ab37ce7;\nuint256 constant UnusedItemParameters_error_length = 0x04;\n\n/*\n *  error NoReentrantCalls()\n *    - Defined in ReentrancyErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant NoReentrantCalls_error_selector = 0x7fa8a987;\nuint256 constant NoReentrantCalls_error_length = 0x04;\n\n/*\n *  error OrderAlreadyFilled(bytes32 orderHash)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant OrderAlreadyFilled_error_selector = 0x10fda3e1;\nuint256 constant OrderAlreadyFilled_error_orderHash_ptr = 0x20;\nuint256 constant OrderAlreadyFilled_error_length = 0x24;\n\n/*\n *  error InvalidTime(uint256 startTime, uint256 endTime)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: startTime\n *    - 0x40: endTime\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant InvalidTime_error_selector = 0x21ccfeb7;\nuint256 constant InvalidTime_error_startTime_ptr = 0x20;\nuint256 constant InvalidTime_error_endTime_ptr = 0x40;\nuint256 constant InvalidTime_error_length = 0x44;\n\n/*\n *  error InvalidConduit(bytes32 conduitKey, address conduit)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: conduitKey\n *    - 0x40: conduit\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant InvalidConduit_error_selector = 0x1cf99b26;\nuint256 constant InvalidConduit_error_conduitKey_ptr = 0x20;\nuint256 constant InvalidConduit_error_conduit_ptr = 0x40;\nuint256 constant InvalidConduit_error_length = 0x44;\n\n/*\n *  error MissingOriginalConsiderationItems()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant MissingOriginalConsiderationItems_error_selector = 0x466aa616;\nuint256 constant MissingOriginalConsiderationItems_error_length = 0x04;\n\n/*\n *  error InvalidCallToConduit(address conduit)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: conduit\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidCallToConduit_error_selector = 0xd13d53d4;\nuint256 constant InvalidCallToConduit_error_conduit_ptr = 0x20;\nuint256 constant InvalidCallToConduit_error_length = 0x24;\n\n/*\n *  error ConsiderationNotMet(\n *      uint256 orderIndex,\n *      uint256 considerationIndex,\n *      uint256 shortfallAmount\n *  )\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderIndex\n *    - 0x40: considerationIndex\n *    - 0x60: shortfallAmount\n * Revert buffer is memory[0x1c:0x80]\n */\nuint256 constant ConsiderationNotMet_error_selector = 0xa5f54208;\nuint256 constant ConsiderationNotMet_error_orderIndex_ptr = 0x20;\nuint256 constant ConsiderationNotMet_error_considerationIndex_ptr = 0x40;\nuint256 constant ConsiderationNotMet_error_shortfallAmount_ptr = 0x60;\nuint256 constant ConsiderationNotMet_error_length = 0x64;\n\n/*\n *  error InsufficientNativeTokensSupplied()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InsufficientNativeTokensSupplied_error_selector = 0x8ffff980;\nuint256 constant InsufficientNativeTokensSupplied_error_length = 0x04;\n\n/*\n *  error NativeTokenTransferGenericFailure(address account, uint256 amount)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: account\n *    - 0x40: amount\n * Revert buffer is memory[0x1c:0x60]\n */\nuint256 constant NativeTokenTransferGenericFailure_error_selector = 0xbc806b96;\nuint256 constant NativeTokenTransferGenericFailure_error_account_ptr = 0x20;\nuint256 constant NativeTokenTransferGenericFailure_error_amount_ptr = 0x40;\nuint256 constant NativeTokenTransferGenericFailure_error_length = 0x44;\n\n/*\n *  error PartialFillsNotEnabledForOrder()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant PartialFillsNotEnabledForOrder_error_selector = 0xa11b63ff;\nuint256 constant PartialFillsNotEnabledForOrder_error_length = 0x04;\n\n/*\n *  error OrderIsCancelled(bytes32 orderHash)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant OrderIsCancelled_error_selector = 0x1a515574;\nuint256 constant OrderIsCancelled_error_orderHash_ptr = 0x20;\nuint256 constant OrderIsCancelled_error_length = 0x24;\n\n/*\n *  error OrderPartiallyFilled(bytes32 orderHash)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: orderHash\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant OrderPartiallyFilled_error_selector = 0xee9e0e63;\nuint256 constant OrderPartiallyFilled_error_orderHash_ptr = 0x20;\nuint256 constant OrderPartiallyFilled_error_length = 0x24;\n\n/*\n *  error CannotCancelOrder()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant CannotCancelOrder_error_selector = 0xfed398fc;\nuint256 constant CannotCancelOrder_error_length = 0x04;\n\n/*\n *  error BadFraction()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant BadFraction_error_selector = 0x5a052b32;\nuint256 constant BadFraction_error_length = 0x04;\n\n/*\n *  error InvalidMsgValue(uint256 value)\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: value\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant InvalidMsgValue_error_selector = 0xa61be9f0;\nuint256 constant InvalidMsgValue_error_value_ptr = 0x20;\nuint256 constant InvalidMsgValue_error_length = 0x24;\n\n/*\n *  error InvalidBasicOrderParameterEncoding()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidBasicOrderParameterEncoding_error_selector = 0x39f3e3fd;\nuint256 constant InvalidBasicOrderParameterEncoding_error_length = 0x04;\n\n/*\n *  error NoSpecifiedOrdersAvailable()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant NoSpecifiedOrdersAvailable_error_selector = 0xd5da9a1b;\nuint256 constant NoSpecifiedOrdersAvailable_error_length = 0x04;\n\n/*\n *  error InvalidNativeOfferItem()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant InvalidNativeOfferItem_error_selector = 0x12d3f5a3;\nuint256 constant InvalidNativeOfferItem_error_length = 0x04;\n\n/*\n *  error ConsiderationLengthNotEqualToTotalOriginal()\n *    - Defined in ConsiderationEventsAndErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n * Revert buffer is memory[0x1c:0x20]\n */\nuint256 constant ConsiderationLengthNotEqualToTotalOriginal_error_selector = (\n    0x2165628a\n);\nuint256 constant ConsiderationLengthNotEqualToTotalOriginal_error_length = 0x04;\n\n/*\n *  error Panic(uint256 code)\n *    - Built-in Solidity error\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: code\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant Panic_error_selector = 0x4e487b71;\nuint256 constant Panic_error_code_ptr = 0x20;\nuint256 constant Panic_error_length = 0x24;\n\nuint256 constant Panic_arithmetic = 0x11;\n// uint256 constant Panic_resource = 0x41;\n"},"contracts/interfaces/ConsiderationEventsAndErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    OrderParameters,\n    ReceivedItem,\n    SpentItem\n} from \"../lib/ConsiderationStructs.sol\";\n\n/**\n * @title ConsiderationEventsAndErrors\n * @author 0age\n * @notice ConsiderationEventsAndErrors contains all events and errors.\n */\ninterface ConsiderationEventsAndErrors {\n    /**\n     * @dev Emit an event whenever an order is successfully fulfilled.\n     *\n     * @param orderHash     The hash of the fulfilled order.\n     * @param offerer       The offerer of the fulfilled order.\n     * @param zone          The zone of the fulfilled order.\n     * @param recipient     The recipient of each spent item on the fulfilled\n     *                      order, or the null address if there is no specific\n     *                      fulfiller (i.e. the order is part of a group of\n     *                      orders). Defaults to the caller unless explicitly\n     *                      specified otherwise by the fulfiller.\n     * @param offer         The offer items spent as part of the order.\n     * @param consideration The consideration items received as part of the\n     *                      order along with the recipients of each item.\n     */\n    event OrderFulfilled(\n        bytes32 orderHash,\n        address indexed offerer,\n        address indexed zone,\n        address recipient,\n        SpentItem[] offer,\n        ReceivedItem[] consideration\n    );\n\n    /**\n     * @dev Emit an event whenever an order is successfully cancelled.\n     *\n     * @param orderHash The hash of the cancelled order.\n     * @param offerer   The offerer of the cancelled order.\n     * @param zone      The zone of the cancelled order.\n     */\n    event OrderCancelled(\n        bytes32 orderHash,\n        address indexed offerer,\n        address indexed zone\n    );\n\n    /**\n     * @dev Emit an event whenever an order is explicitly validated. Note that\n     *      this event will not be emitted on partial fills even though they do\n     *      validate the order as part of partial fulfillment.\n     *\n     * @param orderHash        The hash of the validated order.\n     * @param orderParameters  The parameters of the validated order.\n     */\n    event OrderValidated(bytes32 orderHash, OrderParameters orderParameters);\n\n    /**\n     * @dev Emit an event whenever one or more orders are matched using either\n     *      matchOrders or matchAdvancedOrders.\n     *\n     * @param orderHashes The order hashes of the matched orders.\n     */\n    event OrdersMatched(bytes32[] orderHashes);\n\n    /**\n     * @dev Emit an event whenever a counter for a given offerer is incremented.\n     *\n     * @param newCounter The new counter for the offerer.\n     * @param offerer    The offerer in question.\n     */\n    event CounterIncremented(uint256 newCounter, address indexed offerer);\n\n    /**\n     * @dev Revert with an error when attempting to fill an order that has\n     *      already been fully filled.\n     *\n     * @param orderHash The order hash on which a fill was attempted.\n     */\n    error OrderAlreadyFilled(bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error when attempting to fill an order outside the\n     *      specified start time and end time.\n     *\n     * @param startTime The time at which the order becomes active.\n     * @param endTime   The time at which the order becomes inactive.\n     */\n    error InvalidTime(uint256 startTime, uint256 endTime);\n\n    /**\n     * @dev Revert with an error when attempting to fill an order referencing an\n     *      invalid conduit (i.e. one that has not been deployed).\n     */\n    error InvalidConduit(bytes32 conduitKey, address conduit);\n\n    /**\n     * @dev Revert with an error when an order is supplied for fulfillment with\n     *      a consideration array that is shorter than the original array.\n     */\n    error MissingOriginalConsiderationItems();\n\n    /**\n     * @dev Revert with an error when an order is validated and the length of\n     *      the consideration array is not equal to the supplied total original\n     *      consideration items value. This error is also thrown when contract\n     *      orders supply a total original consideration items value that does\n     *      not match the supplied consideration array length.\n     */\n    error ConsiderationLengthNotEqualToTotalOriginal();\n\n    /**\n     * @dev Revert with an error when a call to a conduit fails with revert data\n     *      that is too expensive to return.\n     */\n    error InvalidCallToConduit(address conduit);\n\n    /**\n     * @dev Revert with an error if a consideration amount has not been fully\n     *      zeroed out after applying all fulfillments.\n     *\n     * @param orderIndex         The index of the order with the consideration\n     *                           item with a shortfall.\n     * @param considerationIndex The index of the consideration item on the\n     *                           order.\n     * @param shortfallAmount    The unfulfilled consideration amount.\n     */\n    error ConsiderationNotMet(\n        uint256 orderIndex,\n        uint256 considerationIndex,\n        uint256 shortfallAmount\n    );\n\n    /**\n     * @dev Revert with an error when insufficient native tokens are supplied as\n     *      part of msg.value when fulfilling orders.\n     */\n    error InsufficientNativeTokensSupplied();\n\n    /**\n     * @dev Revert with an error when a native token transfer reverts.\n     */\n    error NativeTokenTransferGenericFailure(address account, uint256 amount);\n\n    /**\n     * @dev Revert with an error when a partial fill is attempted on an order\n     *      that does not specify partial fill support in its order type.\n     */\n    error PartialFillsNotEnabledForOrder();\n\n    /**\n     * @dev Revert with an error when attempting to fill an order that has been\n     *      cancelled.\n     *\n     * @param orderHash The hash of the cancelled order.\n     */\n    error OrderIsCancelled(bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error when attempting to fill a basic order that has\n     *      been partially filled.\n     *\n     * @param orderHash The hash of the partially used order.\n     */\n    error OrderPartiallyFilled(bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error when attempting to cancel an order as a caller\n     *      other than the indicated offerer or zone or when attempting to\n     *      cancel a contract order.\n     */\n    error CannotCancelOrder();\n\n    /**\n     * @dev Revert with an error when supplying a fraction with a value of zero\n     *      for the numerator or denominator, or one where the numerator exceeds\n     *      the denominator.\n     */\n    error BadFraction();\n\n    /**\n     * @dev Revert with an error when a caller attempts to supply callvalue to a\n     *      non-payable basic order route or does not supply any callvalue to a\n     *      payable basic order route.\n     */\n    error InvalidMsgValue(uint256 value);\n\n    /**\n     * @dev Revert with an error when attempting to fill a basic order using\n     *      calldata not produced by default ABI encoding.\n     */\n    error InvalidBasicOrderParameterEncoding();\n\n    /**\n     * @dev Revert with an error when attempting to fulfill any number of\n     *      available orders when none are fulfillable.\n     */\n    error NoSpecifiedOrdersAvailable();\n\n    /**\n     * @dev Revert with an error when attempting to fulfill an order with an\n     *      offer for a native token outside of matching orders.\n     */\n    error InvalidNativeOfferItem();\n}\n"},"contracts/lib/TokenTransferrerConstants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/*\n * -------------------------- Disambiguation & Other Notes ---------------------\n *    - The term \"head\" is used as it is in the documentation for ABI encoding,\n *      but only in reference to dynamic types, i.e. it always refers to the\n *      offset or pointer to the body of a dynamic type. In calldata, the head\n *      is always an offset (relative to the parent object), while in memory,\n *      the head is always the pointer to the body. More information found here:\n *      https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#argument-encoding\n *        - Note that the length of an array is separate from and precedes the\n *          head of the array.\n *\n *    - The term \"body\" is used in place of the term \"head\" used in the ABI\n *      documentation. It refers to the start of the data for a dynamic type,\n *      e.g. the first word of a struct or the first word of the first element\n *      in an array.\n *\n *    - The term \"pointer\" is used to describe the absolute position of a value\n *      and never an offset relative to another value.\n *        - The suffix \"_ptr\" refers to a memory pointer.\n *        - The suffix \"_cdPtr\" refers to a calldata pointer.\n *\n *    - The term \"offset\" is used to describe the position of a value relative\n *      to some parent value. For example, OrderParameters_conduit_offset is the\n *      offset to the \"conduit\" value in the OrderParameters struct relative to\n *      the start of the body.\n *        - Note: Offsets are used to derive pointers.\n *\n *    - Some structs have pointers defined for all of their fields in this file.\n *      Lines which are commented out are fields that are not used in the\n *      codebase but have been left in for readability.\n */\n\nuint256 constant ThirtyOneBytes = 0x1f;\nuint256 constant OneWord = 0x20;\nuint256 constant TwoWords = 0x40;\nuint256 constant ThreeWords = 0x60;\n\nuint256 constant OneWordShift = 0x5;\nuint256 constant TwoWordsShift = 0x6;\n\nuint256 constant FreeMemoryPointerSlot = 0x40;\nuint256 constant ZeroSlot = 0x60;\nuint256 constant DefaultFreeMemoryPointer = 0x80;\n\nuint256 constant Slot0x80 = 0x80;\nuint256 constant Slot0xA0 = 0xa0;\nuint256 constant Slot0xC0 = 0xc0;\n\nuint256 constant Generic_error_selector_offset = 0x1c;\n\n// abi.encodeWithSignature(\"transferFrom(address,address,uint256)\")\nuint256 constant ERC20_transferFrom_signature = (\n    0x23b872dd00000000000000000000000000000000000000000000000000000000\n);\nuint256 constant ERC20_transferFrom_sig_ptr = 0x0;\nuint256 constant ERC20_transferFrom_from_ptr = 0x04;\nuint256 constant ERC20_transferFrom_to_ptr = 0x24;\nuint256 constant ERC20_transferFrom_amount_ptr = 0x44;\nuint256 constant ERC20_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\n\n// abi.encodeWithSignature(\n//     \"safeTransferFrom(address,address,uint256,uint256,bytes)\"\n// )\nuint256 constant ERC1155_safeTransferFrom_signature = (\n    0xf242432a00000000000000000000000000000000000000000000000000000000\n);\nuint256 constant ERC1155_safeTransferFrom_sig_ptr = 0x0;\nuint256 constant ERC1155_safeTransferFrom_from_ptr = 0x04;\nuint256 constant ERC1155_safeTransferFrom_to_ptr = 0x24;\nuint256 constant ERC1155_safeTransferFrom_id_ptr = 0x44;\nuint256 constant ERC1155_safeTransferFrom_amount_ptr = 0x64;\nuint256 constant ERC1155_safeTransferFrom_data_offset_ptr = 0x84;\nuint256 constant ERC1155_safeTransferFrom_data_length_ptr = 0xa4;\nuint256 constant ERC1155_safeTransferFrom_length = 0xc4; // 4 + 32 * 6 == 196\nuint256 constant ERC1155_safeTransferFrom_data_length_offset = 0xa0;\n\n// abi.encodeWithSignature(\n//     \"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\"\n// )\nuint256 constant ERC1155_safeBatchTransferFrom_signature = (\n    0x2eb2c2d600000000000000000000000000000000000000000000000000000000\n);\n\n// bytes4 constant ERC1155_safeBatchTransferFrom_selector = bytes4(\n//     bytes32(ERC1155_safeBatchTransferFrom_signature)\n// );\n\nuint256 constant ERC721_transferFrom_signature = (\n    0x23b872dd00000000000000000000000000000000000000000000000000000000\n);\nuint256 constant ERC721_transferFrom_sig_ptr = 0x0;\nuint256 constant ERC721_transferFrom_from_ptr = 0x04;\nuint256 constant ERC721_transferFrom_to_ptr = 0x24;\nuint256 constant ERC721_transferFrom_id_ptr = 0x44;\nuint256 constant ERC721_transferFrom_length = 0x64; // 4 + 32 * 3 == 100\n\n/*\n *  error NoContract(address account)\n *    - Defined in TokenTransferrerErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x00: account\n * Revert buffer is memory[0x1c:0x40]\n */\nuint256 constant NoContract_error_selector = 0x5f15d672;\nuint256 constant NoContract_error_account_ptr = 0x20;\nuint256 constant NoContract_error_length = 0x24;\n\n/*\n *  error TokenTransferGenericFailure(\n *      address token,\n *      address from,\n *      address to,\n *      uint256 identifier,\n *      uint256 amount\n *  )\n *    - Defined in TokenTransferrerErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x20: token\n *    - 0x40: from\n *    - 0x60: to\n *    - 0x80: identifier\n *    - 0xa0: amount\n * Revert buffer is memory[0x1c:0xc0]\n */\nuint256 constant TokenTransferGenericFailure_error_selector = 0xf486bc87;\nuint256 constant TokenTransferGenericFailure_error_token_ptr = 0x20;\nuint256 constant TokenTransferGenericFailure_error_from_ptr = 0x40;\nuint256 constant TokenTransferGenericFailure_error_to_ptr = 0x60;\nuint256 constant TokenTransferGenericFailure_error_identifier_ptr = 0x80;\nuint256 constant TokenTransferGenericFailure_err_identifier_ptr = 0x80;\nuint256 constant TokenTransferGenericFailure_error_amount_ptr = 0xa0;\nuint256 constant TokenTransferGenericFailure_error_length = 0xa4;\n\nuint256 constant ExtraGasBuffer = 0x20;\nuint256 constant CostPerWord = 0x3;\nuint256 constant MemoryExpansionCoefficientShift = 0x9;\n\n// Values are offset by 32 bytes in order to write the token to the beginning\n// in the event of a revert\nuint256 constant BatchTransfer1155Params_ptr = 0x24;\nuint256 constant BatchTransfer1155Params_ids_head_ptr = 0x64;\nuint256 constant BatchTransfer1155Params_amounts_head_ptr = 0x84;\nuint256 constant BatchTransfer1155Params_data_head_ptr = 0xa4;\nuint256 constant BatchTransfer1155Params_data_length_basePtr = 0xc4;\nuint256 constant BatchTransfer1155Params_calldata_baseSize = 0xc4;\n\nuint256 constant BatchTransfer1155Params_ids_length_ptr = 0xc4;\n\nuint256 constant BatchTransfer1155Params_ids_length_offset = 0xa0;\n// uint256 constant BatchTransfer1155Params_amounts_length_baseOffset = 0xc0;\n// uint256 constant BatchTransfer1155Params_data_length_baseOffset = 0xe0;\n\nuint256 constant ConduitBatch1155Transfer_usable_head_size = 0x80;\n\nuint256 constant ConduitBatch1155Transfer_from_offset = 0x20;\nuint256 constant ConduitBatch1155Transfer_ids_head_offset = 0x60;\n// uint256 constant ConduitBatch1155Transfer_amounts_head_offset = 0x80;\nuint256 constant ConduitBatch1155Transfer_ids_length_offset = 0xa0;\nuint256 constant ConduitBatch1155Transfer_amounts_length_baseOffset = 0xc0;\n// uint256 constant ConduitBatch1155Transfer_calldata_baseSize = 0xc0;\n\n// Note: abbreviated version of above constant to adhere to line length limit.\nuint256 constant ConduitBatchTransfer_amounts_head_offset = 0x80;\n\nuint256 constant Invalid1155BatchTransferEncoding_ptr = 0x00;\nuint256 constant Invalid1155BatchTransferEncoding_length = 0x04;\nuint256 constant Invalid1155BatchTransferEncoding_selector = (\n    0xeba2084c00000000000000000000000000000000000000000000000000000000\n);\n\nuint256 constant ERC1155BatchTransferGenericFailure_error_signature = (\n    0xafc445e200000000000000000000000000000000000000000000000000000000\n);\nuint256 constant ERC1155BatchTransferGenericFailure_token_ptr = 0x04;\nuint256 constant ERC1155BatchTransferGenericFailure_ids_offset = 0xc0;\n\n/*\n *  error BadReturnValueFromERC20OnTransfer(\n *      address token, address from, address to, uint256 amount\n *  )\n *    - Defined in TokenTransferrerErrors.sol\n *  Memory layout:\n *    - 0x00: Left-padded selector (data begins at 0x1c)\n *    - 0x00: token\n *    - 0x20: from\n *    - 0x40: to\n *    - 0x60: amount\n * Revert buffer is memory[0x1c:0xa0]\n */\nuint256 constant BadReturnValueFromERC20OnTransfer_error_selector = 0x98891923;\nuint256 constant BadReturnValueFromERC20OnTransfer_error_token_ptr = 0x20;\nuint256 constant BadReturnValueFromERC20OnTransfer_error_from_ptr = 0x40;\nuint256 constant BadReturnValueFromERC20OnTransfer_error_to_ptr = 0x60;\nuint256 constant BadReturnValueFromERC20OnTransfer_error_amount_ptr = 0x80;\nuint256 constant BadReturnValueFromERC20OnTransfer_error_length = 0x84;\n"},"contracts/lib/BasicOrderFulfiller.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {\n    BasicOrderRouteType,\n    ItemType,\n    OrderType\n} from \"./ConsiderationEnums.sol\";\n\nimport { BasicOrderParameters } from \"./ConsiderationStructs.sol\";\n\nimport { OrderValidator } from \"./OrderValidator.sol\";\n\nimport {\n    _revertInsufficientNativeTokensSupplied,\n    _revertInvalidMsgValue,\n    _revertInvalidERC721TransferAmount,\n    _revertUnusedItemParameters\n} from \"./ConsiderationErrors.sol\";\n\nimport {\n    AccumulatorDisarmed,\n    AdditionalRecipient_size_shift,\n    AdditionalRecipient_size,\n    BasicOrder_additionalRecipients_data_cdPtr,\n    BasicOrder_additionalRecipients_length_cdPtr,\n    BasicOrder_basicOrderType_cdPtr,\n    BasicOrder_common_params_size,\n    BasicOrder_considerationAmount_cdPtr,\n    BasicOrder_considerationHashesArray_ptr,\n    BasicOrder_considerationIdentifier_cdPtr,\n    BasicOrder_considerationItem_endAmount_ptr,\n    BasicOrder_considerationItem_identifier_ptr,\n    BasicOrder_considerationItem_itemType_ptr,\n    BasicOrder_considerationItem_startAmount_ptr,\n    BasicOrder_considerationItem_token_ptr,\n    BasicOrder_considerationItem_typeHash_ptr,\n    BasicOrder_considerationToken_cdPtr,\n    BasicOrder_endTime_cdPtr,\n    BasicOrder_fulfillerConduit_cdPtr,\n    BasicOrder_offerAmount_cdPtr,\n    BasicOrder_offeredItemByteMap,\n    BasicOrder_offerer_cdPtr,\n    BasicOrder_offererConduit_cdPtr,\n    BasicOrder_offerIdentifier_cdPtr,\n    BasicOrder_offerItem_endAmount_ptr,\n    BasicOrder_offerItem_itemType_ptr,\n    BasicOrder_offerItem_token_ptr,\n    BasicOrder_offerItem_typeHash_ptr,\n    BasicOrder_offerToken_cdPtr,\n    BasicOrder_order_considerationHashes_ptr,\n    BasicOrder_order_counter_ptr,\n    BasicOrder_order_offerer_ptr,\n    BasicOrder_order_offerHashes_ptr,\n    BasicOrder_order_orderType_ptr,\n    BasicOrder_order_startTime_ptr,\n    BasicOrder_order_typeHash_ptr,\n    BasicOrder_receivedItemByteMap,\n    BasicOrder_startTime_cdPtr,\n    BasicOrder_totalOriginalAdditionalRecipients_cdPtr,\n    BasicOrder_zone_cdPtr,\n    Common_token_offset,\n    Conduit_execute_ConduitTransfer_length_ptr,\n    Conduit_execute_ConduitTransfer_length,\n    Conduit_execute_ConduitTransfer_offset_ptr,\n    Conduit_execute_ConduitTransfer_ptr,\n    Conduit_execute_signature,\n    Conduit_execute_transferAmount_ptr,\n    Conduit_execute_transferIdentifier_ptr,\n    Conduit_execute_transferFrom_ptr,\n    Conduit_execute_transferItemType_ptr,\n    Conduit_execute_transferTo_ptr,\n    Conduit_execute_transferToken_ptr,\n    EIP712_ConsiderationItem_size,\n    EIP712_OfferItem_size,\n    EIP712_Order_size,\n    FiveWords,\n    FourWords,\n    FreeMemoryPointerSlot,\n    MaskOverLastTwentyBytes,\n    OneConduitExecute_size,\n    OneWord,\n    OneWordShift,\n    OrderFulfilled_baseOffset,\n    OrderFulfilled_baseSize,\n    OrderFulfilled_consideration_body_offset,\n    OrderFulfilled_consideration_head_offset,\n    OrderFulfilled_consideration_length_baseOffset,\n    OrderFulfilled_fulfiller_offset,\n    OrderFulfilled_offer_body_offset,\n    OrderFulfilled_offer_head_offset,\n    OrderFulfilled_offer_length_baseOffset,\n    OrderFulfilled_selector,\n    ReceivedItem_amount_offset,\n    ReceivedItem_size,\n    receivedItemsHash_ptr,\n    ThreeWords,\n    TwoWords,\n    ZeroSlot\n} from \"./ConsiderationConstants.sol\";\n\nimport {\n    Error_selector_offset,\n    InvalidBasicOrderParameterEncoding_error_length,\n    InvalidBasicOrderParameterEncoding_error_selector,\n    InvalidTime_error_endTime_ptr,\n    InvalidTime_error_length,\n    InvalidTime_error_selector,\n    InvalidTime_error_startTime_ptr,\n    MissingOriginalConsiderationItems_error_length,\n    MissingOriginalConsiderationItems_error_selector,\n    UnusedItemParameters_error_length,\n    UnusedItemParameters_error_selector\n} from \"./ConsiderationErrorConstants.sol\";\n\n/**\n * @title BasicOrderFulfiller\n * @author 0age\n * @notice BasicOrderFulfiller contains functionality for fulfilling \"basic\"\n *         orders with minimal overhead. See documentation for details on what\n *         qualifies as a basic order.\n */\ncontract BasicOrderFulfiller is OrderValidator {\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) OrderValidator(conduitController) {}\n\n    /**\n     * @dev Internal function to fulfill an order offering an ERC20, ERC721, or\n     *      ERC1155 item by supplying Ether (or other native tokens), ERC20\n     *      tokens, an ERC721 item, or an ERC1155 item as consideration. Six\n     *      permutations are supported: Native token to ERC721, Native token to\n     *      ERC1155, ERC20 to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and\n     *      ERC1155 to ERC20 (with native tokens supplied as msg.value). For an\n     *      order to be eligible for fulfillment via this method, it must\n     *      contain a single offer item (though that item may have a greater\n     *      amount if the item is not an ERC721). An arbitrary number of\n     *      \"additional recipients\" may also be supplied which will each receive\n     *      native tokens or ERC20 items from the fulfiller as consideration.\n     *      Refer to the documentation for a more comprehensive summary of how\n     *      to utilize this method and what orders are compatible with it.\n     *\n     * @param parameters Additional information on the fulfilled order. Note\n     *                   that the offerer and the fulfiller must first approve\n     *                   this contract (or their chosen conduit if indicated)\n     *                   before any tokens can be transferred. Also note that\n     *                   contract recipients of ERC1155 consideration items must\n     *                   implement `onERC1155Received` in order to receive those\n     *                   items.\n     *\n     * @return A boolean indicating whether the order has been fulfilled.\n     */\n    function _validateAndFulfillBasicOrder(\n        BasicOrderParameters calldata parameters\n    ) internal returns (bool) {\n        // Declare enums for order type & route to extract from basicOrderType.\n        BasicOrderRouteType route;\n        OrderType orderType;\n\n        // Declare additional recipient item type to derive from the route type.\n        ItemType additionalRecipientsItemType;\n\n        bytes32 orderHash;\n\n        // Utilize assembly to extract the order type and the basic order route.\n        assembly {\n            // Read basicOrderType from calldata.\n            let basicOrderType := calldataload(BasicOrder_basicOrderType_cdPtr)\n\n            // Mask all but 2 least-significant bits to derive the order type.\n            orderType := and(basicOrderType, 3)\n\n            // Divide basicOrderType by four to derive the route.\n            route := shr(2, basicOrderType)\n\n            // If route > 1 additionalRecipient items are ERC20 (1) else native\n            // token (0).\n            additionalRecipientsItemType := gt(route, 1)\n        }\n\n        {\n            // Declare temporary variable for enforcing payable status.\n            bool correctPayableStatus;\n\n            // Utilize assembly to compare the route to the callvalue.\n            assembly {\n                // route 0 and 1 are payable, otherwise route is not payable.\n                correctPayableStatus := eq(\n                    additionalRecipientsItemType,\n                    iszero(callvalue())\n                )\n            }\n\n            // Revert if msg.value has not been supplied as part of payable\n            // routes or has been supplied as part of non-payable routes.\n            if (!correctPayableStatus) {\n                _revertInvalidMsgValue(msg.value);\n            }\n        }\n\n        // Declare more arguments that will be derived from route and calldata.\n        address additionalRecipientsToken;\n        ItemType offeredItemType;\n        bool offerTypeIsAdditionalRecipientsType;\n\n        // Declare scope for received item type to manage stack pressure.\n        {\n            ItemType receivedItemType;\n\n            // Utilize assembly to retrieve function arguments and cast types.\n            assembly {\n                // Check if offered item type == additional recipient item type.\n                offerTypeIsAdditionalRecipientsType := gt(route, 3)\n\n                // If route > 3 additionalRecipientsToken is at 0xc4 else 0x24.\n                additionalRecipientsToken := calldataload(\n                    add(\n                        BasicOrder_considerationToken_cdPtr,\n                        mul(\n                            offerTypeIsAdditionalRecipientsType,\n                            BasicOrder_common_params_size\n                        )\n                    )\n                )\n\n                // If route > 2, receivedItemType is route - 2. If route is 2,\n                // the receivedItemType is ERC20 (1). Otherwise, it is native\n                // token (0).\n                receivedItemType := byte(route, BasicOrder_receivedItemByteMap)\n\n                // If route > 3, offeredItemType is ERC20 (1). Route is 2 or 3,\n                // offeredItemType = route. Route is 0 or 1, it is route + 2.\n                offeredItemType := byte(route, BasicOrder_offeredItemByteMap)\n            }\n\n            // Derive & validate order using parameters and update order status.\n            orderHash = _prepareBasicFulfillmentFromCalldata(\n                parameters,\n                orderType,\n                receivedItemType,\n                additionalRecipientsItemType,\n                additionalRecipientsToken,\n                offeredItemType\n            );\n        }\n\n        // Declare conduitKey argument used by transfer functions.\n        bytes32 conduitKey;\n\n        // Utilize assembly to derive conduit (if relevant) based on route.\n        assembly {\n            // use offerer conduit for routes 0-3, fulfiller conduit otherwise.\n            conduitKey := calldataload(\n                add(\n                    BasicOrder_offererConduit_cdPtr,\n                    shl(OneWordShift, offerTypeIsAdditionalRecipientsType)\n                )\n            )\n        }\n\n        // Transfer tokens based on the route.\n        if (additionalRecipientsItemType == ItemType.NATIVE) {\n            // Ensure neither consideration token nor identifier are set. Note\n            // that dirty upper bits in the consideration token will still cause\n            // this error to be thrown.\n            assembly {\n                if or(\n                    calldataload(BasicOrder_considerationToken_cdPtr),\n                    calldataload(BasicOrder_considerationIdentifier_cdPtr)\n                ) {\n                    // Store left-padded selector with push4 (reduces bytecode),\n                    // mem[28:32] = selector\n                    mstore(0, UnusedItemParameters_error_selector)\n\n                    // revert(abi.encodeWithSignature(\"UnusedItemParameters()\"))\n                    revert(\n                        Error_selector_offset,\n                        UnusedItemParameters_error_length\n                    )\n                }\n            }\n\n            // Transfer the ERC721 or ERC1155 item, bypassing the accumulator.\n            _transferIndividual721Or1155Item(offeredItemType, conduitKey);\n\n            // Transfer native to recipients, return excess to caller & wrap up.\n            _transferNativeTokensAndFinalize();\n        } else {\n            // Initialize an accumulator array. From this point forward, no new\n            // memory regions can be safely allocated until the accumulator is\n            // no longer being utilized, as the accumulator operates in an\n            // open-ended fashion from this memory pointer; existing memory may\n            // still be accessed and modified, however.\n            bytes memory accumulator = new bytes(AccumulatorDisarmed);\n\n            // Choose transfer method for ERC721 or ERC1155 item based on route.\n            if (route == BasicOrderRouteType.ERC20_TO_ERC721) {\n                // Transfer ERC721 to caller using offerer's conduit preference.\n                _transferERC721(\n                    parameters.offerToken,\n                    parameters.offerer,\n                    msg.sender,\n                    parameters.offerIdentifier,\n                    parameters.offerAmount,\n                    conduitKey,\n                    accumulator\n                );\n            } else if (route == BasicOrderRouteType.ERC20_TO_ERC1155) {\n                // Transfer ERC1155 to caller with offerer's conduit preference.\n                _transferERC1155(\n                    parameters.offerToken,\n                    parameters.offerer,\n                    msg.sender,\n                    parameters.offerIdentifier,\n                    parameters.offerAmount,\n                    conduitKey,\n                    accumulator\n                );\n            } else if (route == BasicOrderRouteType.ERC721_TO_ERC20) {\n                // Transfer ERC721 to offerer using caller's conduit preference.\n                _transferERC721(\n                    parameters.considerationToken,\n                    msg.sender,\n                    parameters.offerer,\n                    parameters.considerationIdentifier,\n                    parameters.considerationAmount,\n                    conduitKey,\n                    accumulator\n                );\n            } else {\n                // route == BasicOrderRouteType.ERC1155_TO_ERC20\n\n                // Transfer ERC1155 to offerer with caller's conduit preference.\n                _transferERC1155(\n                    parameters.considerationToken,\n                    msg.sender,\n                    parameters.offerer,\n                    parameters.considerationIdentifier,\n                    parameters.considerationAmount,\n                    conduitKey,\n                    accumulator\n                );\n            }\n\n            // Transfer ERC20 tokens to all recipients and wrap up.\n            _transferERC20AndFinalize(\n                offerTypeIsAdditionalRecipientsType,\n                accumulator\n            );\n\n            // Trigger any remaining accumulated transfers via call to conduit.\n            _triggerIfArmed(accumulator);\n        }\n\n        // Determine whether order is restricted and, if so, that it is valid.\n        _assertRestrictedBasicOrderValidity(orderHash, orderType, parameters);\n\n        // Clear the reentrancy guard.\n        _clearReentrancyGuard();\n\n        return true;\n    }\n\n    /**\n     * @dev Internal function to prepare fulfillment of a basic order with\n     *      manual calldata and memory access. This calculates the order hash,\n     *      emits an OrderFulfilled event, and asserts basic order validity.\n     *      Note that calldata offsets must be validated as this function\n     *      accesses constant calldata pointers for dynamic types that match\n     *      default ABI encoding, but valid ABI encoding can use arbitrary\n     *      offsets. Checking that the offsets were produced by default encoding\n     *      will ensure that other functions using Solidity's calldata accessors\n     *      (which calculate pointers from the stored offsets) are reading the\n     *      same data as the order hash is derived from. Also note that this\n     *      function accesses memory directly.\n     *\n     * @param parameters                   The parameters of the basic order.\n     * @param orderType                    The order type.\n     * @param receivedItemType             The item type of the initial\n     *                                     consideration item on the order.\n     * @param additionalRecipientsItemType The item type of any additional\n     *                                     consideration item on the order.\n     * @param additionalRecipientsToken    The ERC20 token contract address (if\n     *                                     applicable) for any additional\n     *                                     consideration item on the order.\n     * @param offeredItemType              The item type of the offered item on\n     *                                     the order.\n     * @return orderHash The calculated order hash.\n     */\n    function _prepareBasicFulfillmentFromCalldata(\n        BasicOrderParameters calldata parameters,\n        OrderType orderType,\n        ItemType receivedItemType,\n        ItemType additionalRecipientsItemType,\n        address additionalRecipientsToken,\n        ItemType offeredItemType\n    ) internal returns (bytes32 orderHash) {\n        // Ensure this function cannot be triggered during a reentrant call.\n        _setReentrancyGuard(false); // Native tokens rejected during execution.\n\n        // Verify that calldata offsets for all dynamic types were produced by\n        // default encoding. This ensures that the constants used for calldata\n        // pointers to dynamic types are the same as those calculated by\n        // Solidity using their offsets. Also verify that the basic order type\n        // is within range.\n        _assertValidBasicOrderParameters();\n\n        // Check for invalid time and missing original consideration items.\n        // Utilize assembly so that constant calldata pointers can be applied.\n        assembly {\n            // Ensure current timestamp is between order start time & end time.\n            if or(\n                gt(calldataload(BasicOrder_startTime_cdPtr), timestamp()),\n                iszero(gt(calldataload(BasicOrder_endTime_cdPtr), timestamp()))\n            ) {\n                // Store left-padded selector with push4 (reduces bytecode),\n                // mem[28:32] = selector\n                mstore(0, InvalidTime_error_selector)\n\n                // Store arguments.\n                mstore(\n                    InvalidTime_error_startTime_ptr,\n                    calldataload(BasicOrder_startTime_cdPtr)\n                )\n                mstore(\n                    InvalidTime_error_endTime_ptr,\n                    calldataload(BasicOrder_endTime_cdPtr)\n                )\n\n                // revert(abi.encodeWithSignature(\n                //     \"InvalidTime(uint256,uint256)\",\n                //     startTime,\n                //     endTime\n                // ))\n                revert(Error_selector_offset, InvalidTime_error_length)\n            }\n\n            // Ensure consideration array length isn't less than total original.\n            if lt(\n                calldataload(BasicOrder_additionalRecipients_length_cdPtr),\n                calldataload(BasicOrder_totalOriginalAdditionalRecipients_cdPtr)\n            ) {\n                // Store left-padded selector with push4 (reduces bytecode),\n                // mem[28:32] = selector\n                mstore(0, MissingOriginalConsiderationItems_error_selector)\n\n                // revert(abi.encodeWithSignature(\n                //     \"MissingOriginalConsiderationItems()\"\n                // ))\n                revert(\n                    Error_selector_offset,\n                    MissingOriginalConsiderationItems_error_length\n                )\n            }\n        }\n\n        {\n            /**\n             * First, handle consideration items. Memory Layout:\n             *  0x60: final hash of the array of consideration item hashes\n             *  0x80-0x160: reused space for EIP712 hashing of each item\n             *   - 0x80: ConsiderationItem EIP-712 typehash (constant)\n             *   - 0xa0: itemType\n             *   - 0xc0: token\n             *   - 0xe0: identifier\n             *   - 0x100: startAmount\n             *   - 0x120: endAmount\n             *   - 0x140: recipient\n             *  0x160-END_ARR: array of consideration item hashes\n             *   - 0x160: primary consideration item EIP712 hash\n             *   - 0x180-END_ARR: additional recipient item EIP712 hashes\n             *  END_ARR: beginning of data for OrderFulfilled event\n             *   - END_ARR + 0x120: length of ReceivedItem array\n             *   - END_ARR + 0x140: beginning of data for first ReceivedItem\n             * (Note: END_ARR = 0x180 + RECIPIENTS_LENGTH * 0x20)\n             */\n\n            // Load consideration item typehash from runtime and place on stack.\n            bytes32 typeHash = _CONSIDERATION_ITEM_TYPEHASH;\n\n            // Utilize assembly to enable reuse of memory regions and use\n            // constant pointers when possible.\n            assembly {\n                /*\n                 * 1. Calculate the EIP712 ConsiderationItem hash for the\n                 * primary consideration item of the basic order.\n                 */\n\n                // Write ConsiderationItem type hash and item type to memory.\n                mstore(BasicOrder_considerationItem_typeHash_ptr, typeHash)\n                mstore(\n                    BasicOrder_considerationItem_itemType_ptr,\n                    receivedItemType\n                )\n\n                // Copy calldata region with (token, identifier, amount) from\n                // BasicOrderParameters to ConsiderationItem. The\n                // considerationAmount is written to startAmount and endAmount\n                // as basic orders do not have dynamic amounts.\n                calldatacopy(\n                    BasicOrder_considerationItem_token_ptr,\n                    BasicOrder_considerationToken_cdPtr,\n                    ThreeWords\n                )\n\n                // Copy calldata region with considerationAmount and offerer\n                // from BasicOrderParameters to endAmount and recipient in\n                // ConsiderationItem.\n                calldatacopy(\n                    BasicOrder_considerationItem_endAmount_ptr,\n                    BasicOrder_considerationAmount_cdPtr,\n                    TwoWords\n                )\n\n                // Calculate EIP712 ConsiderationItem hash and store it in the\n                // array of EIP712 consideration hashes.\n                mstore(\n                    BasicOrder_considerationHashesArray_ptr,\n                    keccak256(\n                        BasicOrder_considerationItem_typeHash_ptr,\n                        EIP712_ConsiderationItem_size\n                    )\n                )\n\n                /*\n                 * 2. Write a ReceivedItem struct for the primary consideration\n                 * item to the consideration array in OrderFulfilled.\n                 */\n\n                // Get the length of the additional recipients array.\n                let totalAdditionalRecipients := calldataload(\n                    BasicOrder_additionalRecipients_length_cdPtr\n                )\n\n                // Calculate pointer to length of OrderFulfilled consideration\n                // array.\n                let eventConsiderationArrPtr := add(\n                    OrderFulfilled_consideration_length_baseOffset,\n                    shl(OneWordShift, totalAdditionalRecipients)\n                )\n\n                // Set the length of the consideration array to the number of\n                // additional recipients, plus one for the primary consideration\n                // item.\n                mstore(\n                    eventConsiderationArrPtr,\n                    add(totalAdditionalRecipients, 1)\n                )\n\n                // Overwrite the consideration array pointer so it points to the\n                // body of the first element\n                eventConsiderationArrPtr := add(\n                    eventConsiderationArrPtr,\n                    OneWord\n                )\n\n                // Set itemType at start of the ReceivedItem memory region.\n                mstore(eventConsiderationArrPtr, receivedItemType)\n\n                // Copy calldata region (token, identifier, amount & recipient)\n                // from BasicOrderParameters to ReceivedItem memory.\n                calldatacopy(\n                    add(eventConsiderationArrPtr, Common_token_offset),\n                    BasicOrder_considerationToken_cdPtr,\n                    FourWords\n                )\n\n                /*\n                 * 3. Calculate EIP712 ConsiderationItem hashes for original\n                 * additional recipients and add a ReceivedItem for each to the\n                 * consideration array in the OrderFulfilled event. The original\n                 * additional recipients are all the consideration items signed\n                 * by the offerer aside from the primary consideration items of\n                 * the order. Uses memory region from 0x80-0x160 as a buffer for\n                 * calculating EIP712 ConsiderationItem hashes.\n                 */\n\n                // Put pointer to consideration hashes array on the stack.\n                // This will be updated as each additional recipient is hashed\n                let\n                    considerationHashesPtr\n                := BasicOrder_considerationHashesArray_ptr\n\n                // Write item type, token, & identifier for additional recipient\n                // to memory region for hashing EIP712 ConsiderationItem; these\n                // values will be reused for each recipient.\n                mstore(\n                    BasicOrder_considerationItem_itemType_ptr,\n                    additionalRecipientsItemType\n                )\n                mstore(\n                    BasicOrder_considerationItem_token_ptr,\n                    additionalRecipientsToken\n                )\n                mstore(BasicOrder_considerationItem_identifier_ptr, 0)\n\n                // Declare a stack variable where all additional recipients will\n                // be combined to guard against providing dirty upper bits.\n                let combinedAdditionalRecipients\n\n                // Read length of the additionalRecipients array from calldata\n                // and iterate.\n                totalAdditionalRecipients := calldataload(\n                    BasicOrder_totalOriginalAdditionalRecipients_cdPtr\n                )\n                let i := 0\n                for {} lt(i, totalAdditionalRecipients) {\n                    i := add(i, 1)\n                } {\n                    /*\n                     * Calculate EIP712 ConsiderationItem hash for recipient.\n                     */\n\n                    // Retrieve calldata pointer for additional recipient.\n                    let additionalRecipientCdPtr := add(\n                        BasicOrder_additionalRecipients_data_cdPtr,\n                        mul(AdditionalRecipient_size, i)\n                    )\n\n                    // Copy startAmount from calldata to the ConsiderationItem\n                    // struct.\n                    calldatacopy(\n                        BasicOrder_considerationItem_startAmount_ptr,\n                        additionalRecipientCdPtr,\n                        OneWord\n                    )\n\n                    // Copy endAmount and recipient from calldata to the\n                    // ConsiderationItem struct.\n                    calldatacopy(\n                        BasicOrder_considerationItem_endAmount_ptr,\n                        additionalRecipientCdPtr,\n                        AdditionalRecipient_size\n                    )\n\n                    // Include the recipient as part of combined recipients.\n                    combinedAdditionalRecipients := or(\n                        combinedAdditionalRecipients,\n                        calldataload(add(additionalRecipientCdPtr, OneWord))\n                    )\n\n                    // Add 1 word to the pointer as part of each loop to reduce\n                    // operations needed to get local offset into the array.\n                    considerationHashesPtr := add(\n                        considerationHashesPtr,\n                        OneWord\n                    )\n\n                    // Calculate EIP712 ConsiderationItem hash and store it in\n                    // the array of consideration hashes.\n                    mstore(\n                        considerationHashesPtr,\n                        keccak256(\n                            BasicOrder_considerationItem_typeHash_ptr,\n                            EIP712_ConsiderationItem_size\n                        )\n                    )\n\n                    /*\n                     * Write ReceivedItem to OrderFulfilled data.\n                     */\n\n                    // At this point, eventConsiderationArrPtr points to the\n                    // beginning of the ReceivedItem struct of the previous\n                    // element in the array. Increase it by the size of the\n                    // struct to arrive at the pointer for the current element.\n                    eventConsiderationArrPtr := add(\n                        eventConsiderationArrPtr,\n                        ReceivedItem_size\n                    )\n\n                    // Write itemType to the ReceivedItem struct.\n                    mstore(\n                        eventConsiderationArrPtr,\n                        additionalRecipientsItemType\n                    )\n\n                    // Write token to the next word of the ReceivedItem struct.\n                    mstore(\n                        add(eventConsiderationArrPtr, OneWord),\n                        additionalRecipientsToken\n                    )\n\n                    // Copy endAmount & recipient words to ReceivedItem struct.\n                    calldatacopy(\n                        add(\n                            eventConsiderationArrPtr,\n                            ReceivedItem_amount_offset\n                        ),\n                        additionalRecipientCdPtr,\n                        TwoWords\n                    )\n                }\n\n                /*\n                 * 4. Hash packed array of ConsiderationItem EIP712 hashes:\n                 *   `keccak256(abi.encodePacked(receivedItemHashes))`\n                 * Note that it is set at 0x60 — all other memory begins at\n                 * 0x80. 0x60 is the \"zero slot\" and will be restored at the end\n                 * of the assembly section and before required by the compiler.\n                 */\n                mstore(\n                    receivedItemsHash_ptr,\n                    keccak256(\n                        BasicOrder_considerationHashesArray_ptr,\n                        shl(OneWordShift, add(totalAdditionalRecipients, 1))\n                    )\n                )\n\n                /*\n                 * 5. Add a ReceivedItem for each tip to the consideration array\n                 * in the OrderFulfilled event. The tips are all the\n                 * consideration items that were not signed by the offerer and\n                 * were provided by the fulfiller.\n                 */\n\n                // Overwrite length to length of the additionalRecipients array.\n                totalAdditionalRecipients := calldataload(\n                    BasicOrder_additionalRecipients_length_cdPtr\n                )\n\n                for {} lt(i, totalAdditionalRecipients) {\n                    i := add(i, 1)\n                } {\n                    // Retrieve calldata pointer for additional recipient.\n                    let additionalRecipientCdPtr := add(\n                        BasicOrder_additionalRecipients_data_cdPtr,\n                        mul(AdditionalRecipient_size, i)\n                    )\n\n                    // At this point, eventConsiderationArrPtr points to the\n                    // beginning of the ReceivedItem struct of the previous\n                    // element in the array. Increase it by the size of the\n                    // struct to arrive at the pointer for the current element.\n                    eventConsiderationArrPtr := add(\n                        eventConsiderationArrPtr,\n                        ReceivedItem_size\n                    )\n\n                    // Write itemType to the ReceivedItem struct.\n                    mstore(\n                        eventConsiderationArrPtr,\n                        additionalRecipientsItemType\n                    )\n\n                    // Write token to the next word of the ReceivedItem struct.\n                    mstore(\n                        add(eventConsiderationArrPtr, OneWord),\n                        additionalRecipientsToken\n                    )\n\n                    // Copy endAmount & recipient words to ReceivedItem struct.\n                    calldatacopy(\n                        add(\n                            eventConsiderationArrPtr,\n                            ReceivedItem_amount_offset\n                        ),\n                        additionalRecipientCdPtr,\n                        TwoWords\n                    )\n\n                    // Include the recipient as part of combined recipients.\n                    combinedAdditionalRecipients := or(\n                        combinedAdditionalRecipients,\n                        calldataload(add(additionalRecipientCdPtr, OneWord))\n                    )\n                }\n\n                // Ensure no dirty upper bits on combined additional recipients.\n                if gt(combinedAdditionalRecipients, MaskOverLastTwentyBytes) {\n                    // Store left-padded selector with push4 (reduces bytecode),\n                    // mem[28:32] = selector\n                    mstore(0, InvalidBasicOrderParameterEncoding_error_selector)\n\n                    // revert(abi.encodeWithSignature(\n                    //     \"InvalidBasicOrderParameterEncoding()\"\n                    // ))\n                    revert(\n                        Error_selector_offset,\n                        InvalidBasicOrderParameterEncoding_error_length\n                    )\n                }\n            }\n        }\n\n        {\n            /**\n             * Next, handle offered items. Memory Layout:\n             *  EIP712 data for OfferItem\n             *   - 0x80:  OfferItem EIP-712 typehash (constant)\n             *   - 0xa0:  itemType\n             *   - 0xc0:  token\n             *   - 0xe0:  identifier (reused for offeredItemsHash)\n             *   - 0x100: startAmount\n             *   - 0x120: endAmount\n             */\n\n            // Place offer item typehash on the stack.\n            bytes32 typeHash = _OFFER_ITEM_TYPEHASH;\n\n            // Utilize assembly to enable reuse of memory regions when possible.\n            assembly {\n                /*\n                 * 1. Calculate OfferItem EIP712 hash\n                 */\n\n                // Write the OfferItem typeHash to memory.\n                mstore(BasicOrder_offerItem_typeHash_ptr, typeHash)\n\n                // Write the OfferItem item type to memory.\n                mstore(BasicOrder_offerItem_itemType_ptr, offeredItemType)\n\n                // Copy calldata region with (offerToken, offerIdentifier,\n                // offerAmount) from OrderParameters to (token, identifier,\n                // startAmount) in OfferItem struct. The offerAmount is written\n                // to startAmount and endAmount as basic orders do not have\n                // dynamic amounts.\n                calldatacopy(\n                    BasicOrder_offerItem_token_ptr,\n                    BasicOrder_offerToken_cdPtr,\n                    ThreeWords\n                )\n\n                // Copy offerAmount from calldata to endAmount in OfferItem\n                // struct.\n                calldatacopy(\n                    BasicOrder_offerItem_endAmount_ptr,\n                    BasicOrder_offerAmount_cdPtr,\n                    OneWord\n                )\n\n                // Compute EIP712 OfferItem hash, write result to scratch space:\n                //   `keccak256(abi.encode(offeredItem))`\n                mstore(\n                    0,\n                    keccak256(\n                        BasicOrder_offerItem_typeHash_ptr,\n                        EIP712_OfferItem_size\n                    )\n                )\n\n                /*\n                 * 2. Calculate hash of array of EIP712 hashes and write the\n                 * result to the corresponding OfferItem struct:\n                 *   `keccak256(abi.encodePacked(offerItemHashes))`\n                 */\n                mstore(BasicOrder_order_offerHashes_ptr, keccak256(0, OneWord))\n\n                /*\n                 * 3. Write SpentItem to offer array in OrderFulfilled event.\n                 */\n                let eventConsiderationArrPtr := add(\n                    OrderFulfilled_offer_length_baseOffset,\n                    shl(\n                        OneWordShift,\n                        calldataload(\n                            BasicOrder_additionalRecipients_length_cdPtr\n                        )\n                    )\n                )\n\n                // Set a length of 1 for the offer array.\n                mstore(eventConsiderationArrPtr, 1)\n\n                // Write itemType to the SpentItem struct.\n                mstore(add(eventConsiderationArrPtr, OneWord), offeredItemType)\n\n                // Copy calldata region with (offerToken, offerIdentifier,\n                // offerAmount) from OrderParameters to (token, identifier,\n                // amount) in SpentItem struct.\n                calldatacopy(\n                    add(eventConsiderationArrPtr, AdditionalRecipient_size),\n                    BasicOrder_offerToken_cdPtr,\n                    ThreeWords\n                )\n            }\n        }\n\n        {\n            /**\n             * Once consideration items and offer items have been handled,\n             * derive the final order hash. Memory Layout:\n             *  0x80-0x1c0: EIP712 data for order\n             *   - 0x80:   Order EIP-712 typehash (constant)\n             *   - 0xa0:   orderParameters.offerer\n             *   - 0xc0:   orderParameters.zone\n             *   - 0xe0:   keccak256(abi.encodePacked(offerHashes))\n             *   - 0x100:  keccak256(abi.encodePacked(considerationHashes))\n             *   - 0x120:  orderParameters.basicOrderType (% 4 = orderType)\n             *   - 0x140:  orderParameters.startTime\n             *   - 0x160:  orderParameters.endTime\n             *   - 0x180:  orderParameters.zoneHash\n             *   - 0x1a0:  orderParameters.salt\n             *   - 0x1c0:  orderParameters.conduitKey\n             *   - 0x1e0:  _counters[orderParameters.offerer] (from storage)\n             */\n\n            // Read the offerer from calldata and place on the stack.\n            address offerer;\n            assembly {\n                offerer := calldataload(BasicOrder_offerer_cdPtr)\n            }\n\n            // Read offerer's current counter from storage and place on stack.\n            uint256 counter = _getCounter(offerer);\n\n            // Load order typehash from runtime code and place on stack.\n            bytes32 typeHash = _ORDER_TYPEHASH;\n\n            assembly {\n                // Set the OrderItem typeHash in memory.\n                mstore(BasicOrder_order_typeHash_ptr, typeHash)\n\n                // Copy offerer and zone from OrderParameters in calldata to the\n                // Order struct.\n                calldatacopy(\n                    BasicOrder_order_offerer_ptr,\n                    BasicOrder_offerer_cdPtr,\n                    TwoWords\n                )\n\n                // Copy receivedItemsHash from zero slot to the Order struct.\n                mstore(\n                    BasicOrder_order_considerationHashes_ptr,\n                    mload(receivedItemsHash_ptr)\n                )\n\n                // Write the supplied orderType to the Order struct.\n                mstore(BasicOrder_order_orderType_ptr, orderType)\n\n                // Copy startTime, endTime, zoneHash, salt & conduit from\n                // calldata to the Order struct.\n                calldatacopy(\n                    BasicOrder_order_startTime_ptr,\n                    BasicOrder_startTime_cdPtr,\n                    FiveWords\n                )\n\n                // Write offerer's counter, retrieved from storage, to struct.\n                mstore(BasicOrder_order_counter_ptr, counter)\n\n                // Compute the EIP712 Order hash.\n                orderHash := keccak256(\n                    BasicOrder_order_typeHash_ptr,\n                    EIP712_Order_size\n                )\n            }\n        }\n\n        assembly {\n            /**\n             * After the order hash has been derived, emit OrderFulfilled event:\n             *   event OrderFulfilled(\n             *     bytes32 orderHash,\n             *     address indexed offerer,\n             *     address indexed zone,\n             *     address fulfiller,\n             *     SpentItem[] offer,\n             *       > (itemType, token, id, amount)\n             *     ReceivedItem[] consideration\n             *       > (itemType, token, id, amount, recipient)\n             *   )\n             * topic0 - OrderFulfilled event signature\n             * topic1 - offerer\n             * topic2 - zone\n             * data:\n             *  - 0x00: orderHash\n             *  - 0x20: fulfiller\n             *  - 0x40: offer arr ptr (0x80)\n             *  - 0x60: consideration arr ptr (0x120)\n             *  - 0x80: offer arr len (1)\n             *  - 0xa0: offer.itemType\n             *  - 0xc0: offer.token\n             *  - 0xe0: offer.identifier\n             *  - 0x100: offer.amount\n             *  - 0x120: 1 + recipients.length\n             *  - 0x140: recipient 0\n             */\n\n            // Derive pointer to start of OrderFulfilled event data.\n            let eventDataPtr := add(\n                OrderFulfilled_baseOffset,\n                shl(\n                    OneWordShift,\n                    calldataload(BasicOrder_additionalRecipients_length_cdPtr)\n                )\n            )\n\n            // Write the order hash to the head of the event's data region.\n            mstore(eventDataPtr, orderHash)\n\n            // Write the fulfiller (i.e. the caller) next for receiver argument.\n            mstore(add(eventDataPtr, OrderFulfilled_fulfiller_offset), caller())\n\n            // Write the SpentItem and ReceivedItem array offsets (constants).\n            mstore(\n                // SpentItem array offset\n                add(eventDataPtr, OrderFulfilled_offer_head_offset),\n                OrderFulfilled_offer_body_offset\n            )\n            mstore(\n                // ReceivedItem array offset\n                add(eventDataPtr, OrderFulfilled_consideration_head_offset),\n                OrderFulfilled_consideration_body_offset\n            )\n\n            // Derive total data size including SpentItem and ReceivedItem data.\n            // SpentItem portion is already included in the baseSize constant,\n            // as there can only be one element in the array.\n            let dataSize := add(\n                OrderFulfilled_baseSize,\n                mul(\n                    calldataload(BasicOrder_additionalRecipients_length_cdPtr),\n                    ReceivedItem_size\n                )\n            )\n\n            // Emit OrderFulfilled log with three topics (the event signature\n            // as well as the two indexed arguments, the offerer and the zone).\n            log3(\n                // Supply the pointer for event data in memory.\n                eventDataPtr,\n                // Supply the size of event data in memory.\n                dataSize,\n                // Supply the OrderFulfilled event signature.\n                OrderFulfilled_selector,\n                // Supply the first topic (the offerer).\n                calldataload(BasicOrder_offerer_cdPtr),\n                // Supply the second topic (the zone).\n                calldataload(BasicOrder_zone_cdPtr)\n            )\n\n            // Restore the zero slot.\n            mstore(ZeroSlot, 0)\n\n            // Update the free memory pointer so that event data is persisted.\n            mstore(FreeMemoryPointerSlot, add(eventDataPtr, dataSize))\n        }\n\n        // Verify and update the status of the derived order.\n        _validateBasicOrderAndUpdateStatus(orderHash, parameters.signature);\n\n        // Return the derived order hash.\n        return orderHash;\n    }\n\n    /**\n     * @dev Internal function to transfer an individual ERC721 or ERC1155 item\n     *      from a given originator to a given recipient. The accumulator will\n     *      be bypassed, meaning that this function should be utilized in cases\n     *      where multiple item transfers can be accumulated into a single\n     *      conduit call. Sufficient approvals must be set, either on the\n     *      respective conduit or on this contract. Note that this function may\n     *      only be safely called as part of basic orders, as it assumes a\n     *      specific calldata encoding structure that must first be validated.\n     *\n     * @param itemType   The type of item to transfer, either ERC721 or ERC1155.\n     * @param conduitKey A bytes32 value indicating what corresponding conduit,\n     *                   if any, to source token approvals from. The zero hash\n     *                   signifies that no conduit should be used, with direct\n     *                   approvals set on this contract.\n     */\n    function _transferIndividual721Or1155Item(\n        ItemType itemType,\n        bytes32 conduitKey\n    ) internal {\n        // Retrieve token, from, identifier, and amount from calldata using\n        // fixed calldata offsets based on strict basic parameter encoding.\n        address token;\n        address from;\n        uint256 identifier;\n        uint256 amount;\n        assembly {\n            token := calldataload(BasicOrder_offerToken_cdPtr)\n            from := calldataload(BasicOrder_offerer_cdPtr)\n            identifier := calldataload(BasicOrder_offerIdentifier_cdPtr)\n            amount := calldataload(BasicOrder_offerAmount_cdPtr)\n        }\n\n        // Determine if the transfer is to be performed via a conduit.\n        if (conduitKey != bytes32(0)) {\n            // Use free memory pointer as calldata offset for the conduit call.\n            uint256 callDataOffset;\n\n            // Utilize assembly to place each argument in free memory.\n            assembly {\n                // Retrieve the free memory pointer and use it as the offset.\n                callDataOffset := mload(FreeMemoryPointerSlot)\n\n                // Write ConduitInterface.execute.selector to memory.\n                mstore(callDataOffset, Conduit_execute_signature)\n\n                // Write the offset to the ConduitTransfer array in memory.\n                mstore(\n                    add(\n                        callDataOffset,\n                        Conduit_execute_ConduitTransfer_offset_ptr\n                    ),\n                    Conduit_execute_ConduitTransfer_ptr\n                )\n\n                // Write the length of the ConduitTransfer array to memory.\n                mstore(\n                    add(\n                        callDataOffset,\n                        Conduit_execute_ConduitTransfer_length_ptr\n                    ),\n                    Conduit_execute_ConduitTransfer_length\n                )\n\n                // Write the item type to memory.\n                mstore(\n                    add(callDataOffset, Conduit_execute_transferItemType_ptr),\n                    itemType\n                )\n\n                // Write the token to memory.\n                mstore(\n                    add(callDataOffset, Conduit_execute_transferToken_ptr),\n                    token\n                )\n\n                // Write the transfer source to memory.\n                mstore(\n                    add(callDataOffset, Conduit_execute_transferFrom_ptr),\n                    from\n                )\n\n                // Write the transfer recipient (the caller) to memory.\n                mstore(\n                    add(callDataOffset, Conduit_execute_transferTo_ptr),\n                    caller()\n                )\n\n                // Write the token identifier to memory.\n                mstore(\n                    add(callDataOffset, Conduit_execute_transferIdentifier_ptr),\n                    identifier\n                )\n\n                // Write the transfer amount to memory.\n                mstore(\n                    add(callDataOffset, Conduit_execute_transferAmount_ptr),\n                    amount\n                )\n            }\n\n            // Perform the call to the conduit.\n            _callConduitUsingOffsets(\n                conduitKey,\n                callDataOffset,\n                OneConduitExecute_size\n            );\n        } else {\n            // Otherwise, determine whether it is an ERC721 or ERC1155 item.\n            if (itemType == ItemType.ERC721) {\n                // Ensure that exactly one 721 item is being transferred.\n                if (amount != 1) {\n                    _revertInvalidERC721TransferAmount(amount);\n                }\n\n                // Perform transfer to caller via the token contract directly.\n                _performERC721Transfer(token, from, msg.sender, identifier);\n            } else {\n                // Perform transfer to caller via the token contract directly.\n                _performERC1155Transfer(\n                    token,\n                    from,\n                    msg.sender,\n                    identifier,\n                    amount\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer Ether (or other native tokens) to a\n     *      given recipient as part of basic order fulfillment. Note that\n     *      conduits are not utilized for native tokens as the transferred\n     *      amount must be provided as msg.value. Also note that this function\n     *      may only be safely called as part of basic orders, as it assumes a\n     *      specific calldata encoding structure that must first be validated.\n     */\n    function _transferNativeTokensAndFinalize() internal {\n        // Put native token value supplied by the caller on the stack.\n        uint256 nativeTokensRemaining = msg.value;\n\n        // Retrieve consideration amount, offerer, and total size of additional\n        // recipients data from calldata using fixed offsets and place on stack.\n        uint256 amount;\n        address payable to;\n        uint256 totalAdditionalRecipientsDataSize;\n        assembly {\n            amount := calldataload(BasicOrder_considerationAmount_cdPtr)\n            to := calldataload(BasicOrder_offerer_cdPtr)\n            totalAdditionalRecipientsDataSize := shl(\n                AdditionalRecipient_size_shift,\n                calldataload(BasicOrder_additionalRecipients_length_cdPtr)\n            )\n        }\n\n        uint256 additionalRecipientAmount;\n        address payable recipient;\n\n        // Skip overflow check as for loop is indexed starting at zero.\n        unchecked {\n            // Iterate over additional recipient data by two-word element.\n            for (\n                uint256 i = 0;\n                i < totalAdditionalRecipientsDataSize;\n                i += AdditionalRecipient_size\n            ) {\n                assembly {\n                    // Retrieve calldata pointer for additional recipient.\n                    let additionalRecipientCdPtr := add(\n                        BasicOrder_additionalRecipients_data_cdPtr,\n                        i\n                    )\n\n                    additionalRecipientAmount := calldataload(\n                        additionalRecipientCdPtr\n                    )\n                    recipient := calldataload(\n                        add(OneWord, additionalRecipientCdPtr)\n                    )\n                }\n\n                // Ensure that sufficient native tokens are available.\n                if (additionalRecipientAmount > nativeTokensRemaining) {\n                    _revertInsufficientNativeTokensSupplied();\n                }\n\n                // Reduce native token value available. Skip underflow check as\n                // subtracted value is confirmed above as less than remaining.\n                nativeTokensRemaining -= additionalRecipientAmount;\n\n                // Transfer native tokens to the additional recipient.\n                _transferNativeTokens(recipient, additionalRecipientAmount);\n            }\n        }\n\n        // Ensure that sufficient native tokens are still available.\n        if (amount > nativeTokensRemaining) {\n            _revertInsufficientNativeTokensSupplied();\n        }\n\n        // Transfer native tokens to the offerer.\n        _transferNativeTokens(to, amount);\n\n        // If any native tokens remain after transfers, return to the caller.\n        if (nativeTokensRemaining > amount) {\n            // Skip underflow check as nativeTokensRemaining > amount.\n            unchecked {\n                // Transfer remaining native tokens to the caller.\n                _transferNativeTokens(\n                    payable(msg.sender),\n                    nativeTokensRemaining - amount\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer ERC20 tokens to a given recipient as\n     *      part of basic order fulfillment. Note that this function may only be\n     *      safely called as part of basic orders, as it assumes a specific\n     *      calldata encoding structure that must first be validated. Also note\n     *      that basic order parameters are retrieved using fixed offsets, this\n     *      requires that strict basic order encoding has already been verified.\n     *\n     * @param fromOfferer A boolean indicating whether to decrement amount from\n     *                    the offered amount.\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     */\n    function _transferERC20AndFinalize(\n        bool fromOfferer,\n        bytes memory accumulator\n    ) internal {\n        // Declare from and to variables determined by fromOfferer value.\n        address from;\n        address to;\n\n        // Declare token and amount variables determined by fromOfferer value.\n        address token;\n        uint256 amount;\n\n        // Declare and check identifier variable within an isolated scope.\n        {\n            // Declare identifier variable determined by fromOfferer value.\n            uint256 identifier;\n\n            // Set ERC20 token transfer variables based on fromOfferer boolean.\n            if (fromOfferer) {\n                // Use offerer as from value, msg.sender as to value, and offer\n                // token, identifier, & amount values if token is from offerer.\n                assembly {\n                    from := calldataload(BasicOrder_offerer_cdPtr)\n                    to := caller()\n                    token := calldataload(BasicOrder_offerToken_cdPtr)\n                    identifier := calldataload(BasicOrder_offerIdentifier_cdPtr)\n                    amount := calldataload(BasicOrder_offerAmount_cdPtr)\n                }\n            } else {\n                // Otherwise, use msg.sender as from value, offerer as to value,\n                // and consideration token, identifier, and amount values.\n                assembly {\n                    from := caller()\n                    to := calldataload(BasicOrder_offerer_cdPtr)\n                    token := calldataload(BasicOrder_considerationToken_cdPtr)\n                    identifier := calldataload(\n                        BasicOrder_considerationIdentifier_cdPtr\n                    )\n                    amount := calldataload(BasicOrder_considerationAmount_cdPtr)\n                }\n            }\n\n            // Ensure that no identifier is supplied.\n            if (identifier != 0) {\n                _revertUnusedItemParameters();\n            }\n        }\n\n        // Determine the appropriate conduit to utilize.\n        bytes32 conduitKey;\n\n        // Utilize assembly to derive conduit (if relevant) based on route.\n        assembly {\n            // Use offerer conduit if fromOfferer, fulfiller conduit otherwise.\n            conduitKey := calldataload(\n                sub(\n                    BasicOrder_fulfillerConduit_cdPtr,\n                    shl(OneWordShift, fromOfferer)\n                )\n            )\n        }\n\n        // Retrieve total size of additional recipients data and place on stack.\n        uint256 totalAdditionalRecipientsDataSize;\n        assembly {\n            totalAdditionalRecipientsDataSize := shl(\n                AdditionalRecipient_size_shift,\n                calldataload(BasicOrder_additionalRecipients_length_cdPtr)\n            )\n        }\n\n        uint256 additionalRecipientAmount;\n        address recipient;\n\n        // Iterate over each additional recipient.\n        for (uint256 i = 0; i < totalAdditionalRecipientsDataSize; ) {\n            assembly {\n                // Retrieve calldata pointer for additional recipient.\n                let additionalRecipientCdPtr := add(\n                    BasicOrder_additionalRecipients_data_cdPtr,\n                    i\n                )\n\n                additionalRecipientAmount := calldataload(\n                    additionalRecipientCdPtr\n                )\n                recipient := calldataload(\n                    add(OneWord, additionalRecipientCdPtr)\n                )\n            }\n\n            // Decrement the amount to transfer to fulfiller if indicated.\n            if (fromOfferer) {\n                amount -= additionalRecipientAmount;\n            }\n\n            // Transfer ERC20 tokens to additional recipient given approval.\n            _transferERC20(\n                token,\n                from,\n                recipient,\n                additionalRecipientAmount,\n                conduitKey,\n                accumulator\n            );\n\n            // Skip overflow check as for loop is indexed starting at zero.\n            unchecked {\n                i += AdditionalRecipient_size;\n            }\n        }\n\n        // Transfer ERC20 token amount (from account must have proper approval).\n        _transferERC20(token, from, to, amount, conduitKey, accumulator);\n    }\n}\n"},"contracts/lib/ConsiderationEncoder.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {\n    BasicOrder_additionalRecipients_length_cdPtr,\n    BasicOrder_common_params_size,\n    BasicOrder_startTime_cdPtr,\n    BasicOrder_startTimeThroughZoneHash_size,\n    Common_amount_offset,\n    Common_identifier_offset,\n    Common_token_offset,\n    generateOrder_base_tail_offset,\n    generateOrder_context_head_offset,\n    generateOrder_head_offset,\n    generateOrder_maximumSpent_head_offset,\n    generateOrder_minimumReceived_head_offset,\n    generateOrder_selector_offset,\n    generateOrder_selector,\n    OneWord,\n    OneWordShift,\n    OnlyFullWordMask,\n    OrderFulfilled_baseDataSize,\n    OrderFulfilled_offer_length_baseOffset,\n    OrderParameters_consideration_head_offset,\n    OrderParameters_endTime_offset,\n    OrderParameters_offer_head_offset,\n    OrderParameters_startTime_offset,\n    OrderParameters_zoneHash_offset,\n    ratifyOrder_base_tail_offset,\n    ratifyOrder_consideration_head_offset,\n    ratifyOrder_context_head_offset,\n    ratifyOrder_contractNonce_offset,\n    ratifyOrder_head_offset,\n    ratifyOrder_orderHashes_head_offset,\n    ratifyOrder_selector_offset,\n    ratifyOrder_selector,\n    ReceivedItem_size,\n    Selector_length,\n    SixtyThreeBytes,\n    SpentItem_size_shift,\n    SpentItem_size,\n    validateOrder_head_offset,\n    validateOrder_selector_offset,\n    validateOrder_selector,\n    validateOrder_zoneParameters_offset,\n    ZoneParameters_base_tail_offset,\n    ZoneParameters_basicOrderFixedElements_length,\n    ZoneParameters_consideration_head_offset,\n    ZoneParameters_endTime_offset,\n    ZoneParameters_extraData_head_offset,\n    ZoneParameters_fulfiller_offset,\n    ZoneParameters_offer_head_offset,\n    ZoneParameters_offerer_offset,\n    ZoneParameters_orderHashes_head_offset,\n    ZoneParameters_selectorAndPointer_length,\n    ZoneParameters_startTime_offset,\n    ZoneParameters_zoneHash_offset\n} from \"./ConsiderationConstants.sol\";\n\nimport {\n    BasicOrderParameters,\n    OrderParameters\n} from \"./ConsiderationStructs.sol\";\n\nimport {\n    CalldataPointer,\n    getFreeMemoryPointer,\n    MemoryPointer\n} from \"../helpers/PointerLibraries.sol\";\n\ncontract ConsiderationEncoder {\n    /**\n     * @dev Takes a bytes array and casts it to a memory pointer.\n     *\n     * @param obj A bytes array in memory.\n     *\n     * @return ptr A memory pointer to the start of the bytes array in memory.\n     */\n    function toMemoryPointer(\n        bytes memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Takes an array of bytes32 types and casts it to a memory pointer.\n     *\n     * @param obj An array of bytes32 types in memory.\n     *\n     * @return ptr A memory pointer to the start of the array of bytes32 types\n     *             in memory.\n     */\n    function toMemoryPointer(\n        bytes32[] memory obj\n    ) internal pure returns (MemoryPointer ptr) {\n        assembly {\n            ptr := obj\n        }\n    }\n\n    /**\n     * @dev Takes a bytes array in memory and copies it to a new location in\n     *      memory.\n     *\n     * @param src A memory pointer referencing the bytes array to be copied (and\n     *            pointing to the length of the bytes array).\n     * @param src A memory pointer referencing the location in memory to copy\n     *            the bytes array to (and pointing to the length of the copied\n     *            bytes array).\n     *\n     * @return size The size of the bytes array.\n     */\n    function _encodeBytes(\n        MemoryPointer src,\n        MemoryPointer dst\n    ) internal view returns (uint256 size) {\n        unchecked {\n            // Mask the length of the bytes array to protect against overflow\n            // and round up to the nearest word.\n            // Note: `size` also includes the 1 word that stores the length.\n            size = (src.readUint256() + SixtyThreeBytes) & OnlyFullWordMask;\n\n            // Copy the bytes array to the new memory location.\n            src.copy(dst, size);\n        }\n    }\n\n    /**\n     * @dev Takes an OrderParameters struct and a context bytes array in memory\n     *      and encodes it as `generateOrder` calldata.\n     *\n     * @param orderParameters The OrderParameters struct used to construct the\n     *                        encoded `generateOrder` calldata.\n     * @param context         The context bytes array used to construct the\n     *                        encoded `generateOrder` calldata.\n     *\n     * @return dst  A memory pointer referencing the encoded `generateOrder`\n     *              calldata.\n     * @return size The size of the bytes array.\n     */\n    function _encodeGenerateOrder(\n        OrderParameters memory orderParameters,\n        bytes memory context\n    ) internal view returns (MemoryPointer dst, uint256 size) {\n        // Get the memory pointer for the OrderParameters struct.\n        MemoryPointer src = orderParameters.toMemoryPointer();\n\n        // Get free memory pointer to write calldata to.\n        dst = getFreeMemoryPointer();\n\n        // Write generateOrder selector and get pointer to start of calldata.\n        dst.write(generateOrder_selector);\n        dst = dst.offset(generateOrder_selector_offset);\n\n        // Get pointer to the beginning of the encoded data.\n        MemoryPointer dstHead = dst.offset(generateOrder_head_offset);\n\n        // Write `fulfiller` to calldata.\n        dstHead.write(msg.sender);\n\n        // Initialize tail offset, used to populate the minimumReceived array.\n        uint256 tailOffset = generateOrder_base_tail_offset;\n\n        // Write offset to minimumReceived.\n        dstHead.offset(generateOrder_minimumReceived_head_offset).write(\n            tailOffset\n        );\n\n        // Get memory pointer to `orderParameters.offer.length`.\n        MemoryPointer srcOfferPointer = src\n            .offset(OrderParameters_offer_head_offset)\n            .readMemoryPointer();\n\n        // Encode the offer array as a `SpentItem[]`.\n        uint256 minimumReceivedSize = _encodeSpentItems(\n            srcOfferPointer,\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate maximumSpent array.\n            tailOffset += minimumReceivedSize;\n        }\n\n        // Write offset to maximumSpent.\n        dstHead.offset(generateOrder_maximumSpent_head_offset).write(\n            tailOffset\n        );\n\n        // Get memory pointer to `orderParameters.consideration.length`.\n        MemoryPointer srcConsiderationPointer = src\n            .offset(OrderParameters_consideration_head_offset)\n            .readMemoryPointer();\n\n        // Encode the consideration array as a `SpentItem[]`.\n        uint256 maximumSpentSize = _encodeSpentItems(\n            srcConsiderationPointer,\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate context array.\n            tailOffset += maximumSpentSize;\n        }\n\n        // Write offset to context.\n        dstHead.offset(generateOrder_context_head_offset).write(tailOffset);\n\n        // Get memory pointer to context.\n        MemoryPointer srcContext = toMemoryPointer(context);\n\n        // Encode context as a bytes array.\n        uint256 contextSize = _encodeBytes(\n            srcContext,\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment the tail offset, now used to determine final size.\n            tailOffset += contextSize;\n\n            // Derive the final size by including the selector.\n            size = Selector_length + tailOffset;\n        }\n    }\n\n    /**\n     * @dev Takes an order hash (e.g. offerer shifted 96 bits to the left XOR'd\n     *      with the contract nonce in the case of contract orders), an\n     *      OrderParameters struct, context bytes array, and an array of order\n     *      hashes for each order included as part of the current fulfillment\n     *      and encodes it as `ratifyOrder` calldata.\n     *\n     * @param orderHash       The order hash (e.g. shl(0x60, offerer) ^ nonce).\n     * @param orderParameters The OrderParameters struct used to construct the\n     *                        encoded `ratifyOrder` calldata.\n     * @param context         The context bytes array used to construct the\n     *                        encoded `ratifyOrder` calldata.\n     * @param orderHashes     An array of bytes32 values representing the order\n     *                        hashes of all orders included as part of the\n     *                        current fulfillment.\n     * @param shiftedOfferer  The offerer for the order, shifted 96 bits to the\n     *                        left.\n     *\n     * @return dst  A memory pointer referencing the encoded `ratifyOrder`\n     *              calldata.\n     * @return size The size of the bytes array.\n     */\n    function _encodeRatifyOrder(\n        bytes32 orderHash, // e.g. shl(0x60, offerer) ^ contract nonce\n        OrderParameters memory orderParameters,\n        bytes memory context, // encoded based on the schemaID\n        bytes32[] memory orderHashes,\n        uint256 shiftedOfferer\n    ) internal view returns (MemoryPointer dst, uint256 size) {\n        // Get free memory pointer to write calldata to. This isn't allocated as\n        // it is only used for a single function call.\n        dst = getFreeMemoryPointer();\n\n        // Write ratifyOrder selector and get pointer to start of calldata.\n        dst.write(ratifyOrder_selector);\n        dst = dst.offset(ratifyOrder_selector_offset);\n\n        // Get pointer to the beginning of the encoded data.\n        MemoryPointer dstHead = dst.offset(ratifyOrder_head_offset);\n\n        // Write contractNonce to calldata via xor(orderHash, shiftedOfferer).\n        dstHead.offset(ratifyOrder_contractNonce_offset).write(\n            uint256(orderHash) ^ shiftedOfferer\n        );\n\n        // Initialize tail offset, used to populate the offer array.\n        uint256 tailOffset = ratifyOrder_base_tail_offset;\n        MemoryPointer src = orderParameters.toMemoryPointer();\n\n        // Write offset to `offer`.\n        dstHead.write(tailOffset);\n\n        // Get memory pointer to `orderParameters.offer.length`.\n        MemoryPointer srcOfferPointer = src\n            .offset(OrderParameters_offer_head_offset)\n            .readMemoryPointer();\n\n        // Encode the offer array as a `SpentItem[]`.\n        uint256 offerSize = _encodeSpentItems(\n            srcOfferPointer,\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate consideration array.\n            tailOffset += offerSize;\n        }\n\n        // Write offset to consideration.\n        dstHead.offset(ratifyOrder_consideration_head_offset).write(tailOffset);\n\n        // Get pointer to `orderParameters.consideration.length`.\n        MemoryPointer srcConsiderationPointer = src\n            .offset(OrderParameters_consideration_head_offset)\n            .readMemoryPointer();\n\n        // Encode the consideration array as a `ReceivedItem[]`.\n        uint256 considerationSize = _encodeConsiderationAsReceivedItems(\n            srcConsiderationPointer,\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate context array.\n            tailOffset += considerationSize;\n        }\n\n        // Write offset to context.\n        dstHead.offset(ratifyOrder_context_head_offset).write(tailOffset);\n\n        // Encode context.\n        uint256 contextSize = _encodeBytes(\n            toMemoryPointer(context),\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate orderHashes array.\n            tailOffset += contextSize;\n        }\n\n        // Write offset to orderHashes.\n        dstHead.offset(ratifyOrder_orderHashes_head_offset).write(tailOffset);\n\n        // Encode orderHashes.\n        uint256 orderHashesSize = _encodeOrderHashes(\n            toMemoryPointer(orderHashes),\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment the tail offset, now used to determine final size.\n            tailOffset += orderHashesSize;\n\n            // Derive the final size by including the selector.\n            size = Selector_length + tailOffset;\n        }\n    }\n\n    /**\n     * @dev Takes an order hash, OrderParameters struct, extraData bytes array,\n     *      and array of order hashes for each order included as part of the\n     *      current fulfillment and encodes it as `validateOrder` calldata.\n     *      Note that future, new versions of this contract may end up writing\n     *      to a memory region that might have been potentially dirtied by the\n     *      accumulator. Since the book-keeping for the accumulator does not\n     *      update the free memory pointer, it will be necessary to ensure that\n     *      all bytes in the memory in the range [dst, dst+size) are fully\n     *      updated/written to in this function.\n     *\n     * @param orderHash       The order hash.\n     * @param orderParameters The OrderParameters struct used to construct the\n     *                        encoded `validateOrder` calldata.\n     * @param extraData       The extraData bytes array used to construct the\n     *                        encoded `validateOrder` calldata.\n     * @param orderHashes     An array of bytes32 values representing the order\n     *                        hashes of all orders included as part of the\n     *                        current fulfillment.\n     *\n     * @return dst  A memory pointer referencing the encoded `validateOrder`\n     *              calldata.\n     * @return size The size of the bytes array.\n     */\n    function _encodeValidateOrder(\n        bytes32 orderHash,\n        OrderParameters memory orderParameters,\n        bytes memory extraData,\n        bytes32[] memory orderHashes\n    ) internal view returns (MemoryPointer dst, uint256 size) {\n        // Get free memory pointer to write calldata to. This isn't allocated as\n        // it is only used for a single function call.\n        dst = getFreeMemoryPointer();\n\n        // Write validateOrder selector and get pointer to start of calldata.\n        dst.write(validateOrder_selector);\n        dst = dst.offset(validateOrder_selector_offset);\n\n        // Get pointer to the beginning of the encoded data.\n        MemoryPointer dstHead = dst.offset(validateOrder_head_offset);\n\n        // Write offset to zoneParameters to start of calldata.\n        dstHead.write(validateOrder_zoneParameters_offset);\n\n        // Reuse `dstHead` as pointer to zoneParameters.\n        dstHead = dstHead.offset(validateOrder_zoneParameters_offset);\n\n        // Write orderHash and fulfiller to zoneParameters.\n        dstHead.writeBytes32(orderHash);\n        dstHead.offset(ZoneParameters_fulfiller_offset).write(msg.sender);\n\n        // Get the memory pointer to the order parameters struct.\n        MemoryPointer src = orderParameters.toMemoryPointer();\n\n        // Copy offerer, startTime, endTime and zoneHash to zoneParameters.\n        dstHead.offset(ZoneParameters_offerer_offset).write(src.readUint256());\n        dstHead.offset(ZoneParameters_startTime_offset).write(\n            src.offset(OrderParameters_startTime_offset).readUint256()\n        );\n        dstHead.offset(ZoneParameters_endTime_offset).write(\n            src.offset(OrderParameters_endTime_offset).readUint256()\n        );\n        dstHead.offset(ZoneParameters_zoneHash_offset).write(\n            src.offset(OrderParameters_zoneHash_offset).readUint256()\n        );\n\n        // Initialize tail offset, used to populate the offer array.\n        uint256 tailOffset = ZoneParameters_base_tail_offset;\n\n        // Write offset to `offer`.\n        dstHead.offset(ZoneParameters_offer_head_offset).write(tailOffset);\n\n        // Get pointer to `orderParameters.offer.length`.\n        MemoryPointer srcOfferPointer = src\n            .offset(OrderParameters_offer_head_offset)\n            .readMemoryPointer();\n\n        // Encode the offer array as a `SpentItem[]`.\n        uint256 offerSize = _encodeSpentItems(\n            srcOfferPointer,\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate consideration array.\n            tailOffset += offerSize;\n        }\n\n        // Write offset to consideration.\n        dstHead.offset(ZoneParameters_consideration_head_offset).write(\n            tailOffset\n        );\n\n        // Get pointer to `orderParameters.consideration.length`.\n        MemoryPointer srcConsiderationPointer = src\n            .offset(OrderParameters_consideration_head_offset)\n            .readMemoryPointer();\n\n        // Encode the consideration array as a `ReceivedItem[]`.\n        uint256 considerationSize = _encodeConsiderationAsReceivedItems(\n            srcConsiderationPointer,\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate extraData array.\n            tailOffset += considerationSize;\n        }\n\n        // Write offset to extraData.\n        dstHead.offset(ZoneParameters_extraData_head_offset).write(tailOffset);\n        // Copy extraData.\n        uint256 extraDataSize = _encodeBytes(\n            toMemoryPointer(extraData),\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment tail offset, now used to populate orderHashes array.\n            tailOffset += extraDataSize;\n        }\n\n        // Write offset to orderHashes.\n        dstHead.offset(ZoneParameters_orderHashes_head_offset).write(\n            tailOffset\n        );\n\n        // Encode the order hashes array.\n        uint256 orderHashesSize = _encodeOrderHashes(\n            toMemoryPointer(orderHashes),\n            dstHead.offset(tailOffset)\n        );\n\n        unchecked {\n            // Increment the tail offset, now used to determine final size.\n            tailOffset += orderHashesSize;\n\n            // Derive final size including selector and ZoneParameters pointer.\n            size = ZoneParameters_selectorAndPointer_length + tailOffset;\n        }\n    }\n\n    /**\n     * @dev Takes an order hash and BasicOrderParameters struct (from calldata)\n     *      and encodes it as `validateOrder` calldata.\n     *\n     * @param orderHash  The order hash.\n     * @param parameters The BasicOrderParameters struct used to construct the\n     *                   encoded `validateOrder` calldata.\n     *\n     * @return dst  A memory pointer referencing the encoded `validateOrder`\n     *              calldata.\n     * @return size The size of the bytes array.\n     */\n    function _encodeValidateBasicOrder(\n        bytes32 orderHash,\n        BasicOrderParameters calldata parameters\n    ) internal view returns (MemoryPointer dst, uint256 size) {\n        // Get free memory pointer to write calldata to. This isn't allocated as\n        // it is only used for a single function call.\n        dst = getFreeMemoryPointer();\n\n        // Write validateOrder selector and get pointer to start of calldata.\n        dst.write(validateOrder_selector);\n        dst = dst.offset(validateOrder_selector_offset);\n\n        // Get pointer to the beginning of the encoded data.\n        MemoryPointer dstHead = dst.offset(validateOrder_head_offset);\n\n        // Write offset to zoneParameters to start of calldata.\n        dstHead.write(validateOrder_zoneParameters_offset);\n\n        // Reuse `dstHead` as pointer to zoneParameters.\n        dstHead = dstHead.offset(validateOrder_zoneParameters_offset);\n\n        // Write offerer, orderHash and fulfiller to zoneParameters.\n        dstHead.writeBytes32(orderHash);\n        dstHead.offset(ZoneParameters_fulfiller_offset).write(msg.sender);\n        dstHead.offset(ZoneParameters_offerer_offset).write(parameters.offerer);\n\n        // Copy startTime, endTime and zoneHash to zoneParameters.\n        CalldataPointer.wrap(BasicOrder_startTime_cdPtr).copy(\n            dstHead.offset(ZoneParameters_startTime_offset),\n            BasicOrder_startTimeThroughZoneHash_size\n        );\n\n        // Initialize tail offset, used for the offer + consideration arrays.\n        uint256 tailOffset = ZoneParameters_base_tail_offset;\n\n        // Write offset to offer from event data into target calldata.\n        dstHead.offset(ZoneParameters_offer_head_offset).write(tailOffset);\n\n        unchecked {\n            // Write consideration offset next (located 5 words after offer).\n            dstHead.offset(ZoneParameters_consideration_head_offset).write(\n                tailOffset + BasicOrder_common_params_size\n            );\n\n            // Retrieve the offset to the length of additional recipients.\n            uint256 additionalRecipientsLength = CalldataPointer\n                .wrap(BasicOrder_additionalRecipients_length_cdPtr)\n                .readUint256();\n\n            // Derive offset to event data using base offset & total recipients.\n            uint256 offerDataOffset = OrderFulfilled_offer_length_baseOffset +\n                additionalRecipientsLength *\n                OneWord;\n\n            // Derive size of offer and consideration data.\n            // 2 words (lengths) + 4 (offer data) + 5 (consideration 1) + 5 * ar\n            uint256 offerAndConsiderationSize = OrderFulfilled_baseDataSize +\n                (additionalRecipientsLength * ReceivedItem_size);\n\n            // Copy offer and consideration data from event data to calldata.\n            MemoryPointer.wrap(offerDataOffset).copy(\n                dstHead.offset(tailOffset),\n                offerAndConsiderationSize\n            );\n\n            // Increment tail offset, now used to populate extraData array.\n            tailOffset += offerAndConsiderationSize;\n        }\n\n        // Write empty bytes for extraData.\n        dstHead.offset(ZoneParameters_extraData_head_offset).write(tailOffset);\n        dstHead.offset(tailOffset).write(0);\n\n        unchecked {\n            // Increment tail offset, now used to populate orderHashes array.\n            tailOffset += OneWord;\n        }\n\n        // Write offset to orderHashes.\n        dstHead.offset(ZoneParameters_orderHashes_head_offset).write(\n            tailOffset\n        );\n\n        // Write length = 1 to the orderHashes array.\n        dstHead.offset(tailOffset).write(1);\n\n        unchecked {\n            // Write the single order hash to the orderHashes array.\n            dstHead.offset(tailOffset + OneWord).writeBytes32(orderHash);\n\n            // Final size: selector, ZoneParameters pointer, orderHashes & tail.\n            size = ZoneParameters_basicOrderFixedElements_length + tailOffset;\n        }\n    }\n\n    /**\n     * @dev Takes a memory pointer to an array of bytes32 values representing\n     *      the order hashes included as part of the fulfillment and a memory\n     *      pointer to a location to copy it to, and copies the source data to\n     *      the destination in memory.\n     *\n     * @param srcLength A memory pointer referencing the order hashes array to\n     *                  be copied (and pointing to the length of the array).\n     * @param dstLength A memory pointer referencing the location in memory to\n     *                  copy the orderHashes array to (and pointing to the\n     *                  length of the copied array).\n     *\n     * @return size The size of the order hashes array (including the length).\n     */\n    function _encodeOrderHashes(\n        MemoryPointer srcLength,\n        MemoryPointer dstLength\n    ) internal view returns (uint256 size) {\n        // Read length of the array from source and write to destination.\n        uint256 length = srcLength.readUint256();\n        dstLength.write(length);\n\n        unchecked {\n            // Determine head & tail size as one word per element in the array.\n            uint256 headAndTailSize = length << OneWordShift;\n\n            // Copy the tail starting from the next element of the source to the\n            // next element of the destination.\n            srcLength.next().copy(dstLength.next(), headAndTailSize);\n\n            // Set size to the length of the tail plus one word for length.\n            size = headAndTailSize + OneWord;\n        }\n    }\n\n    /**\n     * @dev Takes a memory pointer to an offer or consideration array and a\n     *      memory pointer to a location to copy it to, and copies the source\n     *      data to the destination in memory as a SpentItem array.\n     *\n     * @param srcLength A memory pointer referencing the offer or consideration\n     *                  array to be copied as a SpentItem array (and pointing to\n     *                  the length of the original array).\n     * @param dstLength A memory pointer referencing the location in memory to\n     *                  copy the offer array to (and pointing to the length of\n     *                  the copied array).\n     *\n     * @return size The size of the SpentItem array (including the length).\n     */\n    function _encodeSpentItems(\n        MemoryPointer srcLength,\n        MemoryPointer dstLength\n    ) internal pure returns (uint256 size) {\n        assembly {\n            // Read length of the array from source and write to destination.\n            let length := mload(srcLength)\n            mstore(dstLength, length)\n\n            // Get pointer to first item's head position in the array,\n            // containing the item's pointer in memory. The head pointer will be\n            // incremented until it reaches the tail position (start of the\n            // array data).\n            let mPtrHead := add(srcLength, OneWord)\n\n            // Position in memory to write next item for calldata. Since\n            // SpentItem has a fixed length, the array elements do not contain\n            // head elements in calldata, they are concatenated together after\n            // the array length.\n            let cdPtrData := add(dstLength, OneWord)\n\n            // Pointer to end of array head in memory.\n            let mPtrHeadEnd := add(mPtrHead, shl(OneWordShift, length))\n\n            for {\n\n            } lt(mPtrHead, mPtrHeadEnd) {\n\n            } {\n                // Read pointer to data for array element from head position.\n                let mPtrTail := mload(mPtrHead)\n\n                // Copy itemType, token, identifier, amount to calldata.\n                mstore(cdPtrData, mload(mPtrTail))\n                mstore(\n                    add(cdPtrData, Common_token_offset),\n                    mload(add(mPtrTail, Common_token_offset))\n                )\n                mstore(\n                    add(cdPtrData, Common_identifier_offset),\n                    mload(add(mPtrTail, Common_identifier_offset))\n                )\n                mstore(\n                    add(cdPtrData, Common_amount_offset),\n                    mload(add(mPtrTail, Common_amount_offset))\n                )\n\n                mPtrHead := add(mPtrHead, OneWord)\n                cdPtrData := add(cdPtrData, SpentItem_size)\n            }\n\n            size := add(OneWord, shl(SpentItem_size_shift, length))\n        }\n    }\n\n    /**\n     * @dev Takes a memory pointer to an consideration array and a memory\n     *      pointer to a location to copy it to, and copies the source data to\n     *      the destination in memory as a ReceivedItem array.\n     *\n     * @param srcLength A memory pointer referencing the consideration array to\n     *                  be copied as a ReceivedItem array (and pointing to the\n     *                  length of the original array).\n     * @param dstLength A memory pointer referencing the location in memory to\n     *                  copy the consideration array to as a ReceivedItem array\n     *                  (and pointing to the length of the new array).\n     *\n     * @return size The size of the ReceivedItem array (including the length).\n     */\n    function _encodeConsiderationAsReceivedItems(\n        MemoryPointer srcLength,\n        MemoryPointer dstLength\n    ) internal view returns (uint256 size) {\n        unchecked {\n            // Read length of the array from source and write to destination.\n            uint256 length = srcLength.readUint256();\n            dstLength.write(length);\n\n            // Get pointer to first item's head position in the array,\n            // containing the item's pointer in memory. The head pointer will be\n            // incremented until it reaches the tail position (start of the\n            // array data).\n            MemoryPointer srcHead = srcLength.next();\n            MemoryPointer srcHeadEnd = srcHead.offset(length << OneWordShift);\n\n            // Position in memory to write next item for calldata. Since\n            // ReceivedItem has a fixed length, the array elements do not\n            // contain offsets in calldata, they are concatenated together after\n            // the array length.\n            MemoryPointer dstHead = dstLength.next();\n            while (srcHead.lt(srcHeadEnd)) {\n                MemoryPointer srcTail = srcHead.pptr();\n                srcTail.copy(dstHead, ReceivedItem_size);\n                srcHead = srcHead.next();\n                dstHead = dstHead.offset(ReceivedItem_size);\n            }\n\n            size = OneWord + (length * ReceivedItem_size);\n        }\n    }\n}\n"},"contracts/interfaces/TokenTransferrerErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title TokenTransferrerErrors\n */\ninterface TokenTransferrerErrors {\n    /**\n     * @dev Revert with an error when an ERC721 transfer with amount other than\n     *      one is attempted.\n     *\n     * @param amount The amount of the ERC721 tokens to transfer.\n     */\n    error InvalidERC721TransferAmount(uint256 amount);\n\n    /**\n     * @dev Revert with an error when attempting to fulfill an order where an\n     *      item has an amount of zero.\n     */\n    error MissingItemAmount();\n\n    /**\n     * @dev Revert with an error when attempting to fulfill an order where an\n     *      item has unused parameters. This includes both the token and the\n     *      identifier parameters for native transfers as well as the identifier\n     *      parameter for ERC20 transfers. Note that the conduit does not\n     *      perform this check, leaving it up to the calling channel to enforce\n     *      when desired.\n     */\n    error UnusedItemParameters();\n\n    /**\n     * @dev Revert with an error when an ERC20, ERC721, or ERC1155 token\n     *      transfer reverts.\n     *\n     * @param token      The token for which the transfer was attempted.\n     * @param from       The source of the attempted transfer.\n     * @param to         The recipient of the attempted transfer.\n     * @param identifier The identifier for the attempted transfer.\n     * @param amount     The amount for the attempted transfer.\n     */\n    error TokenTransferGenericFailure(\n        address token,\n        address from,\n        address to,\n        uint256 identifier,\n        uint256 amount\n    );\n\n    /**\n     * @dev Revert with an error when a batch ERC1155 token transfer reverts.\n     *\n     * @param token       The token for which the transfer was attempted.\n     * @param from        The source of the attempted transfer.\n     * @param to          The recipient of the attempted transfer.\n     * @param identifiers The identifiers for the attempted transfer.\n     * @param amounts     The amounts for the attempted transfer.\n     */\n    error ERC1155BatchTransferGenericFailure(\n        address token,\n        address from,\n        address to,\n        uint256[] identifiers,\n        uint256[] amounts\n    );\n\n    /**\n     * @dev Revert with an error when an ERC20 token transfer returns a falsey\n     *      value.\n     *\n     * @param token      The token for which the ERC20 transfer was attempted.\n     * @param from       The source of the attempted ERC20 transfer.\n     * @param to         The recipient of the attempted ERC20 transfer.\n     * @param amount     The amount for the attempted ERC20 transfer.\n     */\n    error BadReturnValueFromERC20OnTransfer(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    );\n\n    /**\n     * @dev Revert with an error when an account being called as an assumed\n     *      contract does not have code and returns no data.\n     *\n     * @param account The account that should contain code.\n     */\n    error NoContract(address account);\n\n    /**\n     * @dev Revert with an error when attempting to execute an 1155 batch\n     *      transfer using calldata not produced by default ABI encoding or with\n     *      different lengths for ids and amounts arrays.\n     */\n    error Invalid1155BatchTransferEncoding();\n}\n"},"contracts/lib/ConsiderationConstants.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/*\n * -------------------------- Disambiguation & Other Notes ---------------------\n *    - The term \"head\" is used as it is in the documentation for ABI encoding,\n *      but only in reference to dynamic types, i.e. it always refers to the\n *      offset or pointer to the body of a dynamic type. In calldata, the head\n *      is always an offset (relative to the parent object), while in memory,\n *      the head is always the pointer to the body. More information found here:\n *      https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#argument-encoding\n *        - Note that the length of an array is separate from and precedes the\n *          head of the array.\n *\n *    - The term \"body\" is used in place of the term \"head\" used in the ABI\n *      documentation. It refers to the start of the data for a dynamic type,\n *      e.g. the first word of a struct or the first word of the first element\n *      in an array.\n *\n *    - The term \"pointer\" is used to describe the absolute position of a value\n *      and never an offset relative to another value.\n *        - The suffix \"_ptr\" refers to a memory pointer.\n *        - The suffix \"_cdPtr\" refers to a calldata pointer.\n *\n *    - The term \"offset\" is used to describe the position of a value relative\n *      to some parent value. For example, OrderParameters_conduit_offset is the\n *      offset to the \"conduit\" value in the OrderParameters struct relative to\n *      the start of the body.\n *        - Note: Offsets are used to derive pointers.\n *\n *    - Some structs have pointers defined for all of their fields in this file.\n *      Lines which are commented out are fields that are not used in the\n *      codebase but have been left in for readability.\n */\n\n// Declare constants for name, version, and reentrancy sentinel values.\n\n// Name is right padded, so it touches the length which is left padded. This\n// enables writing both values at once. Length goes at byte 95 in memory, and\n// name fills bytes 96-109, so both values can be written left-padded to 77.\nuint256 constant NameLengthPtr = 0x4D;\nuint256 constant NameWithLength = 0x0d436F6E73696465726174696F6E;\n\nuint256 constant information_version_offset = 0;\nuint256 constant information_version_cd_offset = 0x60;\nuint256 constant information_domainSeparator_offset = 0x20;\nuint256 constant information_conduitController_offset = 0x40;\nuint256 constant information_versionLengthPtr = 0x63;\nuint256 constant information_versionWithLength = 0x03312e35; // 1.5\nuint256 constant information_length = 0xa0;\n\nuint256 constant _NOT_ENTERED = 1;\nuint256 constant _ENTERED = 2;\nuint256 constant _ENTERED_AND_ACCEPTING_NATIVE_TOKENS = 3;\n\nuint256 constant Offset_fulfillAdvancedOrder_criteriaResolvers = 0x20;\nuint256 constant Offset_fulfillAvailableOrders_offerFulfillments = 0x20;\nuint256 constant Offset_fulfillAvailableOrders_considerationFulfillments = 0x40;\nuint256 constant Offset_fulfillAvailableAdvancedOrders_criteriaResolvers = 0x20;\nuint256 constant Offset_fulfillAvailableAdvancedOrders_offerFulfillments = 0x40;\nuint256 constant Offset_fulfillAvailableAdvancedOrders_cnsdrationFlflmnts = (\n    0x60\n);\n\nuint256 constant Offset_matchOrders_fulfillments = 0x20;\n\nuint256 constant Offset_matchAdvancedOrders_criteriaResolvers = 0x20;\nuint256 constant Offset_matchAdvancedOrders_fulfillments = 0x40;\n\n// Common Offsets\n// Offsets for identically positioned fields shared by:\n// OfferItem, ConsiderationItem, SpentItem, ReceivedItem\n\nuint256 constant Selector_length = 0x4;\n\nuint256 constant Common_token_offset = 0x20;\nuint256 constant Common_identifier_offset = 0x40;\nuint256 constant Common_amount_offset = 0x60;\nuint256 constant Common_endAmount_offset = 0x80;\n\nuint256 constant SpentItem_size = 0x80;\nuint256 constant SpentItem_size_shift = 0x7;\n\nuint256 constant OfferItem_size = 0xa0;\nuint256 constant OfferItem_size_with_length = 0xc0;\n\nuint256 constant ReceivedItem_size_excluding_recipient = 0x80;\nuint256 constant ReceivedItem_size = 0xa0;\nuint256 constant ReceivedItem_amount_offset = 0x60;\nuint256 constant ReceivedItem_recipient_offset = 0x80;\n\nuint256 constant ReceivedItem_CommonParams_size = 0x60;\n\nuint256 constant ConsiderationItem_size = 0xc0;\nuint256 constant ConsiderationItem_size_with_length = 0xe0;\n\nuint256 constant ConsiderationItem_recipient_offset = 0xa0;\n// Store the same constant in an abbreviated format for a line length fix.\nuint256 constant ConsiderItem_recipient_offset = 0xa0;\n\nuint256 constant Execution_offerer_offset = 0x20;\nuint256 constant Execution_conduit_offset = 0x40;\n\n// uint256 constant OrderParameters_offerer_offset = 0x00;\nuint256 constant OrderParameters_zone_offset = 0x20;\nuint256 constant OrderParameters_offer_head_offset = 0x40;\nuint256 constant OrderParameters_consideration_head_offset = 0x60;\n// uint256 constant OrderParameters_orderType_offset = 0x80;\nuint256 constant OrderParameters_startTime_offset = 0xa0;\nuint256 constant OrderParameters_endTime_offset = 0xc0;\nuint256 constant OrderParameters_zoneHash_offset = 0xe0;\n// uint256 constant OrderParameters_salt_offset = 0x100;\nuint256 constant OrderParameters_conduit_offset = 0x120;\nuint256 constant OrderParameters_counter_offset = 0x140;\n\nuint256 constant Fulfillment_itemIndex_offset = 0x20;\n\nuint256 constant AdvancedOrder_head_size = 0xa0;\nuint256 constant AdvancedOrder_numerator_offset = 0x20;\nuint256 constant AdvancedOrder_denominator_offset = 0x40;\nuint256 constant AdvancedOrder_signature_offset = 0x60;\nuint256 constant AdvancedOrder_extraData_offset = 0x80;\n\nuint256 constant OrderStatus_ValidatedAndNotCancelled = 1;\nuint256 constant OrderStatus_filledNumerator_offset = 0x10;\nuint256 constant OrderStatus_filledDenominator_offset = 0x88;\n\nuint256 constant ThirtyOneBytes = 0x1f;\nuint256 constant OneWord = 0x20;\nuint256 constant TwoWords = 0x40;\nuint256 constant ThreeWords = 0x60;\nuint256 constant FourWords = 0x80;\nuint256 constant FiveWords = 0xa0;\n\nuint256 constant OneWordShift = 0x5;\nuint256 constant TwoWordsShift = 0x6;\n\nuint256 constant SixtyThreeBytes = 0x3f;\nuint256 constant OnlyFullWordMask = 0xffffffe0;\n\nuint256 constant FreeMemoryPointerSlot = 0x40;\nuint256 constant ZeroSlot = 0x60;\nuint256 constant DefaultFreeMemoryPointer = 0x80;\n\nuint256 constant Slot0x80 = 0x80;\nuint256 constant Slot0xA0 = 0xa0;\n\n// uint256 constant BasicOrder_endAmount_cdPtr = 0x104;\nuint256 constant BasicOrder_common_params_size = 0xa0;\nuint256 constant BasicOrder_considerationHashesArray_ptr = 0x160;\nuint256 constant BasicOrder_receivedItemByteMap = (\n    0x0000010102030000000000000000000000000000000000000000000000000000\n);\nuint256 constant BasicOrder_offeredItemByteMap = (\n    0x0203020301010000000000000000000000000000000000000000000000000000\n);\n\nbytes32 constant OrdersMatchedTopic0 = (\n    0x4b9f2d36e1b4c93de62cc077b00b1a91d84b6c31b4a14e012718dcca230689e7\n);\n\nuint256 constant EIP712_Order_size = 0x180;\nuint256 constant EIP712_OfferItem_size = 0xc0;\nuint256 constant EIP712_ConsiderationItem_size = 0xe0;\nuint256 constant AdditionalRecipient_size = 0x40;\nuint256 constant AdditionalRecipient_size_shift = 0x6;\n\nuint256 constant EIP712_DomainSeparator_offset = 0x02;\nuint256 constant EIP712_OrderHash_offset = 0x22;\nuint256 constant EIP712_DigestPayload_size = 0x42;\n\nuint256 constant EIP712_domainData_nameHash_offset = 0x20;\nuint256 constant EIP712_domainData_versionHash_offset = 0x40;\nuint256 constant EIP712_domainData_chainId_offset = 0x60;\nuint256 constant EIP712_domainData_verifyingContract_offset = 0x80;\nuint256 constant EIP712_domainData_size = 0xa0;\n\n// Minimum BulkOrder proof size: 64 bytes for signature + 3 for key + 32 for 1\n// sibling. Maximum BulkOrder proof size: 65 bytes for signature + 3 for key +\n// 768 for 24 siblings.\n\nuint256 constant BulkOrderProof_minSize = 0x63;\nuint256 constant BulkOrderProof_rangeSize = 0x2e2;\nuint256 constant BulkOrderProof_lengthAdjustmentBeforeMask = 0x1d;\nuint256 constant BulkOrderProof_lengthRangeAfterMask = 0x2;\nuint256 constant BulkOrderProof_keyShift = 0xe8;\nuint256 constant BulkOrderProof_keySize = 0x3;\n\nuint256 constant BulkOrder_Typehash_Height_One = (\n    0x3ca2711d29384747a8f61d60aad3c450405f7aaff5613541dee28df2d6986d32\n);\nuint256 constant BulkOrder_Typehash_Height_Two = (\n    0xbf8e29b89f29ed9b529c154a63038ffca562f8d7cd1e2545dda53a1b582dde30\n);\nuint256 constant BulkOrder_Typehash_Height_Three = (\n    0x53c6f6856e13104584dd0797ca2b2779202dc2597c6066a42e0d8fe990b0024d\n);\nuint256 constant BulkOrder_Typehash_Height_Four = (\n    0xa02eb7ff164c884e5e2c336dc85f81c6a93329d8e9adf214b32729b894de2af1\n);\nuint256 constant BulkOrder_Typehash_Height_Five = (\n    0x39c9d33c18e050dda0aeb9a8086fb16fc12d5d64536780e1da7405a800b0b9f6\n);\nuint256 constant BulkOrder_Typehash_Height_Six = (\n    0x1c19f71958cdd8f081b4c31f7caf5c010b29d12950be2fa1c95070dc47e30b55\n);\nuint256 constant BulkOrder_Typehash_Height_Seven = (\n    0xca74fab2fece9a1d58234a274220ad05ca096a92ef6a1ca1750b9d90c948955c\n);\nuint256 constant BulkOrder_Typehash_Height_Eight = (\n    0x7ff98d9d4e55d876c5cfac10b43c04039522f3ddfb0ea9bfe70c68cfb5c7cc14\n);\nuint256 constant BulkOrder_Typehash_Height_Nine = (\n    0xbed7be92d41c56f9e59ac7a6272185299b815ddfabc3f25deb51fe55fe2f9e8a\n);\nuint256 constant BulkOrder_Typehash_Height_Ten = (\n    0xd1d97d1ef5eaa37a4ee5fbf234e6f6d64eb511eb562221cd7edfbdde0848da05\n);\nuint256 constant BulkOrder_Typehash_Height_Eleven = (\n    0x896c3f349c4da741c19b37fec49ed2e44d738e775a21d9c9860a69d67a3dae53\n);\nuint256 constant BulkOrder_Typehash_Height_Twelve = (\n    0xbb98d87cc12922b83759626c5f07d72266da9702d19ffad6a514c73a89002f5f\n);\nuint256 constant BulkOrder_Typehash_Height_Thirteen = (\n    0xe6ae19322608dd1f8a8d56aab48ed9c28be489b689f4b6c91268563efc85f20e\n);\nuint256 constant BulkOrder_Typehash_Height_Fourteen = (\n    0x6b5b04cbae4fcb1a9d78e7b2dfc51a36933d023cf6e347e03d517b472a852590\n);\nuint256 constant BulkOrder_Typehash_Height_Fifteen = (\n    0xd1eb68309202b7106b891e109739dbbd334a1817fe5d6202c939e75cf5e35ca9\n);\nuint256 constant BulkOrder_Typehash_Height_Sixteen = (\n    0x1da3eed3ecef6ebaa6e5023c057ec2c75150693fd0dac5c90f4a142f9879fde8\n);\nuint256 constant BulkOrder_Typehash_Height_Seventeen = (\n    0xeee9a1392aa395c7002308119a58f2582777a75e54e0c1d5d5437bd2e8bf6222\n);\nuint256 constant BulkOrder_Typehash_Height_Eighteen = (\n    0xc3939feff011e53ab8c35ca3370aad54c5df1fc2938cd62543174fa6e7d85877\n);\nuint256 constant BulkOrder_Typehash_Height_Nineteen = (\n    0x0efca7572ac20f5ae84db0e2940674f7eca0a4726fa1060ffc2d18cef54b203d\n);\nuint256 constant BulkOrder_Typehash_Height_Twenty = (\n    0x5a4f867d3d458dabecad65f6201ceeaba0096df2d0c491cc32e6ea4e64350017\n);\nuint256 constant BulkOrder_Typehash_Height_TwentyOne = (\n    0x80987079d291feebf21c2230e69add0f283cee0b8be492ca8050b4185a2ff719\n);\nuint256 constant BulkOrder_Typehash_Height_TwentyTwo = (\n    0x3bd8cff538aba49a9c374c806d277181e9651624b3e31111bc0624574f8bca1d\n);\nuint256 constant BulkOrder_Typehash_Height_TwentyThree = (\n    0x5d6a3f098a0bc373f808c619b1bb4028208721b3c4f8d6bc8a874d659814eb76\n);\nuint256 constant BulkOrder_Typehash_Height_TwentyFour = (\n    0x1d51df90cba8de7637ca3e8fe1e3511d1dc2f23487d05dbdecb781860c21ac1c\n);\n\nuint256 constant receivedItemsHash_ptr = 0x60;\n\n/*\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\n *  data for OrderFulfilled\n *\n *   event OrderFulfilled(\n *     bytes32 orderHash,\n *     address indexed offerer,\n *     address indexed zone,\n *     address fulfiller,\n *     SpentItem[] offer,\n *       > (itemType, token, id, amount)\n *     ReceivedItem[] consideration\n *       > (itemType, token, id, amount, recipient)\n *   )\n *\n *  - 0x00: orderHash\n *  - 0x20: fulfiller\n *  - 0x40: offer offset (0x80)\n *  - 0x60: consideration offset (0x120)\n *  - 0x80: offer.length (1)\n *  - 0xa0: offerItemType\n *  - 0xc0: offerToken\n *  - 0xe0: offerIdentifier\n *  - 0x100: offerAmount\n *  - 0x120: consideration.length (1 + additionalRecipients.length)\n *  - 0x140: considerationItemType\n *  - 0x160: considerationToken\n *  - 0x180: considerationIdentifier\n *  - 0x1a0: considerationAmount\n *  - 0x1c0: considerationRecipient\n *  - ...\n */\n\n// Minimum length of the OrderFulfilled event data.\n// Must be added to the size of the ReceivedItem array for additionalRecipients\n// (0xa0 * additionalRecipients.length) to calculate full size of the buffer.\nuint256 constant OrderFulfilled_baseSize = 0x1e0;\nuint256 constant OrderFulfilled_selector = (\n    0x9d9af8e38d66c62e2c12f0225249fd9d721c54b83f48d9352c97c6cacdcb6f31\n);\n\n// Minimum offset in memory to OrderFulfilled event data.\n// Must be added to the size of the EIP712 hash array for additionalRecipients\n// (32 * additionalRecipients.length) to calculate the pointer to event data.\nuint256 constant OrderFulfilled_baseOffset = 0x180;\nuint256 constant OrderFulfilled_consideration_length_baseOffset = 0x2a0;\nuint256 constant OrderFulfilled_offer_length_baseOffset = 0x200;\n\n// Related constants used for restricted order checks on basic orders.\nuint256 constant OrderFulfilled_baseDataSize = 0x160;\n// uint256 constant ValidateOrder_offerDataOffset = 0x184;\n// uint256 constant RatifyOrder_offerDataOffset = 0xc4;\n\n// uint256 constant OrderFulfilled_orderHash_offset = 0x00;\nuint256 constant OrderFulfilled_fulfiller_offset = 0x20;\nuint256 constant OrderFulfilled_offer_head_offset = 0x40;\nuint256 constant OrderFulfilled_offer_body_offset = 0x80;\nuint256 constant OrderFulfilled_consideration_head_offset = 0x60;\nuint256 constant OrderFulfilled_consideration_body_offset = 0x120;\n\n// BasicOrderParameters\nuint256 constant BasicOrder_parameters_cdPtr = 0x04;\nuint256 constant BasicOrder_considerationToken_cdPtr = 0x24;\nuint256 constant BasicOrder_considerationIdentifier_cdPtr = 0x44;\nuint256 constant BasicOrder_considerationAmount_cdPtr = 0x64;\nuint256 constant BasicOrder_offerer_cdPtr = 0x84;\nuint256 constant BasicOrder_zone_cdPtr = 0xa4;\nuint256 constant BasicOrder_offerToken_cdPtr = 0xc4;\nuint256 constant BasicOrder_offerIdentifier_cdPtr = 0xe4;\nuint256 constant BasicOrder_offerAmount_cdPtr = 0x104;\nuint256 constant BasicOrder_basicOrderType_cdPtr = 0x124;\nuint256 constant BasicOrder_startTime_cdPtr = 0x144;\nuint256 constant BasicOrder_endTime_cdPtr = 0x164;\n// uint256 constant BasicOrder_zoneHash_cdPtr = 0x184;\n// uint256 constant BasicOrder_salt_cdPtr = 0x1a4;\nuint256 constant BasicOrder_offererConduit_cdPtr = 0x1c4;\nuint256 constant BasicOrder_fulfillerConduit_cdPtr = 0x1e4;\nuint256 constant BasicOrder_totalOriginalAdditionalRecipients_cdPtr = 0x204;\nuint256 constant BasicOrder_additionalRecipients_head_cdPtr = 0x224;\nuint256 constant BasicOrder_signature_cdPtr = 0x244;\nuint256 constant BasicOrder_additionalRecipients_length_cdPtr = 0x264;\nuint256 constant BasicOrder_additionalRecipients_data_cdPtr = 0x284;\nuint256 constant BasicOrder_parameters_ptr = 0x20;\nuint256 constant BasicOrder_basicOrderType_range = 0x18; // 24 values\n\n/*\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\n *  EIP712 data for ConsiderationItem\n *   - 0x80: ConsiderationItem EIP-712 typehash (constant)\n *   - 0xa0: itemType\n *   - 0xc0: token\n *   - 0xe0: identifier\n *   - 0x100: startAmount\n *   - 0x120: endAmount\n *   - 0x140: recipient\n */\nuint256 constant BasicOrder_considerationItem_typeHash_ptr = 0x80; // memoryPtr\nuint256 constant BasicOrder_considerationItem_itemType_ptr = 0xa0;\nuint256 constant BasicOrder_considerationItem_token_ptr = 0xc0;\nuint256 constant BasicOrder_considerationItem_identifier_ptr = 0xe0;\nuint256 constant BasicOrder_considerationItem_startAmount_ptr = 0x100;\nuint256 constant BasicOrder_considerationItem_endAmount_ptr = 0x120;\n// uint256 constant BasicOrder_considerationItem_recipient_ptr = 0x140;\n\n/*\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\n *  EIP712 data for OfferItem\n *   - 0x80:  OfferItem EIP-712 typehash (constant)\n *   - 0xa0:  itemType\n *   - 0xc0:  token\n *   - 0xe0:  identifier (reused for offeredItemsHash)\n *   - 0x100: startAmount\n *   - 0x120: endAmount\n */\nuint256 constant BasicOrder_offerItem_typeHash_ptr = 0x80;\nuint256 constant BasicOrder_offerItem_itemType_ptr = 0xa0;\nuint256 constant BasicOrder_offerItem_token_ptr = 0xc0;\n// uint256 constant BasicOrder_offerItem_identifier_ptr = 0xe0;\n// uint256 constant BasicOrder_offerItem_startAmount_ptr = 0x100;\nuint256 constant BasicOrder_offerItem_endAmount_ptr = 0x120;\n\n/*\n *  Memory layout in _prepareBasicFulfillmentFromCalldata of\n *  EIP712 data for Order\n *   - 0x80:   Order EIP-712 typehash (constant)\n *   - 0xa0:   orderParameters.offerer\n *   - 0xc0:   orderParameters.zone\n *   - 0xe0:   keccak256(abi.encodePacked(offerHashes))\n *   - 0x100:  keccak256(abi.encodePacked(considerationHashes))\n *   - 0x120:  orderType\n *   - 0x140:  startTime\n *   - 0x160:  endTime\n *   - 0x180:  zoneHash\n *   - 0x1a0:  salt\n *   - 0x1c0:  conduit\n *   - 0x1e0:  _counters[orderParameters.offerer] (from storage)\n */\nuint256 constant BasicOrder_order_typeHash_ptr = 0x80;\nuint256 constant BasicOrder_order_offerer_ptr = 0xa0;\n// uint256 constant BasicOrder_order_zone_ptr = 0xc0;\nuint256 constant BasicOrder_order_offerHashes_ptr = 0xe0;\nuint256 constant BasicOrder_order_considerationHashes_ptr = 0x100;\nuint256 constant BasicOrder_order_orderType_ptr = 0x120;\nuint256 constant BasicOrder_order_startTime_ptr = 0x140;\n// uint256 constant BasicOrder_order_endTime_ptr = 0x160;\n// uint256 constant BasicOrder_order_zoneHash_ptr = 0x180;\n// uint256 constant BasicOrder_order_salt_ptr = 0x1a0;\n// uint256 constant BasicOrder_order_conduitKey_ptr = 0x1c0;\nuint256 constant BasicOrder_order_counter_ptr = 0x1e0;\nuint256 constant BasicOrder_additionalRecipients_head_ptr = 0x240;\nuint256 constant BasicOrder_signature_ptr = 0x260;\nuint256 constant BasicOrder_startTimeThroughZoneHash_size = 0x60;\n\nuint256 constant ContractOrder_orderHash_offerer_shift = 0x60;\n\nuint256 constant Counter_blockhash_shift = 0x80;\n\n// Signature-related\nbytes32 constant EIP2098_allButHighestBitMask = (\n    0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n);\nbytes32 constant ECDSA_twentySeventhAndTwentyEighthBytesSet = (\n    0x0000000000000000000000000000000000000000000000000000000101000000\n);\nuint256 constant ECDSA_MaxLength = 65;\nuint256 constant ECDSA_signature_s_offset = 0x40;\nuint256 constant ECDSA_signature_v_offset = 0x60;\n\nbytes32 constant EIP1271_isValidSignature_selector = (\n    0x1626ba7e00000000000000000000000000000000000000000000000000000000\n);\nuint256 constant EIP1271_isValidSignature_digest_negativeOffset = 0x40;\nuint256 constant EIP1271_isValidSignature_selector_negativeOffset = 0x44;\nuint256 constant EIP1271_isValidSignature_calldata_baseLength = 0x64;\nuint256 constant EIP1271_isValidSignature_signature_head_offset = 0x40;\n\nuint256 constant EIP_712_PREFIX = (\n    0x1901000000000000000000000000000000000000000000000000000000000000\n);\n\nuint256 constant ExtraGasBuffer = 0x20;\nuint256 constant CostPerWord = 0x3;\nuint256 constant MemoryExpansionCoefficientShift = 0x9;\n\nuint256 constant Create2AddressDerivation_ptr = 0x0b;\nuint256 constant Create2AddressDerivation_length = 0x55;\n\nuint256 constant MaskOverByteTwelve = (\n    0x0000000000000000000000ff0000000000000000000000000000000000000000\n);\nuint256 constant MaskOverLastTwentyBytes = (\n    0x000000000000000000000000ffffffffffffffffffffffffffffffffffffffff\n);\nuint256 constant AddressDirtyUpperBitThreshold = (\n    0x0000000000000000000000010000000000000000000000000000000000000000\n);\nuint256 constant MaskOverFirstFourBytes = (\n    0xffffffff00000000000000000000000000000000000000000000000000000000\n);\n\nuint256 constant Conduit_execute_signature = (\n    0x4ce34aa200000000000000000000000000000000000000000000000000000000\n);\n\nuint256 constant MaxUint8 = 0xff;\nuint256 constant MaxUint120 = 0xffffffffffffffffffffffffffffff;\n\nuint256 constant Conduit_execute_ConduitTransfer_ptr = 0x20;\nuint256 constant Conduit_execute_ConduitTransfer_length = 0x01;\nuint256 constant Conduit_execute_ConduitTransfer_offset_ptr = 0x04;\nuint256 constant Conduit_execute_ConduitTransfer_length_ptr = 0x24;\nuint256 constant Conduit_execute_transferItemType_ptr = 0x44;\nuint256 constant Conduit_execute_transferToken_ptr = 0x64;\nuint256 constant Conduit_execute_transferFrom_ptr = 0x84;\nuint256 constant Conduit_execute_transferTo_ptr = 0xa4;\nuint256 constant Conduit_execute_transferIdentifier_ptr = 0xc4;\nuint256 constant Conduit_execute_transferAmount_ptr = 0xe4;\n\nuint256 constant OneConduitExecute_size = 0x104;\n\n// Sentinel value to indicate that the conduit accumulator is not armed.\nuint256 constant AccumulatorDisarmed = 0x20;\nuint256 constant AccumulatorArmed = 0x40;\nuint256 constant Accumulator_conduitKey_ptr = 0x20;\nuint256 constant Accumulator_selector_ptr = 0x40;\nuint256 constant Accumulator_array_offset_ptr = 0x44;\nuint256 constant Accumulator_array_length_ptr = 0x64;\nuint256 constant Accumulator_itemSizeOffsetDifference = 0x3c;\nuint256 constant Accumulator_array_offset = 0x20;\n\nuint256 constant Conduit_transferItem_size = 0xc0;\nuint256 constant Conduit_transferItem_token_ptr = 0x20;\nuint256 constant Conduit_transferItem_from_ptr = 0x40;\nuint256 constant Conduit_transferItem_to_ptr = 0x60;\nuint256 constant Conduit_transferItem_identifier_ptr = 0x80;\nuint256 constant Conduit_transferItem_amount_ptr = 0xa0;\n\nuint256 constant Ecrecover_precompile = 0x1;\nuint256 constant Ecrecover_args_size = 0x80;\nuint256 constant Signature_lower_v = 27;\n\n// Bitmask that only gives a non-zero value if masked with a non-match selector.\nuint256 constant NonMatchSelector_MagicMask = (\n    0x4000000000000000000000000000000000000000000000000000000000\n);\n\n// First bit indicates that a NATIVE offer items has been used and the 231st bit\n// indicates that a non match selector has been called.\nuint256 constant NonMatchSelector_InvalidErrorValue = (\n    0x4000000000000000000000000000000000000000000000000000000001\n);\n\n/**\n * @dev Selector and offsets for generateOrder\n *\n * function generateOrder(\n *   address fulfiller,\n *   SpentItem[] calldata minimumReceived,\n *   SpentItem[] calldata maximumSpent,\n *   bytes calldata context\n * )\n */\nuint256 constant generateOrder_selector = 0x98919765;\nuint256 constant generateOrder_selector_offset = 0x1c;\nuint256 constant generateOrder_head_offset = 0x04;\nuint256 constant generateOrder_minimumReceived_head_offset = 0x20;\nuint256 constant generateOrder_maximumSpent_head_offset = 0x40;\nuint256 constant generateOrder_context_head_offset = 0x60;\nuint256 constant generateOrder_base_tail_offset = 0x80;\nuint256 constant generateOrder_maximum_returndatasize = 0xffff;\n\nuint256 constant ratifyOrder_selector = 0xf4dd92ce;\nuint256 constant ratifyOrder_selector_offset = 0x1c;\nuint256 constant ratifyOrder_head_offset = 0x04;\n// uint256 constant ratifyOrder_offer_head_offset = 0x00;\nuint256 constant ratifyOrder_consideration_head_offset = 0x20;\nuint256 constant ratifyOrder_context_head_offset = 0x40;\nuint256 constant ratifyOrder_orderHashes_head_offset = 0x60;\nuint256 constant ratifyOrder_contractNonce_offset = 0x80;\nuint256 constant ratifyOrder_base_tail_offset = 0xa0;\n\nuint256 constant validateOrder_selector = 0x17b1f942;\nuint256 constant validateOrder_selector_offset = 0x1c;\nuint256 constant validateOrder_head_offset = 0x04;\nuint256 constant validateOrder_zoneParameters_offset = 0x20;\n\n// uint256 constant ZoneParameters_orderHash_offset = 0x00;\nuint256 constant ZoneParameters_fulfiller_offset = 0x20;\nuint256 constant ZoneParameters_offerer_offset = 0x40;\nuint256 constant ZoneParameters_offer_head_offset = 0x60;\nuint256 constant ZoneParameters_consideration_head_offset = 0x80;\nuint256 constant ZoneParameters_extraData_head_offset = 0xa0;\nuint256 constant ZoneParameters_orderHashes_head_offset = 0xc0;\nuint256 constant ZoneParameters_startTime_offset = 0xe0;\nuint256 constant ZoneParameters_endTime_offset = 0x100;\nuint256 constant ZoneParameters_zoneHash_offset = 0x120;\nuint256 constant ZoneParameters_base_tail_offset = 0x140;\nuint256 constant ZoneParameters_selectorAndPointer_length = 0x24;\nuint256 constant ZoneParameters_basicOrderFixedElements_length = 0x64;\n\n// ConsiderationDecoder Constants\nuint256 constant OrderParameters_head_size = 0x0160;\nuint256 constant OrderParameters_totalOriginalConsiderationItems_offset = (\n    0x0140\n);\nuint256 constant AdvancedOrderPlusOrderParameters_head_size = 0x0200;\n\nuint256 constant Order_signature_offset = 0x20;\nuint256 constant Order_head_size = 0x40;\n\nuint256 constant AdvancedOrder_fixed_segment_0 = 0x40;\n\nuint256 constant CriteriaResolver_head_size = 0xa0;\nuint256 constant CriteriaResolver_fixed_segment_0 = 0x80;\nuint256 constant CriteriaResolver_criteriaProof_offset = 0x80;\n\nuint256 constant FulfillmentComponent_mem_tail_size = 0x40;\nuint256 constant FulfillmentComponent_mem_tail_size_shift = 0x6;\nuint256 constant Fulfillment_head_size = 0x40;\nuint256 constant Fulfillment_considerationComponents_offset = 0x20;\n\nuint256 constant OrderComponents_OrderParameters_common_head_size = 0x0140;\n"},"contracts/interfaces/FulfillmentApplicationErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport { Side } from \"../lib/ConsiderationEnums.sol\";\n\n/**\n * @title FulfillmentApplicationErrors\n * @author 0age\n * @notice FulfillmentApplicationErrors contains errors related to fulfillment\n *         application and aggregation.\n */\ninterface FulfillmentApplicationErrors {\n    /**\n     * @dev Revert with an error when a fulfillment is provided that does not\n     *      declare at least one component as part of a call to fulfill\n     *      available orders.\n     */\n    error MissingFulfillmentComponentOnAggregation(Side side);\n\n    /**\n     * @dev Revert with an error when a fulfillment is provided that does not\n     *      declare at least one offer component and at least one consideration\n     *      component.\n     */\n    error OfferAndConsiderationRequiredOnFulfillment();\n\n    /**\n     * @dev Revert with an error when the initial offer item named by a\n     *      fulfillment component does not match the type, token, identifier,\n     *      or conduit preference of the initial consideration item.\n     *\n     * @param fulfillmentIndex The index of the fulfillment component that\n     *                         does not match the initial offer item.\n     */\n    error MismatchedFulfillmentOfferAndConsiderationComponents(\n        uint256 fulfillmentIndex\n    );\n\n    /**\n     * @dev Revert with an error when an order or item index are out of range\n     *      or a fulfillment component does not match the type, token,\n     *      identifier, or conduit preference of the initial consideration item.\n     */\n    error InvalidFulfillmentComponentData();\n}\n"},"contracts/lib/LowLevelHelpers.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {\n    CostPerWord,\n    ExtraGasBuffer,\n    FreeMemoryPointerSlot,\n    MemoryExpansionCoefficientShift,\n    OneWord,\n    OneWordShift,\n    ThirtyOneBytes\n} from \"./ConsiderationConstants.sol\";\n\n/**\n * @title LowLevelHelpers\n * @author 0age\n * @notice LowLevelHelpers contains logic for performing various low-level\n *         operations.\n */\ncontract LowLevelHelpers {\n    /**\n     * @dev Internal view function to revert and pass along the revert reason if\n     *      data was returned by the last call and that the size of that data\n     *      does not exceed the currently allocated memory size.\n     */\n    function _revertWithReasonIfOneIsReturned() internal view {\n        assembly {\n            // If it returned a message, bubble it up as long as sufficient gas\n            // remains to do so:\n            if returndatasize() {\n                // Ensure that sufficient gas is available to copy returndata\n                // while expanding memory where necessary. Start by computing\n                // the word size of returndata and allocated memory.\n                let returnDataWords := shr(\n                    OneWordShift,\n                    add(returndatasize(), ThirtyOneBytes)\n                )\n\n                // Note: use the free memory pointer in place of msize() to work\n                // around a Yul warning that prevents accessing msize directly\n                // when the IR pipeline is activated.\n                let msizeWords := shr(\n                    OneWordShift,\n                    mload(FreeMemoryPointerSlot)\n                )\n\n                // Next, compute the cost of the returndatacopy.\n                let cost := mul(CostPerWord, returnDataWords)\n\n                // Then, compute cost of new memory allocation.\n                if gt(returnDataWords, msizeWords) {\n                    cost := add(\n                        cost,\n                        add(\n                            mul(sub(returnDataWords, msizeWords), CostPerWord),\n                            shr(\n                                MemoryExpansionCoefficientShift,\n                                sub(\n                                    mul(returnDataWords, returnDataWords),\n                                    mul(msizeWords, msizeWords)\n                                )\n                            )\n                        )\n                    )\n                }\n\n                // Finally, add a small constant and compare to gas remaining;\n                // bubble up the revert data if enough gas is still available.\n                if lt(add(cost, ExtraGasBuffer), gas()) {\n                    // Copy returndata to memory; overwrite existing memory.\n                    returndatacopy(0, 0, returndatasize())\n\n                    // Revert, specifying memory region with copied returndata.\n                    revert(0, returndatasize())\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Internal view function to branchlessly select either the caller (if\n     *      a supplied recipient is equal to zero) or the supplied recipient (if\n     *      that recipient is a nonzero value).\n     *\n     * @param recipient The supplied recipient.\n     *\n     * @return updatedRecipient The updated recipient.\n     */\n    function _substituteCallerForEmptyRecipient(\n        address recipient\n    ) internal view returns (address updatedRecipient) {\n        // Utilize assembly to perform a branchless operation on the recipient.\n        assembly {\n            // Add caller to recipient if recipient equals 0; otherwise add 0.\n            updatedRecipient := add(recipient, mul(iszero(recipient), caller()))\n        }\n    }\n\n    /**\n     * @dev Internal pure function to cast a `bool` value to a `uint256` value.\n     *\n     * @param b The `bool` value to cast.\n     *\n     * @return u The `uint256` value.\n     */\n    function _cast(bool b) internal pure returns (uint256 u) {\n        assembly {\n            u := b\n        }\n    }\n}\n"},"contracts/lib/CounterManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {\n    ConsiderationEventsAndErrors\n} from \"../interfaces/ConsiderationEventsAndErrors.sol\";\n\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\n\nimport {\n    Counter_blockhash_shift,\n    OneWord,\n    TwoWords\n} from \"./ConsiderationConstants.sol\";\n\n/**\n * @title CounterManager\n * @author 0age\n * @notice CounterManager contains a storage mapping and related functionality\n *         for retrieving and incrementing a per-offerer counter.\n */\ncontract CounterManager is ConsiderationEventsAndErrors, ReentrancyGuard {\n    // Only orders signed using an offerer's current counter are fulfillable.\n    mapping(address => uint256) private _counters;\n\n    /**\n     * @dev Internal function to cancel all orders from a given offerer in bulk\n     *      by incrementing a counter by a large, quasi-random interval. Note\n     *      that only the offerer may increment the counter. Note that the\n     *      counter is incremented by a large, quasi-random interval, which\n     *      makes it infeasible to \"activate\" signed orders by incrementing the\n     *      counter.  This activation functionality can be achieved instead with\n     *      restricted orders or contract orders.\n     *\n     * @return newCounter The new counter.\n     */\n    function _incrementCounter() internal returns (uint256 newCounter) {\n        // Ensure that the reentrancy guard is not currently set.\n        _assertNonReentrant();\n\n        // Utilize assembly to access counters storage mapping directly. Skip\n        // overflow check as counter cannot be incremented that far.\n        assembly {\n            // Use second half of previous block hash as a quasi-random number.\n            let quasiRandomNumber := shr(\n                Counter_blockhash_shift,\n                blockhash(sub(number(), 1))\n            )\n\n            // Write the caller to scratch space.\n            mstore(0, caller())\n\n            // Write the storage slot for _counters to scratch space.\n            mstore(OneWord, _counters.slot)\n\n            // Derive the storage pointer for the counter value.\n            let storagePointer := keccak256(0, TwoWords)\n\n            // Derive new counter value using random number and original value.\n            newCounter := add(quasiRandomNumber, sload(storagePointer))\n\n            // Store the updated counter value.\n            sstore(storagePointer, newCounter)\n        }\n\n        // Emit an event containing the new counter.\n        emit CounterIncremented(newCounter, msg.sender);\n    }\n\n    /**\n     * @dev Internal view function to retrieve the current counter for a given\n     *      offerer.\n     *\n     * @param offerer The offerer in question.\n     *\n     * @return currentCounter The current counter.\n     */\n    function _getCounter(\n        address offerer\n    ) internal view returns (uint256 currentCounter) {\n        // Return the counter for the supplied offerer.\n        currentCounter = _counters[offerer];\n    }\n}\n"},"contracts/conduit/lib/ConduitEnums.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nenum ConduitItemType {\n    NATIVE, // unused\n    ERC20,\n    ERC721,\n    ERC1155\n}\n"},"contracts/lib/Assertions.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { OrderParameters } from \"./ConsiderationStructs.sol\";\n\nimport { GettersAndDerivers } from \"./GettersAndDerivers.sol\";\n\nimport {\n    TokenTransferrerErrors\n} from \"../interfaces/TokenTransferrerErrors.sol\";\n\nimport { CounterManager } from \"./CounterManager.sol\";\n\nimport {\n    AdditionalRecipient_size_shift,\n    AddressDirtyUpperBitThreshold,\n    BasicOrder_additionalRecipients_head_cdPtr,\n    BasicOrder_additionalRecipients_head_ptr,\n    BasicOrder_additionalRecipients_length_cdPtr,\n    BasicOrder_basicOrderType_cdPtr,\n    BasicOrder_basicOrderType_range,\n    BasicOrder_considerationToken_cdPtr,\n    BasicOrder_offerer_cdPtr,\n    BasicOrder_offerToken_cdPtr,\n    BasicOrder_parameters_cdPtr,\n    BasicOrder_parameters_ptr,\n    BasicOrder_signature_cdPtr,\n    BasicOrder_signature_ptr,\n    BasicOrder_zone_cdPtr\n} from \"./ConsiderationConstants.sol\";\n\nimport {\n    Error_selector_offset,\n    MissingItemAmount_error_length,\n    MissingItemAmount_error_selector\n} from \"./ConsiderationErrorConstants.sol\";\n\nimport {\n    _revertInvalidBasicOrderParameterEncoding,\n    _revertMissingOriginalConsiderationItems\n} from \"./ConsiderationErrors.sol\";\n\n/**\n * @title Assertions\n * @author 0age\n * @notice Assertions contains logic for making various assertions that do not\n *         fit neatly within a dedicated semantic scope.\n */\ncontract Assertions is\n    GettersAndDerivers,\n    CounterManager,\n    TokenTransferrerErrors\n{\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(\n        address conduitController\n    ) GettersAndDerivers(conduitController) {}\n\n    /**\n     * @dev Internal view function to ensure that the supplied consideration\n     *      array length on a given set of order parameters is not less than the\n     *      original consideration array length for that order and to retrieve\n     *      the current counter for a given order's offerer and zone and use it\n     *      to derive the order hash.\n     *\n     * @param orderParameters The parameters of the order to hash.\n     *\n     * @return The hash.\n     */\n    function _assertConsiderationLengthAndGetOrderHash(\n        OrderParameters memory orderParameters\n    ) internal view returns (bytes32) {\n        // Ensure supplied consideration array length is not less than original.\n        _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\n            orderParameters.consideration.length,\n            orderParameters.totalOriginalConsiderationItems\n        );\n\n        // Derive and return order hash using current counter for the offerer.\n        return\n            _deriveOrderHash(\n                orderParameters,\n                _getCounter(orderParameters.offerer)\n            );\n    }\n\n    /**\n     * @dev Internal pure function to ensure that the supplied consideration\n     *      array length for an order to be fulfilled is not less than the\n     *      original consideration array length for that order.\n     *\n     * @param suppliedConsiderationItemTotal The number of consideration items\n     *                                       supplied when fulfilling the order.\n     * @param originalConsiderationItemTotal The number of consideration items\n     *                                       supplied on initial order creation.\n     */\n    function _assertConsiderationLengthIsNotLessThanOriginalConsiderationLength(\n        uint256 suppliedConsiderationItemTotal,\n        uint256 originalConsiderationItemTotal\n    ) internal pure {\n        // Ensure supplied consideration array length is not less than original.\n        if (suppliedConsiderationItemTotal < originalConsiderationItemTotal) {\n            _revertMissingOriginalConsiderationItems();\n        }\n    }\n\n    /**\n     * @dev Internal pure function to ensure that a given item amount is not\n     *      zero.\n     *\n     * @param amount The amount to check.\n     */\n    function _assertNonZeroAmount(uint256 amount) internal pure {\n        assembly {\n            if iszero(amount) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, MissingItemAmount_error_selector)\n\n                // revert(abi.encodeWithSignature(\"MissingItemAmount()\"))\n                revert(Error_selector_offset, MissingItemAmount_error_length)\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to validate calldata offsets for dynamic\n     *      types in BasicOrderParameters and other parameters. This ensures\n     *      that functions using the calldata object normally will be using the\n     *      same data as the assembly functions and that values that are bound\n     *      to a given range are within that range. Note that no parameters are\n     *      supplied as all basic order functions use the same calldata\n     *      encoding.\n     */\n    function _assertValidBasicOrderParameters() internal pure {\n        // Declare a boolean designating basic order parameter offset validity.\n        bool validOffsets;\n\n        // Utilize assembly in order to read offset data directly from calldata.\n        assembly {\n            /*\n             * Checks:\n             * 1. Order parameters struct offset == 0x20\n             * 2. Additional recipients arr offset == 0x240\n             * 3. Signature offset == 0x260 + (recipients.length * 0x40)\n             * 4. BasicOrderType between 0 and 23 (i.e. < 24)\n             * 5. Offerer, zone, offer token, and consideration token have no\n             *    upper dirty bits — each argument is type(uint160).max or less\n             */\n            validOffsets := and(\n                and(\n                    and(\n                        // Order parameters at cd 0x04 must have offset of 0x20.\n                        eq(\n                            calldataload(BasicOrder_parameters_cdPtr),\n                            BasicOrder_parameters_ptr\n                        ),\n                        // Additional recipients (cd 0x224) arr offset == 0x240.\n                        eq(\n                            calldataload(\n                                BasicOrder_additionalRecipients_head_cdPtr\n                            ),\n                            BasicOrder_additionalRecipients_head_ptr\n                        )\n                    ),\n                    // Signature offset == 0x260 + (recipients.length * 0x40).\n                    eq(\n                        // Load signature offset from calldata 0x244.\n                        calldataload(BasicOrder_signature_cdPtr),\n                        // Expected offset is start of recipients + len * 64.\n                        add(\n                            BasicOrder_signature_ptr,\n                            shl(\n                                // Each additional recipient has length of 0x40.\n                                AdditionalRecipient_size_shift,\n                                // Additional recipients length at cd 0x264.\n                                calldataload(\n                                    BasicOrder_additionalRecipients_length_cdPtr\n                                )\n                            )\n                        )\n                    )\n                ),\n                and(\n                    // Ensure BasicOrderType parameter is less than 0x18.\n                    lt(\n                        // BasicOrderType parameter at calldata offset 0x124.\n                        calldataload(BasicOrder_basicOrderType_cdPtr),\n                        // Value should be less than 24.\n                        BasicOrder_basicOrderType_range\n                    ),\n                    // Ensure no dirty upper bits are present on offerer, zone,\n                    // offer token, or consideration token.\n                    lt(\n                        or(\n                            or(\n                                // Offerer parameter at calldata offset 0x84.\n                                calldataload(BasicOrder_offerer_cdPtr),\n                                // Zone parameter at calldata offset 0xa4.\n                                calldataload(BasicOrder_zone_cdPtr)\n                            ),\n                            or(\n                                // Offer token parameter at cd offset 0xc4.\n                                calldataload(BasicOrder_offerToken_cdPtr),\n                                // Consideration token parameter at offset 0x24.\n                                calldataload(\n                                    BasicOrder_considerationToken_cdPtr\n                                )\n                            )\n                        ),\n                        AddressDirtyUpperBitThreshold\n                    )\n                )\n            )\n        }\n\n        // Revert with an error if basic order parameter offsets are invalid.\n        if (!validOffsets) {\n            _revertInvalidBasicOrderParameterEncoding();\n        }\n    }\n}\n"},"contracts/lib/Verifiers.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { OrderStatus } from \"./ConsiderationStructs.sol\";\n\nimport { Assertions } from \"./Assertions.sol\";\n\nimport { SignatureVerification } from \"./SignatureVerification.sol\";\n\nimport {\n    _revertInvalidTime,\n    _revertOrderAlreadyFilled,\n    _revertOrderIsCancelled,\n    _revertOrderPartiallyFilled\n} from \"./ConsiderationErrors.sol\";\n\nimport {\n    BulkOrderProof_keyShift,\n    BulkOrderProof_keySize,\n    BulkOrderProof_lengthAdjustmentBeforeMask,\n    BulkOrderProof_lengthRangeAfterMask,\n    BulkOrderProof_minSize,\n    BulkOrderProof_rangeSize,\n    ECDSA_MaxLength,\n    OneWord,\n    OneWordShift,\n    ThirtyOneBytes,\n    TwoWords\n} from \"./ConsiderationConstants.sol\";\n\n/**\n * @title Verifiers\n * @author 0age\n * @notice Verifiers contains functions for performing verifications.\n */\ncontract Verifiers is Assertions, SignatureVerification {\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) Assertions(conduitController) {}\n\n    /**\n     * @dev Internal view function to ensure that the current time falls within\n     *      an order's valid timespan.\n     *\n     * @param startTime       The time at which the order becomes active.\n     * @param endTime         The time at which the order becomes inactive.\n     * @param revertOnInvalid A boolean indicating whether to revert if the\n     *                        order is not active.\n     *\n     * @return valid A boolean indicating whether the order is active.\n     */\n    function _verifyTime(\n        uint256 startTime,\n        uint256 endTime,\n        bool revertOnInvalid\n    ) internal view returns (bool valid) {\n        // Mark as valid if order has started and has not already ended.\n        assembly {\n            valid := and(\n                iszero(gt(startTime, timestamp())),\n                gt(endTime, timestamp())\n            )\n        }\n\n        // Only revert on invalid if revertOnInvalid has been supplied as true.\n        if (revertOnInvalid && !valid) {\n            _revertInvalidTime(startTime, endTime);\n        }\n    }\n\n    /**\n     * @dev Internal view function to verify the signature of an order. An\n     *      ERC-1271 fallback will be attempted if either the signature length\n     *      is not 64 or 65 bytes or if the recovered signer does not match the\n     *      supplied offerer. Note that in cases where a 64 or 65 byte signature\n     *      is supplied, only standard ECDSA signatures that recover to a\n     *      non-zero address are supported.\n     *\n     * @param offerer   The offerer for the order.\n     * @param orderHash The order hash.\n     * @param signature A signature from the offerer indicating that the order\n     *                  has been approved.\n     */\n    function _verifySignature(\n        address offerer,\n        bytes32 orderHash,\n        bytes memory signature\n    ) internal view {\n        // Determine whether the offerer is the caller.\n        bool offererIsCaller;\n        assembly {\n            offererIsCaller := eq(offerer, caller())\n        }\n\n        // Skip signature verification if the offerer is the caller.\n        if (offererIsCaller) {\n            return;\n        }\n\n        // Derive the EIP-712 domain separator.\n        bytes32 domainSeparator = _domainSeparator();\n\n        // Derive original EIP-712 digest using domain separator and order hash.\n        bytes32 originalDigest = _deriveEIP712Digest(\n            domainSeparator,\n            orderHash\n        );\n\n        // Read the length of the signature from memory and place on the stack.\n        uint256 originalSignatureLength = signature.length;\n\n        // Determine effective digest if signature has a valid bulk order size.\n        bytes32 digest;\n        if (_isValidBulkOrderSize(originalSignatureLength)) {\n            // Rederive order hash and digest using bulk order proof.\n            (orderHash) = _computeBulkOrderProof(signature, orderHash);\n            digest = _deriveEIP712Digest(domainSeparator, orderHash);\n        } else {\n            // Supply the original digest as the effective digest.\n            digest = originalDigest;\n        }\n\n        // Ensure that the signature for the digest is valid for the offerer.\n        _assertValidSignature(\n            offerer,\n            digest,\n            originalDigest,\n            originalSignatureLength,\n            signature\n        );\n    }\n\n    /**\n     * @dev Determines whether the specified bulk order size is valid.\n     *\n     * @param signatureLength The signature length of the bulk order to check.\n     *\n     * @return validLength True if bulk order size is valid, false otherwise.\n     */\n    function _isValidBulkOrderSize(\n        uint256 signatureLength\n    ) internal pure returns (bool validLength) {\n        // Utilize assembly to validate the length; the equivalent logic is\n        // (64 + x) + 3 + 32y where (0 <= x <= 1) and (1 <= y <= 24).\n        assembly {\n            validLength := and(\n                lt(\n                    sub(signatureLength, BulkOrderProof_minSize),\n                    BulkOrderProof_rangeSize\n                ),\n                lt(\n                    and(\n                        add(\n                            signatureLength,\n                            BulkOrderProof_lengthAdjustmentBeforeMask\n                        ),\n                        ThirtyOneBytes\n                    ),\n                    BulkOrderProof_lengthRangeAfterMask\n                )\n            )\n        }\n    }\n\n    /**\n     * @dev Computes the bulk order hash for the specified proof and leaf. Note\n     *      that if an index that exceeds the number of orders in the bulk order\n     *      payload will instead \"wrap around\" and refer to an earlier index.\n     *\n     * @param proofAndSignature The proof and signature of the bulk order.\n     * @param leaf              The leaf of the bulk order tree.\n     *\n     * @return bulkOrderHash The bulk order hash.\n     */\n    function _computeBulkOrderProof(\n        bytes memory proofAndSignature,\n        bytes32 leaf\n    ) internal pure returns (bytes32 bulkOrderHash) {\n        // Declare arguments for the root hash and the height of the proof.\n        bytes32 root;\n        uint256 height;\n\n        // Utilize assembly to efficiently derive the root hash using the proof.\n        assembly {\n            // Retrieve the length of the proof, key, and signature combined.\n            let fullLength := mload(proofAndSignature)\n\n            // If proofAndSignature has odd length, it is a compact signature\n            // with 64 bytes.\n            let signatureLength := sub(ECDSA_MaxLength, and(fullLength, 1))\n\n            // Derive height (or depth of tree) with signature and proof length.\n            height := shr(OneWordShift, sub(fullLength, signatureLength))\n\n            // Update the length in memory to only include the signature.\n            mstore(proofAndSignature, signatureLength)\n\n            // Derive the pointer for the key using the signature length.\n            let keyPtr := add(proofAndSignature, add(OneWord, signatureLength))\n\n            // Retrieve the three-byte key using the derived pointer.\n            let key := shr(BulkOrderProof_keyShift, mload(keyPtr))\n\n            /// Retrieve pointer to first proof element by applying a constant\n            // for the key size to the derived key pointer.\n            let proof := add(keyPtr, BulkOrderProof_keySize)\n\n            // Compute level 1.\n            let scratchPtr1 := shl(OneWordShift, and(key, 1))\n            mstore(scratchPtr1, leaf)\n            mstore(xor(scratchPtr1, OneWord), mload(proof))\n\n            // Compute remaining proofs.\n            for {\n                let i := 1\n            } lt(i, height) {\n                i := add(i, 1)\n            } {\n                proof := add(proof, OneWord)\n                let scratchPtr := shl(OneWordShift, and(shr(i, key), 1))\n                mstore(scratchPtr, keccak256(0, TwoWords))\n                mstore(xor(scratchPtr, OneWord), mload(proof))\n            }\n\n            // Compute root hash.\n            root := keccak256(0, TwoWords)\n        }\n\n        // Retrieve appropriate typehash constant based on height.\n        bytes32 rootTypeHash = _lookupBulkOrderTypehash(height);\n\n        // Use the typehash and the root hash to derive final bulk order hash.\n        assembly {\n            mstore(0, rootTypeHash)\n            mstore(OneWord, root)\n            bulkOrderHash := keccak256(0, TwoWords)\n        }\n    }\n\n    /**\n     * @dev Internal view function to validate that a given order is fillable\n     *      and not cancelled based on the order status.\n     *\n     * @param orderHash       The order hash.\n     * @param orderStatus     The status of the order, including whether it has\n     *                        been cancelled and the fraction filled.\n     * @param onlyAllowUnused A boolean flag indicating whether partial fills\n     *                        are supported by the calling function.\n     * @param revertOnInvalid A boolean indicating whether to revert if the\n     *                        order has been cancelled or filled beyond the\n     *                        allowable amount.\n     *\n     * @return valid A boolean indicating whether the order is valid.\n     */\n    function _verifyOrderStatus(\n        bytes32 orderHash,\n        OrderStatus storage orderStatus,\n        bool onlyAllowUnused,\n        bool revertOnInvalid\n    ) internal view returns (bool valid) {\n        // Ensure that the order has not been cancelled.\n        if (orderStatus.isCancelled) {\n            // Only revert if revertOnInvalid has been supplied as true.\n            if (revertOnInvalid) {\n                _revertOrderIsCancelled(orderHash);\n            }\n\n            // Return false as the order status is invalid.\n            return false;\n        }\n\n        // Read order status numerator from storage and place on stack.\n        uint256 orderStatusNumerator = orderStatus.numerator;\n\n        // If the order is not entirely unused...\n        if (orderStatusNumerator != 0) {\n            // ensure the order has not been partially filled when not allowed.\n            if (onlyAllowUnused) {\n                // Always revert on partial fills when onlyAllowUnused is true.\n                _revertOrderPartiallyFilled(orderHash);\n            }\n            // Otherwise, ensure that order has not been entirely filled.\n            else if (orderStatusNumerator >= orderStatus.denominator) {\n                // Only revert if revertOnInvalid has been supplied as true.\n                if (revertOnInvalid) {\n                    _revertOrderAlreadyFilled(orderHash);\n                }\n\n                // Return false as the order status is invalid.\n                return false;\n            }\n        }\n\n        // Return true as the order status is valid.\n        valid = true;\n    }\n}\n"},"contracts/interfaces/SignatureVerificationErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title SignatureVerificationErrors\n * @author 0age\n * @notice SignatureVerificationErrors contains all errors related to signature\n *         verification.\n */\ninterface SignatureVerificationErrors {\n    /**\n     * @dev Revert with an error when a signature that does not contain a v\n     *      value of 27 or 28 has been supplied.\n     *\n     * @param v The invalid v value.\n     */\n    error BadSignatureV(uint8 v);\n\n    /**\n     * @dev Revert with an error when the signer recovered by the supplied\n     *      signature does not match the offerer or an allowed EIP-1271 signer\n     *      as specified by the offerer in the event they are a contract.\n     */\n    error InvalidSigner();\n\n    /**\n     * @dev Revert with an error when a signer cannot be recovered from the\n     *      supplied signature.\n     */\n    error InvalidSignature();\n\n    /**\n     * @dev Revert with an error when an EIP-1271 call to an account fails.\n     */\n    error BadContractSignature();\n}\n"},"contracts/interfaces/ConduitInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    ConduitBatch1155Transfer,\n    ConduitTransfer\n} from \"../conduit/lib/ConduitStructs.sol\";\n\n/**\n * @title ConduitInterface\n * @author 0age\n * @notice ConduitInterface contains all external function interfaces, events,\n *         and errors for conduit contracts.\n */\ninterface ConduitInterface {\n    /**\n     * @dev Revert with an error when attempting to execute transfers using a\n     *      caller that does not have an open channel.\n     */\n    error ChannelClosed(address channel);\n\n    /**\n     * @dev Revert with an error when attempting to update a channel to the\n     *      current status of that channel.\n     */\n    error ChannelStatusAlreadySet(address channel, bool isOpen);\n\n    /**\n     * @dev Revert with an error when attempting to execute a transfer for an\n     *      item that does not have an ERC20/721/1155 item type.\n     */\n    error InvalidItemType();\n\n    /**\n     * @dev Revert with an error when attempting to update the status of a\n     *      channel from a caller that is not the conduit controller.\n     */\n    error InvalidController();\n\n    /**\n     * @dev Emit an event whenever a channel is opened or closed.\n     *\n     * @param channel The channel that has been updated.\n     * @param open    A boolean indicating whether the conduit is open or not.\n     */\n    event ChannelUpdated(address indexed channel, bool open);\n\n    /**\n     * @notice Execute a sequence of ERC20/721/1155 transfers. Only a caller\n     *         with an open channel can call this function.\n     *\n     * @param transfers The ERC20/721/1155 transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function execute(\n        ConduitTransfer[] calldata transfers\n    ) external returns (bytes4 magicValue);\n\n    /**\n     * @notice Execute a sequence of batch 1155 transfers. Only a caller with an\n     *         open channel can call this function.\n     *\n     * @param batch1155Transfers The 1155 batch transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function executeBatch1155(\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\n    ) external returns (bytes4 magicValue);\n\n    /**\n     * @notice Execute a sequence of transfers, both single and batch 1155. Only\n     *         a caller with an open channel can call this function.\n     *\n     * @param standardTransfers  The ERC20/721/1155 transfers to perform.\n     * @param batch1155Transfers The 1155 batch transfers to perform.\n     *\n     * @return magicValue A magic value indicating that the transfers were\n     *                    performed successfully.\n     */\n    function executeWithBatch1155(\n        ConduitTransfer[] calldata standardTransfers,\n        ConduitBatch1155Transfer[] calldata batch1155Transfers\n    ) external returns (bytes4 magicValue);\n\n    /**\n     * @notice Open or close a given channel. Only callable by the controller.\n     *\n     * @param channel The channel to open or close.\n     * @param isOpen  The status of the channel (either open or closed).\n     */\n    function updateChannel(address channel, bool isOpen) external;\n}\n"},"contracts/lib/FulfillmentApplier.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ItemType, Side } from \"./ConsiderationEnums.sol\";\n\nimport {\n    AdvancedOrder,\n    Execution,\n    FulfillmentComponent,\n    ReceivedItem\n} from \"./ConsiderationStructs.sol\";\n\nimport {\n    _revertMismatchedFulfillmentOfferAndConsiderationComponents,\n    _revertMissingFulfillmentComponentOnAggregation,\n    _revertOfferAndConsiderationRequiredOnFulfillment\n} from \"./ConsiderationErrors.sol\";\n\nimport {\n    FulfillmentApplicationErrors\n} from \"../interfaces/FulfillmentApplicationErrors.sol\";\n\nimport {\n    AdvancedOrder_numerator_offset,\n    Common_amount_offset,\n    Common_identifier_offset,\n    Common_token_offset,\n    Execution_conduit_offset,\n    Execution_offerer_offset,\n    Fulfillment_itemIndex_offset,\n    OneWord,\n    OneWordShift,\n    OrderParameters_conduit_offset,\n    OrderParameters_consideration_head_offset,\n    OrderParameters_offer_head_offset,\n    ReceivedItem_CommonParams_size,\n    ReceivedItem_recipient_offset,\n    ReceivedItem_size\n} from \"./ConsiderationConstants.sol\";\n\nimport {\n    Error_selector_offset,\n    InvalidFulfillmentComponentData_error_length,\n    InvalidFulfillmentComponentData_error_selector,\n    MissingItemAmount_error_length,\n    MissingItemAmount_error_selector,\n    Panic_arithmetic,\n    Panic_error_code_ptr,\n    Panic_error_length,\n    Panic_error_selector\n} from \"./ConsiderationErrorConstants.sol\";\n\n/**\n * @title FulfillmentApplier\n * @author 0age\n * @notice FulfillmentApplier contains logic related to applying fulfillments,\n *         both as part of order matching (where offer items are matched to\n *         consideration items) as well as fulfilling available orders (where\n *         order items and consideration items are independently aggregated).\n */\ncontract FulfillmentApplier is FulfillmentApplicationErrors {\n    /**\n     * @dev Internal pure function to match offer items to consideration items\n     *      on a group of orders via a supplied fulfillment.\n     *\n     * @param advancedOrders          The orders to match.\n     * @param offerComponents         An array designating offer components to\n     *                                match to consideration components.\n     * @param considerationComponents An array designating consideration\n     *                                components to match to offer components.\n     *                                Note that each consideration amount must\n     *                                be zero in order for the match operation\n     *                                to be valid.\n     * @param fulfillmentIndex        The index of the fulfillment being\n     *                                applied.\n     *\n     * @return execution The transfer performed as a result of the fulfillment.\n     */\n    function _applyFulfillment(\n        AdvancedOrder[] memory advancedOrders,\n        FulfillmentComponent[] memory offerComponents,\n        FulfillmentComponent[] memory considerationComponents,\n        uint256 fulfillmentIndex\n    ) internal pure returns (Execution memory execution) {\n        // Ensure 1+ of both offer and consideration components are supplied.\n        if (\n            offerComponents.length == 0 || considerationComponents.length == 0\n        ) {\n            _revertOfferAndConsiderationRequiredOnFulfillment();\n        }\n\n        // Declare a new Execution struct.\n        Execution memory considerationExecution;\n\n        // Validate & aggregate consideration items to new Execution object.\n        _aggregateValidFulfillmentConsiderationItems(\n            advancedOrders,\n            considerationComponents,\n            considerationExecution\n        );\n\n        // Retrieve the consideration item from the execution struct.\n        ReceivedItem memory considerationItem = considerationExecution.item;\n\n        // Skip aggregating offer items if no consideration items are available.\n        if (considerationItem.amount == 0) {\n            // Set the offerer and recipient to null address and the item type\n            // to a non-native item type if the execution amount is zero. This\n            // will cause the execution item to be skipped.\n            considerationExecution.offerer = address(0);\n            considerationExecution.item.recipient = payable(0);\n            considerationExecution.item.itemType = ItemType.ERC20;\n            return considerationExecution;\n        }\n\n        // Recipient does not need to be specified because it will always be set\n        // to that of the consideration.\n        // Validate & aggregate offer items to Execution object.\n        _aggregateValidFulfillmentOfferItems(\n            advancedOrders,\n            offerComponents,\n            execution\n        );\n\n        // Ensure offer & consideration item types, tokens, & identifiers match.\n        // (a != b || c != d || e != f) == (((a ^ b) | (c ^ d) | (e ^ f)) != 0),\n        // but the second expression requires less gas to evaluate.\n        if (\n            ((uint8(execution.item.itemType) ^\n                uint8(considerationItem.itemType)) |\n                (uint160(execution.item.token) ^\n                    uint160(considerationItem.token)) |\n                (execution.item.identifier ^ considerationItem.identifier)) != 0\n        ) {\n            _revertMismatchedFulfillmentOfferAndConsiderationComponents(\n                fulfillmentIndex\n            );\n        }\n\n        // If total consideration amount exceeds the offer amount...\n        if (considerationItem.amount > execution.item.amount) {\n            // Retrieve the first consideration component from the fulfillment.\n            FulfillmentComponent memory targetComponent = (\n                considerationComponents[0]\n            );\n\n            // Skip underflow check as the conditional being true implies that\n            // considerationItem.amount > execution.item.amount.\n            unchecked {\n                // Add excess consideration item amount to original order array.\n                advancedOrders[targetComponent.orderIndex]\n                    .parameters\n                    .consideration[targetComponent.itemIndex]\n                    .startAmount = (considerationItem.amount -\n                    execution.item.amount);\n            }\n        } else {\n            // Retrieve the first offer component from the fulfillment.\n            FulfillmentComponent memory targetComponent = offerComponents[0];\n\n            // Skip underflow check as the conditional being false implies that\n            // execution.item.amount >= considerationItem.amount.\n            unchecked {\n                // Add excess offer item amount to the original array of orders.\n                advancedOrders[targetComponent.orderIndex]\n                    .parameters\n                    .offer[targetComponent.itemIndex]\n                    .startAmount = (execution.item.amount -\n                    considerationItem.amount);\n            }\n\n            // Reduce total offer amount to equal the consideration amount.\n            execution.item.amount = considerationItem.amount;\n        }\n\n        // Reuse consideration recipient.\n        execution.item.recipient = considerationItem.recipient;\n\n        // Return the final execution that will be triggered for relevant items.\n        return execution; // Execution(considerationItem, offerer, conduitKey);\n    }\n\n    /**\n     * @dev Internal view function to aggregate offer or consideration items\n     *      from a group of orders into a single execution via a supplied array\n     *      of fulfillment components. Items that are not available to aggregate\n     *      will not be included in the aggregated execution.\n     *\n     * @param advancedOrders        The orders to aggregate.\n     * @param side                  The side (i.e. offer or consideration).\n     * @param fulfillmentComponents An array designating item components to\n     *                              aggregate if part of an available order.\n     * @param fulfillerConduitKey   A bytes32 value indicating what conduit, if\n     *                              any, to source the fulfiller's token\n     *                              approvals from. The zero hash signifies that\n     *                              no conduit should be used, with approvals\n     *                              set directly on this contract.\n     * @param recipient             The intended recipient for all received\n     *                              items.\n     *\n     * @return execution The transfer performed as a result of the fulfillment.\n     */\n    function _aggregateAvailable(\n        AdvancedOrder[] memory advancedOrders,\n        Side side,\n        FulfillmentComponent[] memory fulfillmentComponents,\n        bytes32 fulfillerConduitKey,\n        address recipient\n    ) internal view returns (Execution memory execution) {\n        // Skip overflow / underflow checks; conditions checked or unreachable.\n        unchecked {\n            // Retrieve fulfillment components array length and place on stack.\n            // Ensure at least one fulfillment component has been supplied.\n            if (fulfillmentComponents.length == 0) {\n                _revertMissingFulfillmentComponentOnAggregation(side);\n            }\n\n            // Retrieve the received item on the execution being returned.\n            ReceivedItem memory item = execution.item;\n\n            // If the fulfillment components are offer components...\n            if (side == Side.OFFER) {\n                // Set the supplied recipient on the execution item.\n                item.recipient = payable(recipient);\n\n                // Return execution for aggregated items provided by offerer.\n                _aggregateValidFulfillmentOfferItems(\n                    advancedOrders,\n                    fulfillmentComponents,\n                    execution\n                );\n            } else {\n                // Otherwise, fulfillment components are consideration\n                // components. Return execution for aggregated items provided by\n                // the fulfiller.\n                _aggregateValidFulfillmentConsiderationItems(\n                    advancedOrders,\n                    fulfillmentComponents,\n                    execution\n                );\n\n                // Set the caller as the offerer on the execution.\n                execution.offerer = msg.sender;\n\n                // Set fulfiller conduit key as the conduit key on execution.\n                execution.conduitKey = fulfillerConduitKey;\n            }\n\n            // Set the offerer and recipient to null address and the item type\n            // to a non-native item type if the execution amount is zero. This\n            // will cause the execution item to be skipped.\n            if (item.amount == 0) {\n                execution.offerer = address(0);\n                item.recipient = payable(0);\n                item.itemType = ItemType.ERC20;\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to aggregate a group of offer items using\n     *      supplied directives on which component items are candidates for\n     *      aggregation, skipping items on orders that are not available.\n     *\n     * @param advancedOrders  The orders to aggregate offer items from.\n     * @param offerComponents An array of FulfillmentComponent structs\n     *                        indicating the order index and item index of each\n     *                        candidate offer item for aggregation.\n     * @param execution       The execution to apply the aggregation to.\n     */\n    function _aggregateValidFulfillmentOfferItems(\n        AdvancedOrder[] memory advancedOrders,\n        FulfillmentComponent[] memory offerComponents,\n        Execution memory execution\n    ) internal pure {\n        assembly {\n            // Declare a variable for the final aggregated item amount.\n            let amount\n\n            // Declare a variable to track errors encountered with amount.\n            let errorBuffer\n\n            // Declare a variable for the hash of itemType, token, & identifier.\n            let dataHash\n\n            // Iterate over each offer component.\n            for {\n                // Create variable to track position in offerComponents head.\n                let fulfillmentHeadPtr := offerComponents\n\n                // Get position one word past last element in head of array.\n                let endPtr := add(\n                    offerComponents,\n                    shl(OneWordShift, mload(offerComponents))\n                )\n            } lt(fulfillmentHeadPtr, endPtr) {\n\n            } {\n                // Increment position in considerationComponents head.\n                fulfillmentHeadPtr := add(fulfillmentHeadPtr, OneWord)\n\n                // Retrieve the order index using the fulfillment pointer.\n                let orderIndex := mload(mload(fulfillmentHeadPtr))\n\n                // Ensure that the order index is not out of range.\n                if iszero(lt(orderIndex, mload(advancedOrders))) {\n                    throwInvalidFulfillmentComponentData()\n                }\n\n                // Read advancedOrders[orderIndex] pointer from its array head.\n                let orderPtr := mload(\n                    // Calculate head position of advancedOrders[orderIndex].\n                    add(\n                        add(advancedOrders, OneWord),\n                        shl(OneWordShift, orderIndex)\n                    )\n                )\n\n                // Read the pointer to OrderParameters from the AdvancedOrder.\n                let paramsPtr := mload(orderPtr)\n\n                // Retrieve item index using an offset of fulfillment pointer.\n                let itemIndex := mload(\n                    add(mload(fulfillmentHeadPtr), Fulfillment_itemIndex_offset)\n                )\n\n                let offerItemPtr\n                {\n                    // Load the offer array pointer.\n                    let offerArrPtr := mload(\n                        add(paramsPtr, OrderParameters_offer_head_offset)\n                    )\n\n                    // If the offer item index is out of range or the numerator\n                    // is zero, skip this item.\n                    if or(\n                        iszero(lt(itemIndex, mload(offerArrPtr))),\n                        iszero(\n                            mload(add(orderPtr, AdvancedOrder_numerator_offset))\n                        )\n                    ) {\n                        continue\n                    }\n\n                    // Retrieve offer item pointer using the item index.\n                    offerItemPtr := mload(\n                        add(\n                            // Get pointer to beginning of receivedItem.\n                            add(offerArrPtr, OneWord),\n                            // Calculate offset to pointer for desired order.\n                            shl(OneWordShift, itemIndex)\n                        )\n                    )\n                }\n\n                // Declare a separate scope for the amount update.\n                {\n                    // Retrieve amount pointer using consideration item pointer.\n                    let amountPtr := add(offerItemPtr, Common_amount_offset)\n\n                    // Add offer item amount to execution amount.\n                    let newAmount := add(amount, mload(amountPtr))\n\n                    // Update error buffer:\n                    // 1 = zero amount, 2 = overflow, 3 = both.\n                    errorBuffer := or(\n                        errorBuffer,\n                        or(\n                            shl(1, lt(newAmount, amount)),\n                            iszero(mload(amountPtr))\n                        )\n                    )\n\n                    // Update the amount to the new, summed amount.\n                    amount := newAmount\n\n                    // Zero out amount on original item to indicate it is spent.\n                    mstore(amountPtr, 0)\n                }\n\n                // Retrieve ReceivedItem pointer from Execution.\n                let receivedItem := mload(execution)\n\n                // Check if this is the first valid fulfillment item.\n                switch iszero(dataHash)\n                case 1 {\n                    // On first valid item, populate the received item in memory\n                    // for later comparison.\n\n                    // Set the item type on the received item.\n                    mstore(receivedItem, mload(offerItemPtr))\n\n                    // Set the token on the received item.\n                    mstore(\n                        add(receivedItem, Common_token_offset),\n                        mload(add(offerItemPtr, Common_token_offset))\n                    )\n\n                    // Set the identifier on the received item.\n                    mstore(\n                        add(receivedItem, Common_identifier_offset),\n                        mload(add(offerItemPtr, Common_identifier_offset))\n                    )\n\n                    // Set offerer on returned execution using order pointer.\n                    mstore(\n                        add(execution, Execution_offerer_offset),\n                        mload(paramsPtr)\n                    )\n\n                    // Set execution conduitKey via order pointer offset.\n                    mstore(\n                        add(execution, Execution_conduit_offset),\n                        mload(add(paramsPtr, OrderParameters_conduit_offset))\n                    )\n\n                    // Calculate the hash of (itemType, token, identifier).\n                    dataHash := keccak256(\n                        receivedItem,\n                        ReceivedItem_CommonParams_size\n                    )\n\n                    // If component index > 0, swap component pointer with\n                    // pointer to first component so that any remainder after\n                    // fulfillment can be added back to the first item.\n                    let firstFulfillmentHeadPtr := add(offerComponents, OneWord)\n                    if xor(firstFulfillmentHeadPtr, fulfillmentHeadPtr) {\n                        let firstFulfillmentPtr := mload(\n                            firstFulfillmentHeadPtr\n                        )\n                        let fulfillmentPtr := mload(fulfillmentHeadPtr)\n                        mstore(firstFulfillmentHeadPtr, fulfillmentPtr)\n                    }\n                }\n                default {\n                    // Compare every subsequent item to the first.\n                    if or(\n                        or(\n                            // The offerer must match on both items.\n                            xor(\n                                mload(paramsPtr),\n                                mload(add(execution, Execution_offerer_offset))\n                            ),\n                            // The conduit key must match on both items.\n                            xor(\n                                mload(\n                                    add(\n                                        paramsPtr,\n                                        OrderParameters_conduit_offset\n                                    )\n                                ),\n                                mload(add(execution, Execution_conduit_offset))\n                            )\n                        ),\n                        // The itemType, token, and identifier must match.\n                        xor(\n                            dataHash,\n                            keccak256(\n                                offerItemPtr,\n                                ReceivedItem_CommonParams_size\n                            )\n                        )\n                    ) {\n                        // Throw if any of the requirements are not met.\n                        throwInvalidFulfillmentComponentData()\n                    }\n                }\n            }\n\n            // Write final amount to execution.\n            mstore(add(mload(execution), Common_amount_offset), amount)\n\n            // Determine whether the error buffer contains a nonzero error code.\n            if errorBuffer {\n                // If errorBuffer is 1, an item had an amount of zero.\n                if eq(errorBuffer, 1) {\n                    // Store left-padded selector with push4 (reduces bytecode)\n                    // mem[28:32] = selector\n                    mstore(0, MissingItemAmount_error_selector)\n\n                    // revert(abi.encodeWithSignature(\"MissingItemAmount()\"))\n                    revert(\n                        Error_selector_offset,\n                        MissingItemAmount_error_length\n                    )\n                }\n\n                // If errorBuffer is not 1 or 0, the sum overflowed.\n                // Panic!\n                throwOverflow()\n            }\n\n            // Declare function for reverts on invalid fulfillment data.\n            function throwInvalidFulfillmentComponentData() {\n                // Store left-padded selector (uses push4 and reduces code size)\n                mstore(0, InvalidFulfillmentComponentData_error_selector)\n\n                // revert(abi.encodeWithSignature(\n                //     \"InvalidFulfillmentComponentData()\"\n                // ))\n                revert(\n                    Error_selector_offset,\n                    InvalidFulfillmentComponentData_error_length\n                )\n            }\n\n            // Declare function for reverts due to arithmetic overflows.\n            function throwOverflow() {\n                // Store the Panic error signature.\n                mstore(0, Panic_error_selector)\n                // Store the arithmetic (0x11) panic code.\n                mstore(Panic_error_code_ptr, Panic_arithmetic)\n                // revert(abi.encodeWithSignature(\"Panic(uint256)\", 0x11))\n                revert(Error_selector_offset, Panic_error_length)\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to aggregate a group of consideration items\n     *      using supplied directives on which component items are candidates\n     *      for aggregation, skipping items on orders that are not available.\n     *      Note that this function depends on memory layout affected by an\n     *      earlier call to _validateOrdersAndPrepareToFulfill.  The memory for\n     *      the consideration arrays needs to be updated before calling\n     *      _aggregateValidFulfillmentConsiderationItems.\n     *      _validateOrdersAndPrepareToFulfill is called in _matchAdvancedOrders\n     *      and _fulfillAvailableAdvancedOrders in the current version.\n     *\n     * @param advancedOrders          The orders to aggregate consideration\n     *                                items from.\n     * @param considerationComponents An array of FulfillmentComponent structs\n     *                                indicating the order index and item index\n     *                                of each candidate consideration item for\n     *                                aggregation.\n     * @param execution               The execution to apply the aggregation to.\n     */\n    function _aggregateValidFulfillmentConsiderationItems(\n        AdvancedOrder[] memory advancedOrders,\n        FulfillmentComponent[] memory considerationComponents,\n        Execution memory execution\n    ) internal pure {\n        // Utilize assembly in order to efficiently aggregate the items.\n        assembly {\n            // Declare a variable for the final aggregated item amount.\n            let amount\n\n            // Create variable to track errors encountered with amount.\n            let errorBuffer\n\n            // Declare variable for hash(itemType, token, identifier, recipient)\n            let dataHash\n\n            // Iterate over each consideration component.\n            for {\n                // Track position in considerationComponents head.\n                let fulfillmentHeadPtr := considerationComponents\n\n                // Get position one word past last element in head of array.\n                let endPtr := add(\n                    considerationComponents,\n                    shl(OneWordShift, mload(considerationComponents))\n                )\n            } lt(fulfillmentHeadPtr, endPtr) {\n\n            } {\n                // Increment position in considerationComponents head.\n                fulfillmentHeadPtr := add(fulfillmentHeadPtr, OneWord)\n\n                // Retrieve the order index using the fulfillment pointer.\n                let orderIndex := mload(mload(fulfillmentHeadPtr))\n\n                // Ensure that the order index is not out of range.\n                if iszero(lt(orderIndex, mload(advancedOrders))) {\n                    throwInvalidFulfillmentComponentData()\n                }\n\n                // Read advancedOrders[orderIndex] pointer from its array head.\n                let orderPtr := mload(\n                    // Calculate head position of advancedOrders[orderIndex].\n                    add(\n                        add(advancedOrders, OneWord),\n                        shl(OneWordShift, orderIndex)\n                    )\n                )\n\n                // Retrieve item index using an offset of fulfillment pointer.\n                let itemIndex := mload(\n                    add(mload(fulfillmentHeadPtr), Fulfillment_itemIndex_offset)\n                )\n\n                let considerationItemPtr\n                {\n                    // Load consideration array pointer.\n                    let considerationArrPtr := mload(\n                        add(\n                            // Read OrderParameters pointer from AdvancedOrder.\n                            mload(orderPtr),\n                            OrderParameters_consideration_head_offset\n                        )\n                    )\n\n                    // If the consideration item index is out of range or the\n                    // numerator is zero, skip this item.\n                    if or(\n                        iszero(lt(itemIndex, mload(considerationArrPtr))),\n                        iszero(\n                            mload(add(orderPtr, AdvancedOrder_numerator_offset))\n                        )\n                    ) {\n                        continue\n                    }\n\n                    // Retrieve consideration item pointer using the item index.\n                    considerationItemPtr := mload(\n                        add(\n                            // Get pointer to beginning of receivedItem.\n                            add(considerationArrPtr, OneWord),\n                            // Calculate offset to pointer for desired order.\n                            shl(OneWordShift, itemIndex)\n                        )\n                    )\n                }\n\n                // Declare a separate scope for the amount update.\n                {\n                    // Retrieve amount pointer using consideration item pointer.\n                    let amountPtr := add(\n                        considerationItemPtr,\n                        Common_amount_offset\n                    )\n\n                    // Add consideration item amount to execution amount.\n                    let newAmount := add(amount, mload(amountPtr))\n\n                    // Update error buffer:\n                    // 1 = zero amount, 2 = overflow, 3 = both.\n                    errorBuffer := or(\n                        errorBuffer,\n                        or(\n                            shl(1, lt(newAmount, amount)),\n                            iszero(mload(amountPtr))\n                        )\n                    )\n\n                    // Update the amount to the new, summed amount.\n                    amount := newAmount\n\n                    // Zero out original item amount to indicate it is credited.\n                    mstore(amountPtr, 0)\n                }\n\n                // Retrieve ReceivedItem pointer from Execution.\n                let receivedItem := mload(execution)\n\n                switch iszero(dataHash)\n                case 1 {\n                    // On first valid item, populate the received item in\n                    // memory for later comparison.\n\n                    // Set the item type on the received item.\n                    mstore(receivedItem, mload(considerationItemPtr))\n\n                    // Set the token on the received item.\n                    mstore(\n                        add(receivedItem, Common_token_offset),\n                        mload(add(considerationItemPtr, Common_token_offset))\n                    )\n\n                    // Set the identifier on the received item.\n                    mstore(\n                        add(receivedItem, Common_identifier_offset),\n                        mload(\n                            add(considerationItemPtr, Common_identifier_offset)\n                        )\n                    )\n\n                    // Set the recipient on the received item. Note that this\n                    // depends on the memory layout established by the\n                    // _validateOrdersAndPrepareToFulfill function.\n                    mstore(\n                        add(receivedItem, ReceivedItem_recipient_offset),\n                        mload(\n                            add(\n                                considerationItemPtr,\n                                ReceivedItem_recipient_offset\n                            )\n                        )\n                    )\n\n                    // Calculate the hash of (itemType, token, identifier,\n                    // recipient). This is run after amount is set to zero, so\n                    // there will be one blank word after identifier included in\n                    // the hash buffer.\n                    dataHash := keccak256(\n                        considerationItemPtr,\n                        ReceivedItem_size\n                    )\n\n                    // If component index > 0, swap component pointer with\n                    // pointer to first component so that any remainder after\n                    // fulfillment can be added back to the first item.\n                    let firstFulfillmentHeadPtr := add(\n                        considerationComponents,\n                        OneWord\n                    )\n                    if xor(firstFulfillmentHeadPtr, fulfillmentHeadPtr) {\n                        let firstFulfillmentPtr := mload(\n                            firstFulfillmentHeadPtr\n                        )\n                        let fulfillmentPtr := mload(fulfillmentHeadPtr)\n                        mstore(firstFulfillmentHeadPtr, fulfillmentPtr)\n                    }\n                }\n                default {\n                    // Compare every subsequent item to the first; the item\n                    // type, token, identifier and recipient must match.\n                    if xor(\n                        dataHash,\n                        // Calculate the hash of (itemType, token, identifier,\n                        // recipient). This is run after amount is set to zero,\n                        // so there will be one blank word after identifier\n                        // included in the hash buffer.\n                        keccak256(considerationItemPtr, ReceivedItem_size)\n                    ) {\n                        // Throw if any of the requirements are not met.\n                        throwInvalidFulfillmentComponentData()\n                    }\n                }\n            }\n\n            // Retrieve ReceivedItem pointer from Execution.\n            let receivedItem := mload(execution)\n\n            // Write final amount to execution.\n            mstore(add(receivedItem, Common_amount_offset), amount)\n\n            // Determine whether the error buffer contains a nonzero error code.\n            if errorBuffer {\n                // If errorBuffer is 1, an item had an amount of zero.\n                if eq(errorBuffer, 1) {\n                    // Store left-padded selector with push4, mem[28:32]\n                    mstore(0, MissingItemAmount_error_selector)\n\n                    // revert(abi.encodeWithSignature(\"MissingItemAmount()\"))\n                    revert(\n                        Error_selector_offset,\n                        MissingItemAmount_error_length\n                    )\n                }\n\n                // If errorBuffer is not 1 or 0, `amount` overflowed.\n                // Panic!\n                throwOverflow()\n            }\n\n            // Declare function for reverts on invalid fulfillment data.\n            function throwInvalidFulfillmentComponentData() {\n                // Store the InvalidFulfillmentComponentData error signature.\n                mstore(0, InvalidFulfillmentComponentData_error_selector)\n\n                // revert(abi.encodeWithSignature(\n                //     \"InvalidFulfillmentComponentData()\"\n                // ))\n                revert(\n                    Error_selector_offset,\n                    InvalidFulfillmentComponentData_error_length\n                )\n            }\n\n            // Declare function for reverts due to arithmetic overflows.\n            function throwOverflow() {\n                // Store the Panic error signature.\n                mstore(0, Panic_error_selector)\n                // Store the arithmetic (0x11) panic code.\n                mstore(Panic_error_code_ptr, Panic_arithmetic)\n                // revert(abi.encodeWithSignature(\"Panic(uint256)\", 0x11))\n                revert(Error_selector_offset, Panic_error_length)\n            }\n        }\n    }\n}\n"},"contracts/lib/Executor.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ConduitInterface } from \"../interfaces/ConduitInterface.sol\";\n\nimport { ConduitItemType } from \"../conduit/lib/ConduitEnums.sol\";\n\nimport { ItemType } from \"./ConsiderationEnums.sol\";\n\nimport { ReceivedItem } from \"./ConsiderationStructs.sol\";\n\nimport { Verifiers } from \"./Verifiers.sol\";\n\nimport { TokenTransferrer } from \"./TokenTransferrer.sol\";\n\nimport {\n    Accumulator_array_length_ptr,\n    Accumulator_array_offset_ptr,\n    Accumulator_array_offset,\n    Accumulator_conduitKey_ptr,\n    Accumulator_itemSizeOffsetDifference,\n    Accumulator_selector_ptr,\n    AccumulatorArmed,\n    AccumulatorDisarmed,\n    Conduit_transferItem_amount_ptr,\n    Conduit_transferItem_from_ptr,\n    Conduit_transferItem_identifier_ptr,\n    Conduit_transferItem_size,\n    Conduit_transferItem_to_ptr,\n    Conduit_transferItem_token_ptr,\n    FreeMemoryPointerSlot,\n    OneWord,\n    TwoWords\n} from \"./ConsiderationConstants.sol\";\n\nimport {\n    Error_selector_offset,\n    NativeTokenTransferGenericFailure_error_account_ptr,\n    NativeTokenTransferGenericFailure_error_amount_ptr,\n    NativeTokenTransferGenericFailure_error_length,\n    NativeTokenTransferGenericFailure_error_selector\n} from \"./ConsiderationErrorConstants.sol\";\n\nimport {\n    _revertInvalidCallToConduit,\n    _revertInvalidConduit,\n    _revertInvalidERC721TransferAmount,\n    _revertUnusedItemParameters\n} from \"./ConsiderationErrors.sol\";\n\n/**\n * @title Executor\n * @author 0age\n * @notice Executor contains functions related to processing executions (i.e.\n *         transferring items, either directly or via conduits).\n */\ncontract Executor is Verifiers, TokenTransferrer {\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) Verifiers(conduitController) {}\n\n    /**\n     * @dev Internal function to transfer a given item, either directly or via\n     *      a corresponding conduit.\n     *\n     * @param item        The item to transfer, including an amount and a\n     *                    recipient.\n     * @param from        The account supplying the item.\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\n     *                    if any, to source token approvals from. The zero hash\n     *                    signifies that no conduit should be used, with direct\n     *                    approvals set on this contract.\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     */\n    function _transfer(\n        ReceivedItem memory item,\n        address from,\n        bytes32 conduitKey,\n        bytes memory accumulator\n    ) internal {\n        // If the item type indicates Ether or a native token...\n        if (item.itemType == ItemType.NATIVE) {\n            // Ensure neither the token nor the identifier parameters are set.\n            if ((uint160(item.token) | item.identifier) != 0) {\n                _revertUnusedItemParameters();\n            }\n\n            // transfer the native tokens to the recipient.\n            _transferNativeTokens(item.recipient, item.amount);\n        } else if (item.itemType == ItemType.ERC20) {\n            // Ensure that no identifier is supplied.\n            if (item.identifier != 0) {\n                _revertUnusedItemParameters();\n            }\n\n            // Transfer ERC20 tokens from the source to the recipient.\n            _transferERC20(\n                item.token,\n                from,\n                item.recipient,\n                item.amount,\n                conduitKey,\n                accumulator\n            );\n        } else if (item.itemType == ItemType.ERC721) {\n            // Transfer ERC721 token from the source to the recipient.\n            _transferERC721(\n                item.token,\n                from,\n                item.recipient,\n                item.identifier,\n                item.amount,\n                conduitKey,\n                accumulator\n            );\n        } else {\n            // Transfer ERC1155 token from the source to the recipient.\n            _transferERC1155(\n                item.token,\n                from,\n                item.recipient,\n                item.identifier,\n                item.amount,\n                conduitKey,\n                accumulator\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer Ether or other native tokens to a\n     *      given recipient.\n     *\n     * @param to     The recipient of the transfer.\n     * @param amount The amount to transfer.\n     */\n    function _transferNativeTokens(\n        address payable to,\n        uint256 amount\n    ) internal {\n        // Ensure that the supplied amount is non-zero.\n        _assertNonZeroAmount(amount);\n\n        // Declare a variable indicating whether the call was successful or not.\n        bool success;\n\n        assembly {\n            // Transfer the native token and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        // If the call fails...\n        if (!success) {\n            // Revert and pass the revert reason along if one was returned.\n            _revertWithReasonIfOneIsReturned();\n\n            // Otherwise, revert with a generic error message.\n            assembly {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, NativeTokenTransferGenericFailure_error_selector)\n\n                // Write `to` and `amount` arguments.\n                mstore(NativeTokenTransferGenericFailure_error_account_ptr, to)\n                mstore(\n                    NativeTokenTransferGenericFailure_error_amount_ptr,\n                    amount\n                )\n\n                // revert(abi.encodeWithSignature(\n                //     \"NativeTokenTransferGenericFailure(address,uint256)\",\n                //     to,\n                //     amount\n                // ))\n                revert(\n                    Error_selector_offset,\n                    NativeTokenTransferGenericFailure_error_length\n                )\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer ERC20 tokens from a given originator\n     *      to a given recipient using a given conduit if applicable. Sufficient\n     *      approvals must be set on this contract or on a respective conduit.\n     *\n     * @param token       The ERC20 token to transfer.\n     * @param from        The originator of the transfer.\n     * @param to          The recipient of the transfer.\n     * @param amount      The amount to transfer.\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\n     *                    if any, to source token approvals from. The zero hash\n     *                    signifies that no conduit should be used, with direct\n     *                    approvals set on this contract.\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     */\n    function _transferERC20(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        bytes32 conduitKey,\n        bytes memory accumulator\n    ) internal {\n        // Ensure that the supplied amount is non-zero.\n        _assertNonZeroAmount(amount);\n\n        // Trigger accumulated transfers if the conduits differ.\n        _triggerIfArmedAndNotAccumulatable(accumulator, conduitKey);\n\n        // If no conduit has been specified...\n        if (conduitKey == bytes32(0)) {\n            // Perform the token transfer directly.\n            _performERC20Transfer(token, from, to, amount);\n        } else {\n            // Insert the call to the conduit into the accumulator.\n            _insert(\n                conduitKey,\n                accumulator,\n                ConduitItemType.ERC20,\n                token,\n                from,\n                to,\n                uint256(0),\n                amount\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer a single ERC721 token from a given\n     *      originator to a given recipient. Sufficient approvals must be set,\n     *      either on the respective conduit or on this contract itself.\n     *\n     * @param token       The ERC721 token to transfer.\n     * @param from        The originator of the transfer.\n     * @param to          The recipient of the transfer.\n     * @param identifier  The tokenId to transfer.\n     * @param amount      The amount to transfer (must be 1 for ERC721).\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\n     *                    if any, to source token approvals from. The zero hash\n     *                    signifies that no conduit should be used, with direct\n     *                    approvals set on this contract.\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     */\n    function _transferERC721(\n        address token,\n        address from,\n        address to,\n        uint256 identifier,\n        uint256 amount,\n        bytes32 conduitKey,\n        bytes memory accumulator\n    ) internal {\n        // Trigger accumulated transfers if the conduits differ.\n        _triggerIfArmedAndNotAccumulatable(accumulator, conduitKey);\n\n        // If no conduit has been specified...\n        if (conduitKey == bytes32(0)) {\n            // Ensure that exactly one 721 item is being transferred.\n            if (amount != 1) {\n                _revertInvalidERC721TransferAmount(amount);\n            }\n\n            // Perform transfer via the token contract directly.\n            _performERC721Transfer(token, from, to, identifier);\n        } else {\n            // Insert the call to the conduit into the accumulator.\n            _insert(\n                conduitKey,\n                accumulator,\n                ConduitItemType.ERC721,\n                token,\n                from,\n                to,\n                identifier,\n                amount\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer ERC1155 tokens from a given originator\n     *      to a given recipient. Sufficient approvals must be set, either on\n     *      the respective conduit or on this contract itself.\n     *\n     * @param token       The ERC1155 token to transfer.\n     * @param from        The originator of the transfer.\n     * @param to          The recipient of the transfer.\n     * @param identifier  The id to transfer.\n     * @param amount      The amount to transfer.\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\n     *                    if any, to source token approvals from. The zero hash\n     *                    signifies that no conduit should be used, with direct\n     *                    approvals set on this contract.\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     */\n    function _transferERC1155(\n        address token,\n        address from,\n        address to,\n        uint256 identifier,\n        uint256 amount,\n        bytes32 conduitKey,\n        bytes memory accumulator\n    ) internal {\n        // Ensure that the supplied amount is non-zero.\n        _assertNonZeroAmount(amount);\n\n        // Trigger accumulated transfers if the conduits differ.\n        _triggerIfArmedAndNotAccumulatable(accumulator, conduitKey);\n\n        // If no conduit has been specified...\n        if (conduitKey == bytes32(0)) {\n            // Perform transfer via the token contract directly.\n            _performERC1155Transfer(token, from, to, identifier, amount);\n        } else {\n            // Insert the call to the conduit into the accumulator.\n            _insert(\n                conduitKey,\n                accumulator,\n                ConduitItemType.ERC1155,\n                token,\n                from,\n                to,\n                identifier,\n                amount\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function to trigger a call to the conduit currently held by\n     *      the accumulator if the accumulator contains item transfers (i.e. it\n     *      is \"armed\") and the supplied conduit key does not match the key held\n     *      by the accumulator.\n     *\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\n     *                    if any, to source token approvals from. The zero hash\n     *                    signifies that no conduit should be used, with direct\n     *                    approvals set on this contract.\n     */\n    function _triggerIfArmedAndNotAccumulatable(\n        bytes memory accumulator,\n        bytes32 conduitKey\n    ) internal {\n        // Retrieve the current conduit key from the accumulator.\n        bytes32 accumulatorConduitKey = _getAccumulatorConduitKey(accumulator);\n\n        // Perform conduit call if the set key does not match the supplied key.\n        if (accumulatorConduitKey != conduitKey) {\n            _triggerIfArmed(accumulator);\n        }\n    }\n\n    /**\n     * @dev Internal function to trigger a call to the conduit currently held by\n     *      the accumulator if the accumulator contains item transfers (i.e. it\n     *      is \"armed\").\n     *\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     */\n    function _triggerIfArmed(bytes memory accumulator) internal {\n        // Exit if the accumulator is not \"armed\".\n        if (accumulator.length != AccumulatorArmed) {\n            return;\n        }\n\n        // Retrieve the current conduit key from the accumulator.\n        bytes32 accumulatorConduitKey = _getAccumulatorConduitKey(accumulator);\n\n        // Perform conduit call.\n        _trigger(accumulatorConduitKey, accumulator);\n    }\n\n    /**\n     * @dev Internal function to trigger a call to the conduit corresponding to\n     *      a given conduit key, supplying all accumulated item transfers. The\n     *      accumulator will be \"disarmed\" and reset in the process.\n     *\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\n     *                    if any, to source token approvals from. The zero hash\n     *                    signifies that no conduit should be used, with direct\n     *                    approvals set on this contract.\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     */\n    function _trigger(bytes32 conduitKey, bytes memory accumulator) internal {\n        // Declare variables for offset in memory & size of calldata to conduit.\n        uint256 callDataOffset;\n        uint256 callDataSize;\n\n        // Call the conduit with all the accumulated transfers.\n        assembly {\n            // Call begins at third word; the first is length or \"armed\" status,\n            // and the second is the current conduit key.\n            callDataOffset := add(accumulator, TwoWords)\n\n            // 68 + items * 192\n            callDataSize := add(\n                Accumulator_array_offset_ptr,\n                mul(\n                    mload(add(accumulator, Accumulator_array_length_ptr)),\n                    Conduit_transferItem_size\n                )\n            )\n        }\n\n        // Call conduit derived from conduit key & supply accumulated transfers.\n        _callConduitUsingOffsets(conduitKey, callDataOffset, callDataSize);\n\n        // Reset accumulator length to signal that it is now \"disarmed\".\n        assembly {\n            mstore(accumulator, AccumulatorDisarmed)\n        }\n    }\n\n    /**\n     * @dev Internal function to perform a call to the conduit corresponding to\n     *      a given conduit key based on the offset and size of the calldata in\n     *      question in memory.\n     *\n     * @param conduitKey     A bytes32 value indicating what corresponding\n     *                       conduit, if any, to source token approvals from.\n     *                       The zero hash signifies that no conduit should be\n     *                       used, with direct approvals set on this contract.\n     * @param callDataOffset The memory pointer where calldata is contained.\n     * @param callDataSize   The size of calldata in memory.\n     */\n    function _callConduitUsingOffsets(\n        bytes32 conduitKey,\n        uint256 callDataOffset,\n        uint256 callDataSize\n    ) internal {\n        // Derive the address of the conduit using the conduit key.\n        address conduit = _deriveConduit(conduitKey);\n\n        bool success;\n        bytes4 result;\n\n        // call the conduit.\n        assembly {\n            // Ensure first word of scratch space is empty.\n            mstore(0, 0)\n\n            // Perform call, placing first word of return data in scratch space.\n            success := call(\n                gas(),\n                conduit,\n                0,\n                callDataOffset,\n                callDataSize,\n                0,\n                OneWord\n            )\n\n            // Take value from scratch space and place it on the stack.\n            result := mload(0)\n        }\n\n        // If the call failed...\n        if (!success) {\n            // Pass along whatever revert reason was given by the conduit.\n            _revertWithReasonIfOneIsReturned();\n\n            // Otherwise, revert with a generic error.\n            _revertInvalidCallToConduit(conduit);\n        }\n\n        // Ensure result was extracted and matches EIP-1271 magic value.\n        if (result != ConduitInterface.execute.selector) {\n            _revertInvalidConduit(conduitKey, conduit);\n        }\n    }\n\n    /**\n     * @dev Internal pure function to retrieve the current conduit key set for\n     *      the accumulator.\n     *\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     *\n     * @return accumulatorConduitKey The conduit key currently set for the\n     *                               accumulator.\n     */\n    function _getAccumulatorConduitKey(\n        bytes memory accumulator\n    ) internal pure returns (bytes32 accumulatorConduitKey) {\n        // Retrieve the current conduit key from the accumulator.\n        assembly {\n            accumulatorConduitKey := mload(\n                add(accumulator, Accumulator_conduitKey_ptr)\n            )\n        }\n    }\n\n    /**\n     * @dev Internal pure function to place an item transfer into an accumulator\n     *      that collects a series of transfers to execute against a given\n     *      conduit in a single call.\n     *\n     * @param conduitKey  A bytes32 value indicating what corresponding conduit,\n     *                    if any, to source token approvals from. The zero hash\n     *                    signifies that no conduit should be used, with direct\n     *                    approvals set on this contract.\n     * @param accumulator An open-ended array that collects transfers to execute\n     *                    against a given conduit in a single call.\n     * @param itemType    The type of the item to transfer.\n     * @param token       The token to transfer.\n     * @param from        The originator of the transfer.\n     * @param to          The recipient of the transfer.\n     * @param identifier  The tokenId to transfer.\n     * @param amount      The amount to transfer.\n     */\n    function _insert(\n        bytes32 conduitKey,\n        bytes memory accumulator,\n        ConduitItemType itemType,\n        address token,\n        address from,\n        address to,\n        uint256 identifier,\n        uint256 amount\n    ) internal pure {\n        uint256 elements;\n        // \"Arm\" and prime accumulator if it's not already armed. The sentinel\n        // value is held in the length of the accumulator array.\n        if (accumulator.length == AccumulatorDisarmed) {\n            elements = 1;\n            bytes4 selector = ConduitInterface.execute.selector;\n            assembly {\n                mstore(accumulator, AccumulatorArmed) // \"arm\" the accumulator.\n                mstore(add(accumulator, Accumulator_conduitKey_ptr), conduitKey)\n                mstore(add(accumulator, Accumulator_selector_ptr), selector)\n                mstore(\n                    add(accumulator, Accumulator_array_offset_ptr),\n                    Accumulator_array_offset\n                )\n                mstore(add(accumulator, Accumulator_array_length_ptr), elements)\n            }\n        } else {\n            // Otherwise, increase the number of elements by one.\n            assembly {\n                elements := add(\n                    mload(add(accumulator, Accumulator_array_length_ptr)),\n                    1\n                )\n                mstore(add(accumulator, Accumulator_array_length_ptr), elements)\n            }\n        }\n\n        // Insert the item.\n        assembly {\n            let itemPointer := sub(\n                add(accumulator, mul(elements, Conduit_transferItem_size)),\n                Accumulator_itemSizeOffsetDifference\n            )\n            mstore(itemPointer, itemType)\n            mstore(add(itemPointer, Conduit_transferItem_token_ptr), token)\n            mstore(add(itemPointer, Conduit_transferItem_from_ptr), from)\n            mstore(add(itemPointer, Conduit_transferItem_to_ptr), to)\n            mstore(\n                add(itemPointer, Conduit_transferItem_identifier_ptr),\n                identifier\n            )\n            mstore(add(itemPointer, Conduit_transferItem_amount_ptr), amount)\n        }\n    }\n}\n"},"contracts/lib/AmountDeriver.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {\n    AmountDerivationErrors\n} from \"../interfaces/AmountDerivationErrors.sol\";\n\nimport {\n    Error_selector_offset,\n    InexactFraction_error_length,\n    InexactFraction_error_selector\n} from \"./ConsiderationErrorConstants.sol\";\n\n/**\n * @title AmountDeriver\n * @author 0age\n * @notice AmountDeriver contains view and pure functions related to deriving\n *         item amounts based on partial fill quantity and on linear\n *         interpolation based on current time when the start amount and end\n *         amount differ.\n */\ncontract AmountDeriver is AmountDerivationErrors {\n    /**\n     * @dev Internal view function to derive the current amount of a given item\n     *      based on the current price, the starting price, and the ending\n     *      price. If the start and end prices differ, the current price will be\n     *      interpolated on a linear basis. Note that this function expects that\n     *      the startTime parameter of orderParameters is not greater than the\n     *      current block timestamp and that the endTime parameter is greater\n     *      than the current block timestamp. If this condition is not upheld,\n     *      duration / elapsed / remaining variables will underflow.\n     *\n     * @param startAmount The starting amount of the item.\n     * @param endAmount   The ending amount of the item.\n     * @param startTime   The starting time of the order.\n     * @param endTime     The end time of the order.\n     * @param roundUp     A boolean indicating whether the resultant amount\n     *                    should be rounded up or down.\n     *\n     * @return amount The current amount.\n     */\n    function _locateCurrentAmount(\n        uint256 startAmount,\n        uint256 endAmount,\n        uint256 startTime,\n        uint256 endTime,\n        bool roundUp\n    ) internal view returns (uint256 amount) {\n        // Only modify end amount if it doesn't already equal start amount.\n        if (startAmount != endAmount) {\n            // Declare variables to derive in the subsequent unchecked scope.\n            uint256 duration;\n            uint256 elapsed;\n            uint256 remaining;\n\n            // Skip underflow checks as startTime <= block.timestamp < endTime.\n            unchecked {\n                // Derive the duration for the order and place it on the stack.\n                duration = endTime - startTime;\n\n                // Derive time elapsed since the order started & place on stack.\n                elapsed = block.timestamp - startTime;\n\n                // Derive time remaining until order expires and place on stack.\n                remaining = duration - elapsed;\n            }\n\n            // Aggregate new amounts weighted by time with rounding factor.\n            uint256 totalBeforeDivision = ((startAmount * remaining) +\n                (endAmount * elapsed));\n\n            // Use assembly to combine operations and skip divide-by-zero check.\n            assembly {\n                // Multiply by iszero(iszero(totalBeforeDivision)) to ensure\n                // amount is set to zero if totalBeforeDivision is zero,\n                // as intermediate overflow can occur if it is zero.\n                amount := mul(\n                    iszero(iszero(totalBeforeDivision)),\n                    // Subtract 1 from the numerator and add 1 to the result if\n                    // roundUp is true to get the proper rounding direction.\n                    // Division is performed with no zero check as duration\n                    // cannot be zero as long as startTime < endTime.\n                    add(\n                        div(sub(totalBeforeDivision, roundUp), duration),\n                        roundUp\n                    )\n                )\n            }\n\n            // Return the current amount.\n            return amount;\n        }\n\n        // Return the original amount as startAmount == endAmount.\n        return endAmount;\n    }\n\n    /**\n     * @dev Internal pure function to return a fraction of a given value and to\n     *      ensure the resultant value does not have any fractional component.\n     *      Note that this function assumes that zero will never be supplied as\n     *      the denominator parameter; invalid / undefined behavior will result\n     *      should a denominator of zero be provided.\n     *\n     * @param numerator   A value indicating the portion of the order that\n     *                    should be filled.\n     * @param denominator A value indicating the total size of the order. Note\n     *                    that this value cannot be equal to zero.\n     * @param value       The value for which to compute the fraction.\n     *\n     * @return newValue The value after applying the fraction.\n     */\n    function _getFraction(\n        uint256 numerator,\n        uint256 denominator,\n        uint256 value\n    ) internal pure returns (uint256 newValue) {\n        // Return value early in cases where the fraction resolves to 1.\n        if (numerator == denominator) {\n            return value;\n        }\n\n        // Ensure fraction can be applied to the value with no remainder. Note\n        // that the denominator cannot be zero.\n        assembly {\n            // Ensure new value contains no remainder via mulmod operator.\n            // Credit to @hrkrshnn + @axic for proposing this optimal solution.\n            if mulmod(value, numerator, denominator) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, InexactFraction_error_selector)\n\n                // revert(abi.encodeWithSignature(\"InexactFraction()\"))\n                revert(Error_selector_offset, InexactFraction_error_length)\n            }\n        }\n\n        // Multiply the numerator by the value and ensure no overflow occurs.\n        uint256 valueTimesNumerator = value * numerator;\n\n        // Divide and check for remainder. Note that denominator cannot be zero.\n        assembly {\n            // Perform division without zero check.\n            newValue := div(valueTimesNumerator, denominator)\n        }\n    }\n\n    /**\n     * @dev Internal view function to apply a fraction to a consideration\n     * or offer item.\n     *\n     * @param startAmount     The starting amount of the item.\n     * @param endAmount       The ending amount of the item.\n     * @param numerator       A value indicating the portion of the order that\n     *                        should be filled.\n     * @param denominator     A value indicating the total size of the order.\n     * @param startTime       The starting time of the order.\n     * @param endTime         The end time of the order.\n     * @param roundUp         A boolean indicating whether the resultant\n     *                        amount should be rounded up or down.\n     *\n     * @return amount The received item to transfer with the final amount.\n     */\n    function _applyFraction(\n        uint256 startAmount,\n        uint256 endAmount,\n        uint256 numerator,\n        uint256 denominator,\n        uint256 startTime,\n        uint256 endTime,\n        bool roundUp\n    ) internal view returns (uint256 amount) {\n        // If start amount equals end amount, apply fraction to end amount.\n        if (startAmount == endAmount) {\n            // Apply fraction to end amount.\n            amount = _getFraction(numerator, denominator, endAmount);\n        } else {\n            // Otherwise, apply fraction to both and interpolated final amount.\n            amount = _locateCurrentAmount(\n                _getFraction(numerator, denominator, startAmount),\n                _getFraction(numerator, denominator, endAmount),\n                startTime,\n                endTime,\n                roundUp\n            );\n        }\n    }\n}\n"},"contracts/lib/Consideration.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {\n    ConsiderationInterface\n} from \"../interfaces/ConsiderationInterface.sol\";\n\nimport {\n    AdvancedOrder,\n    BasicOrderParameters,\n    CriteriaResolver,\n    Execution,\n    Fulfillment,\n    FulfillmentComponent,\n    Order,\n    OrderComponents\n} from \"./ConsiderationStructs.sol\";\n\nimport { OrderCombiner } from \"./OrderCombiner.sol\";\n\nimport {\n    CalldataStart,\n    CalldataPointer\n} from \"../helpers/PointerLibraries.sol\";\n\nimport {\n    Offset_fulfillAdvancedOrder_criteriaResolvers,\n    Offset_fulfillAvailableAdvancedOrders_cnsdrationFlflmnts,\n    Offset_fulfillAvailableAdvancedOrders_criteriaResolvers,\n    Offset_fulfillAvailableAdvancedOrders_offerFulfillments,\n    Offset_fulfillAvailableOrders_considerationFulfillments,\n    Offset_fulfillAvailableOrders_offerFulfillments,\n    Offset_matchAdvancedOrders_criteriaResolvers,\n    Offset_matchAdvancedOrders_fulfillments,\n    Offset_matchOrders_fulfillments,\n    OrderParameters_counter_offset\n} from \"./ConsiderationConstants.sol\";\n\n/**\n * @title Consideration\n * @author 0age (0age.eth)\n * @custom:coauthor d1ll0n (d1ll0n.eth)\n * @custom:coauthor transmissions11 (t11s.eth)\n * @custom:coauthor James Wenzel (emo.eth)\n * @custom:version 1.5\n * @notice Consideration is a generalized native token/ERC20/ERC721/ERC1155\n *         marketplace that provides lightweight methods for common routes as\n *         well as more flexible methods for composing advanced orders or groups\n *         of orders. Each order contains an arbitrary number of items that may\n *         be spent (the \"offer\") along with an arbitrary number of items that\n *         must be received back by the indicated recipients (the\n *         \"consideration\").\n */\ncontract Consideration is ConsiderationInterface, OrderCombiner {\n    /**\n     * @notice Derive and set hashes, reference chainId, and associated domain\n     *         separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) OrderCombiner(conduitController) {}\n\n    /**\n     * @notice Accept native token transfers during execution that may then be\n     *         used to facilitate native token transfers, where any tokens that\n     *         remain will be transferred to the caller. Native tokens are only\n     *         acceptable mid-fulfillment (and not during basic fulfillment).\n     */\n    receive() external payable {\n        // Ensure the reentrancy guard is currently set to accept native tokens.\n        _assertAcceptingNativeTokens();\n    }\n\n    /**\n     * @notice Fulfill an order offering an ERC20, ERC721, or ERC1155 item by\n     *         supplying Ether (or other native tokens), ERC20 tokens, an ERC721\n     *         item, or an ERC1155 item as consideration. Six permutations are\n     *         supported: Native token to ERC721, Native token to ERC1155, ERC20\n     *         to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and ERC1155 to\n     *         ERC20 (with native tokens supplied as msg.value). For an order to\n     *         be eligible for fulfillment via this method, it must contain a\n     *         single offer item (though that item may have a greater amount if\n     *         the item is not an ERC721). An arbitrary number of \"additional\n     *         recipients\" may also be supplied which will each receive native\n     *         tokens or ERC20 items from the fulfiller as consideration. Refer\n     *         to the documentation for a more comprehensive summary of how to\n     *         utilize this method and what orders are compatible with it.\n     *\n     * @param parameters Additional information on the fulfilled order. Note\n     *                   that the offerer and the fulfiller must first approve\n     *                   this contract (or their chosen conduit if indicated)\n     *                   before any tokens can be transferred. Also note that\n     *                   contract recipients of ERC1155 consideration items must\n     *                   implement `onERC1155Received` to receive those items.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillBasicOrder(\n        BasicOrderParameters calldata parameters\n    ) external payable override returns (bool fulfilled) {\n        // Validate and fulfill the basic order.\n        fulfilled = _validateAndFulfillBasicOrder(parameters);\n    }\n\n    /**\n     * @notice Fulfill an order offering an ERC20, ERC721, or ERC1155 item by\n     *         supplying Ether (or other native tokens), ERC20 tokens, an ERC721\n     *         item, or an ERC1155 item as consideration. Six permutations are\n     *         supported: Native token to ERC721, Native token to ERC1155, ERC20\n     *         to ERC721, ERC20 to ERC1155, ERC721 to ERC20, and ERC1155 to\n     *         ERC20 (with native tokens supplied as msg.value). For an order to\n     *         be eligible for fulfillment via this method, it must contain a\n     *         single offer item (though that item may have a greater amount if\n     *         the item is not an ERC721). An arbitrary number of \"additional\n     *         recipients\" may also be supplied which will each receive native\n     *         tokens or ERC20 items from the fulfiller as consideration. Refer\n     *         to the documentation for a more comprehensive summary of how to\n     *         utilize this method and what orders are compatible with it. Note\n     *         that this function costs less gas than `fulfillBasicOrder` due to\n     *         the zero bytes in the function selector (0x00000000) which also\n     *         results in earlier function dispatch.\n     *\n     * @param parameters Additional information on the fulfilled order. Note\n     *                   that the offerer and the fulfiller must first approve\n     *                   this contract (or their chosen conduit if indicated)\n     *                   before any tokens can be transferred. Also note that\n     *                   contract recipients of ERC1155 consideration items must\n     *                   implement `onERC1155Received` to receive those items.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillBasicOrder_efficient_6GL6yc(\n        BasicOrderParameters calldata parameters\n    ) external payable override returns (bool fulfilled) {\n        // Validate and fulfill the basic order.\n        fulfilled = _validateAndFulfillBasicOrder(parameters);\n    }\n\n    /**\n     * @notice Fulfill an order with an arbitrary number of items for offer and\n     *         consideration. Note that this function does not support\n     *         criteria-based orders or partial filling of orders (though\n     *         filling the remainder of a partially-filled order is supported).\n     *\n     * @custom:param order        The order to fulfill. Note that both the\n     *                            offerer and the fulfiller must first approve\n     *                            this contract (or the corresponding conduit if\n     *                            indicated) to transfer any relevant tokens on\n     *                            their behalf and that contracts must implement\n     *                            `onERC1155Received` to receive ERC1155 tokens\n     *                            as consideration.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller's token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used (and direct approvals set on\n     *                            this contract).\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillOrder(\n        /**\n         * @custom:name order\n         */\n        Order calldata,\n        bytes32 fulfillerConduitKey\n    ) external payable override returns (bool fulfilled) {\n        // Convert order to \"advanced\" order, then validate and fulfill it.\n        fulfilled = _validateAndFulfillAdvancedOrder(\n            _toAdvancedOrderReturnType(_decodeOrderAsAdvancedOrder)(\n                CalldataStart.pptr()\n            ),\n            new CriteriaResolver[](0), // No criteria resolvers supplied.\n            fulfillerConduitKey,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Fill an order, fully or partially, with an arbitrary number of\n     *         items for offer and consideration alongside criteria resolvers\n     *         containing specific token identifiers and associated proofs.\n     *\n     * @custom:param advancedOrder     The order to fulfill along with the\n     *                                 fraction of the order to attempt to fill.\n     *                                 Note that both the offerer and the\n     *                                 fulfiller must first approve this\n     *                                 contract (or their conduit if indicated\n     *                                 by the order) to transfer any relevant\n     *                                 tokens on their behalf and that contracts\n     *                                 must implement `onERC1155Received` to\n     *                                 receive ERC1155 tokens as consideration.\n     *                                 Also note that all offer and\n     *                                 consideration components must have no\n     *                                 remainder after multiplication of the\n     *                                 respective amount with the supplied\n     *                                 fraction for the partial fill to be\n     *                                 considered valid.\n     * @custom:param criteriaResolvers An array where each element contains a\n     *                                 reference to a specific offer or\n     *                                 consideration, a token identifier, and a\n     *                                 proof that the supplied token identifier\n     *                                 is contained in the merkle root held by\n     *                                 the item in question's criteria element.\n     *                                 Note that an empty criteria indicates\n     *                                 that any (transferable) token identifier\n     *                                 on the token in question is valid and\n     *                                 that no associated proof needs to be\n     *                                 supplied.\n     * @param fulfillerConduitKey      A bytes32 value indicating what conduit,\n     *                                 if any, to source the fulfiller's token\n     *                                 approvals from. The zero hash signifies\n     *                                 that no conduit should be used (and\n     *                                 direct approvals set on this contract).\n     * @param recipient                The intended recipient for all received\n     *                                 items, with `address(0)` indicating that\n     *                                 the caller should receive the items.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillAdvancedOrder(\n        /**\n         * @custom:name advancedOrder\n         */\n        AdvancedOrder calldata,\n        /**\n         * @custom:name criteriaResolvers\n         */\n        CriteriaResolver[] calldata,\n        bytes32 fulfillerConduitKey,\n        address recipient\n    ) external payable override returns (bool fulfilled) {\n        // Validate and fulfill the order.\n        fulfilled = _validateAndFulfillAdvancedOrder(\n            _toAdvancedOrderReturnType(_decodeAdvancedOrder)(\n                CalldataStart.pptr()\n            ),\n            _toCriteriaResolversReturnType(_decodeCriteriaResolvers)(\n                CalldataStart.pptr(\n                    Offset_fulfillAdvancedOrder_criteriaResolvers\n                )\n            ),\n            fulfillerConduitKey,\n            _substituteCallerForEmptyRecipient(recipient)\n        );\n    }\n\n    /**\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\n     *         of items for offer and consideration. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *         Note that this function does not support criteria-based orders or\n     *         partial filling of orders (though filling the remainder of a\n     *         partially-filled order is supported).\n     *\n     * @custom:param orders                    The orders to fulfill. Note that\n     *                                         both the offerer and the\n     *                                         fulfiller must first approve this\n     *                                         contract (or the corresponding\n     *                                         conduit if indicated) to transfer\n     *                                         any relevant tokens on their\n     *                                         behalf and that contracts must\n     *                                         implement `onERC1155Received` to\n     *                                         receive ERC1155 tokens as\n     *                                         consideration.\n     * @custom:param offerFulfillments         An array of FulfillmentComponent\n     *                                         arrays indicating which offer\n     *                                         items to attempt to aggregate\n     *                                         when preparing executions. Note\n     *                                         that any offer items not included\n     *                                         as part of a fulfillment will be\n     *                                         sent unaggregated to the caller.\n     * @custom:param considerationFulfillments An array of FulfillmentComponent\n     *                                         arrays indicating which\n     *                                         consideration items to attempt to\n     *                                         aggregate when preparing\n     *                                         executions.\n     * @param fulfillerConduitKey              A bytes32 value indicating what\n     *                                         conduit, if any, to source the\n     *                                         fulfiller's token approvals from.\n     *                                         The zero hash signifies that no\n     *                                         conduit should be used (and\n     *                                         direct approvals set on this\n     *                                         contract).\n     * @param maximumFulfilled                 The maximum number of orders to\n     *                                         fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function fulfillAvailableOrders(\n        /**\n         * @custom:name orders\n         */\n        Order[] calldata,\n        /**\n         * @custom:name offerFulfillments\n         */\n        FulfillmentComponent[][] calldata,\n        /**\n         * @custom:name considerationFulfillments\n         */\n        FulfillmentComponent[][] calldata,\n        bytes32 fulfillerConduitKey,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        override\n        returns (\n            bool[] memory /* availableOrders */,\n            Execution[] memory /* executions */\n        )\n    {\n        // Convert orders to \"advanced\" orders and fulfill all available orders.\n        return\n            _fulfillAvailableAdvancedOrders(\n                _toAdvancedOrdersReturnType(_decodeOrdersAsAdvancedOrders)(\n                    CalldataStart.pptr()\n                ), // Convert to advanced orders.\n                new CriteriaResolver[](0), // No criteria resolvers supplied.\n                _toNestedFulfillmentComponentsReturnType(\n                    _decodeNestedFulfillmentComponents\n                )(\n                    CalldataStart.pptr(\n                        Offset_fulfillAvailableOrders_offerFulfillments\n                    )\n                ),\n                _toNestedFulfillmentComponentsReturnType(\n                    _decodeNestedFulfillmentComponents\n                )(\n                    CalldataStart.pptr(\n                        Offset_fulfillAvailableOrders_considerationFulfillments\n                    )\n                ),\n                fulfillerConduitKey,\n                msg.sender,\n                maximumFulfilled\n            );\n    }\n\n    /**\n     * @notice Attempt to fill a group of orders, fully or partially, with an\n     *         arbitrary number of items for offer and consideration per order\n     *         alongside criteria resolvers containing specific token\n     *         identifiers and associated proofs. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *\n     * @custom:param advancedOrders            The orders to fulfill along with\n     *                                         the fraction of those orders to\n     *                                         attempt to fill. Note that both\n     *                                         the offerer and the fulfiller\n     *                                         must first approve this contract\n     *                                         (or their conduit if indicated by\n     *                                         the order) to transfer any\n     *                                         relevant tokens on their behalf\n     *                                         and that contracts must implement\n     *                                         `onERC1155Received` to receive\n     *                                         ERC1155 tokens as consideration.\n     *                                         Also note that all offer and\n     *                                         consideration components must\n     *                                         have no remainder after\n     *                                         multiplication of the respective\n     *                                         amount with the supplied fraction\n     *                                         for an order's partial fill\n     *                                         amount to be considered valid.\n     * @custom:param criteriaResolvers         An array where each element\n     *                                         contains a reference to a\n     *                                         specific offer or consideration,\n     *                                         a token identifier, and a proof\n     *                                         that the supplied token\n     *                                         identifier is contained in the\n     *                                         merkle root held by the item in\n     *                                         question's criteria element. Note\n     *                                         that an empty criteria indicates\n     *                                         that any (transferable) token\n     *                                         identifier on the token in\n     *                                         question is valid and that no\n     *                                         associated proof needs to be\n     *                                         supplied.\n     * @custom:param offerFulfillments         An array of FulfillmentComponent\n     *                                         arrays indicating which offer\n     *                                         items to attempt to aggregate\n     *                                         when preparing executions. Note\n     *                                         that any offer items not included\n     *                                         as part of a fulfillment will be\n     *                                         sent unaggregated to the caller.\n     * @custom:param considerationFulfillments An array of FulfillmentComponent\n     *                                         arrays indicating which\n     *                                         consideration items to attempt to\n     *                                         aggregate when preparing\n     *                                         executions.\n     * @param fulfillerConduitKey              A bytes32 value indicating what\n     *                                         conduit, if any, to source the\n     *                                         fulfiller's token approvals from.\n     *                                         The zero hash signifies that no\n     *                                         conduit should be used (and\n     *                                         direct approvals set on this\n     *                                         contract).\n     * @param recipient                        The intended recipient for all\n     *                                         received items, with `address(0)`\n     *                                         indicating that the caller should\n     *                                         receive the offer items.\n     * @param maximumFulfilled                 The maximum number of orders to\n     *                                         fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function fulfillAvailableAdvancedOrders(\n        /**\n         * @custom:name advancedOrders\n         */\n        AdvancedOrder[] calldata,\n        /**\n         * @custom:name criteriaResolvers\n         */\n        CriteriaResolver[] calldata,\n        /**\n         * @custom:name offerFulfillments\n         */\n        FulfillmentComponent[][] calldata,\n        /**\n         * @custom:name considerationFulfillments\n         */\n        FulfillmentComponent[][] calldata,\n        bytes32 fulfillerConduitKey,\n        address recipient,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        override\n        returns (\n            bool[] memory /* availableOrders */,\n            Execution[] memory /* executions */\n        )\n    {\n        // Fulfill all available orders.\n        return\n            _fulfillAvailableAdvancedOrders(\n                _toAdvancedOrdersReturnType(_decodeAdvancedOrders)(\n                    CalldataStart.pptr()\n                ),\n                _toCriteriaResolversReturnType(_decodeCriteriaResolvers)(\n                    CalldataStart.pptr(\n                        Offset_fulfillAvailableAdvancedOrders_criteriaResolvers\n                    )\n                ),\n                _toNestedFulfillmentComponentsReturnType(\n                    _decodeNestedFulfillmentComponents\n                )(\n                    CalldataStart.pptr(\n                        Offset_fulfillAvailableAdvancedOrders_offerFulfillments\n                    )\n                ),\n                _toNestedFulfillmentComponentsReturnType(\n                    _decodeNestedFulfillmentComponents\n                )(\n                    CalldataStart.pptr(\n                        Offset_fulfillAvailableAdvancedOrders_cnsdrationFlflmnts\n                    )\n                ),\n                fulfillerConduitKey,\n                _substituteCallerForEmptyRecipient(recipient),\n                maximumFulfilled\n            );\n    }\n\n    /**\n     * @notice Match an arbitrary number of orders, each with an arbitrary\n     *         number of items for offer and consideration along with a set of\n     *         fulfillments allocating offer components to consideration\n     *         components. Note that this function does not support\n     *         criteria-based or partial filling of orders (though filling the\n     *         remainder of a partially-filled order is supported). Any unspent\n     *         offer item amounts or native tokens will be transferred to the\n     *         caller.\n     *\n     * @custom:param orders       The orders to match. Note that both the\n     *                            offerer and fulfiller on each order must first\n     *                            approve this contract (or their conduit if\n     *                            indicated by the order) to transfer any\n     *                            relevant tokens on their behalf and each\n     *                            consideration recipient must implement\n     *                            `onERC1155Received` to receive ERC1155 tokens.\n     * @custom:param fulfillments An array of elements allocating offer\n     *                            components to consideration components. Note\n     *                            that each consideration component must be\n     *                            fully met for the match operation to be valid,\n     *                            and that any unspent offer items will be sent\n     *                            unaggregated to the caller.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders. Note that unspent offer item amounts or native\n     *                    tokens will not be reflected as part of this array.\n     */\n    function matchOrders(\n        /**\n         * @custom:name orders\n         */\n        Order[] calldata,\n        /**\n         * @custom:name fulfillments\n         */\n        Fulfillment[] calldata\n    ) external payable override returns (Execution[] memory /* executions */) {\n        // Convert to advanced, validate, and match orders using fulfillments.\n        return\n            _matchAdvancedOrders(\n                _toAdvancedOrdersReturnType(_decodeOrdersAsAdvancedOrders)(\n                    CalldataStart.pptr()\n                ),\n                new CriteriaResolver[](0), // No criteria resolvers supplied.\n                _toFulfillmentsReturnType(_decodeFulfillments)(\n                    CalldataStart.pptr(Offset_matchOrders_fulfillments)\n                ),\n                msg.sender\n            );\n    }\n\n    /**\n     * @notice Match an arbitrary number of full, partial, or contract orders,\n     *         each with an arbitrary number of items for offer and\n     *         consideration, supplying criteria resolvers containing specific\n     *         token identifiers and associated proofs as well as fulfillments\n     *         allocating offer components to consideration components. Any\n     *         unspent offer item amounts will be transferred to the designated\n     *         recipient (with the null address signifying to use the caller)\n     *         and any unspent native tokens will be returned to the caller.\n     *\n     * @custom:param advancedOrders    The advanced orders to match. Note that\n     *                                 both the offerer and fulfiller on each\n     *                                 order must first approve this contract\n     *                                 (or their conduit if indicated by the\n     *                                 order) to transfer any relevant tokens on\n     *                                 their behalf and each consideration\n     *                                 recipient must implement\n     *                                 `onERC1155Received` to receive ERC1155\n     *                                 tokens. Also note that the offer and\n     *                                 consideration components for each order\n     *                                 must have no remainder after multiplying\n     *                                 the respective amount with the supplied\n     *                                 fraction for the group of partial fills\n     *                                 to be considered valid.\n     * @custom:param criteriaResolvers An array where each element contains a\n     *                                 reference to a specific offer or\n     *                                 consideration, a token identifier, and a\n     *                                 proof that the supplied token identifier\n     *                                 is contained in the merkle root held by\n     *                                 the item in question's criteria element.\n     *                                 Note that an empty criteria indicates\n     *                                 that any (transferable) token identifier\n     *                                 on the token in question is valid and\n     *                                 that no associated proof needs to be\n     *                                 supplied.\n     * @custom:param fulfillments      An array of elements allocating offer\n     *                                 components to consideration components.\n     *                                 Note that each consideration component\n     *                                 must be fully met for the match operation\n     *                                 to be valid, and that any unspent offer\n     *                                 items will be sent unaggregated to the\n     *                                 designated recipient.\n     * @param recipient                The intended recipient for all unspent\n     *                                 offer item amounts, or the caller if the\n     *                                 null address is supplied.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                     transfers performed as part of matching the given\n     *                     orders. Note that unspent offer item amounts or\n     *                     native tokens will not be reflected as part of this\n     *                     array.\n     */\n    function matchAdvancedOrders(\n        /**\n         * @custom:name advancedOrders\n         */\n        AdvancedOrder[] calldata,\n        /**\n         * @custom:name criteriaResolvers\n         */\n        CriteriaResolver[] calldata,\n        /**\n         * @custom:name fulfillments\n         */\n        Fulfillment[] calldata,\n        address recipient\n    ) external payable override returns (Execution[] memory /* executions */) {\n        // Validate and match the advanced orders using supplied fulfillments.\n        return\n            _matchAdvancedOrders(\n                _toAdvancedOrdersReturnType(_decodeAdvancedOrders)(\n                    CalldataStart.pptr()\n                ),\n                _toCriteriaResolversReturnType(_decodeCriteriaResolvers)(\n                    CalldataStart.pptr(\n                        Offset_matchAdvancedOrders_criteriaResolvers\n                    )\n                ),\n                _toFulfillmentsReturnType(_decodeFulfillments)(\n                    CalldataStart.pptr(Offset_matchAdvancedOrders_fulfillments)\n                ),\n                _substituteCallerForEmptyRecipient(recipient)\n            );\n    }\n\n    /**\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\n     *         or the zone of a given order may cancel it. Callers should ensure\n     *         that the intended order was cancelled by calling `getOrderStatus`\n     *         and confirming that `isCancelled` returns `true`.\n     *\n     * @param orders The orders to cancel.\n     *\n     * @return cancelled A boolean indicating whether the supplied orders have\n     *                   been successfully cancelled.\n     */\n    function cancel(\n        OrderComponents[] calldata orders\n    ) external override returns (bool cancelled) {\n        // Cancel the orders.\n        cancelled = _cancel(orders);\n    }\n\n    /**\n     * @notice Validate an arbitrary number of orders, thereby registering their\n     *         signatures as valid and allowing the fulfiller to skip signature\n     *         verification on fulfillment. Note that validated orders may still\n     *         be unfulfillable due to invalid item amounts or other factors;\n     *         callers should determine whether validated orders are fulfillable\n     *         by simulating the fulfillment call prior to execution. Also note\n     *         that anyone can validate a signed order, but only the offerer can\n     *         validate an order without supplying a signature.\n     *\n     * @custom:param orders The orders to validate.\n     *\n     * @return validated A boolean indicating whether the supplied orders have\n     *                   been successfully validated.\n     */\n    function validate(\n        /**\n         * @custom:name orders\n         */\n        Order[] calldata\n    ) external override returns (bool /* validated */) {\n        return\n            _validate(_toOrdersReturnType(_decodeOrders)(CalldataStart.pptr()));\n    }\n\n    /**\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\n     *         by incrementing a counter. Note that only the offerer may\n     *         increment the counter.\n     *\n     * @return newCounter The new counter.\n     */\n    function incrementCounter() external override returns (uint256 newCounter) {\n        // Increment current counter for the supplied offerer.  Note that the\n        // counter is incremented by a large, quasi-random interval.\n        newCounter = _incrementCounter();\n    }\n\n    /**\n     * @notice Retrieve the order hash for a given order.\n     *\n     * @custom:param order The components of the order.\n     *\n     * @return orderHash The order hash.\n     */\n    function getOrderHash(\n        /**\n         * @custom:name order\n         */\n        OrderComponents calldata\n    ) external view override returns (bytes32 orderHash) {\n        CalldataPointer orderPointer = CalldataStart.pptr();\n\n        // Derive order hash by supplying order parameters along with counter.\n        orderHash = _deriveOrderHash(\n            _toOrderParametersReturnType(\n                _decodeOrderComponentsAsOrderParameters\n            )(orderPointer),\n            // Read order counter\n            orderPointer.offset(OrderParameters_counter_offset).readUint256()\n        );\n    }\n\n    /**\n     * @notice Retrieve the status of a given order by hash, including whether\n     *         the order has been cancelled or validated and the fraction of the\n     *         order that has been filled. Since the _orderStatus[orderHash]\n     *         does not get set for contract orders, getOrderStatus will always\n     *         return (false, false, 0, 0) for those hashes. Note that this\n     *         function is susceptible to view reentrancy and so should be used\n     *         with care when calling from other contracts.\n     *\n     * @param orderHash The order hash in question.\n     *\n     * @return isValidated A boolean indicating whether the order in question\n     *                     has been validated (i.e. previously approved or\n     *                     partially filled).\n     * @return isCancelled A boolean indicating whether the order in question\n     *                     has been cancelled.\n     * @return totalFilled The total portion of the order that has been filled\n     *                     (i.e. the \"numerator\").\n     * @return totalSize   The total size of the order that is either filled or\n     *                     unfilled (i.e. the \"denominator\").\n     */\n    function getOrderStatus(\n        bytes32 orderHash\n    )\n        external\n        view\n        override\n        returns (\n            bool isValidated,\n            bool isCancelled,\n            uint256 totalFilled,\n            uint256 totalSize\n        )\n    {\n        // Retrieve the order status using the order hash.\n        return _getOrderStatus(orderHash);\n    }\n\n    /**\n     * @notice Retrieve the current counter for a given offerer.\n     *\n     * @param offerer The offerer in question.\n     *\n     * @return counter The current counter.\n     */\n    function getCounter(\n        address offerer\n    ) external view override returns (uint256 counter) {\n        // Return the counter for the supplied offerer.\n        counter = _getCounter(offerer);\n    }\n\n    /**\n     * @notice Retrieve configuration information for this contract.\n     *\n     * @return version           The contract version.\n     * @return domainSeparator   The domain separator for this contract.\n     * @return conduitController The conduit Controller set for this contract.\n     */\n    function information()\n        external\n        view\n        override\n        returns (\n            string memory version,\n            bytes32 domainSeparator,\n            address conduitController\n        )\n    {\n        // Return the information for this contract.\n        return _information();\n    }\n\n    /**\n     * @dev Gets the contract offerer nonce for the specified contract offerer.\n     *      Note that this function is susceptible to view reentrancy and so\n     *      should be used with care when calling from other contracts.\n     *\n     * @param contractOfferer The contract offerer for which to get the nonce.\n     *\n     * @return nonce The contract offerer nonce.\n     */\n    function getContractOffererNonce(\n        address contractOfferer\n    ) external view override returns (uint256 nonce) {\n        nonce = _contractNonces[contractOfferer];\n    }\n\n    /**\n     * @notice Retrieve the name of this contract.\n     *\n     * @return contractName The name of this contract.\n     */\n    function name()\n        external\n        pure\n        override\n        returns (string memory /* contractName */)\n    {\n        // Return the name of the contract.\n        return _name();\n    }\n}\n"},"contracts/lib/OrderValidator.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { OrderType } from \"./ConsiderationEnums.sol\";\n\nimport {\n    AdvancedOrder,\n    ConsiderationItem,\n    OfferItem,\n    Order,\n    OrderComponents,\n    OrderParameters,\n    OrderStatus\n} from \"./ConsiderationStructs.sol\";\n\nimport {\n    _revertBadFraction,\n    _revertCannotCancelOrder,\n    _revertConsiderationLengthNotEqualToTotalOriginal,\n    _revertInvalidContractOrder,\n    _revertPartialFillsNotEnabledForOrder\n} from \"./ConsiderationErrors.sol\";\n\nimport { Executor } from \"./Executor.sol\";\n\nimport { ZoneInteraction } from \"./ZoneInteraction.sol\";\n\nimport { MemoryPointer } from \"../helpers/PointerLibraries.sol\";\n\nimport {\n    AdvancedOrder_denominator_offset,\n    AdvancedOrder_numerator_offset,\n    BasicOrder_offerer_cdPtr,\n    Common_amount_offset,\n    Common_endAmount_offset,\n    Common_identifier_offset,\n    Common_token_offset,\n    ConsiderItem_recipient_offset,\n    ContractOrder_orderHash_offerer_shift,\n    MaxUint120,\n    OrderStatus_filledDenominator_offset,\n    OrderStatus_filledNumerator_offset,\n    OrderStatus_ValidatedAndNotCancelled\n} from \"./ConsiderationConstants.sol\";\n\nimport {\n    Error_selector_offset,\n    Panic_arithmetic,\n    Panic_error_code_ptr,\n    Panic_error_length,\n    Panic_error_selector\n} from \"./ConsiderationErrorConstants.sol\";\n\n/**\n * @title OrderValidator\n * @author 0age\n * @notice OrderValidator contains functionality related to validating orders\n *         and updating their status.\n */\ncontract OrderValidator is Executor, ZoneInteraction {\n    // Track status of each order (validated, cancelled, and fraction filled).\n    mapping(bytes32 => OrderStatus) private _orderStatus;\n\n    // Track nonces for contract offerers.\n    mapping(address => uint256) internal _contractNonces;\n\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) Executor(conduitController) {}\n\n    /**\n     * @dev Internal function to verify and update the status of a basic order.\n     *      Note that this function may only be safely called as part of basic\n     *      orders, as it assumes a specific calldata encoding structure that\n     *      must first be validated.\n     *\n     * @param orderHash The hash of the order.\n     * @param signature A signature from the offerer indicating that the order\n     *                  has been approved.\n     */\n    function _validateBasicOrderAndUpdateStatus(\n        bytes32 orderHash,\n        bytes calldata signature\n    ) internal {\n        // Retrieve offerer directly using fixed calldata offset based on strict\n        // basic parameter encoding.\n        address offerer;\n        assembly {\n            offerer := calldataload(BasicOrder_offerer_cdPtr)\n        }\n\n        // Retrieve the order status for the given order hash.\n        OrderStatus storage orderStatus = _orderStatus[orderHash];\n\n        // Ensure order is fillable and is not cancelled.\n        _verifyOrderStatus(\n            orderHash,\n            orderStatus,\n            true, // Only allow unused orders when fulfilling basic orders.\n            true // Signifies to revert if the order is invalid.\n        );\n\n        // If the order is not already validated, verify the supplied signature.\n        if (!orderStatus.isValidated) {\n            _verifySignature(offerer, orderHash, signature);\n        }\n\n        // Update order status as fully filled, packing struct values.\n        orderStatus.isValidated = true;\n        orderStatus.isCancelled = false;\n        orderStatus.numerator = 1;\n        orderStatus.denominator = 1;\n    }\n\n    /**\n     * @dev Internal function to validate an order, determine what portion to\n     *      fill, and update its status. The desired fill amount is supplied as\n     *      a fraction, as is the returned amount to fill.\n     *\n     * @param advancedOrder     The order to fulfill as well as the fraction to\n     *                          fill. Note that all offer and consideration\n     *                          amounts must divide with no remainder in order\n     *                          for a partial fill to be valid.\n     * @param revertOnInvalid   A boolean indicating whether to revert if the\n     *                          order is invalid due to the time or status.\n     *\n     * @return orderHash      The order hash.\n     * @return numerator      A value indicating the portion of the order that\n     *                        will be filled.\n     * @return denominator    A value indicating the total size of the order.\n     */\n    function _validateOrderAndUpdateStatus(\n        AdvancedOrder memory advancedOrder,\n        bool revertOnInvalid\n    )\n        internal\n        returns (bytes32 orderHash, uint256 numerator, uint256 denominator)\n    {\n        // Retrieve the parameters for the order.\n        OrderParameters memory orderParameters = advancedOrder.parameters;\n\n        // Ensure current timestamp falls between order start time and end time.\n        if (\n            !_verifyTime(\n                orderParameters.startTime,\n                orderParameters.endTime,\n                revertOnInvalid\n            )\n        ) {\n            // Assuming an invalid time and no revert, return zeroed out values.\n            return (bytes32(0), 0, 0);\n        }\n\n        // Read numerator and denominator from memory and place on the stack.\n        // Note that overflowed values are masked.\n        assembly {\n            numerator := and(\n                mload(add(advancedOrder, AdvancedOrder_numerator_offset)),\n                MaxUint120\n            )\n\n            denominator := and(\n                mload(add(advancedOrder, AdvancedOrder_denominator_offset)),\n                MaxUint120\n            )\n        }\n\n        // Declare variable for tracking the validity of the supplied fraction.\n        bool invalidFraction;\n\n        // If the order is a contract order, return the generated order.\n        if (orderParameters.orderType == OrderType.CONTRACT) {\n            // Ensure that the numerator and denominator are both equal to 1.\n            assembly {\n                // (1 ^ nd =/= 0) => (nd =/= 1) => (n =/= 1) || (d =/= 1)\n                // It's important that the values are 120-bit masked before\n                // multiplication is applied. Otherwise, the last implication\n                // above is not correct (mod 2^256).\n                invalidFraction := xor(mul(numerator, denominator), 1)\n            }\n\n            // Revert if the supplied numerator and denominator are not valid.\n            if (invalidFraction) {\n                _revertBadFraction();\n            }\n\n            // Return the generated order based on the order params and the\n            // provided extra data. If revertOnInvalid is true, the function\n            // will revert if the input is invalid.\n            return\n                _getGeneratedOrder(\n                    orderParameters,\n                    advancedOrder.extraData,\n                    revertOnInvalid\n                );\n        }\n\n        // Ensure numerator does not exceed denominator and is not zero.\n        assembly {\n            invalidFraction := or(gt(numerator, denominator), iszero(numerator))\n        }\n\n        // Revert if the supplied numerator and denominator are not valid.\n        if (invalidFraction) {\n            _revertBadFraction();\n        }\n\n        // If attempting partial fill (n < d) check order type & ensure support.\n        if (\n            _doesNotSupportPartialFills(\n                orderParameters.orderType,\n                numerator,\n                denominator\n            )\n        ) {\n            // Revert if partial fill was attempted on an unsupported order.\n            _revertPartialFillsNotEnabledForOrder();\n        }\n\n        // Retrieve current counter & use it w/ parameters to derive order hash.\n        orderHash = _assertConsiderationLengthAndGetOrderHash(orderParameters);\n\n        // Retrieve the order status using the derived order hash.\n        OrderStatus storage orderStatus = _orderStatus[orderHash];\n\n        // Ensure order is fillable and is not cancelled.\n        if (\n            !_verifyOrderStatus(\n                orderHash,\n                orderStatus,\n                false, // Allow partially used orders to be filled.\n                revertOnInvalid\n            )\n        ) {\n            // Assuming an invalid order status and no revert, return zero fill.\n            return (orderHash, 0, 0);\n        }\n\n        // If the order is not already validated, verify the supplied signature.\n        if (!orderStatus.isValidated) {\n            _verifySignature(\n                orderParameters.offerer,\n                orderHash,\n                advancedOrder.signature\n            );\n        }\n\n        // Utilize assembly to determine the fraction to fill and update status.\n        assembly {\n            let orderStatusSlot := orderStatus.slot\n            // Read filled amount as numerator and denominator and put on stack.\n            let filledNumerator := sload(orderStatusSlot)\n            let filledDenominator := shr(\n                OrderStatus_filledDenominator_offset,\n                filledNumerator\n            )\n\n            // \"Loop\" until the appropriate fill fraction has been determined.\n            for { } 1 { } {\n                // If no portion of the order has been filled yet...\n                if iszero(filledDenominator) {\n                    // fill the full supplied fraction.\n                    filledNumerator := numerator\n\n                    // Exit the \"loop\" early.\n                    break\n                }\n\n                // Shift and mask to calculate the current filled numerator.\n                filledNumerator := and(\n                    shr(OrderStatus_filledNumerator_offset, filledNumerator),\n                    MaxUint120\n                )\n\n                // If denominator of 1 supplied, fill entire remaining amount.\n                if eq(denominator, 1) {\n                    // Set the amount to fill to the remaining amount.\n                    numerator := sub(filledDenominator, filledNumerator)\n\n                    // Set the fill size to the current size.\n                    denominator := filledDenominator\n\n                    // Set the filled amount to the current size.\n                    filledNumerator := filledDenominator\n\n                    // Exit the \"loop\" early.\n                    break\n                }\n\n                // If supplied denominator is equal to the current one:\n                if eq(denominator, filledDenominator) {\n                    // Increment the filled numerator by the new numerator.\n                    filledNumerator := add(numerator, filledNumerator)\n\n                    // Once adjusted, if current + supplied numerator exceeds\n                    // the denominator:\n                    let carry := mul(\n                        sub(filledNumerator, denominator),\n                        gt(filledNumerator, denominator)\n                    )\n\n                    // reduce the amount to fill by the excess.\n                    numerator := sub(numerator, carry)\n\n                    // Reduce the filled amount by the excess as well.\n                    filledNumerator := sub(filledNumerator, carry)\n\n                    // Exit the \"loop\" early.\n                    break\n                }\n\n                // Otherwise, if supplied denominator differs from current one:\n                // Scale the filled amount up by the supplied size.\n                filledNumerator := mul(filledNumerator, denominator)\n\n                // Scale the supplied amount and size up by the current size.\n                numerator := mul(numerator, filledDenominator)\n                denominator := mul(denominator, filledDenominator)\n\n                // Increment the filled numerator by the new numerator.\n                filledNumerator := add(numerator, filledNumerator)\n\n                // Once adjusted, if current + supplied numerator exceeds\n                // denominator:\n                let carry := mul(\n                    sub(filledNumerator, denominator),\n                    gt(filledNumerator, denominator)\n                )\n\n                // reduce the amount to fill by the excess.\n                numerator := sub(numerator, carry)\n\n                // Reduce the filled amount by the excess as well.\n                filledNumerator := sub(filledNumerator, carry)\n\n                // Check filledNumerator and denominator for uint120 overflow.\n                if or(\n                    gt(filledNumerator, MaxUint120),\n                    gt(denominator, MaxUint120)\n                ) {\n                    // Derive greatest common divisor using euclidean algorithm.\n                    function gcd(_a, _b) -> out {\n                        // \"Loop\" until only one non-zero value remains.\n                        for { } _b { } {\n                            // Assign the second value to a temporary variable.\n                            let _c := _b\n\n                            // Derive the modulus of the two values.\n                            _b := mod(_a, _c)\n\n                            // Set the first value to the temporary value.\n                            _a := _c\n                        }\n\n                        // Return the remaining non-zero value.\n                        out := _a\n                    }\n\n                    // Determine the amount to scale down the fill fractions.\n                    let scaleDown := gcd(\n                        numerator,\n                        gcd(filledNumerator, denominator)\n                    )\n\n                    // Ensure that the divisor is at least one.\n                    let safeScaleDown := add(scaleDown, iszero(scaleDown))\n\n                    // Scale all fractional values down by gcd.\n                    numerator := div(numerator, safeScaleDown)\n                    filledNumerator := div(filledNumerator, safeScaleDown)\n                    denominator := div(denominator, safeScaleDown)\n\n                    // Perform the overflow check a second time.\n                    if or(\n                        gt(filledNumerator, MaxUint120),\n                        gt(denominator, MaxUint120)\n                    ) {\n                        // Store the Panic error signature.\n                        mstore(0, Panic_error_selector)\n                        // Store the arithmetic (0x11) panic code.\n                        mstore(Panic_error_code_ptr, Panic_arithmetic)\n\n                        // revert(abi.encodeWithSignature(\n                        //     \"Panic(uint256)\", 0x11\n                        // ))\n                        revert(Error_selector_offset, Panic_error_length)\n                    }\n                }\n\n                // Exit the \"loop\" now that all evaluation is complete.\n                break\n            }\n\n            // Update order status and fill amount, packing struct values.\n            // [denominator: 15 bytes] [numerator: 15 bytes]\n            // [isCancelled: 1 byte] [isValidated: 1 byte]\n            sstore(\n                orderStatusSlot,\n                or(\n                    OrderStatus_ValidatedAndNotCancelled,\n                    or(\n                        shl(\n                            OrderStatus_filledNumerator_offset,\n                            filledNumerator\n                        ),\n                        shl(OrderStatus_filledDenominator_offset, denominator)\n                    )\n                )\n            )\n        }\n    }\n\n    /**\n     * @dev Internal pure function to check the compatibility of two offer\n     *      or consideration items for contract orders.  Note that the itemType\n     *      and identifier are reset in cases where criteria = 0 (collection-\n     *      wide offers), which means that a contract offerer has full latitude\n     *      to choose any identifier it wants mid-flight, in contrast to the\n     *      normal behavior, where the fulfiller can pick which identifier to\n     *      receive by providing a CriteriaResolver.\n     *\n     * @param originalItem The original offer or consideration item.\n     * @param newItem      The new offer or consideration item.\n     *\n     * @return isInvalid Error buffer indicating if items are incompatible.\n     */\n    function _compareItems(\n        MemoryPointer originalItem,\n        MemoryPointer newItem\n    ) internal pure returns (uint256 isInvalid) {\n        assembly {\n            let itemType := mload(originalItem)\n            let identifier := mload(add(originalItem, Common_identifier_offset))\n\n            // Set returned identifier for criteria-based items w/ criteria = 0.\n            if and(gt(itemType, 3), iszero(identifier)) {\n                // replace item type\n                itemType := sub(3, eq(itemType, 4))\n                identifier := mload(add(newItem, Common_identifier_offset))\n            }\n\n            let originalAmount := mload(add(originalItem, Common_amount_offset))\n            let newAmount := mload(add(newItem, Common_amount_offset))\n\n            isInvalid := iszero(\n                and(\n                    // originalItem.token == newItem.token &&\n                    // originalItem.itemType == newItem.itemType\n                    and(\n                        eq(\n                            mload(add(originalItem, Common_token_offset)),\n                            mload(add(newItem, Common_token_offset))\n                        ),\n                        eq(itemType, mload(newItem))\n                    ),\n                    // originalItem.identifier == newItem.identifier &&\n                    // originalItem.startAmount == originalItem.endAmount\n                    and(\n                        eq(\n                            identifier,\n                            mload(add(newItem, Common_identifier_offset))\n                        ),\n                        eq(\n                            originalAmount,\n                            mload(add(originalItem, Common_endAmount_offset))\n                        )\n                    )\n                )\n            )\n        }\n    }\n\n    /**\n     * @dev Internal pure function to check the compatibility of two recipients\n     *      on consideration items for contract orders. This check is skipped if\n     *      no recipient is originally supplied.\n     *\n     * @param originalRecipient The original consideration item recipient.\n     * @param newRecipient      The new consideration item recipient.\n     *\n     * @return isInvalid Error buffer indicating if recipients are incompatible.\n     */\n    function _checkRecipients(\n        address originalRecipient,\n        address newRecipient\n    ) internal pure returns (uint256 isInvalid) {\n        assembly {\n            isInvalid := iszero(\n                or(\n                    iszero(originalRecipient),\n                    eq(newRecipient, originalRecipient)\n                )\n            )\n        }\n    }\n\n    /**\n     * @dev Internal function to generate a contract order. When a\n     *      collection-wide criteria-based item (criteria = 0) is provided as an\n     *      input to a contract order, the contract offerer has full latitude to\n     *      choose any identifier it wants mid-flight, which differs from the\n     *      usual behavior.  For regular criteria-based orders with\n     *      identifierOrCriteria = 0, the fulfiller can pick which identifier to\n     *      receive by providing a CriteriaResolver. For contract offers with\n     *      identifierOrCriteria = 0, Seaport does not expect a corresponding\n     *      CriteriaResolver, and will revert if one is provided.\n     *\n     * @param orderParameters The parameters for the order.\n     * @param context         The context for generating the order.\n     * @param revertOnInvalid Whether to revert on invalid input.\n     *\n     * @return orderHash   The order hash.\n     * @return numerator   The numerator.\n     * @return denominator The denominator.\n     */\n    function _getGeneratedOrder(\n        OrderParameters memory orderParameters,\n        bytes memory context,\n        bool revertOnInvalid\n    )\n        internal\n        returns (bytes32 orderHash, uint256 numerator, uint256 denominator)\n    {\n        // Ensure that consideration array length is equal to the total original\n        // consideration items value.\n        if (\n            orderParameters.consideration.length !=\n            orderParameters.totalOriginalConsiderationItems\n        ) {\n            _revertConsiderationLengthNotEqualToTotalOriginal();\n        }\n\n        {\n            address offerer = orderParameters.offerer;\n            bool success;\n            (MemoryPointer cdPtr, uint256 size) = _encodeGenerateOrder(\n                orderParameters,\n                context\n            );\n            assembly {\n                success := call(gas(), offerer, 0, cdPtr, size, 0, 0)\n            }\n\n            {\n                // Note: overflow impossible; nonce can't increment that high.\n                uint256 contractNonce;\n                unchecked {\n                    // Note: nonce will be incremented even for skipped orders,\n                    // and  even if generateOrder's return data does not satisfy\n                    // all the constraints. This is the case when errorBuffer\n                    // != 0 and revertOnInvalid == false.\n                    contractNonce = _contractNonces[offerer]++;\n                }\n\n                assembly {\n                    // Shift offerer address up 96 bytes and combine with nonce.\n                    orderHash := xor(\n                        contractNonce,\n                        shl(ContractOrder_orderHash_offerer_shift, offerer)\n                    )\n                }\n            }\n\n            // Revert or skip if the call to generate the contract order failed.\n            if (!success) {\n                return _revertOrReturnEmpty(revertOnInvalid, orderHash);\n            }\n        }\n\n        // From this point onward, do not allow for skipping orders as the\n        // contract offerer may have modified state in expectation of any named\n        // consideration items being sent to their designated recipients.\n\n        // Decode the returned contract order and/or update the error buffer.\n        (\n            uint256 errorBuffer,\n            OfferItem[] memory offer,\n            ConsiderationItem[] memory consideration\n        ) = _convertGetGeneratedOrderResult(_decodeGenerateOrderReturndata)();\n\n        // Revert if the returndata could not be decoded correctly.\n        if (errorBuffer != 0) {\n            _revertInvalidContractOrder(orderHash);\n        }\n\n        {\n            // Designate lengths.\n            uint256 originalOfferLength = orderParameters.offer.length;\n            uint256 newOfferLength = offer.length;\n\n            // Explicitly specified offer items cannot be removed.\n            if (originalOfferLength > newOfferLength) {\n                _revertInvalidContractOrder(orderHash);\n            }\n\n            // Iterate over each specified offer (e.g. minimumReceived) item.\n            for (uint256 i = 0; i < originalOfferLength; ) {\n                // Retrieve the pointer to the originally supplied item.\n                MemoryPointer mPtrOriginal = orderParameters\n                    .offer[i]\n                    .toMemoryPointer();\n\n                // Retrieve the pointer to the newly returned item.\n                MemoryPointer mPtrNew = offer[i].toMemoryPointer();\n\n                // Compare the items and update the error buffer accordingly.\n                errorBuffer |=\n                    _cast(\n                        mPtrOriginal\n                            .offset(Common_amount_offset)\n                            .readUint256() >\n                            mPtrNew.offset(Common_amount_offset).readUint256()\n                    ) |\n                    _compareItems(mPtrOriginal, mPtrNew);\n\n                // Increment the array (cannot overflow as index starts at 0).\n                unchecked {\n                    ++i;\n                }\n            }\n\n            // Assign the returned offer item in place of the original item.\n            orderParameters.offer = offer;\n        }\n\n        {\n            // Designate lengths & memory locations.\n            ConsiderationItem[] memory originalConsiderationArray = (\n                orderParameters.consideration\n            );\n            uint256 newConsiderationLength = consideration.length;\n\n            // New consideration items cannot be created.\n            if (newConsiderationLength > originalConsiderationArray.length) {\n                _revertInvalidContractOrder(orderHash);\n            }\n\n            // Iterate over returned consideration & do not exceed maximumSpent.\n            for (uint256 i = 0; i < newConsiderationLength; ) {\n                // Retrieve the pointer to the originally supplied item.\n                MemoryPointer mPtrOriginal = originalConsiderationArray[i]\n                    .toMemoryPointer();\n\n                // Retrieve the pointer to the newly returned item.\n                MemoryPointer mPtrNew = consideration[i].toMemoryPointer();\n\n                // Compare the items and update the error buffer accordingly\n                // and ensure that the recipients are equal when provided.\n                errorBuffer |=\n                    _cast(\n                        mPtrNew.offset(Common_amount_offset).readUint256() >\n                            mPtrOriginal\n                                .offset(Common_amount_offset)\n                                .readUint256()\n                    ) |\n                    _compareItems(mPtrOriginal, mPtrNew) |\n                    _checkRecipients(\n                        mPtrOriginal\n                            .offset(ConsiderItem_recipient_offset)\n                            .readAddress(),\n                        mPtrNew\n                            .offset(ConsiderItem_recipient_offset)\n                            .readAddress()\n                    );\n\n                // Increment the array (cannot overflow as index starts at 0).\n                unchecked {\n                    ++i;\n                }\n            }\n\n            // Assign returned consideration item in place of the original item.\n            orderParameters.consideration = consideration;\n        }\n\n        // Revert if any item comparison failed.\n        if (errorBuffer != 0) {\n            _revertInvalidContractOrder(orderHash);\n        }\n\n        // Return order hash and full fill amount (numerator & denominator = 1).\n        return (orderHash, 1, 1);\n    }\n\n    /**\n     * @dev Internal function to cancel an arbitrary number of orders. Note that\n     *      only the offerer or the zone of a given order may cancel it. Callers\n     *      should ensure that the intended order was cancelled by calling\n     *      `getOrderStatus` and confirming that `isCancelled` returns `true`.\n     *      Also note that contract orders are not cancellable.\n     *\n     * @param orders The orders to cancel.\n     *\n     * @return cancelled A boolean indicating whether the supplied orders were\n     *                   successfully cancelled.\n     */\n    function _cancel(\n        OrderComponents[] calldata orders\n    ) internal returns (bool cancelled) {\n        // Ensure that the reentrancy guard is not currently set.\n        _assertNonReentrant();\n\n        // Declare variables outside of the loop.\n        OrderStatus storage orderStatus;\n\n        // Declare a variable for tracking invariants in the loop.\n        bool anyInvalidCallerOrContractOrder;\n\n        // Skip overflow check as for loop is indexed starting at zero.\n        unchecked {\n            // Read length of the orders array from memory and place on stack.\n            uint256 totalOrders = orders.length;\n\n            // Iterate over each order.\n            for (uint256 i = 0; i < totalOrders; ) {\n                // Retrieve the order.\n                OrderComponents calldata order = orders[i];\n\n                address offerer = order.offerer;\n                address zone = order.zone;\n                OrderType orderType = order.orderType;\n\n                assembly {\n                    // If caller is neither the offerer nor zone, or a contract\n                    // order is present, flag anyInvalidCallerOrContractOrder.\n                    anyInvalidCallerOrContractOrder := or(\n                        anyInvalidCallerOrContractOrder,\n                        // orderType == CONTRACT ||\n                        // !(caller == offerer || caller == zone)\n                        or(\n                            eq(orderType, 4),\n                            iszero(\n                                or(eq(caller(), offerer), eq(caller(), zone))\n                            )\n                        )\n                    )\n                }\n\n                bytes32 orderHash = _deriveOrderHash(\n                    _toOrderParametersReturnType(\n                        _decodeOrderComponentsAsOrderParameters\n                    )(order.toCalldataPointer()),\n                    order.counter\n                );\n\n                // Retrieve the order status using the derived order hash.\n                orderStatus = _orderStatus[orderHash];\n\n                // Update the order status as not valid and cancelled.\n                orderStatus.isValidated = false;\n                orderStatus.isCancelled = true;\n\n                // Emit an event signifying that the order has been cancelled.\n                emit OrderCancelled(orderHash, offerer, zone);\n\n                // Increment counter inside body of loop for gas efficiency.\n                ++i;\n            }\n        }\n\n        if (anyInvalidCallerOrContractOrder) {\n            _revertCannotCancelOrder();\n        }\n\n        // Return a boolean indicating that orders were successfully cancelled.\n        cancelled = true;\n    }\n\n    /**\n     * @dev Internal function to validate an arbitrary number of orders, thereby\n     *      registering their signatures as valid and allowing the fulfiller to\n     *      skip signature verification on fulfillment. Note that validated\n     *      orders may still be unfulfillable due to invalid item amounts or\n     *      other factors; callers should determine whether validated orders are\n     *      fulfillable by simulating the fulfillment call prior to execution.\n     *      Also note that anyone can validate a signed order, but only the\n     *      offerer can validate an order without supplying a signature.\n     *\n     * @param orders The orders to validate.\n     *\n     * @return validated A boolean indicating whether the supplied orders were\n     *                   successfully validated.\n     */\n    function _validate(\n        Order[] memory orders\n    ) internal returns (bool validated) {\n        // Ensure that the reentrancy guard is not currently set.\n        _assertNonReentrant();\n\n        // Declare variables outside of the loop.\n        OrderStatus storage orderStatus;\n        bytes32 orderHash;\n        address offerer;\n\n        // Skip overflow check as for loop is indexed starting at zero.\n        unchecked {\n            // Read length of the orders array from memory and place on stack.\n            uint256 totalOrders = orders.length;\n\n            // Iterate over each order.\n            for (uint256 i = 0; i < totalOrders; ++i) {\n                // Retrieve the order.\n                Order memory order = orders[i];\n\n                // Retrieve the order parameters.\n                OrderParameters memory orderParameters = order.parameters;\n\n                // Skip contract orders.\n                if (orderParameters.orderType == OrderType.CONTRACT) {\n                    continue;\n                }\n\n                // Move offerer from memory to the stack.\n                offerer = orderParameters.offerer;\n\n                // Get current counter & use it w/ params to derive order hash.\n                orderHash = _assertConsiderationLengthAndGetOrderHash(\n                    orderParameters\n                );\n\n                // Retrieve the order status using the derived order hash.\n                orderStatus = _orderStatus[orderHash];\n\n                // Ensure order is fillable and retrieve the filled amount.\n                _verifyOrderStatus(\n                    orderHash,\n                    orderStatus,\n                    false, // Signifies that partially filled orders are valid.\n                    true // Signifies to revert if the order is invalid.\n                );\n\n                // If the order has not already been validated...\n                if (!orderStatus.isValidated) {\n                    // Ensure that consideration array length is equal to the\n                    // total original consideration items value.\n                    if (\n                        orderParameters.consideration.length !=\n                        orderParameters.totalOriginalConsiderationItems\n                    ) {\n                        _revertConsiderationLengthNotEqualToTotalOriginal();\n                    }\n\n                    // Verify the supplied signature.\n                    _verifySignature(offerer, orderHash, order.signature);\n\n                    // Update order status to mark the order as valid.\n                    orderStatus.isValidated = true;\n\n                    // Emit an event signifying the order has been validated.\n                    emit OrderValidated(orderHash, orderParameters);\n                }\n            }\n        }\n\n        // Return a boolean indicating that orders were successfully validated.\n        validated = true;\n    }\n\n    /**\n     * @dev Internal view function to retrieve the status of a given order by\n     *      hash, including whether the order has been cancelled or validated\n     *      and the fraction of the order that has been filled.\n     *\n     * @param orderHash The order hash in question.\n     *\n     * @return isValidated A boolean indicating whether the order in question\n     *                     has been validated (i.e. previously approved or\n     *                     partially filled).\n     * @return isCancelled A boolean indicating whether the order in question\n     *                     has been cancelled.\n     * @return totalFilled The total portion of the order that has been filled\n     *                     (i.e. the \"numerator\").\n     * @return totalSize   The total size of the order that is either filled or\n     *                     unfilled (i.e. the \"denominator\").\n     */\n    function _getOrderStatus(\n        bytes32 orderHash\n    )\n        internal\n        view\n        returns (\n            bool isValidated,\n            bool isCancelled,\n            uint256 totalFilled,\n            uint256 totalSize\n        )\n    {\n        // Retrieve the order status using the order hash.\n        OrderStatus storage orderStatus = _orderStatus[orderHash];\n\n        // Return the fields on the order status.\n        return (\n            orderStatus.isValidated,\n            orderStatus.isCancelled,\n            orderStatus.numerator,\n            orderStatus.denominator\n        );\n    }\n\n    /**\n     * @dev Internal pure function to either revert or return an empty tuple\n     *      depending on the value of `revertOnInvalid`.\n     *\n     * @param revertOnInvalid   Whether to revert on invalid input.\n     * @param contractOrderHash The contract order hash.\n     *\n     * @return orderHash   The order hash.\n     * @return numerator   The numerator.\n     * @return denominator The denominator.\n     */\n    function _revertOrReturnEmpty(\n        bool revertOnInvalid,\n        bytes32 contractOrderHash\n    )\n        internal\n        pure\n        returns (bytes32 orderHash, uint256 numerator, uint256 denominator)\n    {\n        if (revertOnInvalid) {\n            _revertInvalidContractOrder(contractOrderHash);\n        }\n\n        return (contractOrderHash, 0, 0);\n    }\n\n    /**\n     * @dev Internal pure function to check whether a given order type indicates\n     *      that partial fills are not supported (e.g. only \"full fills\" are\n     *      allowed for the order in question).\n     *\n     * @param orderType   The order type in question.\n     * @param numerator   The numerator in question.\n     * @param denominator The denominator in question.\n     *\n     * @return isFullOrder A boolean indicating whether the order type only\n     *                     supports full fills.\n     */\n    function _doesNotSupportPartialFills(\n        OrderType orderType,\n        uint256 numerator,\n        uint256 denominator\n    ) internal pure returns (bool isFullOrder) {\n        // The \"full\" order types are even, while \"partial\" order types are odd.\n        // Bitwise and by 1 is equivalent to modulo by 2, but 2 gas cheaper. The\n        // check is only necessary if numerator is less than denominator.\n        assembly {\n            // Equivalent to `uint256(orderType) & 1 == 0`.\n            isFullOrder := and(\n                lt(numerator, denominator),\n                iszero(and(orderType, 1))\n            )\n        }\n    }\n}\n"},"contracts/lib/OrderFulfiller.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ItemType, OrderType } from \"./ConsiderationEnums.sol\";\n\nimport {\n    AdvancedOrder,\n    ConsiderationItem,\n    CriteriaResolver,\n    OfferItem,\n    OrderParameters,\n    ReceivedItem,\n    SpentItem\n} from \"./ConsiderationStructs.sol\";\n\nimport { BasicOrderFulfiller } from \"./BasicOrderFulfiller.sol\";\n\nimport { CriteriaResolution } from \"./CriteriaResolution.sol\";\n\nimport { AmountDeriver } from \"./AmountDeriver.sol\";\n\nimport {\n    _revertInsufficientNativeTokensSupplied,\n    _revertInvalidNativeOfferItem\n} from \"./ConsiderationErrors.sol\";\n\nimport {\n    AccumulatorDisarmed,\n    ConsiderationItem_recipient_offset,\n    ReceivedItem_amount_offset,\n    ReceivedItem_recipient_offset\n} from \"./ConsiderationConstants.sol\";\n\n/**\n * @title OrderFulfiller\n * @author 0age\n * @notice OrderFulfiller contains logic related to order fulfillment where a\n *         single order is being fulfilled and where basic order fulfillment is\n *         not available as an option.\n */\ncontract OrderFulfiller is\n    BasicOrderFulfiller,\n    CriteriaResolution,\n    AmountDeriver\n{\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(\n        address conduitController\n    ) BasicOrderFulfiller(conduitController) {}\n\n    /**\n     * @dev Internal function to validate an order and update its status, adjust\n     *      prices based on current time, apply criteria resolvers, determine\n     *      what portion to fill, and transfer relevant tokens.\n     *\n     * @param advancedOrder       The order to fulfill as well as the fraction\n     *                            to fill. Note that all offer and consideration\n     *                            components must divide with no remainder for\n     *                            the partial fill to be valid.\n     * @param criteriaResolvers   An array where each element contains a\n     *                            reference to a specific offer or\n     *                            consideration, a token identifier, and a proof\n     *                            that the supplied token identifier is\n     *                            contained in the order's merkle root. Note\n     *                            that a criteria of zero indicates that any\n     *                            (transferable) token identifier is valid and\n     *                            that no proof needs to be supplied.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller's token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used, with direct approvals set on\n     *                            Consideration.\n     * @param recipient           The intended recipient for all received items.\n     *\n     * @return A boolean indicating whether the order has been fulfilled.\n     */\n    function _validateAndFulfillAdvancedOrder(\n        AdvancedOrder memory advancedOrder,\n        CriteriaResolver[] memory criteriaResolvers,\n        bytes32 fulfillerConduitKey,\n        address recipient\n    ) internal returns (bool) {\n        // Ensure this function cannot be triggered during a reentrant call.\n        _setReentrancyGuard(\n            // Native tokens accepted during execution for contract order types.\n            advancedOrder.parameters.orderType == OrderType.CONTRACT\n        );\n\n        // Validate order, update status, and determine fraction to fill.\n        (\n            bytes32 orderHash,\n            uint256 fillNumerator,\n            uint256 fillDenominator\n        ) = _validateOrderAndUpdateStatus(advancedOrder, true);\n\n        // Create an array with length 1 containing the order.\n        AdvancedOrder[] memory advancedOrders = new AdvancedOrder[](1);\n\n        // Populate the order as the first and only element of the new array.\n        advancedOrders[0] = advancedOrder;\n\n        // Apply criteria resolvers using generated orders and details arrays.\n        _applyCriteriaResolvers(advancedOrders, criteriaResolvers);\n\n        // Retrieve the order parameters after applying criteria resolvers.\n        OrderParameters memory orderParameters = advancedOrders[0].parameters;\n\n        // Perform each item transfer with the appropriate fractional amount.\n        _applyFractionsAndTransferEach(\n            orderParameters,\n            fillNumerator,\n            fillDenominator,\n            fulfillerConduitKey,\n            recipient\n        );\n\n        // Declare empty bytes32 array and populate with the order hash.\n        bytes32[] memory orderHashes = new bytes32[](1);\n        orderHashes[0] = orderHash;\n\n        // Ensure restricted orders have a valid submitter or pass a zone check.\n        _assertRestrictedAdvancedOrderValidity(\n            advancedOrders[0],\n            orderHashes,\n            orderHash\n        );\n\n        // Emit an event signifying that the order has been fulfilled.\n        _emitOrderFulfilledEvent(\n            orderHash,\n            orderParameters.offerer,\n            orderParameters.zone,\n            recipient,\n            orderParameters.offer,\n            orderParameters.consideration\n        );\n\n        // Clear the reentrancy guard.\n        _clearReentrancyGuard();\n\n        return true;\n    }\n\n    /**\n     * @dev Internal function to transfer each item contained in a given single\n     *      order fulfillment after applying a respective fraction to the amount\n     *      being transferred.\n     *\n     * @param orderParameters     The parameters for the fulfilled order.\n     * @param numerator           A value indicating the portion of the order\n     *                            that should be filled.\n     * @param denominator         A value indicating the total order size.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller's token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used, with direct approvals set on\n     *                            Consideration.\n     * @param recipient           The intended recipient for all received items.\n     */\n    function _applyFractionsAndTransferEach(\n        OrderParameters memory orderParameters,\n        uint256 numerator,\n        uint256 denominator,\n        bytes32 fulfillerConduitKey,\n        address recipient\n    ) internal {\n        // Read start time & end time from order parameters and place on stack.\n        uint256 startTime = orderParameters.startTime;\n        uint256 endTime = orderParameters.endTime;\n\n        // Initialize an accumulator array. From this point forward, no new\n        // memory regions can be safely allocated until the accumulator is no\n        // longer being utilized, as the accumulator operates in an open-ended\n        // fashion from this memory pointer; existing memory may still be\n        // accessed and modified, however.\n        bytes memory accumulator = new bytes(AccumulatorDisarmed);\n\n        // As of solidity 0.6.0, inline assembly cannot directly access function\n        // definitions, but can still access locally scoped function variables.\n        // This means that a local variable to reference the internal function\n        // definition (using the same type), along with a local variable with\n        // the desired type, must first be created. Then, the original function\n        // pointer can be recast to the desired type.\n\n        /**\n         * Repurpose existing OfferItem memory regions on the offer array for\n         * the order by overriding the _transfer function pointer to accept a\n         * modified OfferItem argument in place of the usual ReceivedItem:\n         *\n         *   ========= OfferItem ==========   ====== ReceivedItem ======\n         *   ItemType itemType; ------------> ItemType itemType;\n         *   address token; ----------------> address token;\n         *   uint256 identifierOrCriteria; -> uint256 identifier;\n         *   uint256 startAmount; ----------> uint256 amount;\n         *   uint256 endAmount; ------------> address recipient;\n         */\n\n        // Declare a nested scope to minimize stack depth.\n        unchecked {\n            // Read offer array length from memory and place on stack.\n            uint256 totalOfferItems = orderParameters.offer.length;\n\n            // Create a variable to indicate whether the order has any\n            // native offer items\n            uint256 anyNativeItems;\n\n            // Iterate over each offer on the order.\n            // Skip overflow check as for loop is indexed starting at zero.\n            for (uint256 i = 0; i < totalOfferItems; ++i) {\n                // Retrieve the offer item.\n                OfferItem memory offerItem = orderParameters.offer[i];\n\n                // Offer items for the native token can not be received outside\n                // of a match order function except as part of a contract order.\n                {\n                    ItemType itemType = offerItem.itemType;\n                    assembly {\n                        anyNativeItems := or(anyNativeItems, iszero(itemType))\n                    }\n                }\n\n                // Declare an additional nested scope to minimize stack depth.\n                {\n                    // Apply fill fraction to get offer item amount to transfer.\n                    uint256 amount = _applyFraction(\n                        offerItem.startAmount,\n                        offerItem.endAmount,\n                        numerator,\n                        denominator,\n                        startTime,\n                        endTime,\n                        false\n                    );\n\n                    // Utilize assembly to set overloaded offerItem arguments.\n                    assembly {\n                        // Write new fractional amount to startAmount as amount.\n                        mstore(\n                            add(offerItem, ReceivedItem_amount_offset),\n                            amount\n                        )\n\n                        // Write recipient to endAmount.\n                        mstore(\n                            add(offerItem, ReceivedItem_recipient_offset),\n                            recipient\n                        )\n                    }\n                }\n\n                // Transfer the item from the offerer to the recipient.\n                _toOfferItemInput(_transfer)(\n                    offerItem,\n                    orderParameters.offerer,\n                    orderParameters.conduitKey,\n                    accumulator\n                );\n            }\n\n            // If a non-contract order has native offer items, throw with an\n            // `InvalidNativeOfferItem` custom error.\n            {\n                OrderType orderType = orderParameters.orderType;\n                uint256 invalidNativeOfferItem;\n                assembly {\n                    invalidNativeOfferItem := and(\n                        // Note that this check requires that there are no order\n                        // types beyond the current set (0-4).  It will need to\n                        // be modified if more order types are added.\n                        lt(orderType, 4),\n                        anyNativeItems\n                    )\n                }\n                if (invalidNativeOfferItem != 0) {\n                    _revertInvalidNativeOfferItem();\n                }\n            }\n        }\n\n        // Declare a variable for the available native token balance.\n        uint256 nativeTokenBalance;\n\n        /**\n         * Repurpose existing ConsiderationItem memory regions on the\n         * consideration array for the order by overriding the _transfer\n         * function pointer to accept a modified ConsiderationItem argument in\n         * place of the usual ReceivedItem:\n         *\n         *   ====== ConsiderationItem =====   ====== ReceivedItem ======\n         *   ItemType itemType; ------------> ItemType itemType;\n         *   address token; ----------------> address token;\n         *   uint256 identifierOrCriteria;--> uint256 identifier;\n         *   uint256 startAmount; ----------> uint256 amount;\n         *   uint256 endAmount;        /----> address recipient;\n         *   address recipient; ------/\n         */\n\n        // Declare a nested scope to minimize stack depth.\n        unchecked {\n            // Read consideration array length from memory and place on stack.\n            uint256 totalConsiderationItems = orderParameters\n                .consideration\n                .length;\n\n            // Iterate over each consideration item on the order.\n            // Skip overflow check as for loop is indexed starting at zero.\n            for (uint256 i = 0; i < totalConsiderationItems; ++i) {\n                // Retrieve the consideration item.\n                ConsiderationItem memory considerationItem = (\n                    orderParameters.consideration[i]\n                );\n\n                // Apply fraction & derive considerationItem amount to transfer.\n                uint256 amount = _applyFraction(\n                    considerationItem.startAmount,\n                    considerationItem.endAmount,\n                    numerator,\n                    denominator,\n                    startTime,\n                    endTime,\n                    true\n                );\n\n                // Use assembly to set overloaded considerationItem arguments.\n                assembly {\n                    // Write derived fractional amount to startAmount as amount.\n                    mstore(\n                        add(considerationItem, ReceivedItem_amount_offset),\n                        amount\n                    )\n\n                    // Write original recipient to endAmount as recipient.\n                    mstore(\n                        add(considerationItem, ReceivedItem_recipient_offset),\n                        mload(\n                            add(\n                                considerationItem,\n                                ConsiderationItem_recipient_offset\n                            )\n                        )\n                    )\n                }\n\n                if (considerationItem.itemType == ItemType.NATIVE) {\n                    // Get the current available balance of native tokens.\n                    assembly {\n                        nativeTokenBalance := selfbalance()\n                    }\n\n                    // Ensure that sufficient native tokens are still available.\n                    if (amount > nativeTokenBalance) {\n                        _revertInsufficientNativeTokensSupplied();\n                    }\n                }\n\n                // Transfer item from caller to recipient specified by the item.\n                _toConsiderationItemInput(_transfer)(\n                    considerationItem,\n                    msg.sender,\n                    fulfillerConduitKey,\n                    accumulator\n                );\n            }\n        }\n\n        // Trigger any remaining accumulated transfers via call to the conduit.\n        _triggerIfArmed(accumulator);\n\n        // Determine whether any native token balance remains.\n        assembly {\n            nativeTokenBalance := selfbalance()\n        }\n\n        // Return any remaining native token balance to the caller.\n        if (nativeTokenBalance != 0) {\n            _transferNativeTokens(payable(msg.sender), nativeTokenBalance);\n        }\n    }\n\n    /**\n     * @dev Internal function to emit an OrderFulfilled event. OfferItems are\n     *      translated into SpentItems and ConsiderationItems are translated\n     *      into ReceivedItems.\n     *\n     * @param orderHash     The order hash.\n     * @param offerer       The offerer for the order.\n     * @param zone          The zone for the order.\n     * @param recipient     The recipient of the order, or the null address if\n     *                      the order was fulfilled via order matching.\n     * @param offer         The offer items for the order.\n     * @param consideration The consideration items for the order.\n     */\n    function _emitOrderFulfilledEvent(\n        bytes32 orderHash,\n        address offerer,\n        address zone,\n        address recipient,\n        OfferItem[] memory offer,\n        ConsiderationItem[] memory consideration\n    ) internal {\n        // Cast already-modified offer memory region as spent items.\n        SpentItem[] memory spentItems;\n        assembly {\n            spentItems := offer\n        }\n\n        // Cast already-modified consideration memory region as received items.\n        ReceivedItem[] memory receivedItems;\n        assembly {\n            receivedItems := consideration\n        }\n\n        // Emit an event signifying that the order has been fulfilled.\n        emit OrderFulfilled(\n            orderHash,\n            offerer,\n            zone,\n            recipient,\n            spentItems,\n            receivedItems\n        );\n    }\n}\n"},"contracts/interfaces/ConsiderationInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    AdvancedOrder,\n    BasicOrderParameters,\n    CriteriaResolver,\n    Execution,\n    Fulfillment,\n    FulfillmentComponent,\n    Order,\n    OrderComponents\n} from \"../lib/ConsiderationStructs.sol\";\n\n/**\n * @title ConsiderationInterface\n * @author 0age\n * @custom:version 1.5\n * @notice Consideration is a generalized native token/ERC20/ERC721/ERC1155\n *         marketplace. It minimizes external calls to the greatest extent\n *         possible and provides lightweight methods for common routes as well\n *         as more flexible methods for composing advanced orders.\n *\n * @dev ConsiderationInterface contains all external function interfaces for\n *      Consideration.\n */\ninterface ConsiderationInterface {\n    /**\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\n     *         the native token for the given chain) as consideration for the\n     *         order. An arbitrary number of \"additional recipients\" may also be\n     *         supplied which will each receive native tokens from the fulfiller\n     *         as consideration.\n     *\n     * @param parameters Additional information on the fulfilled order. Note\n     *                   that the offerer must first approve this contract (or\n     *                   their preferred conduit if indicated by the order) for\n     *                   their offered ERC721 token to be transferred.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillBasicOrder(\n        BasicOrderParameters calldata parameters\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Fulfill an order with an arbitrary number of items for offer and\n     *         consideration. Note that this function does not support\n     *         criteria-based orders or partial filling of orders (though\n     *         filling the remainder of a partially-filled order is supported).\n     *\n     * @param order               The order to fulfill. Note that both the\n     *                            offerer and the fulfiller must first approve\n     *                            this contract (or the corresponding conduit if\n     *                            indicated) to transfer any relevant tokens on\n     *                            their behalf and that contracts must implement\n     *                            `onERC1155Received` to receive ERC1155 tokens\n     *                            as consideration.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller's token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used, with direct approvals set on\n     *                            Consideration.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillOrder(\n        Order calldata order,\n        bytes32 fulfillerConduitKey\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Fill an order, fully or partially, with an arbitrary number of\n     *         items for offer and consideration alongside criteria resolvers\n     *         containing specific token identifiers and associated proofs.\n     *\n     * @param advancedOrder       The order to fulfill along with the fraction\n     *                            of the order to attempt to fill. Note that\n     *                            both the offerer and the fulfiller must first\n     *                            approve this contract (or their preferred\n     *                            conduit if indicated by the order) to transfer\n     *                            any relevant tokens on their behalf and that\n     *                            contracts must implement `onERC1155Received`\n     *                            to receive ERC1155 tokens as consideration.\n     *                            Also note that all offer and consideration\n     *                            components must have no remainder after\n     *                            multiplication of the respective amount with\n     *                            the supplied fraction for the partial fill to\n     *                            be considered valid.\n     * @param criteriaResolvers   An array where each element contains a\n     *                            reference to a specific offer or\n     *                            consideration, a token identifier, and a proof\n     *                            that the supplied token identifier is\n     *                            contained in the merkle root held by the item\n     *                            in question's criteria element. Note that an\n     *                            empty criteria indicates that any\n     *                            (transferable) token identifier on the token\n     *                            in question is valid and that no associated\n     *                            proof needs to be supplied.\n     * @param fulfillerConduitKey A bytes32 value indicating what conduit, if\n     *                            any, to source the fulfiller's token approvals\n     *                            from. The zero hash signifies that no conduit\n     *                            should be used, with direct approvals set on\n     *                            Consideration.\n     * @param recipient           The intended recipient for all received items,\n     *                            with `address(0)` indicating that the caller\n     *                            should receive the items.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillAdvancedOrder(\n        AdvancedOrder calldata advancedOrder,\n        CriteriaResolver[] calldata criteriaResolvers,\n        bytes32 fulfillerConduitKey,\n        address recipient\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Attempt to fill a group of orders, each with an arbitrary number\n     *         of items for offer and consideration. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *         Note that this function does not support criteria-based orders or\n     *         partial filling of orders (though filling the remainder of a\n     *         partially-filled order is supported).\n     *\n     * @param orders                    The orders to fulfill. Note that both\n     *                                  the offerer and the fulfiller must first\n     *                                  approve this contract (or the\n     *                                  corresponding conduit if indicated) to\n     *                                  transfer any relevant tokens on their\n     *                                  behalf and that contracts must implement\n     *                                  `onERC1155Received` to receive ERC1155\n     *                                  tokens as consideration.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used, with\n     *                                  direct approvals set on this contract.\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders. Note that unspent offer item amounts or\n     *                         native tokens will not be reflected as part of\n     *                         this array.\n     */\n    function fulfillAvailableOrders(\n        Order[] calldata orders,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        returns (bool[] memory availableOrders, Execution[] memory executions);\n\n    /**\n     * @notice Attempt to fill a group of orders, fully or partially, with an\n     *         arbitrary number of items for offer and consideration per order\n     *         alongside criteria resolvers containing specific token\n     *         identifiers and associated proofs. Any order that is not\n     *         currently active, has already been fully filled, or has been\n     *         cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *\n     * @param advancedOrders            The orders to fulfill along with the\n     *                                  fraction of those orders to attempt to\n     *                                  fill. Note that both the offerer and the\n     *                                  fulfiller must first approve this\n     *                                  contract (or their preferred conduit if\n     *                                  indicated by the order) to transfer any\n     *                                  relevant tokens on their behalf and that\n     *                                  contracts must implement\n     *                                  `onERC1155Received` to enable receipt of\n     *                                  ERC1155 tokens as consideration. Also\n     *                                  note that all offer and consideration\n     *                                  components must have no remainder after\n     *                                  multiplication of the respective amount\n     *                                  with the supplied fraction for an\n     *                                  order's partial fill amount to be\n     *                                  considered valid.\n     * @param criteriaResolvers         An array where each element contains a\n     *                                  reference to a specific offer or\n     *                                  consideration, a token identifier, and a\n     *                                  proof that the supplied token identifier\n     *                                  is contained in the merkle root held by\n     *                                  the item in question's criteria element.\n     *                                  Note that an empty criteria indicates\n     *                                  that any (transferable) token\n     *                                  identifier on the token in question is\n     *                                  valid and that no associated proof needs\n     *                                  to be supplied.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used, with\n     *                                  direct approvals set on this contract.\n     * @param recipient                 The intended recipient for all received\n     *                                  items, with `address(0)` indicating that\n     *                                  the caller should receive the items.\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders. Note that unspent offer item amounts or\n     *                         native tokens will not be reflected as part of\n     *                         this array.\n     */\n    function fulfillAvailableAdvancedOrders(\n        AdvancedOrder[] calldata advancedOrders,\n        CriteriaResolver[] calldata criteriaResolvers,\n        FulfillmentComponent[][] calldata offerFulfillments,\n        FulfillmentComponent[][] calldata considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        address recipient,\n        uint256 maximumFulfilled\n    )\n        external\n        payable\n        returns (bool[] memory availableOrders, Execution[] memory executions);\n\n    /**\n     * @notice Match an arbitrary number of orders, each with an arbitrary\n     *         number of items for offer and consideration along with a set of\n     *         fulfillments allocating offer components to consideration\n     *         components. Note that this function does not support\n     *         criteria-based or partial filling of orders (though filling the\n     *         remainder of a partially-filled order is supported). Any unspent\n     *         offer item amounts or native tokens will be transferred to the\n     *         caller.\n     *\n     * @param orders       The orders to match. Note that both the offerer and\n     *                     fulfiller on each order must first approve this\n     *                     contract (or their conduit if indicated by the order)\n     *                     to transfer any relevant tokens on their behalf and\n     *                     each consideration recipient must implement\n     *                     `onERC1155Received` to enable ERC1155 token receipt.\n     * @param fulfillments An array of elements allocating offer components to\n     *                     consideration components. Note that each\n     *                     consideration component must be fully met for the\n     *                     match operation to be valid.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders. Note that unspent offer item amounts or\n     *                    native tokens will not be reflected as part of this\n     *                    array.\n     */\n    function matchOrders(\n        Order[] calldata orders,\n        Fulfillment[] calldata fulfillments\n    ) external payable returns (Execution[] memory executions);\n\n    /**\n     * @notice Match an arbitrary number of full or partial orders, each with an\n     *         arbitrary number of items for offer and consideration, supplying\n     *         criteria resolvers containing specific token identifiers and\n     *         associated proofs as well as fulfillments allocating offer\n     *         components to consideration components. Any unspent offer item\n     *         amounts will be transferred to the designated recipient (with the\n     *         null address signifying to use the caller) and any unspent native\n     *         tokens will be returned to the caller.\n     *\n     * @param orders            The advanced orders to match. Note that both the\n     *                          offerer and fulfiller on each order must first\n     *                          approve this contract (or a preferred conduit if\n     *                          indicated by the order) to transfer any relevant\n     *                          tokens on their behalf and each consideration\n     *                          recipient must implement `onERC1155Received` in\n     *                          order to receive ERC1155 tokens. Also note that\n     *                          the offer and consideration components for each\n     *                          order must have no remainder after multiplying\n     *                          the respective amount with the supplied fraction\n     *                          in order for the group of partial fills to be\n     *                          considered valid.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific order as well as that order's\n     *                          offer or consideration, a token identifier, and\n     *                          a proof that the supplied token identifier is\n     *                          contained in the order's merkle root. Note that\n     *                          an empty root indicates that any (transferable)\n     *                          token identifier is valid and that no associated\n     *                          proof needs to be supplied.\n     * @param fulfillments      An array of elements allocating offer components\n     *                          to consideration components. Note that each\n     *                          consideration component must be fully met in\n     *                          order for the match operation to be valid.\n     * @param recipient         The intended recipient for all unspent offer\n     *                          item amounts, or the caller if the null address\n     *                          is supplied.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders. Note that unspent offer item amounts or native\n     *                    tokens will not be reflected as part of this array.\n     */\n    function matchAdvancedOrders(\n        AdvancedOrder[] calldata orders,\n        CriteriaResolver[] calldata criteriaResolvers,\n        Fulfillment[] calldata fulfillments,\n        address recipient\n    ) external payable returns (Execution[] memory executions);\n\n    /**\n     * @notice Cancel an arbitrary number of orders. Note that only the offerer\n     *         or the zone of a given order may cancel it. Callers should ensure\n     *         that the intended order was cancelled by calling `getOrderStatus`\n     *         and confirming that `isCancelled` returns `true`.\n     *\n     * @param orders The orders to cancel.\n     *\n     * @return cancelled A boolean indicating whether the supplied orders have\n     *                   been successfully cancelled.\n     */\n    function cancel(\n        OrderComponents[] calldata orders\n    ) external returns (bool cancelled);\n\n    /**\n     * @notice Validate an arbitrary number of orders, thereby registering their\n     *         signatures as valid and allowing the fulfiller to skip signature\n     *         verification on fulfillment. Note that validated orders may still\n     *         be unfulfillable due to invalid item amounts or other factors;\n     *         callers should determine whether validated orders are fulfillable\n     *         by simulating the fulfillment call prior to execution. Also note\n     *         that anyone can validate a signed order, but only the offerer can\n     *         validate an order without supplying a signature.\n     *\n     * @param orders The orders to validate.\n     *\n     * @return validated A boolean indicating whether the supplied orders have\n     *                   been successfully validated.\n     */\n    function validate(\n        Order[] calldata orders\n    ) external returns (bool validated);\n\n    /**\n     * @notice Cancel all orders from a given offerer with a given zone in bulk\n     *         by incrementing a counter. Note that only the offerer may\n     *         increment the counter.\n     *\n     * @return newCounter The new counter.\n     */\n    function incrementCounter() external returns (uint256 newCounter);\n\n    /**\n     * @notice Fulfill an order offering an ERC721 token by supplying Ether (or\n     *         the native token for the given chain) as consideration for the\n     *         order. An arbitrary number of \"additional recipients\" may also be\n     *         supplied which will each receive native tokens from the fulfiller\n     *         as consideration. Note that this function costs less gas than\n     *         `fulfillBasicOrder` due to the zero bytes in the function\n     *         selector (0x00000000) which also results in earlier function\n     *         dispatch.\n     *\n     * @param parameters Additional information on the fulfilled order. Note\n     *                   that the offerer must first approve this contract (or\n     *                   their preferred conduit if indicated by the order) for\n     *                   their offered ERC721 token to be transferred.\n     *\n     * @return fulfilled A boolean indicating whether the order has been\n     *                   successfully fulfilled.\n     */\n    function fulfillBasicOrder_efficient_6GL6yc(\n        BasicOrderParameters calldata parameters\n    ) external payable returns (bool fulfilled);\n\n    /**\n     * @notice Retrieve the order hash for a given order.\n     *\n     * @param order The components of the order.\n     *\n     * @return orderHash The order hash.\n     */\n    function getOrderHash(\n        OrderComponents calldata order\n    ) external view returns (bytes32 orderHash);\n\n    /**\n     * @notice Retrieve the status of a given order by hash, including whether\n     *         the order has been cancelled or validated and the fraction of the\n     *         order that has been filled.\n     *\n     * @param orderHash The order hash in question.\n     *\n     * @return isValidated A boolean indicating whether the order in question\n     *                     has been validated (i.e. previously approved or\n     *                     partially filled).\n     * @return isCancelled A boolean indicating whether the order in question\n     *                     has been cancelled.\n     * @return totalFilled The total portion of the order that has been filled\n     *                     (i.e. the \"numerator\").\n     * @return totalSize   The total size of the order that is either filled or\n     *                     unfilled (i.e. the \"denominator\").\n     */\n    function getOrderStatus(\n        bytes32 orderHash\n    )\n        external\n        view\n        returns (\n            bool isValidated,\n            bool isCancelled,\n            uint256 totalFilled,\n            uint256 totalSize\n        );\n\n    /**\n     * @notice Retrieve the current counter for a given offerer.\n     *\n     * @param offerer The offerer in question.\n     *\n     * @return counter The current counter.\n     */\n    function getCounter(\n        address offerer\n    ) external view returns (uint256 counter);\n\n    /**\n     * @notice Retrieve configuration information for this contract.\n     *\n     * @return version           The contract version.\n     * @return domainSeparator   The domain separator for this contract.\n     * @return conduitController The conduit Controller set for this contract.\n     */\n    function information()\n        external\n        view\n        returns (\n            string memory version,\n            bytes32 domainSeparator,\n            address conduitController\n        );\n\n    function getContractOffererNonce(\n        address contractOfferer\n    ) external view returns (uint256 nonce);\n\n    /**\n     * @notice Retrieve the name of this contract.\n     *\n     * @return contractName The name of this contract.\n     */\n    function name() external view returns (string memory contractName);\n}\n"},"contracts/interfaces/CriteriaResolutionErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport { Side } from \"../lib/ConsiderationEnums.sol\";\n\n/**\n * @title CriteriaResolutionErrors\n * @author 0age\n * @notice CriteriaResolutionErrors contains all errors related to criteria\n *         resolution.\n */\ninterface CriteriaResolutionErrors {\n    /**\n     * @dev Revert with an error when providing a criteria resolver that refers\n     *      to an order that has not been supplied.\n     *\n     * @param side The side of the order that was not supplied.\n     */\n    error OrderCriteriaResolverOutOfRange(Side side);\n\n    /**\n     * @dev Revert with an error if an offer item still has unresolved criteria\n     *      after applying all criteria resolvers.\n     *\n     * @param orderIndex The index of the order that contains the offer item.\n     * @param offerIndex The index of the offer item that still has unresolved\n     *                   criteria.\n     */\n    error UnresolvedOfferCriteria(uint256 orderIndex, uint256 offerIndex);\n\n    /**\n     * @dev Revert with an error if a consideration item still has unresolved\n     *      criteria after applying all criteria resolvers.\n     *\n     * @param orderIndex         The index of the order that contains the\n     *                           consideration item.\n     * @param considerationIndex The index of the consideration item that still\n     *                           has unresolved criteria.\n     */\n    error UnresolvedConsiderationCriteria(\n        uint256 orderIndex,\n        uint256 considerationIndex\n    );\n\n    /**\n     * @dev Revert with an error when providing a criteria resolver that refers\n     *      to an order with an offer item that has not been supplied.\n     */\n    error OfferCriteriaResolverOutOfRange();\n\n    /**\n     * @dev Revert with an error when providing a criteria resolver that refers\n     *      to an order with a consideration item that has not been supplied.\n     */\n    error ConsiderationCriteriaResolverOutOfRange();\n\n    /**\n     * @dev Revert with an error when providing a criteria resolver that refers\n     *      to an order with an item that does not expect a criteria to be\n     *      resolved.\n     */\n    error CriteriaNotEnabledForItem();\n\n    /**\n     * @dev Revert with an error when providing a criteria resolver that\n     *      contains an invalid proof with respect to the given item and\n     *      chosen identifier.\n     */\n    error InvalidProof();\n}\n"},"contracts/lib/SignatureVerification.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {\n    SignatureVerificationErrors\n} from \"../interfaces/SignatureVerificationErrors.sol\";\n\nimport { LowLevelHelpers } from \"./LowLevelHelpers.sol\";\n\nimport {\n    ECDSA_MaxLength,\n    ECDSA_signature_s_offset,\n    ECDSA_signature_v_offset,\n    ECDSA_twentySeventhAndTwentyEighthBytesSet,\n    Ecrecover_args_size,\n    Ecrecover_precompile,\n    EIP1271_isValidSignature_calldata_baseLength,\n    EIP1271_isValidSignature_digest_negativeOffset,\n    EIP1271_isValidSignature_selector_negativeOffset,\n    EIP1271_isValidSignature_selector,\n    EIP1271_isValidSignature_signature_head_offset,\n    EIP2098_allButHighestBitMask,\n    MaxUint8,\n    OneWord,\n    Signature_lower_v\n} from \"./ConsiderationConstants.sol\";\n\nimport {\n    BadContractSignature_error_length,\n    BadContractSignature_error_selector,\n    BadSignatureV_error_length,\n    BadSignatureV_error_selector,\n    BadSignatureV_error_v_ptr,\n    Error_selector_offset,\n    InvalidSignature_error_length,\n    InvalidSignature_error_selector,\n    InvalidSigner_error_length,\n    InvalidSigner_error_selector\n} from \"./ConsiderationErrorConstants.sol\";\n\n/**\n * @title SignatureVerification\n * @author 0age\n * @notice SignatureVerification contains logic for verifying signatures.\n */\ncontract SignatureVerification is SignatureVerificationErrors, LowLevelHelpers {\n    /**\n     * @dev Internal view function to verify the signature of an order. An\n     *      ERC-1271 fallback will be attempted if either the signature length\n     *      is not 64 or 65 bytes or if the recovered signer does not match the\n     *      supplied signer.\n     *\n     * @param signer                  The signer for the order.\n     * @param digest                  The digest to verify signature against.\n     * @param originalDigest          The original digest to verify signature\n     *                                against.\n     * @param originalSignatureLength The original signature length.\n     * @param signature               A signature from the signer indicating\n     *                                that the order has been approved.\n     */\n    function _assertValidSignature(\n        address signer,\n        bytes32 digest,\n        bytes32 originalDigest,\n        uint256 originalSignatureLength,\n        bytes memory signature\n    ) internal view {\n        // Declare value for ecrecover equality or 1271 call success status.\n        bool success;\n\n        // Utilize assembly to perform optimized signature verification check.\n        assembly {\n            // Ensure that first word of scratch space is empty.\n            mstore(0, 0)\n\n            // Get the length of the signature.\n            let signatureLength := mload(signature)\n\n            // Get the pointer to the value preceding the signature length.\n            // This will be used for temporary memory overrides - either the\n            // signature head for isValidSignature or the digest for ecrecover.\n            let wordBeforeSignaturePtr := sub(signature, OneWord)\n\n            // Cache the current value behind the signature to restore it later.\n            let cachedWordBeforeSignature := mload(wordBeforeSignaturePtr)\n\n            // Declare lenDiff + recoveredSigner scope to manage stack pressure.\n            {\n                // Take the difference between the max ECDSA signature length\n                // and the actual signature length. Overflow desired for any\n                // values > 65. If the diff is not 0 or 1, it is not a valid\n                // ECDSA signature - move on to EIP1271 check.\n                let lenDiff := sub(ECDSA_MaxLength, signatureLength)\n\n                // Declare variable for recovered signer.\n                let recoveredSigner\n\n                // If diff is 0 or 1, it may be an ECDSA signature.\n                // Try to recover signer.\n                if iszero(gt(lenDiff, 1)) {\n                    // Read the signature `s` value.\n                    let originalSignatureS := mload(\n                        add(signature, ECDSA_signature_s_offset)\n                    )\n\n                    // Read the first byte of the word after `s`. If the\n                    // signature is 65 bytes, this will be the real `v` value.\n                    // If not, it will need to be modified - doing it this way\n                    // saves an extra condition.\n                    let v := byte(\n                        0,\n                        mload(add(signature, ECDSA_signature_v_offset))\n                    )\n\n                    // If lenDiff is 1, parse 64-byte signature as ECDSA.\n                    if lenDiff {\n                        // Extract yParity from highest bit of vs and add 27 to\n                        // get v.\n                        v := add(\n                            shr(MaxUint8, originalSignatureS),\n                            Signature_lower_v\n                        )\n\n                        // Extract canonical s from vs, all but the highest bit.\n                        // Temporarily overwrite the original `s` value in the\n                        // signature.\n                        mstore(\n                            add(signature, ECDSA_signature_s_offset),\n                            and(\n                                originalSignatureS,\n                                EIP2098_allButHighestBitMask\n                            )\n                        )\n                    }\n                    // Temporarily overwrite the signature length with `v` to\n                    // conform to the expected input for ecrecover.\n                    mstore(signature, v)\n\n                    // Temporarily overwrite the word before the length with\n                    // `digest` to conform to the expected input for ecrecover.\n                    mstore(wordBeforeSignaturePtr, digest)\n\n                    // Attempt to recover the signer for the given signature. Do\n                    // not check the call status as ecrecover will return a null\n                    // address if the signature is invalid.\n                    pop(\n                        staticcall(\n                            gas(),\n                            Ecrecover_precompile, // Call ecrecover precompile.\n                            wordBeforeSignaturePtr, // Use data memory location.\n                            Ecrecover_args_size, // Size of digest, v, r, and s.\n                            0, // Write result to scratch space.\n                            OneWord // Provide size of returned result.\n                        )\n                    )\n\n                    // Restore cached word before signature.\n                    mstore(wordBeforeSignaturePtr, cachedWordBeforeSignature)\n\n                    // Restore cached signature length.\n                    mstore(signature, signatureLength)\n\n                    // Restore cached signature `s` value.\n                    mstore(\n                        add(signature, ECDSA_signature_s_offset),\n                        originalSignatureS\n                    )\n\n                    // Read the recovered signer from the buffer given as return\n                    // space for ecrecover.\n                    recoveredSigner := mload(0)\n                }\n\n                // Set success to true if the signature provided was a valid\n                // ECDSA signature and the signer is not the null address. Use\n                // gt instead of direct as success is used outside of assembly.\n                success := and(eq(signer, recoveredSigner), gt(signer, 0))\n            }\n\n            // If the signature was not verified with ecrecover, try EIP1271.\n            if iszero(success) {\n                // Reset the original signature length.\n                mstore(signature, originalSignatureLength)\n\n                // Temporarily overwrite the word before the signature length\n                // and use it as the head of the signature input to\n                // `isValidSignature`, which has a value of 64.\n                mstore(\n                    wordBeforeSignaturePtr,\n                    EIP1271_isValidSignature_signature_head_offset\n                )\n\n                // Get pointer to use for the selector of `isValidSignature`.\n                let selectorPtr := sub(\n                    signature,\n                    EIP1271_isValidSignature_selector_negativeOffset\n                )\n\n                // Cache the value currently stored at the selector pointer.\n                let cachedWordOverwrittenBySelector := mload(selectorPtr)\n\n                // Cache the value currently stored at the digest pointer.\n                let cachedWordOverwrittenByDigest := mload(\n                    sub(\n                        signature,\n                        EIP1271_isValidSignature_digest_negativeOffset\n                    )\n                )\n\n                // Write the selector first, since it overlaps the digest.\n                mstore(selectorPtr, EIP1271_isValidSignature_selector)\n\n                // Next, write the original digest.\n                mstore(\n                    sub(\n                        signature,\n                        EIP1271_isValidSignature_digest_negativeOffset\n                    ),\n                    originalDigest\n                )\n\n                // Call signer with `isValidSignature` to validate signature.\n                success := staticcall(\n                    gas(),\n                    signer,\n                    selectorPtr,\n                    add(\n                        originalSignatureLength,\n                        EIP1271_isValidSignature_calldata_baseLength\n                    ),\n                    0,\n                    OneWord\n                )\n\n                // Determine if the signature is valid on successful calls.\n                if success {\n                    // If first word of scratch space does not contain EIP-1271\n                    // signature selector, revert.\n                    if iszero(eq(mload(0), EIP1271_isValidSignature_selector)) {\n                        // Revert with bad 1271 signature if signer has code.\n                        if extcodesize(signer) {\n                            // Bad contract signature.\n                            // Store left-padded selector with push4, mem[28:32]\n                            mstore(0, BadContractSignature_error_selector)\n\n                            // revert(abi.encodeWithSignature(\n                            //     \"BadContractSignature()\"\n                            // ))\n                            revert(\n                                Error_selector_offset,\n                                BadContractSignature_error_length\n                            )\n                        }\n\n                        // Check if signature length was invalid.\n                        if gt(sub(ECDSA_MaxLength, signatureLength), 1) {\n                            // Revert with generic invalid signature error.\n                            // Store left-padded selector with push4, mem[28:32]\n                            mstore(0, InvalidSignature_error_selector)\n\n                            // revert(abi.encodeWithSignature(\n                            //     \"InvalidSignature()\"\n                            // ))\n                            revert(\n                                Error_selector_offset,\n                                InvalidSignature_error_length\n                            )\n                        }\n\n                        // Check if v was invalid.\n                        if and(\n                            eq(signatureLength, ECDSA_MaxLength),\n                            iszero(\n                                byte(\n                                    byte(\n                                        0,\n                                        mload(\n                                            add(\n                                                signature,\n                                                ECDSA_signature_v_offset\n                                            )\n                                        )\n                                    ),\n                                    ECDSA_twentySeventhAndTwentyEighthBytesSet\n                                )\n                            )\n                        ) {\n                            // Revert with invalid v value.\n                            // Store left-padded selector with push4, mem[28:32]\n                            mstore(0, BadSignatureV_error_selector)\n                            mstore(\n                                BadSignatureV_error_v_ptr,\n                                byte(\n                                    0,\n                                    mload(\n                                        add(signature, ECDSA_signature_v_offset)\n                                    )\n                                )\n                            )\n\n                            // revert(abi.encodeWithSignature(\n                            //     \"BadSignatureV(uint8)\", v\n                            // ))\n                            revert(\n                                Error_selector_offset,\n                                BadSignatureV_error_length\n                            )\n                        }\n\n                        // Revert with generic invalid signer error message.\n                        // Store left-padded selector with push4, mem[28:32]\n                        mstore(0, InvalidSigner_error_selector)\n\n                        // revert(abi.encodeWithSignature(\"InvalidSigner()\"))\n                        revert(\n                            Error_selector_offset,\n                            InvalidSigner_error_length\n                        )\n                    }\n                }\n\n                // Restore the cached values overwritten by selector, digest and\n                // signature head.\n                mstore(wordBeforeSignaturePtr, cachedWordBeforeSignature)\n                mstore(selectorPtr, cachedWordOverwrittenBySelector)\n                mstore(\n                    sub(\n                        signature,\n                        EIP1271_isValidSignature_digest_negativeOffset\n                    ),\n                    cachedWordOverwrittenByDigest\n                )\n            }\n        }\n\n        // If the call failed...\n        if (!success) {\n            // Revert and pass reason along if one was returned.\n            _revertWithReasonIfOneIsReturned();\n\n            // Otherwise, revert with error indicating bad contract signature.\n            assembly {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, BadContractSignature_error_selector)\n                // revert(abi.encodeWithSignature(\"BadContractSignature()\"))\n                revert(Error_selector_offset, BadContractSignature_error_length)\n            }\n        }\n    }\n}\n"},"contracts/lib/ConsiderationBase.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {\n    ConduitControllerInterface\n} from \"../interfaces/ConduitControllerInterface.sol\";\n\nimport {\n    ConsiderationEventsAndErrors\n} from \"../interfaces/ConsiderationEventsAndErrors.sol\";\n\nimport {\n    BulkOrder_Typehash_Height_One,\n    BulkOrder_Typehash_Height_Two,\n    BulkOrder_Typehash_Height_Three,\n    BulkOrder_Typehash_Height_Four,\n    BulkOrder_Typehash_Height_Five,\n    BulkOrder_Typehash_Height_Six,\n    BulkOrder_Typehash_Height_Seven,\n    BulkOrder_Typehash_Height_Eight,\n    BulkOrder_Typehash_Height_Nine,\n    BulkOrder_Typehash_Height_Ten,\n    BulkOrder_Typehash_Height_Eleven,\n    BulkOrder_Typehash_Height_Twelve,\n    BulkOrder_Typehash_Height_Thirteen,\n    BulkOrder_Typehash_Height_Fourteen,\n    BulkOrder_Typehash_Height_Fifteen,\n    BulkOrder_Typehash_Height_Sixteen,\n    BulkOrder_Typehash_Height_Seventeen,\n    BulkOrder_Typehash_Height_Eighteen,\n    BulkOrder_Typehash_Height_Nineteen,\n    BulkOrder_Typehash_Height_Twenty,\n    BulkOrder_Typehash_Height_TwentyOne,\n    BulkOrder_Typehash_Height_TwentyTwo,\n    BulkOrder_Typehash_Height_TwentyThree,\n    BulkOrder_Typehash_Height_TwentyFour,\n    EIP712_domainData_chainId_offset,\n    EIP712_domainData_nameHash_offset,\n    EIP712_domainData_size,\n    EIP712_domainData_verifyingContract_offset,\n    EIP712_domainData_versionHash_offset,\n    FreeMemoryPointerSlot,\n    NameLengthPtr,\n    NameWithLength,\n    OneWord,\n    Slot0x80,\n    ThreeWords,\n    ZeroSlot\n} from \"./ConsiderationConstants.sol\";\n\nimport { ConsiderationDecoder } from \"./ConsiderationDecoder.sol\";\n\nimport { ConsiderationEncoder } from \"./ConsiderationEncoder.sol\";\n\n/**\n * @title ConsiderationBase\n * @author 0age\n * @notice ConsiderationBase contains immutable constants and constructor logic.\n */\ncontract ConsiderationBase is\n    ConsiderationDecoder,\n    ConsiderationEncoder,\n    ConsiderationEventsAndErrors\n{\n    // Precompute hashes, original chainId, and domain separator on deployment.\n    bytes32 internal immutable _NAME_HASH;\n    bytes32 internal immutable _VERSION_HASH;\n    bytes32 internal immutable _EIP_712_DOMAIN_TYPEHASH;\n    bytes32 internal immutable _OFFER_ITEM_TYPEHASH;\n    bytes32 internal immutable _CONSIDERATION_ITEM_TYPEHASH;\n    bytes32 internal immutable _ORDER_TYPEHASH;\n    uint256 internal immutable _CHAIN_ID;\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n\n    // Allow for interaction with the conduit controller.\n    ConduitControllerInterface internal immutable _CONDUIT_CONTROLLER;\n\n    // Cache the conduit creation code hash used by the conduit controller.\n    bytes32 internal immutable _CONDUIT_CREATION_CODE_HASH;\n\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) {\n        // Derive name and version hashes alongside required EIP-712 typehashes.\n        (\n            _NAME_HASH,\n            _VERSION_HASH,\n            _EIP_712_DOMAIN_TYPEHASH,\n            _OFFER_ITEM_TYPEHASH,\n            _CONSIDERATION_ITEM_TYPEHASH,\n            _ORDER_TYPEHASH\n        ) = _deriveTypehashes();\n\n        // Store the current chainId and derive the current domain separator.\n        _CHAIN_ID = block.chainid;\n        _DOMAIN_SEPARATOR = _deriveDomainSeparator();\n\n        // Set the supplied conduit controller.\n        _CONDUIT_CONTROLLER = ConduitControllerInterface(conduitController);\n\n        // Retrieve the conduit creation code hash from the supplied controller.\n        (_CONDUIT_CREATION_CODE_HASH, ) = (\n            _CONDUIT_CONTROLLER.getConduitCodeHashes()\n        );\n    }\n\n    /**\n     * @dev Internal view function to derive the EIP-712 domain separator.\n     *\n     * @return domainSeparator The derived domain separator.\n     */\n    function _deriveDomainSeparator()\n        internal\n        view\n        returns (bytes32 domainSeparator)\n    {\n        bytes32 typehash = _EIP_712_DOMAIN_TYPEHASH;\n        bytes32 nameHash = _NAME_HASH;\n        bytes32 versionHash = _VERSION_HASH;\n\n        // Leverage scratch space and other memory to perform an efficient hash.\n        assembly {\n            // Retrieve the free memory pointer; it will be replaced afterwards.\n            let freeMemoryPointer := mload(FreeMemoryPointerSlot)\n\n            // Retrieve value at 0x80; it will also be replaced afterwards.\n            let slot0x80 := mload(Slot0x80)\n\n            // Place typehash, name hash, and version hash at start of memory.\n            mstore(0, typehash)\n            mstore(EIP712_domainData_nameHash_offset, nameHash)\n            mstore(EIP712_domainData_versionHash_offset, versionHash)\n\n            // Place chainId in the next memory location.\n            mstore(EIP712_domainData_chainId_offset, chainid())\n\n            // Place the address of this contract in the next memory location.\n            mstore(EIP712_domainData_verifyingContract_offset, address())\n\n            // Hash relevant region of memory to derive the domain separator.\n            domainSeparator := keccak256(0, EIP712_domainData_size)\n\n            // Restore the free memory pointer.\n            mstore(FreeMemoryPointerSlot, freeMemoryPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZeroSlot, 0)\n\n            // Restore the value at 0x80.\n            mstore(Slot0x80, slot0x80)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to retrieve the default name of this\n     *      contract and return.\n     *\n     * @return The name of this contract.\n     */\n    function _name() internal pure virtual returns (string memory) {\n        // Return the name of the contract.\n        assembly {\n            // First element is the offset for the returned string. Offset the\n            // value in memory by one word so that the free memory pointer will\n            // be overwritten by the next write.\n            mstore(OneWord, OneWord)\n\n            // Name is right padded, so it touches the length which is left\n            // padded. This enables writing both values at once. The free memory\n            // pointer will be overwritten in the process.\n            mstore(NameLengthPtr, NameWithLength)\n\n            // Standard ABI encoding pads returned data to the nearest word. Use\n            // the already empty zero slot memory region for this purpose and\n            // return the final name string, offset by the original single word.\n            return(OneWord, ThreeWords)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to retrieve the default name of this contract\n     *      as a string that can be used internally.\n     *\n     * @return The name of this contract.\n     */\n    function _nameString() internal pure virtual returns (string memory) {\n        // Return the name of the contract.\n        return \"Consideration\";\n    }\n\n    /**\n     * @dev Internal pure function to derive required EIP-712 typehashes and\n     *      other hashes during contract creation.\n     *\n     * @return nameHash                  The hash of the name of the contract.\n     * @return versionHash               The hash of the version string of the\n     *                                   contract.\n     * @return eip712DomainTypehash      The primary EIP-712 domain typehash.\n     * @return offerItemTypehash         The EIP-712 typehash for OfferItem\n     *                                   types.\n     * @return considerationItemTypehash The EIP-712 typehash for\n     *                                   ConsiderationItem types.\n     * @return orderTypehash             The EIP-712 typehash for Order types.\n     */\n    function _deriveTypehashes()\n        internal\n        pure\n        returns (\n            bytes32 nameHash,\n            bytes32 versionHash,\n            bytes32 eip712DomainTypehash,\n            bytes32 offerItemTypehash,\n            bytes32 considerationItemTypehash,\n            bytes32 orderTypehash\n        )\n    {\n        // Derive hash of the name of the contract.\n        nameHash = keccak256(bytes(_nameString()));\n\n        // Derive hash of the version string of the contract.\n        versionHash = keccak256(bytes(\"1.5\"));\n\n        // Construct the OfferItem type string.\n        bytes memory offerItemTypeString = bytes(\n            \"OfferItem(\"\n            \"uint8 itemType,\"\n            \"address token,\"\n            \"uint256 identifierOrCriteria,\"\n            \"uint256 startAmount,\"\n            \"uint256 endAmount\"\n            \")\"\n        );\n\n        // Construct the ConsiderationItem type string.\n        bytes memory considerationItemTypeString = bytes(\n            \"ConsiderationItem(\"\n            \"uint8 itemType,\"\n            \"address token,\"\n            \"uint256 identifierOrCriteria,\"\n            \"uint256 startAmount,\"\n            \"uint256 endAmount,\"\n            \"address recipient\"\n            \")\"\n        );\n\n        // Construct the OrderComponents type string, not including the above.\n        bytes memory orderComponentsPartialTypeString = bytes(\n            \"OrderComponents(\"\n            \"address offerer,\"\n            \"address zone,\"\n            \"OfferItem[] offer,\"\n            \"ConsiderationItem[] consideration,\"\n            \"uint8 orderType,\"\n            \"uint256 startTime,\"\n            \"uint256 endTime,\"\n            \"bytes32 zoneHash,\"\n            \"uint256 salt,\"\n            \"bytes32 conduitKey,\"\n            \"uint256 counter\"\n            \")\"\n        );\n\n        // Construct the primary EIP-712 domain type string.\n        eip712DomainTypehash = keccak256(\n            bytes(\n                \"EIP712Domain(\"\n                \"string name,\"\n                \"string version,\"\n                \"uint256 chainId,\"\n                \"address verifyingContract\"\n                \")\"\n            )\n        );\n\n        // Derive the OfferItem type hash using the corresponding type string.\n        offerItemTypehash = keccak256(offerItemTypeString);\n\n        // Derive ConsiderationItem type hash using corresponding type string.\n        considerationItemTypehash = keccak256(considerationItemTypeString);\n\n        bytes memory orderTypeString = bytes.concat(\n            orderComponentsPartialTypeString,\n            considerationItemTypeString,\n            offerItemTypeString\n        );\n\n        // Derive OrderItem type hash via combination of relevant type strings.\n        orderTypehash = keccak256(orderTypeString);\n    }\n\n    /**\n     * @dev Internal pure function to look up one of twenty-four potential bulk\n     *      order typehash constants based on the height of the bulk order tree.\n     *      Note that values between one and twenty-four are supported, which is\n     *      enforced by _isValidBulkOrderSize.\n     *\n     * @param _treeHeight The height of the bulk order tree. The value must be\n     *                    between one and twenty-four.\n     *\n     * @return _typeHash The EIP-712 typehash for the bulk order type with the\n     *                   given height.\n     */\n    function _lookupBulkOrderTypehash(\n        uint256 _treeHeight\n    ) internal pure returns (bytes32 _typeHash) {\n        // Utilize assembly to efficiently retrieve correct bulk order typehash.\n        assembly {\n            // Use a Yul function to enable use of the `leave` keyword\n            // to stop searching once the appropriate type hash is found.\n            function lookupTypeHash(treeHeight) -> typeHash {\n                // Handle tree heights one through eight.\n                if lt(treeHeight, 9) {\n                    // Handle tree heights one through four.\n                    if lt(treeHeight, 5) {\n                        // Handle tree heights one and two.\n                        if lt(treeHeight, 3) {\n                            // Utilize branchless logic to determine typehash.\n                            typeHash := ternary(\n                                eq(treeHeight, 1),\n                                BulkOrder_Typehash_Height_One,\n                                BulkOrder_Typehash_Height_Two\n                            )\n\n                            // Exit the function once typehash has been located.\n                            leave\n                        }\n\n                        // Handle height three and four via branchless logic.\n                        typeHash := ternary(\n                            eq(treeHeight, 3),\n                            BulkOrder_Typehash_Height_Three,\n                            BulkOrder_Typehash_Height_Four\n                        )\n\n                        // Exit the function once typehash has been located.\n                        leave\n                    }\n\n                    // Handle tree height five and six.\n                    if lt(treeHeight, 7) {\n                        // Utilize branchless logic to determine typehash.\n                        typeHash := ternary(\n                            eq(treeHeight, 5),\n                            BulkOrder_Typehash_Height_Five,\n                            BulkOrder_Typehash_Height_Six\n                        )\n\n                        // Exit the function once typehash has been located.\n                        leave\n                    }\n\n                    // Handle height seven and eight via branchless logic.\n                    typeHash := ternary(\n                        eq(treeHeight, 7),\n                        BulkOrder_Typehash_Height_Seven,\n                        BulkOrder_Typehash_Height_Eight\n                    )\n\n                    // Exit the function once typehash has been located.\n                    leave\n                }\n\n                // Handle tree height nine through sixteen.\n                if lt(treeHeight, 17) {\n                    // Handle tree height nine through twelve.\n                    if lt(treeHeight, 13) {\n                        // Handle tree height nine and ten.\n                        if lt(treeHeight, 11) {\n                            // Utilize branchless logic to determine typehash.\n                            typeHash := ternary(\n                                eq(treeHeight, 9),\n                                BulkOrder_Typehash_Height_Nine,\n                                BulkOrder_Typehash_Height_Ten\n                            )\n\n                            // Exit the function once typehash has been located.\n                            leave\n                        }\n\n                        // Handle height eleven and twelve via branchless logic.\n                        typeHash := ternary(\n                            eq(treeHeight, 11),\n                            BulkOrder_Typehash_Height_Eleven,\n                            BulkOrder_Typehash_Height_Twelve\n                        )\n\n                        // Exit the function once typehash has been located.\n                        leave\n                    }\n\n                    // Handle tree height thirteen and fourteen.\n                    if lt(treeHeight, 15) {\n                        // Utilize branchless logic to determine typehash.\n                        typeHash := ternary(\n                            eq(treeHeight, 13),\n                            BulkOrder_Typehash_Height_Thirteen,\n                            BulkOrder_Typehash_Height_Fourteen\n                        )\n\n                        // Exit the function once typehash has been located.\n                        leave\n                    }\n                    // Handle height fifteen and sixteen via branchless logic.\n                    typeHash := ternary(\n                        eq(treeHeight, 15),\n                        BulkOrder_Typehash_Height_Fifteen,\n                        BulkOrder_Typehash_Height_Sixteen\n                    )\n\n                    // Exit the function once typehash has been located.\n                    leave\n                }\n\n                // Handle tree height seventeen through twenty.\n                if lt(treeHeight, 21) {\n                    // Handle tree height seventeen and eighteen.\n                    if lt(treeHeight, 19) {\n                        // Utilize branchless logic to determine typehash.\n                        typeHash := ternary(\n                            eq(treeHeight, 17),\n                            BulkOrder_Typehash_Height_Seventeen,\n                            BulkOrder_Typehash_Height_Eighteen\n                        )\n\n                        // Exit the function once typehash has been located.\n                        leave\n                    }\n\n                    // Handle height nineteen and twenty via branchless logic.\n                    typeHash := ternary(\n                        eq(treeHeight, 19),\n                        BulkOrder_Typehash_Height_Nineteen,\n                        BulkOrder_Typehash_Height_Twenty\n                    )\n\n                    // Exit the function once typehash has been located.\n                    leave\n                }\n\n                // Handle tree height twenty-one and twenty-two.\n                if lt(treeHeight, 23) {\n                    // Utilize branchless logic to determine typehash.\n                    typeHash := ternary(\n                        eq(treeHeight, 21),\n                        BulkOrder_Typehash_Height_TwentyOne,\n                        BulkOrder_Typehash_Height_TwentyTwo\n                    )\n\n                    // Exit the function once typehash has been located.\n                    leave\n                }\n\n                // Handle height twenty-three & twenty-four w/ branchless logic.\n                typeHash := ternary(\n                    eq(treeHeight, 23),\n                    BulkOrder_Typehash_Height_TwentyThree,\n                    BulkOrder_Typehash_Height_TwentyFour\n                )\n\n                // Exit the function once typehash has been located.\n                leave\n            }\n\n            // Implement ternary conditional using branchless logic.\n            function ternary(cond, ifTrue, ifFalse) -> c {\n                c := xor(ifFalse, mul(cond, xor(ifFalse, ifTrue)))\n            }\n\n            // Look up the typehash using the supplied tree height.\n            _typeHash := lookupTypeHash(_treeHeight)\n        }\n    }\n}\n"},"contracts/lib/ConsiderationDecoder.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport {\n    AdvancedOrder,\n    ConsiderationItem,\n    CriteriaResolver,\n    Fulfillment,\n    FulfillmentComponent,\n    OfferItem,\n    Order,\n    OrderParameters,\n    ReceivedItem\n} from \"./ConsiderationStructs.sol\";\n\nimport {\n    AdvancedOrder_denominator_offset,\n    AdvancedOrder_extraData_offset,\n    AdvancedOrder_fixed_segment_0,\n    AdvancedOrder_head_size,\n    AdvancedOrder_numerator_offset,\n    AdvancedOrder_signature_offset,\n    AdvancedOrderPlusOrderParameters_head_size,\n    Common_amount_offset,\n    Common_endAmount_offset,\n    ConsiderationItem_size_with_length,\n    ConsiderationItem_size,\n    CriteriaResolver_criteriaProof_offset,\n    CriteriaResolver_fixed_segment_0,\n    CriteriaResolver_head_size,\n    FourWords,\n    FreeMemoryPointerSlot,\n    Fulfillment_considerationComponents_offset,\n    Fulfillment_head_size,\n    FulfillmentComponent_mem_tail_size_shift,\n    FulfillmentComponent_mem_tail_size,\n    generateOrder_maximum_returndatasize,\n    OfferItem_size_with_length,\n    OfferItem_size,\n    OneWord,\n    OneWordShift,\n    OnlyFullWordMask,\n    Order_head_size,\n    Order_signature_offset,\n    OrderComponents_OrderParameters_common_head_size,\n    OrderParameters_consideration_head_offset,\n    OrderParameters_head_size,\n    OrderParameters_offer_head_offset,\n    OrderParameters_totalOriginalConsiderationItems_offset,\n    ReceivedItem_recipient_offset,\n    ReceivedItem_size,\n    ReceivedItem_size_excluding_recipient,\n    SpentItem_size_shift,\n    SpentItem_size,\n    ThirtyOneBytes,\n    TwoWords\n} from \"./ConsiderationConstants.sol\";\n\nimport {\n    CalldataPointer,\n    malloc,\n    MemoryPointer,\n    OffsetOrLengthMask\n} from \"../helpers/PointerLibraries.sol\";\n\ncontract ConsiderationDecoder {\n    /**\n     * @dev Takes a bytes array from calldata and copies it into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the bytes array in\n     *                    calldata which contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the bytes array in\n     *                    memory which contains the length of the array.\n     */\n    function _decodeBytes(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        assembly {\n            // Get the current free memory pointer.\n            mPtrLength := mload(FreeMemoryPointerSlot)\n\n            // Derive the size of the bytes array, rounding up to nearest word\n            // and adding a word for the length field. Note: masking\n            // `calldataload(cdPtrLength)` is redundant here.\n            let size := add(\n                and(\n                    add(calldataload(cdPtrLength), ThirtyOneBytes),\n                    OnlyFullWordMask\n                ),\n                OneWord\n            )\n\n            // Copy bytes from calldata into memory based on pointers and size.\n            calldatacopy(mPtrLength, cdPtrLength, size)\n\n            // Store the masked value in memory. Note: the value of `size` is at\n            // least 32, meaning the calldatacopy above will at least write to\n            // `[mPtrLength, mPtrLength + 32)`.\n            mstore(\n                mPtrLength,\n                and(calldataload(cdPtrLength), OffsetOrLengthMask)\n            )\n\n            // Update free memory pointer based on the size of the bytes array.\n            mstore(FreeMemoryPointerSlot, add(mPtrLength, size))\n        }\n    }\n\n    /**\n     * @dev Takes an offer array from calldata and copies it into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the offer array\n     *                    in calldata which contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the offer array in\n     *                    memory which contains the length of the array.\n     */\n    function _decodeOffer(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        assembly {\n            // Retrieve length of array, masking to prevent potential overflow.\n            let arrLength := and(calldataload(cdPtrLength), OffsetOrLengthMask)\n\n            // Get the current free memory pointer.\n            mPtrLength := mload(FreeMemoryPointerSlot)\n\n            // Write the array length to memory.\n            mstore(mPtrLength, arrLength)\n\n            // Derive the head by adding one word to the length pointer.\n            let mPtrHead := add(mPtrLength, OneWord)\n\n            // Derive the tail by adding one word per element (note that structs\n            // are written to memory with an offset per struct element).\n            let mPtrTail := add(mPtrHead, shl(OneWordShift, arrLength))\n\n            // Track the next tail, beginning with the initial tail value.\n            let mPtrTailNext := mPtrTail\n\n            // Copy all offer array data into memory at the tail pointer.\n            calldatacopy(\n                mPtrTail,\n                add(cdPtrLength, OneWord),\n                mul(arrLength, OfferItem_size)\n            )\n\n            // Track the next head pointer, starting with initial head value.\n            let mPtrHeadNext := mPtrHead\n\n            // Iterate over each head pointer until it reaches the tail.\n            for {\n\n            } lt(mPtrHeadNext, mPtrTail) {\n\n            } {\n                // Write the next tail pointer to next head pointer in memory.\n                mstore(mPtrHeadNext, mPtrTailNext)\n\n                // Increment the next head pointer by one word.\n                mPtrHeadNext := add(mPtrHeadNext, OneWord)\n\n                // Increment the next tail pointer by the size of an offer item.\n                mPtrTailNext := add(mPtrTailNext, OfferItem_size)\n            }\n\n            // Update free memory pointer to allocate memory up to end of tail.\n            mstore(FreeMemoryPointerSlot, mPtrTailNext)\n        }\n    }\n\n    /**\n     * @dev Takes a consideration array from calldata and copies it into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the consideration\n     *                    array in calldata which contains the length of the\n     *                    array.\n     *\n     * @return mPtrLength A memory pointer to the start of the consideration\n     *                    array in memory which contains the length of the\n     *                    array.\n     */\n    function _decodeConsideration(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        assembly {\n            // Retrieve length of array, masking to prevent potential overflow.\n            let arrLength := and(calldataload(cdPtrLength), OffsetOrLengthMask)\n\n            // Get the current free memory pointer.\n            mPtrLength := mload(FreeMemoryPointerSlot)\n\n            // Write the array length to memory.\n            mstore(mPtrLength, arrLength)\n\n            // Derive the head by adding one word to the length pointer.\n            let mPtrHead := add(mPtrLength, OneWord)\n\n            // Derive the tail by adding one word per element (note that structs\n            // are written to memory with an offset per struct element).\n            let mPtrTail := add(mPtrHead, shl(OneWordShift, arrLength))\n\n            // Track the next tail, beginning with the initial tail value.\n            let mPtrTailNext := mPtrTail\n\n            // Copy all consideration array data into memory at tail pointer.\n            calldatacopy(\n                mPtrTail,\n                add(cdPtrLength, OneWord),\n                mul(arrLength, ConsiderationItem_size)\n            )\n\n            // Track the next head pointer, starting with initial head value.\n            let mPtrHeadNext := mPtrHead\n\n            // Iterate over each head pointer until it reaches the tail.\n            for {\n\n            } lt(mPtrHeadNext, mPtrTail) {\n\n            } {\n                // Write the next tail pointer to next head pointer in memory.\n                mstore(mPtrHeadNext, mPtrTailNext)\n\n                // Increment the next head pointer by one word.\n                mPtrHeadNext := add(mPtrHeadNext, OneWord)\n\n                // Increment next tail pointer by size of a consideration item.\n                mPtrTailNext := add(mPtrTailNext, ConsiderationItem_size)\n            }\n\n            // Update free memory pointer to allocate memory up to end of tail.\n            mstore(FreeMemoryPointerSlot, mPtrTailNext)\n        }\n    }\n\n    /**\n     * @dev Takes a calldata pointer and memory pointer and copies a referenced\n     *      OrderParameters struct and associated offer and consideration data\n     *      to memory.\n     *\n     * @param cdPtr A calldata pointer for the OrderParameters struct.\n     * @param mPtr A memory pointer to the OrderParameters struct head.\n     */\n    function _decodeOrderParametersTo(\n        CalldataPointer cdPtr,\n        MemoryPointer mPtr\n    ) internal pure {\n        // Copy the full OrderParameters head from calldata to memory.\n        cdPtr.copy(mPtr, OrderParameters_head_size);\n\n        // Resolve the offer calldata offset, use that to decode and copy offer\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(OrderParameters_offer_head_offset).write(\n            _decodeOffer(cdPtr.pptr(OrderParameters_offer_head_offset))\n        );\n\n        // Resolve consideration calldata offset, use that to copy consideration\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(OrderParameters_consideration_head_offset).write(\n            _decodeConsideration(\n                cdPtr.pptr(OrderParameters_consideration_head_offset)\n            )\n        );\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an OrderParameters struct and copies the\n     *      decoded struct to memory.\n     *\n     * @param cdPtr A calldata pointer for the OrderParameters struct.\n     *\n     * @return mPtr A memory pointer to the OrderParameters struct head.\n     */\n    function _decodeOrderParameters(\n        CalldataPointer cdPtr\n    ) internal pure returns (MemoryPointer mPtr) {\n        // Allocate required memory for the OrderParameters head (offer and\n        // consideration are allocated independently).\n        mPtr = malloc(OrderParameters_head_size);\n\n        // Decode and copy the order parameters to the newly allocated memory.\n        _decodeOrderParametersTo(cdPtr, mPtr);\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an Order struct and copies the decoded\n     *      struct to memory.\n     *\n     * @param cdPtr A calldata pointer for the Order struct.\n     *\n     * @return mPtr A memory pointer to the Order struct head.\n     */\n    function _decodeOrder(\n        CalldataPointer cdPtr\n    ) internal pure returns (MemoryPointer mPtr) {\n        // Allocate required memory for the Order head (OrderParameters and\n        // signature are allocated independently).\n        mPtr = malloc(Order_head_size);\n\n        // Resolve OrderParameters calldata offset, use it to decode and copy\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.write(_decodeOrderParameters(cdPtr.pptr()));\n\n        // Resolve signature calldata offset, use that to decode and copy from\n        // calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(Order_signature_offset).write(\n            _decodeBytes(cdPtr.pptr(Order_signature_offset))\n        );\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an AdvancedOrder struct and copies the\n     *      decoded struct to memory.\n     *\n     * @param cdPtr A calldata pointer for the AdvancedOrder struct.\n     *\n     * @return mPtr A memory pointer to the AdvancedOrder struct head.\n     */\n    function _decodeAdvancedOrder(\n        CalldataPointer cdPtr\n    ) internal pure returns (MemoryPointer mPtr) {\n        // Allocate memory for AdvancedOrder head and OrderParameters head.\n        mPtr = malloc(AdvancedOrderPlusOrderParameters_head_size);\n\n        // Use numerator + denominator calldata offset to decode and copy\n        // from calldata and write resultant memory offset to head in memory.\n        cdPtr.offset(AdvancedOrder_numerator_offset).copy(\n            mPtr.offset(AdvancedOrder_numerator_offset),\n            AdvancedOrder_fixed_segment_0\n        );\n\n        // Get pointer to memory immediately after advanced order.\n        MemoryPointer mPtrParameters = mPtr.offset(AdvancedOrder_head_size);\n\n        // Write pptr for advanced order parameters to memory.\n        mPtr.write(mPtrParameters);\n\n        // Resolve OrderParameters calldata pointer & write to allocated region.\n        _decodeOrderParametersTo(cdPtr.pptr(), mPtrParameters);\n\n        // Resolve signature calldata offset, use that to decode and copy from\n        // calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(AdvancedOrder_signature_offset).write(\n            _decodeBytes(cdPtr.pptr(AdvancedOrder_signature_offset))\n        );\n\n        // Resolve extraData calldata offset, use that to decode and copy from\n        // calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(AdvancedOrder_extraData_offset).write(\n            _decodeBytes(cdPtr.pptr(AdvancedOrder_extraData_offset))\n        );\n    }\n\n    /**\n     * @dev Allocates a single word of empty bytes in memory and returns the\n     *      pointer to that memory region.\n     *\n     * @return mPtr The memory pointer to the new empty word in memory.\n     */\n    function _getEmptyBytesOrArray()\n        internal\n        pure\n        returns (MemoryPointer mPtr)\n    {\n        mPtr = malloc(OneWord);\n        mPtr.write(0);\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an Order struct and copies the decoded\n     *      struct to memory as an AdvancedOrder.\n     *\n     * @param cdPtr A calldata pointer for the Order struct.\n     *\n     * @return mPtr A memory pointer to the AdvancedOrder struct head.\n     */\n    function _decodeOrderAsAdvancedOrder(\n        CalldataPointer cdPtr\n    ) internal pure returns (MemoryPointer mPtr) {\n        // Allocate memory for AdvancedOrder head and OrderParameters head.\n        mPtr = malloc(AdvancedOrderPlusOrderParameters_head_size);\n\n        // Get pointer to memory immediately after advanced order.\n        MemoryPointer mPtrParameters = mPtr.offset(AdvancedOrder_head_size);\n\n        // Write pptr for advanced order parameters.\n        mPtr.write(mPtrParameters);\n\n        // Resolve OrderParameters calldata pointer & write to allocated region.\n        _decodeOrderParametersTo(cdPtr.pptr(), mPtrParameters);\n\n        // Write default Order numerator and denominator values (i.e. 1/1).\n        mPtr.offset(AdvancedOrder_numerator_offset).write(1);\n        mPtr.offset(AdvancedOrder_denominator_offset).write(1);\n\n        // Resolve signature calldata offset, use that to decode and copy from\n        // calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(AdvancedOrder_signature_offset).write(\n            _decodeBytes(cdPtr.pptr(Order_signature_offset))\n        );\n\n        // Resolve extraData calldata offset, use that to decode and copy from\n        // calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(AdvancedOrder_extraData_offset).write(\n            _getEmptyBytesOrArray()\n        );\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an array of Order structs and copies the\n     *      decoded array to memory as an array of AdvancedOrder structs.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the orders array in\n     *                    calldata which contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the array of advanced\n     *                    orders in memory which contains length of the array.\n     */\n    function _decodeOrdersAsAdvancedOrders(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength << OneWordShift;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve Order calldata offset, use it to decode and copy from\n                // calldata, and write resultant AdvancedOrder offset to memory.\n                mPtrHead.offset(offset).write(\n                    _decodeOrderAsAdvancedOrder(cdPtrHead.pptr(offset))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Takes a calldata pointer to a criteria proof, or an array bytes32\n     *      types, and copies the decoded proof to memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the criteria proof\n     *                    in calldata which contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the criteria proof\n     *                    in memory which contains length of the array.\n     */\n    function _decodeCriteriaProof(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive array size based on one word per array element and length.\n            uint256 arrSize = (arrLength + 1) << OneWordShift;\n\n            // Allocate memory equal to the array size.\n            mPtrLength = malloc(arrSize);\n\n            // Copy the array from calldata into memory.\n            cdPtrLength.copy(mPtrLength, arrSize);\n        }\n    }\n\n    /**\n     * @dev Takes a calldata pointer to a CriteriaResolver struct and copies the\n     *      decoded struct to memory.\n     *\n     * @param cdPtr A calldata pointer for the CriteriaResolver struct.\n     *\n     * @return mPtr A memory pointer to the CriteriaResolver struct head.\n     */\n    function _decodeCriteriaResolver(\n        CalldataPointer cdPtr\n    ) internal pure returns (MemoryPointer mPtr) {\n        // Allocate required memory for the CriteriaResolver head (the criteria\n        // proof bytes32 array is allocated independently).\n        mPtr = malloc(CriteriaResolver_head_size);\n\n        // Decode and copy order index, side, index, and identifier from\n        // calldata and write resultant memory offset to head in memory.\n        cdPtr.copy(mPtr, CriteriaResolver_fixed_segment_0);\n\n        // Resolve criteria proof calldata offset, use it to decode and copy\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(CriteriaResolver_criteriaProof_offset).write(\n            _decodeCriteriaProof(\n                cdPtr.pptr(CriteriaResolver_criteriaProof_offset)\n            )\n        );\n    }\n\n    /**\n     * @dev Takes an array of criteria resolvers from calldata and copies it\n     *      into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the criteria\n     *                    resolver array in calldata which contains the length\n     *                    of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the criteria resolver\n     *                    array in memory which contains the length of the\n     *                    array.\n     */\n    function _decodeCriteriaResolvers(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength << OneWordShift;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve CriteriaResolver calldata offset, use it to decode\n                // and copy from calldata, and write resultant memory offset.\n                mPtrHead.offset(offset).write(\n                    _decodeCriteriaResolver(cdPtrHead.pptr(offset))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Takes an array of orders from calldata and copies it into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the orders array in\n     *                    calldata which contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the orders array\n     *                    in memory which contains the length of the array.\n     */\n    function _decodeOrders(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength << OneWordShift;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve Order calldata offset, use it to decode and copy\n                // from calldata, and write resultant memory offset.\n                mPtrHead.offset(offset).write(\n                    _decodeOrder(cdPtrHead.pptr(offset))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Takes an array of fulfillment components from calldata and copies it\n     *      into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the fulfillment\n     *                    components array in calldata which contains the length\n     *                    of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the fulfillment\n     *                    components array in memory which contains the length\n     *                    of the array.\n     */\n    function _decodeFulfillmentComponents(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        assembly {\n            let arrLength := and(calldataload(cdPtrLength), OffsetOrLengthMask)\n\n            // Get the current free memory pointer.\n            mPtrLength := mload(FreeMemoryPointerSlot)\n\n            mstore(mPtrLength, arrLength)\n            let mPtrHead := add(mPtrLength, OneWord)\n            let mPtrTail := add(mPtrHead, shl(OneWordShift, arrLength))\n            let mPtrTailNext := mPtrTail\n            calldatacopy(\n                mPtrTail,\n                add(cdPtrLength, OneWord),\n                shl(FulfillmentComponent_mem_tail_size_shift, arrLength)\n            )\n            let mPtrHeadNext := mPtrHead\n            for {\n\n            } lt(mPtrHeadNext, mPtrTail) {\n\n            } {\n                mstore(mPtrHeadNext, mPtrTailNext)\n                mPtrHeadNext := add(mPtrHeadNext, OneWord)\n                mPtrTailNext := add(\n                    mPtrTailNext,\n                    FulfillmentComponent_mem_tail_size\n                )\n            }\n\n            // Update the free memory pointer.\n            mstore(FreeMemoryPointerSlot, mPtrTailNext)\n        }\n    }\n\n    /**\n     * @dev Takes a nested array of fulfillment components from calldata and\n     *      copies it into memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the nested\n     *                    fulfillment components array in calldata which\n     *                    contains the length of the array.\n     *\n     * @return mPtrLength A memory pointer to the start of the nested\n     *                    fulfillment components array in memory which\n     *                    contains the length of the array.\n     */\n    function _decodeNestedFulfillmentComponents(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength << OneWordShift;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve FulfillmentComponents array calldata offset, use it\n                // to decode and copy from calldata, and write memory offset.\n                mPtrHead.offset(offset).write(\n                    _decodeFulfillmentComponents(cdPtrHead.pptr(offset))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Takes an array of advanced orders from calldata and copies it into\n     *      memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the advanced orders\n     *                    array in calldata which contains the length of the\n     *                    array.\n     *\n     * @return mPtrLength A memory pointer to the start of the advanced orders\n     *                    array in memory which contains the length of the\n     *                    array.\n     */\n    function _decodeAdvancedOrders(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength << OneWordShift;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve AdvancedOrder calldata offset, use it to decode and\n                // copy from calldata, and write resultant memory offset.\n                mPtrHead.offset(offset).write(\n                    _decodeAdvancedOrder(cdPtrHead.pptr(offset))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Takes a calldata pointer to a Fulfillment struct and copies the\n     *      decoded struct to memory.\n     *\n     * @param cdPtr A calldata pointer for the Fulfillment struct.\n     *\n     * @return mPtr A memory pointer to the Fulfillment struct head.\n     */\n    function _decodeFulfillment(\n        CalldataPointer cdPtr\n    ) internal pure returns (MemoryPointer mPtr) {\n        // Allocate required memory for the Fulfillment head (the fulfillment\n        // components arrays are allocated independently).\n        mPtr = malloc(Fulfillment_head_size);\n\n        // Resolve offerComponents calldata offset, use it to decode and copy\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.write(_decodeFulfillmentComponents(cdPtr.pptr()));\n\n        // Resolve considerationComponents calldata offset, use it to decode and\n        // copy from calldata, and write resultant memory offset to memory head.\n        mPtr.offset(Fulfillment_considerationComponents_offset).write(\n            _decodeFulfillmentComponents(\n                cdPtr.pptr(Fulfillment_considerationComponents_offset)\n            )\n        );\n    }\n\n    /**\n     * @dev Takes an array of fulfillments from calldata and copies it into\n     *      memory.\n     *\n     * @param cdPtrLength A calldata pointer to the start of the fulfillments\n     *                    array in calldata which contains the length of the\n     *                    array.\n     *\n     * @return mPtrLength A memory pointer to the start of the fulfillments\n     *                    array in memory which contains the length of the\n     *                    array.\n     */\n    function _decodeFulfillments(\n        CalldataPointer cdPtrLength\n    ) internal pure returns (MemoryPointer mPtrLength) {\n        // Retrieve length of array, masking to prevent potential overflow.\n        uint256 arrLength = cdPtrLength.readMaskedUint256();\n\n        unchecked {\n            // Derive offset to the tail based on one word per array element.\n            uint256 tailOffset = arrLength << OneWordShift;\n\n            // Add one additional word for the length and allocate memory.\n            mPtrLength = malloc(tailOffset + OneWord);\n\n            // Write the length of the array to memory.\n            mPtrLength.write(arrLength);\n\n            // Advance to first memory & calldata pointers (e.g. after length).\n            MemoryPointer mPtrHead = mPtrLength.next();\n            CalldataPointer cdPtrHead = cdPtrLength.next();\n\n            // Iterate over each pointer, word by word, until tail is reached.\n            for (uint256 offset = 0; offset < tailOffset; offset += OneWord) {\n                // Resolve Fulfillment calldata offset, use it to decode and\n                // copy from calldata, and write resultant memory offset.\n                mPtrHead.offset(offset).write(\n                    _decodeFulfillment(cdPtrHead.pptr(offset))\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Takes a calldata pointer to an OrderComponents struct and copies the\n     *      decoded struct to memory as an OrderParameters struct (with the\n     *      totalOriginalConsiderationItems value set equal to the length of the\n     *      supplied consideration array).\n     *\n     * @param cdPtr A calldata pointer for the OrderComponents struct.\n     *\n     * @return mPtr A memory pointer to the OrderParameters struct head.\n     */\n    function _decodeOrderComponentsAsOrderParameters(\n        CalldataPointer cdPtr\n    ) internal pure returns (MemoryPointer mPtr) {\n        // Allocate memory for the OrderParameters head.\n        mPtr = malloc(OrderParameters_head_size);\n\n        // Copy the full OrderComponents head from calldata to memory.\n        cdPtr.copy(mPtr, OrderComponents_OrderParameters_common_head_size);\n\n        // Resolve the offer calldata offset, use that to decode and copy offer\n        // from calldata, and write resultant memory offset to head in memory.\n        mPtr.offset(OrderParameters_offer_head_offset).write(\n            _decodeOffer(cdPtr.pptr(OrderParameters_offer_head_offset))\n        );\n\n        // Resolve consideration calldata offset, use that to copy consideration\n        // from calldata, and write resultant memory offset to head in memory.\n        MemoryPointer consideration = _decodeConsideration(\n            cdPtr.pptr(OrderParameters_consideration_head_offset)\n        );\n        mPtr.offset(OrderParameters_consideration_head_offset).write(\n            consideration\n        );\n\n        // Write masked consideration length to totalOriginalConsiderationItems.\n        mPtr\n            .offset(OrderParameters_totalOriginalConsiderationItems_offset)\n            .write(consideration.readUint256());\n    }\n\n    /**\n     * @dev Decodes the returndata from a call to generateOrder, or returns\n     *      empty arrays and a boolean signifying that the returndata does not\n     *      adhere to a valid encoding scheme if it cannot be decoded.\n     *\n     * @return invalidEncoding A boolean signifying whether the returndata has\n     *                         an invalid encoding.\n     * @return offer           The decoded offer array.\n     * @return consideration   The decoded consideration array.\n     */\n    function _decodeGenerateOrderReturndata()\n        internal\n        pure\n        returns (\n            uint256 invalidEncoding,\n            MemoryPointer offer,\n            MemoryPointer consideration\n        )\n    {\n        assembly {\n            // Check that returndatasize is at least four words: offerOffset,\n            // considerationOffset, offerLength, & considerationLength\n            invalidEncoding := lt(returndatasize(), FourWords)\n\n            let offsetOffer\n            let offsetConsideration\n            let offerLength\n            let considerationLength\n\n            // Proceed if enough returndata is present to continue evaluation.\n            if iszero(invalidEncoding) {\n                // Copy first two words of returndata (the offsets to offer and\n                // consideration array lengths) to scratch space.\n                returndatacopy(0, 0, TwoWords)\n                offsetOffer := mload(0)\n                offsetConsideration := mload(OneWord)\n\n                // If valid length, check that offsets are within returndata.\n                let invalidOfferOffset := gt(offsetOffer, returndatasize())\n                let invalidConsiderationOffset := gt(\n                    offsetConsideration,\n                    returndatasize()\n                )\n\n                // Only proceed if length (and thus encoding) is valid so far.\n                invalidEncoding := or(\n                    invalidOfferOffset,\n                    invalidConsiderationOffset\n                )\n                if iszero(invalidEncoding) {\n                    // Copy length of offer array to scratch space.\n                    returndatacopy(0, offsetOffer, OneWord)\n                    offerLength := mload(0)\n\n                    // Copy length of consideration array to scratch space.\n                    returndatacopy(OneWord, offsetConsideration, OneWord)\n                    considerationLength := mload(OneWord)\n\n                    {\n                        // Calculate total size of offer & consideration arrays.\n                        let totalOfferSize := shl(\n                            SpentItem_size_shift,\n                            offerLength\n                        )\n                        let totalConsiderationSize := mul(\n                            ReceivedItem_size,\n                            considerationLength\n                        )\n\n                        // Add 4 words to total size to cover the offset and\n                        // length fields of the two arrays.\n                        let totalSize := add(\n                            FourWords,\n                            add(totalOfferSize, totalConsiderationSize)\n                        )\n                        // Don't continue if returndatasize exceeds 65535 bytes\n                        // or is greater than the calculated size.\n                        invalidEncoding := or(\n                            gt(\n                                or(offerLength, considerationLength),\n                                generateOrder_maximum_returndatasize\n                            ),\n                            gt(totalSize, returndatasize())\n                        )\n\n                        // Set first word of scratch space to 0 so length of\n                        // offer/consideration are set to 0 on invalid encoding.\n                        mstore(0, 0)\n                    }\n                }\n            }\n\n            if iszero(invalidEncoding) {\n                offer := copySpentItemsAsOfferItems(\n                    add(offsetOffer, OneWord),\n                    offerLength\n                )\n\n                consideration := copyReceivedItemsAsConsiderationItems(\n                    add(offsetConsideration, OneWord),\n                    considerationLength\n                )\n            }\n\n            function copySpentItemsAsOfferItems(rdPtrHead, length)\n                -> mPtrLength\n            {\n                // Retrieve the current free memory pointer.\n                mPtrLength := mload(FreeMemoryPointerSlot)\n\n                // Allocate memory for the array.\n                mstore(\n                    FreeMemoryPointerSlot,\n                    add(\n                        mPtrLength,\n                        add(OneWord, mul(length, OfferItem_size_with_length))\n                    )\n                )\n\n                // Write the length of the array to the start of free memory.\n                mstore(mPtrLength, length)\n\n                // Use offset from length to minimize stack depth.\n                let headOffsetFromLength := OneWord\n                let headSizeWithLength := shl(OneWordShift, add(1, length))\n                let mPtrTailNext := add(mPtrLength, headSizeWithLength)\n\n                // Iterate over each element.\n                for {\n\n                } lt(headOffsetFromLength, headSizeWithLength) {\n\n                } {\n                    // Write the memory pointer to the accompanying head offset.\n                    mstore(add(mPtrLength, headOffsetFromLength), mPtrTailNext)\n\n                    // Copy itemType, token, identifier and amount.\n                    returndatacopy(mPtrTailNext, rdPtrHead, SpentItem_size)\n\n                    // Copy amount to endAmount.\n                    mstore(\n                        add(mPtrTailNext, Common_endAmount_offset),\n                        mload(add(mPtrTailNext, Common_amount_offset))\n                    )\n\n                    // Update read pointer, next tail pointer, and head offset.\n                    rdPtrHead := add(rdPtrHead, SpentItem_size)\n                    mPtrTailNext := add(mPtrTailNext, OfferItem_size)\n                    headOffsetFromLength := add(headOffsetFromLength, OneWord)\n                }\n            }\n\n            function copyReceivedItemsAsConsiderationItems(rdPtrHead, length)\n                -> mPtrLength\n            {\n                // Retrieve the current free memory pointer.\n                mPtrLength := mload(FreeMemoryPointerSlot)\n\n                // Allocate memory for the array.\n                mstore(\n                    FreeMemoryPointerSlot,\n                    add(\n                        mPtrLength,\n                        add(\n                            OneWord,\n                            mul(length, ConsiderationItem_size_with_length)\n                        )\n                    )\n                )\n\n                // Write the length of the array to the start of free memory.\n                mstore(mPtrLength, length)\n\n                // Use offset from length to minimize stack depth.\n                let headOffsetFromLength := OneWord\n                let headSizeWithLength := shl(OneWordShift, add(1, length))\n                let mPtrTailNext := add(mPtrLength, headSizeWithLength)\n\n                // Iterate over each element.\n                for {\n\n                } lt(headOffsetFromLength, headSizeWithLength) {\n\n                } {\n                    // Write the memory pointer to the accompanying head offset.\n                    mstore(add(mPtrLength, headOffsetFromLength), mPtrTailNext)\n\n                    // Copy itemType, token, identifier and amount.\n                    returndatacopy(\n                        mPtrTailNext,\n                        rdPtrHead,\n                        ReceivedItem_size_excluding_recipient\n                    )\n\n                    // Copy amount and recipient.\n                    returndatacopy(\n                        add(mPtrTailNext, Common_endAmount_offset),\n                        add(rdPtrHead, Common_amount_offset),\n                        TwoWords\n                    )\n\n                    // Update read pointer, next tail pointer, and head offset.\n                    rdPtrHead := add(rdPtrHead, ReceivedItem_size)\n                    mPtrTailNext := add(mPtrTailNext, ConsiderationItem_size)\n                    headOffsetFromLength := add(headOffsetFromLength, OneWord)\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Converts a function returning _decodeGenerateOrderReturndata types\n     *      into a function returning offer and consideration types.\n     *\n     * @param inFn The input function, taking no arguments and returning an\n     *             error buffer, spent item array, and received item array.\n     *\n     * @return outFn The output function, taking no arguments and returning an\n     *               error buffer, offer array, and consideration array.\n     */\n    function _convertGetGeneratedOrderResult(\n        function()\n            internal\n            pure\n            returns (uint256, MemoryPointer, MemoryPointer) inFn\n    )\n        internal\n        pure\n        returns (\n            function()\n                internal\n                pure\n                returns (\n                    uint256,\n                    OfferItem[] memory,\n                    ConsiderationItem[] memory\n                ) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking ReceivedItem, address, bytes32, and bytes\n     *      types (e.g. the _transfer function) into a function taking\n     *      OfferItem, address, bytes32, and bytes types.\n     *\n     * @param inFn The input function, taking ReceivedItem, address, bytes32,\n     *             and bytes types (e.g. the _transfer function).\n     *\n     * @return outFn The output function, taking OfferItem, address, bytes32,\n     *               and bytes types.\n     */\n    function _toOfferItemInput(\n        function(ReceivedItem memory, address, bytes32, bytes memory)\n            internal inFn\n    )\n        internal\n        pure\n        returns (\n            function(OfferItem memory, address, bytes32, bytes memory)\n                internal outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking ReceivedItem, address, bytes32, and bytes\n     *      types (e.g. the _transfer function) into a function taking\n     *      ConsiderationItem, address, bytes32, and bytes types.\n     *\n     * @param inFn The input function, taking ReceivedItem, address, bytes32,\n     *             and bytes types (e.g. the _transfer function).\n     *\n     * @return outFn The output function, taking ConsiderationItem, address,\n     *               bytes32, and bytes types.\n     */\n    function _toConsiderationItemInput(\n        function(ReceivedItem memory, address, bytes32, bytes memory)\n            internal inFn\n    )\n        internal\n        pure\n        returns (\n            function(ConsiderationItem memory, address, bytes32, bytes memory)\n                internal outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      an OrderParameters type.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning an OrderParameters type.\n     */\n    function _toOrderParametersReturnType(\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\n    )\n        internal\n        pure\n        returns (\n            function(CalldataPointer)\n                internal\n                pure\n                returns (OrderParameters memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      an AdvancedOrder type.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning an AdvancedOrder type.\n     */\n    function _toAdvancedOrderReturnType(\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\n    )\n        internal\n        pure\n        returns (\n            function(CalldataPointer)\n                internal\n                pure\n                returns (AdvancedOrder memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      a dynamic array of CriteriaResolver types.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning a dynamic array of CriteriaResolver types.\n     */\n    function _toCriteriaResolversReturnType(\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\n    )\n        internal\n        pure\n        returns (\n            function(CalldataPointer)\n                internal\n                pure\n                returns (CriteriaResolver[] memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      a dynamic array of Order types.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning a dynamic array of Order types.\n     */\n    function _toOrdersReturnType(\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\n    )\n        internal\n        pure\n        returns (\n            function(CalldataPointer)\n                internal\n                pure\n                returns (Order[] memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      a nested dynamic array of dynamic arrays of FulfillmentComponent\n     *      types.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning a nested dynamic array of dynamic arrays of\n     *               FulfillmentComponent types.\n     */\n    function _toNestedFulfillmentComponentsReturnType(\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\n    )\n        internal\n        pure\n        returns (\n            function(CalldataPointer)\n                internal\n                pure\n                returns (FulfillmentComponent[][] memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      a dynamic array of AdvancedOrder types.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning a dynamic array of AdvancedOrder types.\n     */\n    function _toAdvancedOrdersReturnType(\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\n    )\n        internal\n        pure\n        returns (\n            function(CalldataPointer)\n                internal\n                pure\n                returns (AdvancedOrder[] memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Converts a function taking a calldata pointer and returning a memory\n     *      pointer into a function taking that calldata pointer and returning\n     *      a dynamic array of Fulfillment types.\n     *\n     * @param inFn The input function, taking an arbitrary calldata pointer and\n     *             returning an arbitrary memory pointer.\n     *\n     * @return outFn The output function, taking an arbitrary calldata pointer\n     *               and returning a dynamic array of Fulfillment types.\n     */\n    function _toFulfillmentsReturnType(\n        function(CalldataPointer) internal pure returns (MemoryPointer) inFn\n    )\n        internal\n        pure\n        returns (\n            function(CalldataPointer)\n                internal\n                pure\n                returns (Fulfillment[] memory) outFn\n        )\n    {\n        assembly {\n            outFn := inFn\n        }\n    }\n\n    /**\n     * @dev Caches the endAmount in an offer item and replaces it with\n     * a given recipient so that its memory may be reused as a temporary\n     * ReceivedItem.\n     *\n     * @param offerItem The offer item.\n     * @param recipient The recipient.\n     *\n     * @return originalEndAmount The original end amount.\n     */\n    function _replaceEndAmountWithRecipient(\n        OfferItem memory offerItem,\n        address recipient\n    ) internal pure returns (uint256 originalEndAmount) {\n        assembly {\n            // Derive the pointer to the end amount on the offer item.\n            let endAmountPtr := add(offerItem, ReceivedItem_recipient_offset)\n\n            // Retrieve the value of the end amount on the offer item.\n            originalEndAmount := mload(endAmountPtr)\n\n            // Write recipient to received item at the offer end amount pointer.\n            mstore(endAmountPtr, recipient)\n        }\n    }\n}\n"},"contracts/interfaces/ZoneInteractionErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title ZoneInteractionErrors\n * @author 0age\n * @notice ZoneInteractionErrors contains errors related to zone interaction.\n */\ninterface ZoneInteractionErrors {\n    /**\n     * @dev Revert with an error when attempting to fill an order that specifies\n     *      a restricted submitter as its order type when not submitted by\n     *      either the offerer or the order's zone or approved as valid by the\n     *      zone in question via a call to `isValidOrder`.\n     *\n     * @param orderHash The order hash for the invalid restricted order.\n     */\n    error InvalidRestrictedOrder(bytes32 orderHash);\n\n    /**\n     * @dev Revert with an error when attempting to fill a contract order that\n     *      fails to generate an order successfully, that does not adhere to the\n     *      requirements for minimum spent or maximum received supplied by the\n     *      fulfiller, or that fails the post-execution `ratifyOrder` check..\n     *\n     * @param orderHash The order hash for the invalid contract order.\n     */\n    error InvalidContractOrder(bytes32 orderHash);\n}\n"},"contracts/lib/ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ReentrancyErrors } from \"../interfaces/ReentrancyErrors.sol\";\n\nimport { LowLevelHelpers } from \"./LowLevelHelpers.sol\";\n\nimport {\n    _revertInvalidMsgValue,\n    _revertNoReentrantCalls\n} from \"./ConsiderationErrors.sol\";\n\nimport {\n    _ENTERED_AND_ACCEPTING_NATIVE_TOKENS,\n    _ENTERED,\n    _NOT_ENTERED\n} from \"./ConsiderationConstants.sol\";\n\n/**\n * @title ReentrancyGuard\n * @author 0age\n * @notice ReentrancyGuard contains a storage variable and related functionality\n *         for protecting against reentrancy.\n */\ncontract ReentrancyGuard is ReentrancyErrors, LowLevelHelpers {\n    // Prevent reentrant calls on protected functions.\n    uint256 private _reentrancyGuard;\n\n    /**\n     * @dev Initialize the reentrancy guard during deployment.\n     */\n    constructor() {\n        // Initialize the reentrancy guard in a cleared state.\n        _reentrancyGuard = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Internal function to ensure that a sentinel value for the reentrancy\n     *      guard is not currently set and, if not, to set a sentinel value for\n     *      the reentrancy guard based on whether or not native tokens may be\n     *      received during execution or not.\n     *\n     * @param acceptNativeTokens A boolean indicating whether native tokens may\n     *                           be received during execution or not.\n     */\n    function _setReentrancyGuard(bool acceptNativeTokens) internal {\n        // Ensure that the reentrancy guard is not already set.\n        _assertNonReentrant();\n\n        // Set the reentrancy guard. A value of 2 indicates that native tokens\n        // may not be accepted during execution, whereas a value of 3 indicates\n        // that they will be accepted (with any remaining native tokens returned\n        // to the caller).\n        unchecked {\n            _reentrancyGuard = _ENTERED + _cast(acceptNativeTokens);\n        }\n    }\n\n    /**\n     * @dev Internal function to unset the reentrancy guard sentinel value.\n     */\n    function _clearReentrancyGuard() internal {\n        // Clear the reentrancy guard.\n        _reentrancyGuard = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Internal view function to ensure that a sentinel value for the\n            reentrancy guard is not currently set.\n     */\n    function _assertNonReentrant() internal view {\n        // Ensure that the reentrancy guard is not currently set.\n        if (_reentrancyGuard != _NOT_ENTERED) {\n            _revertNoReentrantCalls();\n        }\n    }\n\n    /**\n     * @dev Internal view function to ensure that the sentinel value indicating\n     *      native tokens may be received during execution is currently set.\n     */\n    function _assertAcceptingNativeTokens() internal view {\n        // Ensure that the reentrancy guard is not currently set.\n        if (_reentrancyGuard != _ENTERED_AND_ACCEPTING_NATIVE_TOKENS) {\n            _revertInvalidMsgValue(msg.value);\n        }\n    }\n}\n"},"contracts/interfaces/ReentrancyErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title ReentrancyErrors\n * @author 0age\n * @notice ReentrancyErrors contains errors related to reentrancy.\n */\ninterface ReentrancyErrors {\n    /**\n     * @dev Revert with an error when a caller attempts to reenter a protected\n     *      function.\n     */\n    error NoReentrantCalls();\n}\n"},"contracts/lib/CriteriaResolution.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ItemType, Side } from \"./ConsiderationEnums.sol\";\n\nimport {\n    AdvancedOrder,\n    CriteriaResolver,\n    MemoryPointer,\n    OfferItem,\n    OrderParameters\n} from \"./ConsiderationStructs.sol\";\n\nimport {\n    _revertCriteriaNotEnabledForItem,\n    _revertInvalidProof,\n    _revertOrderCriteriaResolverOutOfRange,\n    _revertUnresolvedConsiderationCriteria,\n    _revertUnresolvedOfferCriteria\n} from \"./ConsiderationErrors.sol\";\n\nimport {\n    CriteriaResolutionErrors\n} from \"../interfaces/CriteriaResolutionErrors.sol\";\n\nimport {\n    OneWord,\n    OneWordShift,\n    OrderParameters_consideration_head_offset,\n    Selector_length,\n    TwoWords\n} from \"./ConsiderationConstants.sol\";\n\nimport {\n    ConsiderationCriteriaResolverOutOfRange_err_selector,\n    Error_selector_offset,\n    OfferCriteriaResolverOutOfRange_error_selector\n} from \"./ConsiderationErrorConstants.sol\";\n\n/**\n * @title CriteriaResolution\n * @author 0age\n * @notice CriteriaResolution contains a collection of pure functions related to\n *         resolving criteria-based items.\n */\ncontract CriteriaResolution is CriteriaResolutionErrors {\n    /**\n     * @dev Internal pure function to apply criteria resolvers containing\n     *      specific token identifiers and associated proofs to order items.\n     *\n     * @param advancedOrders     The orders to apply criteria resolvers to.\n     * @param criteriaResolvers  An array where each element contains a\n     *                           reference to a specific order as well as that\n     *                           order's offer or consideration, a token\n     *                           identifier, and a proof that the supplied token\n     *                           identifier is contained in the order's merkle\n     *                           root. Note that a root of zero indicates that\n     *                           any transferable token identifier is valid and\n     *                           that no proof needs to be supplied.\n     */\n    function _applyCriteriaResolvers(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] memory criteriaResolvers\n    ) internal pure {\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Retrieve length of criteria resolvers array and place on stack.\n            uint256 totalCriteriaResolvers = criteriaResolvers.length;\n\n            // Retrieve length of orders array and place on stack.\n            uint256 totalAdvancedOrders = advancedOrders.length;\n\n            // Iterate over each criteria resolver.\n            for (uint256 i = 0; i < totalCriteriaResolvers; ++i) {\n                // Retrieve the criteria resolver.\n                CriteriaResolver memory criteriaResolver = (\n                    criteriaResolvers[i]\n                );\n\n                // Read the order index from memory and place it on the stack.\n                uint256 orderIndex = criteriaResolver.orderIndex;\n\n                // Ensure that the order index is in range.\n                if (orderIndex >= totalAdvancedOrders) {\n                    _revertOrderCriteriaResolverOutOfRange(\n                        criteriaResolver.side\n                    );\n                }\n\n                // Retrieve the referenced advanced order.\n                AdvancedOrder memory advancedOrder = advancedOrders[orderIndex];\n\n                // Skip criteria resolution for order if not fulfilled.\n                if (advancedOrder.numerator == 0) {\n                    continue;\n                }\n\n                // Retrieve the parameters for the order.\n                OrderParameters memory orderParameters = (\n                    advancedOrder.parameters\n                );\n\n                {\n                    // Get a pointer to the list of items to give to\n                    // _updateCriteriaItem. If the resolver refers to a\n                    // consideration item, this array pointer will be replaced\n                    // with the consideration array.\n                    OfferItem[] memory items = orderParameters.offer;\n\n                    // Read component index from memory and place it on stack.\n                    uint256 componentIndex = criteriaResolver.index;\n\n                    // Get error selector for `OfferCriteriaResolverOutOfRange`.\n                    uint256 errorSelector = (\n                        OfferCriteriaResolverOutOfRange_error_selector\n                    );\n\n                    // If the resolver refers to a consideration item...\n                    if (criteriaResolver.side != Side.OFFER) {\n                        // Get the pointer to `orderParameters.consideration`\n                        // Using the array directly has a significant impact on\n                        // the optimized compiler output.\n                        MemoryPointer considerationPtr = orderParameters\n                            .toMemoryPointer()\n                            .pptr(OrderParameters_consideration_head_offset);\n\n                        // Replace the items pointer with a pointer to the\n                        // consideration array.\n                        assembly {\n                            items := considerationPtr\n                        }\n\n                        // Replace the error selector with the selector for\n                        // `ConsiderationCriteriaResolverOutOfRange`.\n                        errorSelector = (\n                            ConsiderationCriteriaResolverOutOfRange_err_selector\n                        );\n                    }\n\n                    // Ensure that the component index is in range.\n                    if (componentIndex >= items.length) {\n                        assembly {\n                            // Revert with either\n                            // `OfferCriteriaResolverOutOfRange()` or\n                            // `ConsiderationCriteriaResolverOutOfRange()`,\n                            // depending on whether the resolver refers to a\n                            // consideration item.\n                            mstore(0, errorSelector)\n                            // revert(abi.encodeWithSignature(\n                            //    \"OfferCriteriaResolverOutOfRange()\"\n                            // ))\n                            // or\n                            // revert(abi.encodeWithSignature(\n                            //    \"ConsiderationCriteriaResolverOutOfRange()\"\n                            // ))\n                            revert(Error_selector_offset, Selector_length)\n                        }\n                    }\n\n                    // Apply the criteria resolver to the item in question.\n                    _updateCriteriaItem(\n                        items,\n                        componentIndex,\n                        criteriaResolver\n                    );\n                }\n            }\n\n            // Iterate over each advanced order.\n            for (uint256 i = 0; i < totalAdvancedOrders; ++i) {\n                // Retrieve the advanced order.\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\n\n                // Skip criteria resolution for order if not fulfilled.\n                if (advancedOrder.numerator == 0) {\n                    continue;\n                }\n\n                // Retrieve the parameters for the order.\n                OrderParameters memory orderParameters = (\n                    advancedOrder.parameters\n                );\n\n                // Read consideration length from memory and place on stack.\n                uint256 totalItems = orderParameters.consideration.length;\n\n                // Iterate over each consideration item on the order.\n                for (uint256 j = 0; j < totalItems; ++j) {\n                    // Ensure item type no longer indicates criteria usage.\n                    if (\n                        _isItemWithCriteria(\n                            orderParameters.consideration[j].itemType\n                        )\n                    ) {\n                        _revertUnresolvedConsiderationCriteria(i, j);\n                    }\n                }\n\n                // Read offer length from memory and place on stack.\n                totalItems = orderParameters.offer.length;\n\n                // Iterate over each offer item on the order.\n                for (uint256 j = 0; j < totalItems; ++j) {\n                    // Ensure item type no longer indicates criteria usage.\n                    if (\n                        _isItemWithCriteria(orderParameters.offer[j].itemType)\n                    ) {\n                        _revertUnresolvedOfferCriteria(i, j);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Internal pure function to update a criteria item.\n     *\n     * @param offer             The offer containing the item to update.\n     * @param componentIndex    The index of the item to update.\n     * @param criteriaResolver  The criteria resolver to use to update the item.\n     */\n    function _updateCriteriaItem(\n        OfferItem[] memory offer,\n        uint256 componentIndex,\n        CriteriaResolver memory criteriaResolver\n    ) internal pure {\n        // Retrieve relevant item using the component index.\n        OfferItem memory offerItem = offer[componentIndex];\n\n        // Read item type and criteria from memory & place on stack.\n        ItemType itemType = offerItem.itemType;\n\n        // Ensure the specified item type indicates criteria usage.\n        if (!_isItemWithCriteria(itemType)) {\n            _revertCriteriaNotEnabledForItem();\n        }\n\n        uint256 identifierOrCriteria = offerItem.identifierOrCriteria;\n\n        // If criteria is not 0 (i.e. a collection-wide criteria-based item)...\n        if (identifierOrCriteria != uint256(0)) {\n            // Verify identifier inclusion in criteria root using proof.\n            _verifyProof(\n                criteriaResolver.identifier,\n                identifierOrCriteria,\n                criteriaResolver.criteriaProof\n            );\n        } else if (criteriaResolver.criteriaProof.length != 0) {\n            // Revert if non-empty proof is supplied for a collection-wide item.\n            _revertInvalidProof();\n        }\n\n        // Update item type to remove criteria usage.\n        // Use assembly to operate on ItemType enum as a number.\n        ItemType newItemType;\n        assembly {\n            // Item type 4 becomes 2 and item type 5 becomes 3.\n            newItemType := sub(3, eq(itemType, 4))\n        }\n        offerItem.itemType = newItemType;\n\n        // Update identifier w/ supplied identifier.\n        offerItem.identifierOrCriteria = criteriaResolver.identifier;\n    }\n\n    /**\n     * @dev Internal pure function to check whether a given item type represents\n     *      a criteria-based ERC721 or ERC1155 item (e.g. an item that can be\n     *      resolved to one of a number of different identifiers at the time of\n     *      order fulfillment).\n     *\n     * @param itemType The item type in question.\n     *\n     * @return withCriteria A boolean indicating that the item type in question\n     *                      represents a criteria-based item.\n     */\n    function _isItemWithCriteria(\n        ItemType itemType\n    ) internal pure returns (bool withCriteria) {\n        // ERC721WithCriteria is ItemType 4. ERC1155WithCriteria is ItemType 5.\n        assembly {\n            withCriteria := gt(itemType, 3)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to ensure that a given element is contained\n     *      in a merkle root via a supplied proof.\n     *\n     * @param leaf  The element for which to prove inclusion.\n     * @param root  The merkle root that inclusion will be proved against.\n     * @param proof The merkle proof.\n     */\n    function _verifyProof(\n        uint256 leaf,\n        uint256 root,\n        bytes32[] memory proof\n    ) internal pure {\n        // Declare a variable that will be used to determine proof validity.\n        bool isValid;\n\n        // Utilize assembly to efficiently verify the proof against the root.\n        assembly {\n            // Store the leaf at the beginning of scratch space.\n            mstore(0, leaf)\n\n            // Derive the hash of the leaf to use as the initial proof element.\n            let computedHash := keccak256(0, OneWord)\n\n            // Get memory start location of the first element in proof array.\n            let data := add(proof, OneWord)\n\n            // Iterate over each proof element to compute the root hash.\n            for {\n                // Left shift by 5 is equivalent to multiplying by 0x20.\n                let end := add(data, shl(OneWordShift, mload(proof)))\n            } lt(data, end) {\n                // Increment by one word at a time.\n                data := add(data, OneWord)\n            } {\n                // Get the proof element.\n                let loadedData := mload(data)\n\n                // Sort proof elements and place them in scratch space.\n                // Slot of `computedHash` in scratch space.\n                // If the condition is true: 0x20, otherwise: 0x00.\n                let scratch := shl(OneWordShift, gt(computedHash, loadedData))\n\n                // Store elements to hash contiguously in scratch space. Scratch\n                // space is 64 bytes (0x00 - 0x3f) & both elements are 32 bytes.\n                mstore(scratch, computedHash)\n                mstore(xor(scratch, OneWord), loadedData)\n\n                // Derive the updated hash.\n                computedHash := keccak256(0, TwoWords)\n            }\n\n            // Compare the final hash to the supplied root.\n            isValid := eq(computedHash, root)\n        }\n\n        // Revert if computed hash does not equal supplied root.\n        if (!isValid) {\n            _revertInvalidProof();\n        }\n    }\n}\n"},"contracts/interfaces/ConduitControllerInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title ConduitControllerInterface\n * @author 0age\n * @notice ConduitControllerInterface contains all external function interfaces,\n *         structs, events, and errors for the conduit controller.\n */\ninterface ConduitControllerInterface {\n    /**\n     * @dev Track the conduit key, current owner, new potential owner, and open\n     *      channels for each deployed conduit.\n     */\n    struct ConduitProperties {\n        bytes32 key;\n        address owner;\n        address potentialOwner;\n        address[] channels;\n        mapping(address => uint256) channelIndexesPlusOne;\n    }\n\n    /**\n     * @dev Emit an event whenever a new conduit is created.\n     *\n     * @param conduit    The newly created conduit.\n     * @param conduitKey The conduit key used to create the new conduit.\n     */\n    event NewConduit(address conduit, bytes32 conduitKey);\n\n    /**\n     * @dev Emit an event whenever conduit ownership is transferred.\n     *\n     * @param conduit       The conduit for which ownership has been\n     *                      transferred.\n     * @param previousOwner The previous owner of the conduit.\n     * @param newOwner      The new owner of the conduit.\n     */\n    event OwnershipTransferred(\n        address indexed conduit,\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Emit an event whenever a conduit owner registers a new potential\n     *      owner for that conduit.\n     *\n     * @param newPotentialOwner The new potential owner of the conduit.\n     */\n    event PotentialOwnerUpdated(address indexed newPotentialOwner);\n\n    /**\n     * @dev Revert with an error when attempting to create a new conduit using a\n     *      conduit key where the first twenty bytes of the key do not match the\n     *      address of the caller.\n     */\n    error InvalidCreator();\n\n    /**\n     * @dev Revert with an error when attempting to create a new conduit when no\n     *      initial owner address is supplied.\n     */\n    error InvalidInitialOwner();\n\n    /**\n     * @dev Revert with an error when attempting to set a new potential owner\n     *      that is already set.\n     */\n    error NewPotentialOwnerAlreadySet(\n        address conduit,\n        address newPotentialOwner\n    );\n\n    /**\n     * @dev Revert with an error when attempting to cancel ownership transfer\n     *      when no new potential owner is currently set.\n     */\n    error NoPotentialOwnerCurrentlySet(address conduit);\n\n    /**\n     * @dev Revert with an error when attempting to interact with a conduit that\n     *      does not yet exist.\n     */\n    error NoConduit();\n\n    /**\n     * @dev Revert with an error when attempting to create a conduit that\n     *      already exists.\n     */\n    error ConduitAlreadyExists(address conduit);\n\n    /**\n     * @dev Revert with an error when attempting to update channels or transfer\n     *      ownership of a conduit when the caller is not the owner of the\n     *      conduit in question.\n     */\n    error CallerIsNotOwner(address conduit);\n\n    /**\n     * @dev Revert with an error when attempting to register a new potential\n     *      owner and supplying the null address.\n     */\n    error NewPotentialOwnerIsZeroAddress(address conduit);\n\n    /**\n     * @dev Revert with an error when attempting to claim ownership of a conduit\n     *      with a caller that is not the current potential owner for the\n     *      conduit in question.\n     */\n    error CallerIsNotNewPotentialOwner(address conduit);\n\n    /**\n     * @dev Revert with an error when attempting to retrieve a channel using an\n     *      index that is out of range.\n     */\n    error ChannelOutOfRange(address conduit);\n\n    /**\n     * @notice Deploy a new conduit using a supplied conduit key and assigning\n     *         an initial owner for the deployed conduit. Note that the first\n     *         twenty bytes of the supplied conduit key must match the caller\n     *         and that a new conduit cannot be created if one has already been\n     *         deployed using the same conduit key.\n     *\n     * @param conduitKey   The conduit key used to deploy the conduit. Note that\n     *                     the first twenty bytes of the conduit key must match\n     *                     the caller of this contract.\n     * @param initialOwner The initial owner to set for the new conduit.\n     *\n     * @return conduit The address of the newly deployed conduit.\n     */\n    function createConduit(\n        bytes32 conduitKey,\n        address initialOwner\n    ) external returns (address conduit);\n\n    /**\n     * @notice Open or close a channel on a given conduit, thereby allowing the\n     *         specified account to execute transfers against that conduit.\n     *         Extreme care must be taken when updating channels, as malicious\n     *         or vulnerable channels can transfer any ERC20, ERC721 and ERC1155\n     *         tokens where the token holder has granted the conduit approval.\n     *         Only the owner of the conduit in question may call this function.\n     *\n     * @param conduit The conduit for which to open or close the channel.\n     * @param channel The channel to open or close on the conduit.\n     * @param isOpen  A boolean indicating whether to open or close the channel.\n     */\n    function updateChannel(\n        address conduit,\n        address channel,\n        bool isOpen\n    ) external;\n\n    /**\n     * @notice Initiate conduit ownership transfer by assigning a new potential\n     *         owner for the given conduit. Once set, the new potential owner\n     *         may call `acceptOwnership` to claim ownership of the conduit.\n     *         Only the owner of the conduit in question may call this function.\n     *\n     * @param conduit The conduit for which to initiate ownership transfer.\n     * @param newPotentialOwner The new potential owner of the conduit.\n     */\n    function transferOwnership(\n        address conduit,\n        address newPotentialOwner\n    ) external;\n\n    /**\n     * @notice Clear the currently set potential owner, if any, from a conduit.\n     *         Only the owner of the conduit in question may call this function.\n     *\n     * @param conduit The conduit for which to cancel ownership transfer.\n     */\n    function cancelOwnershipTransfer(address conduit) external;\n\n    /**\n     * @notice Accept ownership of a supplied conduit. Only accounts that the\n     *         current owner has set as the new potential owner may call this\n     *         function.\n     *\n     * @param conduit The conduit for which to accept ownership.\n     */\n    function acceptOwnership(address conduit) external;\n\n    /**\n     * @notice Retrieve the current owner of a deployed conduit.\n     *\n     * @param conduit The conduit for which to retrieve the associated owner.\n     *\n     * @return owner The owner of the supplied conduit.\n     */\n    function ownerOf(address conduit) external view returns (address owner);\n\n    /**\n     * @notice Retrieve the conduit key for a deployed conduit via reverse\n     *         lookup.\n     *\n     * @param conduit The conduit for which to retrieve the associated conduit\n     *                key.\n     *\n     * @return conduitKey The conduit key used to deploy the supplied conduit.\n     */\n    function getKey(address conduit) external view returns (bytes32 conduitKey);\n\n    /**\n     * @notice Derive the conduit associated with a given conduit key and\n     *         determine whether that conduit exists (i.e. whether it has been\n     *         deployed).\n     *\n     * @param conduitKey The conduit key used to derive the conduit.\n     *\n     * @return conduit The derived address of the conduit.\n     * @return exists  A boolean indicating whether the derived conduit has been\n     *                 deployed or not.\n     */\n    function getConduit(\n        bytes32 conduitKey\n    ) external view returns (address conduit, bool exists);\n\n    /**\n     * @notice Retrieve the potential owner, if any, for a given conduit. The\n     *         current owner may set a new potential owner via\n     *         `transferOwnership` and that owner may then accept ownership of\n     *         the conduit in question via `acceptOwnership`.\n     *\n     * @param conduit The conduit for which to retrieve the potential owner.\n     *\n     * @return potentialOwner The potential owner, if any, for the conduit.\n     */\n    function getPotentialOwner(\n        address conduit\n    ) external view returns (address potentialOwner);\n\n    /**\n     * @notice Retrieve the status (either open or closed) of a given channel on\n     *         a conduit.\n     *\n     * @param conduit The conduit for which to retrieve the channel status.\n     * @param channel The channel for which to retrieve the status.\n     *\n     * @return isOpen The status of the channel on the given conduit.\n     */\n    function getChannelStatus(\n        address conduit,\n        address channel\n    ) external view returns (bool isOpen);\n\n    /**\n     * @notice Retrieve the total number of open channels for a given conduit.\n     *\n     * @param conduit The conduit for which to retrieve the total channel count.\n     *\n     * @return totalChannels The total number of open channels for the conduit.\n     */\n    function getTotalChannels(\n        address conduit\n    ) external view returns (uint256 totalChannels);\n\n    /**\n     * @notice Retrieve an open channel at a specific index for a given conduit.\n     *         Note that the index of a channel can change as a result of other\n     *         channels being closed on the conduit.\n     *\n     * @param conduit      The conduit for which to retrieve the open channel.\n     * @param channelIndex The index of the channel in question.\n     *\n     * @return channel The open channel, if any, at the specified channel index.\n     */\n    function getChannel(\n        address conduit,\n        uint256 channelIndex\n    ) external view returns (address channel);\n\n    /**\n     * @notice Retrieve all open channels for a given conduit. Note that calling\n     *         this function for a conduit with many channels will revert with\n     *         an out-of-gas error.\n     *\n     * @param conduit The conduit for which to retrieve open channels.\n     *\n     * @return channels An array of open channels on the given conduit.\n     */\n    function getChannels(\n        address conduit\n    ) external view returns (address[] memory channels);\n\n    /**\n     * @dev Retrieve the conduit creation code and runtime code hashes.\n     */\n    function getConduitCodeHashes()\n        external\n        view\n        returns (bytes32 creationCodeHash, bytes32 runtimeCodeHash);\n}\n"},"contracts/lib/ConsiderationEnums.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nenum OrderType {\n    // 0: no partial fills, anyone can execute\n    FULL_OPEN,\n\n    // 1: partial fills supported, anyone can execute\n    PARTIAL_OPEN,\n\n    // 2: no partial fills, only offerer or zone can execute\n    FULL_RESTRICTED,\n\n    // 3: partial fills supported, only offerer or zone can execute\n    PARTIAL_RESTRICTED,\n\n    // 4: contract order type\n    CONTRACT\n}\n\nenum BasicOrderType {\n    // 0: no partial fills, anyone can execute\n    ETH_TO_ERC721_FULL_OPEN,\n\n    // 1: partial fills supported, anyone can execute\n    ETH_TO_ERC721_PARTIAL_OPEN,\n\n    // 2: no partial fills, only offerer or zone can execute\n    ETH_TO_ERC721_FULL_RESTRICTED,\n\n    // 3: partial fills supported, only offerer or zone can execute\n    ETH_TO_ERC721_PARTIAL_RESTRICTED,\n\n    // 4: no partial fills, anyone can execute\n    ETH_TO_ERC1155_FULL_OPEN,\n\n    // 5: partial fills supported, anyone can execute\n    ETH_TO_ERC1155_PARTIAL_OPEN,\n\n    // 6: no partial fills, only offerer or zone can execute\n    ETH_TO_ERC1155_FULL_RESTRICTED,\n\n    // 7: partial fills supported, only offerer or zone can execute\n    ETH_TO_ERC1155_PARTIAL_RESTRICTED,\n\n    // 8: no partial fills, anyone can execute\n    ERC20_TO_ERC721_FULL_OPEN,\n\n    // 9: partial fills supported, anyone can execute\n    ERC20_TO_ERC721_PARTIAL_OPEN,\n\n    // 10: no partial fills, only offerer or zone can execute\n    ERC20_TO_ERC721_FULL_RESTRICTED,\n\n    // 11: partial fills supported, only offerer or zone can execute\n    ERC20_TO_ERC721_PARTIAL_RESTRICTED,\n\n    // 12: no partial fills, anyone can execute\n    ERC20_TO_ERC1155_FULL_OPEN,\n\n    // 13: partial fills supported, anyone can execute\n    ERC20_TO_ERC1155_PARTIAL_OPEN,\n\n    // 14: no partial fills, only offerer or zone can execute\n    ERC20_TO_ERC1155_FULL_RESTRICTED,\n\n    // 15: partial fills supported, only offerer or zone can execute\n    ERC20_TO_ERC1155_PARTIAL_RESTRICTED,\n\n    // 16: no partial fills, anyone can execute\n    ERC721_TO_ERC20_FULL_OPEN,\n\n    // 17: partial fills supported, anyone can execute\n    ERC721_TO_ERC20_PARTIAL_OPEN,\n\n    // 18: no partial fills, only offerer or zone can execute\n    ERC721_TO_ERC20_FULL_RESTRICTED,\n\n    // 19: partial fills supported, only offerer or zone can execute\n    ERC721_TO_ERC20_PARTIAL_RESTRICTED,\n\n    // 20: no partial fills, anyone can execute\n    ERC1155_TO_ERC20_FULL_OPEN,\n\n    // 21: partial fills supported, anyone can execute\n    ERC1155_TO_ERC20_PARTIAL_OPEN,\n\n    // 22: no partial fills, only offerer or zone can execute\n    ERC1155_TO_ERC20_FULL_RESTRICTED,\n\n    // 23: partial fills supported, only offerer or zone can execute\n    ERC1155_TO_ERC20_PARTIAL_RESTRICTED\n}\n\nenum BasicOrderRouteType {\n    // 0: provide Ether (or other native token) to receive offered ERC721 item.\n    ETH_TO_ERC721,\n\n    // 1: provide Ether (or other native token) to receive offered ERC1155 item.\n    ETH_TO_ERC1155,\n\n    // 2: provide ERC20 item to receive offered ERC721 item.\n    ERC20_TO_ERC721,\n\n    // 3: provide ERC20 item to receive offered ERC1155 item.\n    ERC20_TO_ERC1155,\n\n    // 4: provide ERC721 item to receive offered ERC20 item.\n    ERC721_TO_ERC20,\n\n    // 5: provide ERC1155 item to receive offered ERC20 item.\n    ERC1155_TO_ERC20\n}\n\nenum ItemType {\n    // 0: ETH on mainnet, MATIC on polygon, etc.\n    NATIVE,\n\n    // 1: ERC20 items (ERC777 and ERC20 analogues could also technically work)\n    ERC20,\n\n    // 2: ERC721 items\n    ERC721,\n\n    // 3: ERC1155 items\n    ERC1155,\n\n    // 4: ERC721 items where a number of tokenIds are supported\n    ERC721_WITH_CRITERIA,\n\n    // 5: ERC1155 items where a number of ids are supported\n    ERC1155_WITH_CRITERIA\n}\n\nenum Side {\n    // 0: Items that can be spent\n    OFFER,\n\n    // 1: Items that must be received\n    CONSIDERATION\n}\n"},"contracts/lib/GettersAndDerivers.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { OrderParameters } from \"./ConsiderationStructs.sol\";\n\nimport { ConsiderationBase } from \"./ConsiderationBase.sol\";\n\nimport {\n    Create2AddressDerivation_length,\n    Create2AddressDerivation_ptr,\n    EIP_712_PREFIX,\n    EIP712_ConsiderationItem_size,\n    EIP712_DigestPayload_size,\n    EIP712_DomainSeparator_offset,\n    EIP712_OfferItem_size,\n    EIP712_Order_size,\n    EIP712_OrderHash_offset,\n    FreeMemoryPointerSlot,\n    information_conduitController_offset,\n    information_domainSeparator_offset,\n    information_length,\n    information_version_cd_offset,\n    information_version_offset,\n    information_versionLengthPtr,\n    information_versionWithLength,\n    MaskOverByteTwelve,\n    MaskOverLastTwentyBytes,\n    OneWord,\n    OneWordShift,\n    OrderParameters_consideration_head_offset,\n    OrderParameters_counter_offset,\n    OrderParameters_offer_head_offset,\n    TwoWords\n} from \"./ConsiderationConstants.sol\";\n\n/**\n * @title GettersAndDerivers\n * @author 0age\n * @notice ConsiderationInternal contains pure and internal view functions\n *         related to getting or deriving various values.\n */\ncontract GettersAndDerivers is ConsiderationBase {\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(\n        address conduitController\n    ) ConsiderationBase(conduitController) {}\n\n    /**\n     * @dev Internal view function to derive the order hash for a given order.\n     *      Note that only the original consideration items are included in the\n     *      order hash, as additional consideration items may be supplied by the\n     *      caller.\n     *\n     * @param orderParameters The parameters of the order to hash.\n     * @param counter         The counter of the order to hash.\n     *\n     * @return orderHash The hash.\n     */\n    function _deriveOrderHash(\n        OrderParameters memory orderParameters,\n        uint256 counter\n    ) internal view returns (bytes32 orderHash) {\n        // Get length of original consideration array and place it on the stack.\n        uint256 originalConsiderationLength = (\n            orderParameters.totalOriginalConsiderationItems\n        );\n\n        /*\n         * Memory layout for an array of structs (dynamic or not) is similar\n         * to ABI encoding of dynamic types, with a head segment followed by\n         * a data segment. The main difference is that the head of an element\n         * is a memory pointer rather than an offset.\n         */\n\n        // Declare a variable for the derived hash of the offer array.\n        bytes32 offerHash;\n\n        // Read offer item EIP-712 typehash from runtime code & place on stack.\n        bytes32 typeHash = _OFFER_ITEM_TYPEHASH;\n\n        // Utilize assembly so that memory regions can be reused across hashes.\n        assembly {\n            // Retrieve the free memory pointer and place on the stack.\n            let hashArrPtr := mload(FreeMemoryPointerSlot)\n\n            // Get the pointer to the offers array.\n            let offerArrPtr := mload(\n                add(orderParameters, OrderParameters_offer_head_offset)\n            )\n\n            // Load the length.\n            let offerLength := mload(offerArrPtr)\n\n            // Set the pointer to the first offer's head.\n            offerArrPtr := add(offerArrPtr, OneWord)\n\n            // Iterate over the offer items.\n            for { let i := 0 } lt(i, offerLength) {\n                i := add(i, 1)\n            } {\n                // Read the pointer to the offer data and subtract one word\n                // to get typeHash pointer.\n                let ptr := sub(mload(offerArrPtr), OneWord)\n\n                // Read the current value before the offer data.\n                let value := mload(ptr)\n\n                // Write the type hash to the previous word.\n                mstore(ptr, typeHash)\n\n                // Take the EIP712 hash and store it in the hash array.\n                mstore(hashArrPtr, keccak256(ptr, EIP712_OfferItem_size))\n\n                // Restore the previous word.\n                mstore(ptr, value)\n\n                // Increment the array pointers by one word.\n                offerArrPtr := add(offerArrPtr, OneWord)\n                hashArrPtr := add(hashArrPtr, OneWord)\n            }\n\n            // Derive the offer hash using the hashes of each item.\n            offerHash := keccak256(\n                mload(FreeMemoryPointerSlot),\n                shl(OneWordShift, offerLength)\n            )\n        }\n\n        // Declare a variable for the derived hash of the consideration array.\n        bytes32 considerationHash;\n\n        // Read consideration item typehash from runtime code & place on stack.\n        typeHash = _CONSIDERATION_ITEM_TYPEHASH;\n\n        // Utilize assembly so that memory regions can be reused across hashes.\n        assembly {\n            // Retrieve the free memory pointer and place on the stack.\n            let hashArrPtr := mload(FreeMemoryPointerSlot)\n\n            // Get the pointer to the consideration array.\n            let considerationArrPtr := add(\n                mload(\n                    add(\n                        orderParameters,\n                        OrderParameters_consideration_head_offset\n                    )\n                ),\n                OneWord\n            )\n\n            // Iterate over the consideration items (not including tips).\n            for { let i := 0 } lt(i, originalConsiderationLength) {\n                i := add(i, 1)\n            } {\n                // Read the pointer to the consideration data and subtract one\n                // word to get typeHash pointer.\n                let ptr := sub(mload(considerationArrPtr), OneWord)\n\n                // Read the current value before the consideration data.\n                let value := mload(ptr)\n\n                // Write the type hash to the previous word.\n                mstore(ptr, typeHash)\n\n                // Take the EIP712 hash and store it in the hash array.\n                mstore(\n                    hashArrPtr,\n                    keccak256(ptr, EIP712_ConsiderationItem_size)\n                )\n\n                // Restore the previous word.\n                mstore(ptr, value)\n\n                // Increment the array pointers by one word.\n                considerationArrPtr := add(considerationArrPtr, OneWord)\n                hashArrPtr := add(hashArrPtr, OneWord)\n            }\n\n            // Derive the consideration hash using the hashes of each item.\n            considerationHash := keccak256(\n                mload(FreeMemoryPointerSlot),\n                shl(OneWordShift, originalConsiderationLength)\n            )\n        }\n\n        // Read order item EIP-712 typehash from runtime code & place on stack.\n        typeHash = _ORDER_TYPEHASH;\n\n        // Utilize assembly to access derived hashes & other arguments directly.\n        assembly {\n            // Retrieve pointer to the region located just behind parameters.\n            let typeHashPtr := sub(orderParameters, OneWord)\n\n            // Store the value at that pointer location to restore later.\n            let previousValue := mload(typeHashPtr)\n\n            // Store the order item EIP-712 typehash at the typehash location.\n            mstore(typeHashPtr, typeHash)\n\n            // Retrieve the pointer for the offer array head.\n            let offerHeadPtr := add(\n                orderParameters,\n                OrderParameters_offer_head_offset\n            )\n\n            // Retrieve the data pointer referenced by the offer head.\n            let offerDataPtr := mload(offerHeadPtr)\n\n            // Store the offer hash at the retrieved memory location.\n            mstore(offerHeadPtr, offerHash)\n\n            // Retrieve the pointer for the consideration array head.\n            let considerationHeadPtr := add(\n                orderParameters,\n                OrderParameters_consideration_head_offset\n            )\n\n            // Retrieve the data pointer referenced by the consideration head.\n            let considerationDataPtr := mload(considerationHeadPtr)\n\n            // Store the consideration hash at the retrieved memory location.\n            mstore(considerationHeadPtr, considerationHash)\n\n            // Retrieve the pointer for the counter.\n            let counterPtr := add(\n                orderParameters,\n                OrderParameters_counter_offset\n            )\n\n            // Store the counter at the retrieved memory location.\n            mstore(counterPtr, counter)\n\n            // Derive the order hash using the full range of order parameters.\n            orderHash := keccak256(typeHashPtr, EIP712_Order_size)\n\n            // Restore the value previously held at typehash pointer location.\n            mstore(typeHashPtr, previousValue)\n\n            // Restore offer data pointer at the offer head pointer location.\n            mstore(offerHeadPtr, offerDataPtr)\n\n            // Restore consideration data pointer at the consideration head ptr.\n            mstore(considerationHeadPtr, considerationDataPtr)\n\n            // Restore consideration item length at the counter pointer.\n            mstore(counterPtr, originalConsiderationLength)\n        }\n    }\n\n    /**\n     * @dev Internal view function to derive the address of a given conduit\n     *      using a corresponding conduit key.\n     *\n     * @param conduitKey A bytes32 value indicating what corresponding conduit,\n     *                   if any, to source token approvals from. This value is\n     *                   the \"salt\" parameter supplied by the deployer (i.e. the\n     *                   conduit controller) when deploying the given conduit.\n     *\n     * @return conduit The address of the conduit associated with the given\n     *                 conduit key.\n     */\n    function _deriveConduit(\n        bytes32 conduitKey\n    ) internal view returns (address conduit) {\n        // Read conduit controller address from runtime and place on the stack.\n        address conduitController = address(_CONDUIT_CONTROLLER);\n\n        // Read conduit creation code hash from runtime and place on the stack.\n        bytes32 conduitCreationCodeHash = _CONDUIT_CREATION_CODE_HASH;\n\n        // Leverage scratch space to perform an efficient hash.\n        assembly {\n            // Retrieve the free memory pointer; it will be replaced afterwards.\n            let freeMemoryPointer := mload(FreeMemoryPointerSlot)\n\n            // Place the control character and the conduit controller in scratch\n            // space; note that eleven bytes at the beginning are left unused.\n            mstore(0, or(MaskOverByteTwelve, conduitController))\n\n            // Place the conduit key in the next region of scratch space.\n            mstore(OneWord, conduitKey)\n\n            // Place conduit creation code hash in free memory pointer location.\n            mstore(TwoWords, conduitCreationCodeHash)\n\n            // Derive conduit by hashing and applying a mask over last 20 bytes.\n            conduit := and(\n                // Hash the relevant region.\n                keccak256(\n                    // The region starts at memory pointer 11.\n                    Create2AddressDerivation_ptr,\n                    // The region is 85 bytes long (1 + 20 + 32 + 32).\n                    Create2AddressDerivation_length\n                ),\n                // The address equals the last twenty bytes of the hash.\n                MaskOverLastTwentyBytes\n            )\n\n            // Restore the free memory pointer.\n            mstore(FreeMemoryPointerSlot, freeMemoryPointer)\n        }\n    }\n\n    /**\n     * @dev Internal view function to get the EIP-712 domain separator. If the\n     *      chainId matches the chainId set on deployment, the cached domain\n     *      separator will be returned; otherwise, it will be derived from\n     *      scratch.\n     *\n     * @return The domain separator.\n     */\n    function _domainSeparator() internal view returns (bytes32) {\n        return block.chainid == _CHAIN_ID\n            ? _DOMAIN_SEPARATOR\n            : _deriveDomainSeparator();\n    }\n\n    /**\n     * @dev Internal view function to retrieve configuration information for\n     *      this contract.\n     *\n     * @return The contract version.\n     * @return The domain separator for this contract.\n     * @return The conduit Controller set for this contract.\n     */\n    function _information()\n        internal\n        view\n        returns (\n            string memory /* version */,\n            bytes32 /* domainSeparator */,\n            address /* conduitController */\n        )\n    {\n        // Derive the domain separator.\n        bytes32 domainSeparator = _domainSeparator();\n\n        // Declare variable as immutables cannot be accessed within assembly.\n        address conduitController = address(_CONDUIT_CONTROLLER);\n\n        // Return the version, domain separator, and conduit controller.\n        assembly {\n            mstore(information_version_offset, information_version_cd_offset)\n            mstore(information_domainSeparator_offset, domainSeparator)\n            mstore(information_conduitController_offset, conduitController)\n            mstore(information_versionLengthPtr, information_versionWithLength)\n            return(information_version_offset, information_length)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to efficiently derive an digest to sign for\n     *      an order in accordance with EIP-712.\n     *\n     * @param domainSeparator The domain separator.\n     * @param orderHash       The order hash.\n     *\n     * @return value The hash.\n     */\n    function _deriveEIP712Digest(\n        bytes32 domainSeparator,\n        bytes32 orderHash\n    ) internal pure returns (bytes32 value) {\n        // Leverage scratch space to perform an efficient hash.\n        assembly {\n            // Place the EIP-712 prefix at the start of scratch space.\n            mstore(0, EIP_712_PREFIX)\n\n            // Place the domain separator in the next region of scratch space.\n            mstore(EIP712_DomainSeparator_offset, domainSeparator)\n\n            // Place the order hash in scratch space, spilling into the first\n            // two bytes of the free memory pointer — this should never be set\n            // as memory cannot be expanded to that size, and will be zeroed out\n            // after the hash is performed.\n            mstore(EIP712_OrderHash_offset, orderHash)\n\n            // Hash the relevant region (65 bytes).\n            value := keccak256(0, EIP712_DigestPayload_size)\n\n            // Clear out the dirtied bits in the memory pointer.\n            mstore(EIP712_OrderHash_offset, 0)\n        }\n    }\n}\n"},"contracts/lib/ZoneInteraction.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { OrderType } from \"./ConsiderationEnums.sol\";\n\nimport {\n    AdvancedOrder,\n    BasicOrderParameters,\n    OrderParameters\n} from \"./ConsiderationStructs.sol\";\n\nimport { ZoneInteractionErrors } from \"../interfaces/ZoneInteractionErrors.sol\";\n\nimport { LowLevelHelpers } from \"./LowLevelHelpers.sol\";\n\nimport { ConsiderationEncoder } from \"./ConsiderationEncoder.sol\";\n\nimport { MemoryPointer } from \"../helpers/PointerLibraries.sol\";\n\nimport {\n    ContractOrder_orderHash_offerer_shift,\n    MaskOverFirstFourBytes,\n    OneWord,\n    OrderParameters_zone_offset\n} from \"./ConsiderationConstants.sol\";\n\nimport {\n    Error_selector_offset,\n    InvalidContractOrder_error_selector,\n    InvalidRestrictedOrder_error_length,\n    InvalidRestrictedOrder_error_orderHash_ptr,\n    InvalidRestrictedOrder_error_selector\n} from \"./ConsiderationErrorConstants.sol\";\n\n/**\n * @title ZoneInteraction\n * @author 0age\n * @notice ZoneInteraction contains logic related to interacting with zones.\n */\ncontract ZoneInteraction is\n    ConsiderationEncoder,\n    ZoneInteractionErrors,\n    LowLevelHelpers\n{\n    /**\n     * @dev Internal function to determine if an order has a restricted order\n     *      type and, if so, to ensure that either the zone is the caller or\n     *      that a call to `validateOrder` on the zone returns a magic value\n     *      indicating that the order is currently valid. Note that contract\n     *      orders are not accessible via the basic fulfillment method.\n     *\n     * @param orderHash  The hash of the order.\n     * @param orderType  The order type.\n     * @param parameters The parameters of the basic order.\n     */\n    function _assertRestrictedBasicOrderValidity(\n        bytes32 orderHash,\n        OrderType orderType,\n        BasicOrderParameters calldata parameters\n    ) internal {\n        // Order type 2-3 require zone be caller or zone to approve.\n        // Note that in cases where fulfiller == zone, the restricted order\n        // validation will be skipped.\n        if (_isRestrictedAndCallerNotZone(orderType, parameters.zone)) {\n            // Encode the `validateOrder` call in memory.\n            (MemoryPointer callData, uint256 size) = _encodeValidateBasicOrder(\n                orderHash,\n                parameters\n            );\n\n            // Perform `validateOrder` call and ensure magic value was returned.\n            _callAndCheckStatus(\n                parameters.zone,\n                orderHash,\n                callData,\n                size,\n                InvalidRestrictedOrder_error_selector\n            );\n        }\n    }\n\n    /**\n     * @dev Internal function to determine the post-execution validity of\n     *      restricted and contract orders. Restricted orders where the caller\n     *      is not the zone must successfully call `validateOrder` with the\n     *      correct magic value returned. Contract orders must successfully call\n     *      `ratifyOrder` with the correct magic value returned.\n     *\n     * @param advancedOrder The advanced order in question.\n     * @param orderHashes   The order hashes of each order included as part of\n     *                      the current fulfillment.\n     * @param orderHash     The hash of the order.\n     */\n    function _assertRestrictedAdvancedOrderValidity(\n        AdvancedOrder memory advancedOrder,\n        bytes32[] memory orderHashes,\n        bytes32 orderHash\n    ) internal {\n        // Declare variables that will be assigned based on the order type.\n        address target;\n        uint256 errorSelector;\n        MemoryPointer callData;\n        uint256 size;\n\n        // Retrieve the parameters of the order in question.\n        OrderParameters memory parameters = advancedOrder.parameters;\n\n        // OrderType 2-3 require zone to be caller or approve via validateOrder.\n        if (\n            _isRestrictedAndCallerNotZone(parameters.orderType, parameters.zone)\n        ) {\n            // Encode the `validateOrder` call in memory.\n            (callData, size) = _encodeValidateOrder(\n                orderHash,\n                parameters,\n                advancedOrder.extraData,\n                orderHashes\n            );\n\n            // Set the target to the zone.\n            target = (\n                parameters\n                    .toMemoryPointer()\n                    .offset(OrderParameters_zone_offset)\n                    .readAddress()\n            );\n\n            // Set the restricted-order-specific error selector.\n            errorSelector = InvalidRestrictedOrder_error_selector;\n        } else if (parameters.orderType == OrderType.CONTRACT) {\n            // Set the target to the offerer (note the offerer has no offset).\n            target = parameters.toMemoryPointer().readAddress();\n\n            // Shift the target 96 bits to the left.\n            uint256 shiftedOfferer;\n            assembly {\n                shiftedOfferer := shl(\n                    ContractOrder_orderHash_offerer_shift,\n                    target\n                )\n            }\n\n            // Encode the `ratifyOrder` call in memory.\n            (callData, size) = _encodeRatifyOrder(\n                orderHash,\n                parameters,\n                advancedOrder.extraData,\n                orderHashes,\n                shiftedOfferer\n            );\n\n            // Set the contract-order-specific error selector.\n            errorSelector = InvalidContractOrder_error_selector;\n        } else {\n            return;\n        }\n\n        // Perform call and ensure a corresponding magic value was returned.\n        _callAndCheckStatus(target, orderHash, callData, size, errorSelector);\n    }\n\n    /**\n     * @dev Determines whether the specified order type is restricted and the\n     *      caller is not the specified zone.\n     *\n     * @param orderType     The type of the order to check.\n     * @param zone          The address of the zone to check against.\n     *\n     * @return mustValidate True if the order type is restricted and the caller\n     *                      is not the specified zone, false otherwise.\n     */\n    function _isRestrictedAndCallerNotZone(\n        OrderType orderType,\n        address zone\n    ) internal view returns (bool mustValidate) {\n        assembly {\n            mustValidate := and(\n                // Note that this check requires that there are no order types\n                // beyond the current set (0-4).  It will need to be modified if\n                // more order types are added.\n                and(lt(orderType, 4), gt(orderType, 1)),\n                iszero(eq(caller(), zone))\n            )\n        }\n    }\n\n    /**\n     * @dev Calls the specified target with the given data and checks the status\n     *      of the call. Revert reasons will be \"bubbled up\" if one is returned,\n     *      otherwise reverting calls will throw a generic error based on the\n     *      supplied error handler.\n     *\n     * @param target        The address of the contract to call.\n     * @param orderHash     The hash of the order associated with the call.\n     * @param callData      The data to pass to the contract call.\n     * @param size          The size of calldata.\n     * @param errorSelector The error handling function to call if the call\n     *                      fails or the magic value does not match.\n     */\n    function _callAndCheckStatus(\n        address target,\n        bytes32 orderHash,\n        MemoryPointer callData,\n        uint256 size,\n        uint256 errorSelector\n    ) internal {\n        bool success;\n        bool magicMatch;\n        assembly {\n            // Get magic value from the selector at start of provided calldata.\n            let magic := and(mload(callData), MaskOverFirstFourBytes)\n\n            // Clear the start of scratch space.\n            mstore(0, 0)\n\n            // Perform call, placing result in the first word of scratch space.\n            success := call(gas(), target, 0, callData, size, 0, OneWord)\n\n            // Determine if returned magic value matches the calldata selector.\n            magicMatch := eq(magic, mload(0))\n        }\n\n        // Revert if the call was not successful.\n        if (!success) {\n            // Revert and pass reason along if one was returned.\n            _revertWithReasonIfOneIsReturned();\n\n            // If no reason was returned, revert with supplied error selector.\n            assembly {\n                mstore(0, errorSelector)\n                mstore(InvalidRestrictedOrder_error_orderHash_ptr, orderHash)\n                // revert(abi.encodeWithSelector(\n                //     \"InvalidRestrictedOrder(bytes32)\",\n                //     orderHash\n                // ))\n                revert(\n                    Error_selector_offset,\n                    InvalidRestrictedOrder_error_length\n                )\n            }\n        }\n\n        // Revert if the correct magic value was not returned.\n        if (!magicMatch) {\n            // Revert with a generic error message.\n            assembly {\n                mstore(0, errorSelector)\n                mstore(InvalidRestrictedOrder_error_orderHash_ptr, orderHash)\n\n                // revert(abi.encodeWithSelector(\n                //     \"InvalidRestrictedOrder(bytes32)\",\n                //     orderHash\n                // ))\n                revert(\n                    Error_selector_offset,\n                    InvalidRestrictedOrder_error_length\n                )\n            }\n        }\n    }\n}\n"},"contracts/lib/TokenTransferrer.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport {\n    BadReturnValueFromERC20OnTransfer_error_amount_ptr,\n    BadReturnValueFromERC20OnTransfer_error_from_ptr,\n    BadReturnValueFromERC20OnTransfer_error_length,\n    BadReturnValueFromERC20OnTransfer_error_selector,\n    BadReturnValueFromERC20OnTransfer_error_to_ptr,\n    BadReturnValueFromERC20OnTransfer_error_token_ptr,\n    BatchTransfer1155Params_amounts_head_ptr,\n    BatchTransfer1155Params_calldata_baseSize,\n    BatchTransfer1155Params_data_head_ptr,\n    BatchTransfer1155Params_data_length_basePtr,\n    BatchTransfer1155Params_ids_head_ptr,\n    BatchTransfer1155Params_ids_length_offset,\n    BatchTransfer1155Params_ids_length_ptr,\n    BatchTransfer1155Params_ptr,\n    ConduitBatch1155Transfer_amounts_length_baseOffset,\n    ConduitBatch1155Transfer_from_offset,\n    ConduitBatch1155Transfer_ids_head_offset,\n    ConduitBatch1155Transfer_ids_length_offset,\n    ConduitBatch1155Transfer_usable_head_size,\n    ConduitBatchTransfer_amounts_head_offset,\n    CostPerWord,\n    DefaultFreeMemoryPointer,\n    ERC1155_safeBatchTransferFrom_signature,\n    ERC1155_safeTransferFrom_amount_ptr,\n    ERC1155_safeTransferFrom_data_length_offset,\n    ERC1155_safeTransferFrom_data_length_ptr,\n    ERC1155_safeTransferFrom_data_offset_ptr,\n    ERC1155_safeTransferFrom_from_ptr,\n    ERC1155_safeTransferFrom_id_ptr,\n    ERC1155_safeTransferFrom_length,\n    ERC1155_safeTransferFrom_sig_ptr,\n    ERC1155_safeTransferFrom_signature,\n    ERC1155_safeTransferFrom_to_ptr,\n    ERC1155BatchTransferGenericFailure_error_signature,\n    ERC1155BatchTransferGenericFailure_ids_offset,\n    ERC1155BatchTransferGenericFailure_token_ptr,\n    ERC20_transferFrom_amount_ptr,\n    ERC20_transferFrom_from_ptr,\n    ERC20_transferFrom_length,\n    ERC20_transferFrom_sig_ptr,\n    ERC20_transferFrom_signature,\n    ERC20_transferFrom_to_ptr,\n    ERC721_transferFrom_from_ptr,\n    ERC721_transferFrom_id_ptr,\n    ERC721_transferFrom_length,\n    ERC721_transferFrom_sig_ptr,\n    ERC721_transferFrom_signature,\n    ERC721_transferFrom_to_ptr,\n    ExtraGasBuffer,\n    FreeMemoryPointerSlot,\n    Generic_error_selector_offset,\n    Invalid1155BatchTransferEncoding_length,\n    Invalid1155BatchTransferEncoding_ptr,\n    Invalid1155BatchTransferEncoding_selector,\n    MemoryExpansionCoefficientShift,\n    NoContract_error_account_ptr,\n    NoContract_error_length,\n    NoContract_error_selector,\n    OneWord,\n    OneWordShift,\n    Slot0x80,\n    Slot0xA0,\n    Slot0xC0,\n    ThirtyOneBytes,\n    TokenTransferGenericFailure_err_identifier_ptr,\n    TokenTransferGenericFailure_error_amount_ptr,\n    TokenTransferGenericFailure_error_from_ptr,\n    TokenTransferGenericFailure_error_identifier_ptr,\n    TokenTransferGenericFailure_error_length,\n    TokenTransferGenericFailure_error_selector,\n    TokenTransferGenericFailure_error_to_ptr,\n    TokenTransferGenericFailure_error_token_ptr,\n    TwoWords,\n    TwoWordsShift,\n    ZeroSlot\n} from \"./TokenTransferrerConstants.sol\";\n\nimport {\n    TokenTransferrerErrors\n} from \"../interfaces/TokenTransferrerErrors.sol\";\n\nimport { ConduitBatch1155Transfer } from \"../conduit/lib/ConduitStructs.sol\";\n\n/**\n * @title TokenTransferrer\n * @author 0age\n * @custom:coauthor d1ll0n\n * @custom:coauthor transmissions11\n * @notice TokenTransferrer is a library for performing optimized ERC20, ERC721,\n *         ERC1155, and batch ERC1155 transfers, used by both Seaport as well as\n *         by conduits deployed by the ConduitController. Use great caution when\n *         considering these functions for use in other codebases, as there are\n *         significant side effects and edge cases that need to be thoroughly\n *         understood and carefully addressed.\n */\ncontract TokenTransferrer is TokenTransferrerErrors {\n    /**\n     * @dev Internal function to transfer ERC20 tokens from a given originator\n     *      to a given recipient. Sufficient approvals must be set on the\n     *      contract performing the transfer.\n     *\n     * @param token      The ERC20 token to transfer.\n     * @param from       The originator of the transfer.\n     * @param to         The recipient of the transfer.\n     * @param amount     The amount to transfer.\n     */\n    function _performERC20Transfer(\n        address token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        // Utilize assembly to perform an optimized ERC20 token transfer.\n        assembly {\n            // The free memory pointer memory slot will be used when populating\n            // call data for the transfer; read the value and restore it later.\n            let memPointer := mload(FreeMemoryPointerSlot)\n\n            // Write call data into memory, starting with function selector.\n            mstore(ERC20_transferFrom_sig_ptr, ERC20_transferFrom_signature)\n            mstore(ERC20_transferFrom_from_ptr, from)\n            mstore(ERC20_transferFrom_to_ptr, to)\n            mstore(ERC20_transferFrom_amount_ptr, amount)\n\n            // Make call & copy up to 32 bytes of return data to scratch space.\n            // Scratch space does not need to be cleared ahead of time, as the\n            // subsequent check will ensure that either at least a full word of\n            // return data is received (in which case it will be overwritten) or\n            // that no data is received (in which case scratch space will be\n            // ignored) on a successful call to the given token.\n            let callStatus := call(\n                gas(),\n                token,\n                0,\n                ERC20_transferFrom_sig_ptr,\n                ERC20_transferFrom_length,\n                0,\n                OneWord\n            )\n\n            // Determine whether transfer was successful using status & result.\n            let success := and(\n                // Set success to whether the call reverted, if not check it\n                // either returned exactly 1 (can't just be non-zero data), or\n                // had no return data.\n                or(\n                    and(eq(mload(0), 1), gt(returndatasize(), 31)),\n                    iszero(returndatasize())\n                ),\n                callStatus\n            )\n\n            // Handle cases where either the transfer failed or no data was\n            // returned. Group these, as most transfers will succeed with data.\n            // Equivalent to `or(iszero(success), iszero(returndatasize()))`\n            // but after it's inverted for JUMPI this expression is cheaper.\n            if iszero(and(success, iszero(iszero(returndatasize())))) {\n                // If the token has no code or the transfer failed: Equivalent\n                // to `or(iszero(success), iszero(extcodesize(token)))` but\n                // after it's inverted for JUMPI this expression is cheaper.\n                if iszero(and(iszero(iszero(extcodesize(token))), success)) {\n                    // If the transfer failed:\n                    if iszero(success) {\n                        // If it was due to a revert:\n                        if iszero(callStatus) {\n                            // If it returned a message, bubble it up as long as\n                            // sufficient gas remains to do so:\n                            if returndatasize() {\n                                // Ensure that sufficient gas is available to\n                                // copy returndata while expanding memory where\n                                // necessary. Start by computing the word size\n                                // of returndata and allocated memory. Round up\n                                // to the nearest full word.\n                                let returnDataWords := shr(\n                                    OneWordShift,\n                                    add(returndatasize(), ThirtyOneBytes)\n                                )\n\n                                // Note: use the free memory pointer in place of\n                                // msize() to work around a Yul warning that\n                                // prevents accessing msize directly when the IR\n                                // pipeline is activated.\n                                let msizeWords := shr(OneWordShift, memPointer)\n\n                                // Next, compute the cost of the returndatacopy.\n                                let cost := mul(CostPerWord, returnDataWords)\n\n                                // Then, compute cost of new memory allocation.\n                                if gt(returnDataWords, msizeWords) {\n                                    cost := add(\n                                        cost,\n                                        add(\n                                            mul(\n                                                sub(\n                                                    returnDataWords,\n                                                    msizeWords\n                                                ),\n                                                CostPerWord\n                                            ),\n                                            shr(\n                                                MemoryExpansionCoefficientShift,\n                                                sub(\n                                                    mul(\n                                                        returnDataWords,\n                                                        returnDataWords\n                                                    ),\n                                                    mul(msizeWords, msizeWords)\n                                                )\n                                            )\n                                        )\n                                    )\n                                }\n\n                                // Finally, add a small constant and compare to\n                                // gas remaining; bubble up the revert data if\n                                // enough gas is still available.\n                                if lt(add(cost, ExtraGasBuffer), gas()) {\n                                    // Copy returndata to memory; overwrite\n                                    // existing memory.\n                                    returndatacopy(0, 0, returndatasize())\n\n                                    // Revert, specifying memory region with\n                                    // copied returndata.\n                                    revert(0, returndatasize())\n                                }\n                            }\n\n                            // Store left-padded selector with push4, mem[28:32]\n                            mstore(\n                                0,\n                                TokenTransferGenericFailure_error_selector\n                            )\n                            mstore(\n                                TokenTransferGenericFailure_error_token_ptr,\n                                token\n                            )\n                            mstore(\n                                TokenTransferGenericFailure_error_from_ptr,\n                                from\n                            )\n                            mstore(TokenTransferGenericFailure_error_to_ptr, to)\n                            mstore(\n                                TokenTransferGenericFailure_err_identifier_ptr,\n                                0\n                            )\n                            mstore(\n                                TokenTransferGenericFailure_error_amount_ptr,\n                                amount\n                            )\n\n                            // revert(abi.encodeWithSignature(\n                            //     \"TokenTransferGenericFailure(\n                            //         address,address,address,uint256,uint256\n                            //     )\", token, from, to, identifier, amount\n                            // ))\n                            revert(\n                                Generic_error_selector_offset,\n                                TokenTransferGenericFailure_error_length\n                            )\n                        }\n\n                        // Otherwise revert with a message about the token\n                        // returning false or non-compliant return values.\n\n                        // Store left-padded selector with push4, mem[28:32]\n                        mstore(\n                            0,\n                            BadReturnValueFromERC20OnTransfer_error_selector\n                        )\n                        mstore(\n                            BadReturnValueFromERC20OnTransfer_error_token_ptr,\n                            token\n                        )\n                        mstore(\n                            BadReturnValueFromERC20OnTransfer_error_from_ptr,\n                            from\n                        )\n                        mstore(\n                            BadReturnValueFromERC20OnTransfer_error_to_ptr,\n                            to\n                        )\n                        mstore(\n                            BadReturnValueFromERC20OnTransfer_error_amount_ptr,\n                            amount\n                        )\n\n                        // revert(abi.encodeWithSignature(\n                        //     \"BadReturnValueFromERC20OnTransfer(\n                        //         address,address,address,uint256\n                        //     )\", token, from, to, amount\n                        // ))\n                        revert(\n                            Generic_error_selector_offset,\n                            BadReturnValueFromERC20OnTransfer_error_length\n                        )\n                    }\n\n                    // Otherwise, revert with error about token not having code:\n                    // Store left-padded selector with push4, mem[28:32]\n                    mstore(0, NoContract_error_selector)\n                    mstore(NoContract_error_account_ptr, token)\n\n                    // revert(abi.encodeWithSignature(\n                    //      \"NoContract(address)\", account\n                    // ))\n                    revert(\n                        Generic_error_selector_offset,\n                        NoContract_error_length\n                    )\n                }\n\n                // Otherwise, the token just returned no data despite the call\n                // having succeeded; no need to optimize for this as it's not\n                // technically ERC20 compliant.\n            }\n\n            // Restore the original free memory pointer.\n            mstore(FreeMemoryPointerSlot, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZeroSlot, 0)\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer an ERC721 token from a given\n     *      originator to a given recipient. Sufficient approvals must be set on\n     *      the contract performing the transfer. Note that this function does\n     *      not check whether the receiver can accept the ERC721 token (i.e. it\n     *      does not use `safeTransferFrom`).\n     *\n     * @param token      The ERC721 token to transfer.\n     * @param from       The originator of the transfer.\n     * @param to         The recipient of the transfer.\n     * @param identifier The tokenId to transfer.\n     */\n    function _performERC721Transfer(\n        address token,\n        address from,\n        address to,\n        uint256 identifier\n    ) internal {\n        // Utilize assembly to perform an optimized ERC721 token transfer.\n        assembly {\n            // If the token has no code, revert.\n            if iszero(extcodesize(token)) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, NoContract_error_selector)\n                mstore(NoContract_error_account_ptr, token)\n\n                // revert(abi.encodeWithSignature(\n                //     \"NoContract(address)\", account\n                // ))\n                revert(Generic_error_selector_offset, NoContract_error_length)\n            }\n\n            // The free memory pointer memory slot will be used when populating\n            // call data for the transfer; read the value and restore it later.\n            let memPointer := mload(FreeMemoryPointerSlot)\n\n            // Write call data to memory starting with function selector.\n            mstore(ERC721_transferFrom_sig_ptr, ERC721_transferFrom_signature)\n            mstore(ERC721_transferFrom_from_ptr, from)\n            mstore(ERC721_transferFrom_to_ptr, to)\n            mstore(ERC721_transferFrom_id_ptr, identifier)\n\n            // Perform the call, ignoring return data.\n            let success := call(\n                gas(),\n                token,\n                0,\n                ERC721_transferFrom_sig_ptr,\n                ERC721_transferFrom_length,\n                0,\n                0\n            )\n\n            // If the transfer reverted:\n            if iszero(success) {\n                // If it returned a message, bubble it up as long as sufficient\n                // gas remains to do so:\n                if returndatasize() {\n                    // Ensure that sufficient gas is available to copy\n                    // returndata while expanding memory where necessary. Start\n                    // by computing word size of returndata & allocated memory.\n                    // Round up to the nearest full word.\n                    let returnDataWords := shr(\n                        OneWordShift,\n                        add(returndatasize(), ThirtyOneBytes)\n                    )\n\n                    // Note: use the free memory pointer in place of msize() to\n                    // work around a Yul warning that prevents accessing msize\n                    // directly when the IR pipeline is activated.\n                    let msizeWords := shr(OneWordShift, memPointer)\n\n                    // Next, compute the cost of the returndatacopy.\n                    let cost := mul(CostPerWord, returnDataWords)\n\n                    // Then, compute cost of new memory allocation.\n                    if gt(returnDataWords, msizeWords) {\n                        cost := add(\n                            cost,\n                            add(\n                                mul(\n                                    sub(returnDataWords, msizeWords),\n                                    CostPerWord\n                                ),\n                                shr(\n                                    MemoryExpansionCoefficientShift,\n                                    sub(\n                                        mul(returnDataWords, returnDataWords),\n                                        mul(msizeWords, msizeWords)\n                                    )\n                                )\n                            )\n                        )\n                    }\n\n                    // Finally, add a small constant and compare to gas\n                    // remaining; bubble up the revert data if enough gas is\n                    // still available.\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\n                        // Copy returndata to memory; overwrite existing memory.\n                        returndatacopy(0, 0, returndatasize())\n\n                        // Revert, giving memory region with copied returndata.\n                        revert(0, returndatasize())\n                    }\n                }\n\n                // Otherwise revert with a generic error message.\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, TokenTransferGenericFailure_error_selector)\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\n                mstore(\n                    TokenTransferGenericFailure_error_identifier_ptr,\n                    identifier\n                )\n                mstore(TokenTransferGenericFailure_error_amount_ptr, 1)\n\n                // revert(abi.encodeWithSignature(\n                //     \"TokenTransferGenericFailure(\n                //         address,address,address,uint256,uint256\n                //     )\", token, from, to, identifier, amount\n                // ))\n                revert(\n                    Generic_error_selector_offset,\n                    TokenTransferGenericFailure_error_length\n                )\n            }\n\n            // Restore the original free memory pointer.\n            mstore(FreeMemoryPointerSlot, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZeroSlot, 0)\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer ERC1155 tokens from a given\n     *      originator to a given recipient. Sufficient approvals must be set on\n     *      the contract performing the transfer and contract recipients must\n     *      implement the ERC1155TokenReceiver interface to indicate that they\n     *      are willing to accept the transfer.\n     *\n     * @param token      The ERC1155 token to transfer.\n     * @param from       The originator of the transfer.\n     * @param to         The recipient of the transfer.\n     * @param identifier The id to transfer.\n     * @param amount     The amount to transfer.\n     */\n    function _performERC1155Transfer(\n        address token,\n        address from,\n        address to,\n        uint256 identifier,\n        uint256 amount\n    ) internal {\n        // Utilize assembly to perform an optimized ERC1155 token transfer.\n        assembly {\n            // If the token has no code, revert.\n            if iszero(extcodesize(token)) {\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, NoContract_error_selector)\n                mstore(NoContract_error_account_ptr, token)\n\n                // revert(abi.encodeWithSignature(\n                //     \"NoContract(address)\", account\n                // ))\n                revert(Generic_error_selector_offset, NoContract_error_length)\n            }\n\n            // The following memory slots will be used when populating call data\n            // for the transfer; read the values and restore them later.\n            let memPointer := mload(FreeMemoryPointerSlot)\n            let slot0x80 := mload(Slot0x80)\n            let slot0xA0 := mload(Slot0xA0)\n            let slot0xC0 := mload(Slot0xC0)\n\n            // Write call data into memory, beginning with function selector.\n            mstore(\n                ERC1155_safeTransferFrom_sig_ptr,\n                ERC1155_safeTransferFrom_signature\n            )\n            mstore(ERC1155_safeTransferFrom_from_ptr, from)\n            mstore(ERC1155_safeTransferFrom_to_ptr, to)\n            mstore(ERC1155_safeTransferFrom_id_ptr, identifier)\n            mstore(ERC1155_safeTransferFrom_amount_ptr, amount)\n            mstore(\n                ERC1155_safeTransferFrom_data_offset_ptr,\n                ERC1155_safeTransferFrom_data_length_offset\n            )\n            mstore(ERC1155_safeTransferFrom_data_length_ptr, 0)\n\n            // Perform the call, ignoring return data.\n            let success := call(\n                gas(),\n                token,\n                0,\n                ERC1155_safeTransferFrom_sig_ptr,\n                ERC1155_safeTransferFrom_length,\n                0,\n                0\n            )\n\n            // If the transfer reverted:\n            if iszero(success) {\n                // If it returned a message, bubble it up as long as sufficient\n                // gas remains to do so:\n                if returndatasize() {\n                    // Ensure that sufficient gas is available to copy\n                    // returndata while expanding memory where necessary. Start\n                    // by computing word size of returndata & allocated memory.\n                    // Round up to the nearest full word.\n                    let returnDataWords := shr(\n                        OneWordShift,\n                        add(returndatasize(), ThirtyOneBytes)\n                    )\n\n                    // Note: use the free memory pointer in place of msize() to\n                    // work around a Yul warning that prevents accessing msize\n                    // directly when the IR pipeline is activated.\n                    let msizeWords := shr(OneWordShift, memPointer)\n\n                    // Next, compute the cost of the returndatacopy.\n                    let cost := mul(CostPerWord, returnDataWords)\n\n                    // Then, compute cost of new memory allocation.\n                    if gt(returnDataWords, msizeWords) {\n                        cost := add(\n                            cost,\n                            add(\n                                mul(\n                                    sub(returnDataWords, msizeWords),\n                                    CostPerWord\n                                ),\n                                shr(\n                                    MemoryExpansionCoefficientShift,\n                                    sub(\n                                        mul(returnDataWords, returnDataWords),\n                                        mul(msizeWords, msizeWords)\n                                    )\n                                )\n                            )\n                        )\n                    }\n\n                    // Finally, add a small constant and compare to gas\n                    // remaining; bubble up the revert data if enough gas is\n                    // still available.\n                    if lt(add(cost, ExtraGasBuffer), gas()) {\n                        // Copy returndata to memory; overwrite existing memory.\n                        returndatacopy(0, 0, returndatasize())\n\n                        // Revert, giving memory region with copied returndata.\n                        revert(0, returndatasize())\n                    }\n                }\n\n                // Otherwise revert with a generic error message.\n\n                // Store left-padded selector with push4, mem[28:32] = selector\n                mstore(0, TokenTransferGenericFailure_error_selector)\n                mstore(TokenTransferGenericFailure_error_token_ptr, token)\n                mstore(TokenTransferGenericFailure_error_from_ptr, from)\n                mstore(TokenTransferGenericFailure_error_to_ptr, to)\n                mstore(\n                    TokenTransferGenericFailure_error_identifier_ptr,\n                    identifier\n                )\n                mstore(TokenTransferGenericFailure_error_amount_ptr, amount)\n\n                // revert(abi.encodeWithSignature(\n                //     \"TokenTransferGenericFailure(\n                //         address,address,address,uint256,uint256\n                //     )\", token, from, to, identifier, amount\n                // ))\n                revert(\n                    Generic_error_selector_offset,\n                    TokenTransferGenericFailure_error_length\n                )\n            }\n\n            mstore(Slot0x80, slot0x80) // Restore slot 0x80.\n            mstore(Slot0xA0, slot0xA0) // Restore slot 0xA0.\n            mstore(Slot0xC0, slot0xC0) // Restore slot 0xC0.\n\n            // Restore the original free memory pointer.\n            mstore(FreeMemoryPointerSlot, memPointer)\n\n            // Restore the zero slot to zero.\n            mstore(ZeroSlot, 0)\n        }\n    }\n\n    /**\n     * @dev Internal function to transfer ERC1155 tokens from a given\n     *      originator to a given recipient. Sufficient approvals must be set on\n     *      the contract performing the transfer and contract recipients must\n     *      implement the ERC1155TokenReceiver interface to indicate that they\n     *      are willing to accept the transfer. NOTE: this function is not\n     *      memory-safe; it will overwrite existing memory, restore the free\n     *      memory pointer to the default value, and overwrite the zero slot.\n     *      This function should only be called once memory is no longer\n     *      required and when uninitialized arrays are not utilized, and memory\n     *      should be considered fully corrupted (aside from the existence of a\n     *      default-value free memory pointer) after calling this function.\n     *\n     * @param batchTransfers The group of 1155 batch transfers to perform.\n     */\n    function _performERC1155BatchTransfers(\n        ConduitBatch1155Transfer[] calldata batchTransfers\n    ) internal {\n        // Utilize assembly to perform optimized batch 1155 transfers.\n        assembly {\n            let len := batchTransfers.length\n            // Pointer to first head in the array, which is offset to the struct\n            // at each index. This gets incremented after each loop to avoid\n            // multiplying by 32 to get the offset for each element.\n            let nextElementHeadPtr := batchTransfers.offset\n\n            // Pointer to beginning of the head of the array. This is the\n            // reference position each offset references. It's held static to\n            // let each loop calculate the data position for an element.\n            let arrayHeadPtr := nextElementHeadPtr\n\n            // Write the function selector, which will be reused for each call:\n            // safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\n            mstore(\n                ConduitBatch1155Transfer_from_offset,\n                ERC1155_safeBatchTransferFrom_signature\n            )\n\n            // Iterate over each batch transfer.\n            for {\n                let i := 0\n            } lt(i, len) {\n                i := add(i, 1)\n            } {\n                // Read the offset to the beginning of the element and add\n                // it to pointer to the beginning of the array head to get\n                // the absolute position of the element in calldata.\n                let elementPtr := add(\n                    arrayHeadPtr,\n                    calldataload(nextElementHeadPtr)\n                )\n\n                // Retrieve the token from calldata.\n                let token := calldataload(elementPtr)\n\n                // If the token has no code, revert.\n                if iszero(extcodesize(token)) {\n                    // Store left-padded selector with push4, mem[28:32]\n                    mstore(0, NoContract_error_selector)\n                    mstore(NoContract_error_account_ptr, token)\n\n                    // revert(abi.encodeWithSignature(\n                    //     \"NoContract(address)\", account\n                    // ))\n                    revert(\n                        Generic_error_selector_offset,\n                        NoContract_error_length\n                    )\n                }\n\n                // Get the total number of supplied ids.\n                let idsLength := calldataload(\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset)\n                )\n\n                // Determine the expected offset for the amounts array.\n                let expectedAmountsOffset := add(\n                    ConduitBatch1155Transfer_amounts_length_baseOffset,\n                    shl(OneWordShift, idsLength)\n                )\n\n                // Validate struct encoding.\n                let invalidEncoding := iszero(\n                    and(\n                        // ids.length == amounts.length\n                        eq(\n                            idsLength,\n                            calldataload(add(elementPtr, expectedAmountsOffset))\n                        ),\n                        and(\n                            // ids_offset == 0xa0\n                            eq(\n                                calldataload(\n                                    add(\n                                        elementPtr,\n                                        ConduitBatch1155Transfer_ids_head_offset\n                                    )\n                                ),\n                                ConduitBatch1155Transfer_ids_length_offset\n                            ),\n                            // amounts_offset == 0xc0 + ids.length*32\n                            eq(\n                                calldataload(\n                                    add(\n                                        elementPtr,\n                                        ConduitBatchTransfer_amounts_head_offset\n                                    )\n                                ),\n                                expectedAmountsOffset\n                            )\n                        )\n                    )\n                )\n\n                // Revert with an error if the encoding is not valid.\n                if invalidEncoding {\n                    // Store left-padded selector with push4, mem[28:32]\n                    mstore(\n                        Invalid1155BatchTransferEncoding_ptr,\n                        Invalid1155BatchTransferEncoding_selector\n                    )\n\n                    // revert(abi.encodeWithSignature(\n                    //     \"Invalid1155BatchTransferEncoding()\"\n                    // ))\n                    revert(\n                        Invalid1155BatchTransferEncoding_ptr,\n                        Invalid1155BatchTransferEncoding_length\n                    )\n                }\n\n                // Update the offset position for the next loop\n                nextElementHeadPtr := add(nextElementHeadPtr, OneWord)\n\n                // Copy the first section of calldata (before dynamic values).\n                calldatacopy(\n                    BatchTransfer1155Params_ptr,\n                    add(elementPtr, ConduitBatch1155Transfer_from_offset),\n                    ConduitBatch1155Transfer_usable_head_size\n                )\n\n                // Determine size of calldata required for ids and amounts. Note\n                // that the size includes both lengths as well as the data.\n                let idsAndAmountsSize := add(\n                    TwoWords,\n                    shl(TwoWordsShift, idsLength)\n                )\n\n                // Update the offset for the data array in memory.\n                mstore(\n                    BatchTransfer1155Params_data_head_ptr,\n                    add(\n                        BatchTransfer1155Params_ids_length_offset,\n                        idsAndAmountsSize\n                    )\n                )\n\n                // Set the length of the data array in memory to zero.\n                mstore(\n                    add(\n                        BatchTransfer1155Params_data_length_basePtr,\n                        idsAndAmountsSize\n                    ),\n                    0\n                )\n\n                // Determine the total calldata size for the call to transfer.\n                let transferDataSize := add(\n                    BatchTransfer1155Params_calldata_baseSize,\n                    idsAndAmountsSize\n                )\n\n                // Copy second section of calldata (including dynamic values).\n                calldatacopy(\n                    BatchTransfer1155Params_ids_length_ptr,\n                    add(elementPtr, ConduitBatch1155Transfer_ids_length_offset),\n                    idsAndAmountsSize\n                )\n\n                // Perform the call to transfer 1155 tokens.\n                let success := call(\n                    gas(),\n                    token,\n                    0,\n                    ConduitBatch1155Transfer_from_offset, // Data portion start.\n                    transferDataSize, // Location of the length of callData.\n                    0,\n                    0\n                )\n\n                // If the transfer reverted:\n                if iszero(success) {\n                    // If it returned a message, bubble it up as long as\n                    // sufficient gas remains to do so:\n                    if returndatasize() {\n                        // Ensure that sufficient gas is available to copy\n                        // returndata while expanding memory where necessary.\n                        // Start by computing word size of returndata and\n                        // allocated memory. Round up to the nearest full word.\n                        let returnDataWords := shr(\n                            OneWordShift,\n                            add(returndatasize(), ThirtyOneBytes)\n                        )\n\n                        // Note: use transferDataSize in place of msize() to\n                        // work around a Yul warning that prevents accessing\n                        // msize directly when the IR pipeline is activated.\n                        // The free memory pointer is not used here because\n                        // this function does almost all memory management\n                        // manually and does not update it, and transferDataSize\n                        // should be the largest memory value used (unless a\n                        // previous batch was larger).\n                        let msizeWords := shr(OneWordShift, transferDataSize)\n\n                        // Next, compute the cost of the returndatacopy.\n                        let cost := mul(CostPerWord, returnDataWords)\n\n                        // Then, compute cost of new memory allocation.\n                        if gt(returnDataWords, msizeWords) {\n                            cost := add(\n                                cost,\n                                add(\n                                    mul(\n                                        sub(returnDataWords, msizeWords),\n                                        CostPerWord\n                                    ),\n                                    shr(\n                                        MemoryExpansionCoefficientShift,\n                                        sub(\n                                            mul(\n                                                returnDataWords,\n                                                returnDataWords\n                                            ),\n                                            mul(msizeWords, msizeWords)\n                                        )\n                                    )\n                                )\n                            )\n                        }\n\n                        // Finally, add a small constant and compare to gas\n                        // remaining; bubble up the revert data if enough gas is\n                        // still available.\n                        if lt(add(cost, ExtraGasBuffer), gas()) {\n                            // Copy returndata to memory; overwrite existing.\n                            returndatacopy(0, 0, returndatasize())\n\n                            // Revert with memory region containing returndata.\n                            revert(0, returndatasize())\n                        }\n                    }\n\n                    // Set the error signature.\n                    mstore(\n                        0,\n                        ERC1155BatchTransferGenericFailure_error_signature\n                    )\n\n                    // Write the token.\n                    mstore(ERC1155BatchTransferGenericFailure_token_ptr, token)\n\n                    // Increase the offset to ids by 32.\n                    mstore(\n                        BatchTransfer1155Params_ids_head_ptr,\n                        ERC1155BatchTransferGenericFailure_ids_offset\n                    )\n\n                    // Increase the offset to amounts by 32.\n                    mstore(\n                        BatchTransfer1155Params_amounts_head_ptr,\n                        add(\n                            OneWord,\n                            mload(BatchTransfer1155Params_amounts_head_ptr)\n                        )\n                    )\n\n                    // Return modified region. The total size stays the same as\n                    // `token` uses the same number of bytes as `data.length`.\n                    revert(0, transferDataSize)\n                }\n            }\n\n            // Reset the free memory pointer to the default value; memory must\n            // be assumed to be dirtied and not reused from this point forward.\n            // Also note that the zero slot is not reset to zero, meaning empty\n            // arrays cannot be safely created or utilized until it is restored.\n            mstore(FreeMemoryPointerSlot, DefaultFreeMemoryPointer)\n        }\n    }\n}\n"},"contracts/interfaces/AmountDerivationErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n/**\n * @title AmountDerivationErrors\n * @author 0age\n * @notice AmountDerivationErrors contains errors related to amount derivation.\n */\ninterface AmountDerivationErrors {\n    /**\n     * @dev Revert with an error when attempting to apply a fraction as part of\n     *      a partial fill that does not divide the target amount cleanly.\n     */\n    error InexactFraction();\n}\n"},"contracts/lib/OrderCombiner.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { Side, ItemType, OrderType } from \"./ConsiderationEnums.sol\";\n\nimport {\n    AdvancedOrder,\n    ConsiderationItem,\n    CriteriaResolver,\n    Execution,\n    Fulfillment,\n    FulfillmentComponent,\n    OfferItem,\n    OrderParameters,\n    ReceivedItem\n} from \"./ConsiderationStructs.sol\";\n\nimport { OrderFulfiller } from \"./OrderFulfiller.sol\";\n\nimport { FulfillmentApplier } from \"./FulfillmentApplier.sol\";\n\nimport {\n    _revertConsiderationNotMet,\n    _revertInsufficientNativeTokensSupplied,\n    _revertInvalidNativeOfferItem,\n    _revertNoSpecifiedOrdersAvailable\n} from \"./ConsiderationErrors.sol\";\n\nimport {\n    AccumulatorDisarmed,\n    ConsiderationItem_recipient_offset,\n    Execution_offerer_offset,\n    NonMatchSelector_InvalidErrorValue,\n    NonMatchSelector_MagicMask,\n    OneWord,\n    OneWordShift,\n    OrdersMatchedTopic0,\n    ReceivedItem_amount_offset,\n    ReceivedItem_recipient_offset,\n    TwoWords\n} from \"./ConsiderationConstants.sol\";\n\n/**\n * @title OrderCombiner\n * @author 0age\n * @notice OrderCombiner contains logic for fulfilling combinations of orders,\n *         either by matching offer items to consideration items or by\n *         fulfilling orders where available.\n */\ncontract OrderCombiner is OrderFulfiller, FulfillmentApplier {\n    /**\n     * @dev Derive and set hashes, reference chainId, and associated domain\n     *      separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) OrderFulfiller(conduitController) {}\n\n    /**\n     * @notice Internal function to attempt to fill a group of orders, fully or\n     *         partially, with an arbitrary number of items for offer and\n     *         consideration per order alongside criteria resolvers containing\n     *         specific token identifiers and associated proofs. Any order that\n     *         is not currently active, has already been fully filled, or has\n     *         been cancelled will be omitted. Remaining offer and consideration\n     *         items will then be aggregated where possible as indicated by the\n     *         supplied offer and consideration component arrays and aggregated\n     *         items will be transferred to the fulfiller or to each intended\n     *         recipient, respectively. Note that a failing item transfer or an\n     *         issue with order formatting will cause the entire batch to fail.\n     *\n     * @param advancedOrders            The orders to fulfill along with the\n     *                                  fraction of those orders to attempt to\n     *                                  fill. Note that both the offerer and the\n     *                                  fulfiller must first approve this\n     *                                  contract (or a conduit if indicated by\n     *                                  the order) to transfer any relevant\n     *                                  tokens on their behalf and that\n     *                                  contracts must implement\n     *                                  `onERC1155Received` in order to receive\n     *                                  ERC1155 tokens as consideration. Also\n     *                                  note that all offer and consideration\n     *                                  components must have no remainder after\n     *                                  multiplication of the respective amount\n     *                                  with the supplied fraction for an\n     *                                  order's partial fill amount to be\n     *                                  considered valid.\n     * @param criteriaResolvers         An array where each element contains a\n     *                                  reference to a specific offer or\n     *                                  consideration, a token identifier, and a\n     *                                  proof that the supplied token identifier\n     *                                  is contained in the merkle root held by\n     *                                  the item in question's criteria element.\n     *                                  Note that an empty criteria indicates\n     *                                  that any (transferable) token\n     *                                  identifier on the token in question is\n     *                                  valid and that no associated proof needs\n     *                                  to be supplied.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used (and\n     *                                  direct approvals set on Consideration).\n     * @param recipient                 The intended recipient for all received\n     *                                  items.\n     * @param maximumFulfilled          The maximum number of orders to fulfill.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function _fulfillAvailableAdvancedOrders(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] memory criteriaResolvers,\n        FulfillmentComponent[][] memory offerFulfillments,\n        FulfillmentComponent[][] memory considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        address recipient,\n        uint256 maximumFulfilled\n    )\n        internal\n        returns (\n            bool[] memory /* availableOrders */,\n            Execution[] memory /* executions */\n        )\n    {\n        // Validate orders, apply amounts, & determine if they use conduits.\n        (\n            bytes32[] memory orderHashes,\n            bool containsNonOpen\n        ) = _validateOrdersAndPrepareToFulfill(\n                advancedOrders,\n                criteriaResolvers,\n                false, // Signifies that invalid orders should NOT revert.\n                maximumFulfilled,\n                recipient\n            );\n\n        // Aggregate used offer and consideration items and execute transfers.\n        return\n            _executeAvailableFulfillments(\n                advancedOrders,\n                offerFulfillments,\n                considerationFulfillments,\n                fulfillerConduitKey,\n                recipient,\n                orderHashes,\n                containsNonOpen\n            );\n    }\n\n    /**\n     * @dev Internal function to validate a group of orders, update their\n     *      statuses, reduce amounts by their previously filled fractions, apply\n     *      criteria resolvers, and emit OrderFulfilled events. Note that this\n     *      function needs to be called before\n     *      _aggregateValidFulfillmentConsiderationItems to set the memory\n     *      layout that _aggregateValidFulfillmentConsiderationItems depends on.\n     *\n     * @param advancedOrders    The advanced orders to validate and reduce by\n     *                          their previously filled amounts.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific order as well as that order's\n     *                          offer or consideration, a token identifier, and\n     *                          a proof that the supplied token identifier is\n     *                          contained in the order's merkle root. Note that\n     *                          a root of zero indicates that any transferable\n     *                          token identifier is valid and that no proof\n     *                          needs to be supplied.\n     * @param revertOnInvalid   A boolean indicating whether to revert on any\n     *                          order being invalid; setting this to false will\n     *                          instead cause the invalid order to be skipped.\n     * @param maximumFulfilled  The maximum number of orders to fulfill.\n     * @param recipient         The intended recipient for all items that do not\n     *                          already have a designated recipient and are not\n     *                          already used as part of a provided fulfillment.\n     *\n     * @return orderHashes     The hashes of the orders being fulfilled.\n     * @return containsNonOpen A boolean indicating whether any restricted or\n     *                         contract orders are present within the provided\n     *                         array of advanced orders.\n     */\n    function _validateOrdersAndPrepareToFulfill(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] memory criteriaResolvers,\n        bool revertOnInvalid,\n        uint256 maximumFulfilled,\n        address recipient\n    ) internal returns (bytes32[] memory orderHashes, bool containsNonOpen) {\n        // Ensure this function cannot be triggered during a reentrant call.\n        _setReentrancyGuard(true); // Native tokens accepted during execution.\n\n        // Declare an error buffer indicating status of any native offer items.\n        // Native tokens may only be provided as part of contract orders or when\n        // fulfilling via matchOrders or matchAdvancedOrders; if bits indicating\n        // these conditions are not met have been set, throw.\n        uint256 invalidNativeOfferItemErrorBuffer;\n\n        // Use assembly to set the value for the second bit of the error buffer.\n        assembly {\n            /**\n             * Use the 231st bit of the error buffer to indicate whether the\n             * current function is not matchAdvancedOrders or matchOrders.\n             *\n             * sig                                func\n             * -----------------------------------------------------------------\n             * 1010100000010111010001000 0 000100 matchOrders\n             * 1111001011010001001010110 0 010010 matchAdvancedOrders\n             * 1110110110011000101001010 1 110100 fulfillAvailableOrders\n             * 1000011100100000000110110 1 000001 fulfillAvailableAdvancedOrders\n             *                           ^ 7th bit\n             */\n            invalidNativeOfferItemErrorBuffer := and(\n                NonMatchSelector_MagicMask,\n                calldataload(0)\n            )\n        }\n\n        // Declare variables for later use.\n        AdvancedOrder memory advancedOrder;\n        uint256 terminalMemoryOffset;\n\n        unchecked {\n            // Read length of orders array and place on the stack.\n            uint256 totalOrders = advancedOrders.length;\n\n            // Track the order hash for each order being fulfilled.\n            orderHashes = new bytes32[](totalOrders);\n\n            // Determine the memory offset to terminate on during loops.\n            terminalMemoryOffset = (totalOrders + 1) << OneWordShift;\n        }\n\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Declare inner variables.\n            OfferItem[] memory offer;\n            ConsiderationItem[] memory consideration;\n\n            // Iterate over each order.\n            for (uint256 i = OneWord; i < terminalMemoryOffset; i += OneWord) {\n                // Retrieve order using assembly to bypass out-of-range check.\n                assembly {\n                    advancedOrder := mload(add(advancedOrders, i))\n                }\n\n                // Determine if max number orders have already been fulfilled.\n                if (maximumFulfilled == 0) {\n                    // Mark fill fraction as zero as the order will not be used.\n                    advancedOrder.numerator = 0;\n\n                    // Continue iterating through the remaining orders.\n                    continue;\n                }\n\n                // Validate it, update status, and determine fraction to fill.\n                (\n                    bytes32 orderHash,\n                    uint256 numerator,\n                    uint256 denominator\n                ) = _validateOrderAndUpdateStatus(\n                        advancedOrder,\n                        revertOnInvalid\n                    );\n\n                // Do not track hash or adjust prices if order is not fulfilled.\n                if (numerator == 0) {\n                    // Mark fill fraction as zero if the order is not fulfilled.\n                    advancedOrder.numerator = 0;\n\n                    // Continue iterating through the remaining orders.\n                    continue;\n                }\n\n                // Otherwise, track the order hash in question.\n                assembly {\n                    mstore(add(orderHashes, i), orderHash)\n                }\n\n                // Decrement the number of fulfilled orders.\n                // Skip underflow check as the condition before\n                // implies that maximumFulfilled > 0.\n                --maximumFulfilled;\n\n                // Place the start time for the order on the stack.\n                uint256 startTime = advancedOrder.parameters.startTime;\n\n                // Place the end time for the order on the stack.\n                uint256 endTime = advancedOrder.parameters.endTime;\n\n                // Retrieve array of offer items for the order in question.\n                offer = advancedOrder.parameters.offer;\n\n                // Read length of offer array and place on the stack.\n                uint256 totalOfferItems = offer.length;\n\n                {\n                    // Determine the order type, used to check for eligibility\n                    // for native token offer items as well as for the presence\n                    // of restricted and contract orders (or non-open orders).\n                    OrderType orderType = advancedOrder.parameters.orderType;\n\n                    // Utilize assembly to efficiently check for order types.\n                    // Note that these checks expect that there are no order\n                    // types beyond the current set (0-4) and will need to be\n                    // modified if more order types are added.\n                    assembly {\n                        // Declare a variable indicating if the order is not a\n                        // contract order. Cache in scratch space to avoid stack\n                        // depth errors.\n                        let isNonContract := lt(orderType, 4)\n                        mstore(0, isNonContract)\n\n                        // Update the variable indicating if the order is not an\n                        // open order, remaining set if it has been set already.\n                        containsNonOpen := or(containsNonOpen, gt(orderType, 1))\n                    }\n                }\n\n                // Iterate over each offer item on the order.\n                for (uint256 j = 0; j < totalOfferItems; ++j) {\n                    // Retrieve the offer item.\n                    OfferItem memory offerItem = offer[j];\n\n                    // If the offer item is for the native token and the order\n                    // type is not a contract order type, set the first bit of\n                    // the error buffer to true.\n                    assembly {\n                        invalidNativeOfferItemErrorBuffer := or(\n                            invalidNativeOfferItemErrorBuffer,\n                            lt(mload(offerItem), mload(0))\n                        )\n                    }\n\n                    // Apply order fill fraction to offer item end amount.\n                    uint256 endAmount = _getFraction(\n                        numerator,\n                        denominator,\n                        offerItem.endAmount\n                    );\n\n                    // Reuse same fraction if start and end amounts are equal.\n                    if (offerItem.startAmount == offerItem.endAmount) {\n                        // Apply derived amount to both start and end amount.\n                        offerItem.startAmount = endAmount;\n                    } else {\n                        // Apply order fill fraction to offer item start amount.\n                        offerItem.startAmount = _getFraction(\n                            numerator,\n                            denominator,\n                            offerItem.startAmount\n                        );\n                    }\n\n                    // Adjust offer amount using current time; round down.\n                    uint256 currentAmount = _locateCurrentAmount(\n                        offerItem.startAmount,\n                        endAmount,\n                        startTime,\n                        endTime,\n                        false // round down\n                    );\n\n                    // Update amounts in memory to match the current amount.\n                    // Note that the end amount is used to track spent amounts.\n                    offerItem.startAmount = currentAmount;\n                    offerItem.endAmount = currentAmount;\n                }\n\n                // Retrieve array of consideration items for order in question.\n                consideration = (advancedOrder.parameters.consideration);\n\n                // Read length of consideration array and place on the stack.\n                uint256 totalConsiderationItems = consideration.length;\n\n                // Iterate over each consideration item on the order.\n                for (uint256 j = 0; j < totalConsiderationItems; ++j) {\n                    // Retrieve the consideration item.\n                    ConsiderationItem memory considerationItem = (\n                        consideration[j]\n                    );\n\n                    // Apply fraction to consideration item end amount.\n                    uint256 endAmount = _getFraction(\n                        numerator,\n                        denominator,\n                        considerationItem.endAmount\n                    );\n\n                    // Reuse same fraction if start and end amounts are equal.\n                    if (\n                        considerationItem.startAmount ==\n                        considerationItem.endAmount\n                    ) {\n                        // Apply derived amount to both start and end amount.\n                        considerationItem.startAmount = endAmount;\n                    } else {\n                        // Apply fraction to consideration item start amount.\n                        considerationItem.startAmount = _getFraction(\n                            numerator,\n                            denominator,\n                            considerationItem.startAmount\n                        );\n                    }\n\n                    // Adjust consideration amount using current time; round up.\n                    uint256 currentAmount = (\n                        _locateCurrentAmount(\n                            considerationItem.startAmount,\n                            endAmount,\n                            startTime,\n                            endTime,\n                            true // round up\n                        )\n                    );\n\n                    considerationItem.startAmount = currentAmount;\n\n                    // Utilize assembly to manually \"shift\" the recipient value,\n                    // then to copy the start amount to the recipient.\n                    // Note that this sets up the memory layout that is\n                    // subsequently relied upon by\n                    // _aggregateValidFulfillmentConsiderationItems.\n                    assembly {\n                        // Derive the pointer to the recipient using the item\n                        // pointer along with the offset to the recipient.\n                        let considerationItemRecipientPtr := add(\n                            considerationItem,\n                            ConsiderationItem_recipient_offset // recipient\n                        )\n\n                        // Write recipient to endAmount, as endAmount is not\n                        // used from this point on and can be repurposed to fit\n                        // the layout of a ReceivedItem.\n                        mstore(\n                            add(\n                                considerationItem,\n                                ReceivedItem_recipient_offset // old endAmount\n                            ),\n                            mload(considerationItemRecipientPtr)\n                        )\n\n                        // Write startAmount to recipient, as recipient is not\n                        // used from this point on and can be repurposed to\n                        // track received amounts.\n                        mstore(considerationItemRecipientPtr, currentAmount)\n                    }\n                }\n            }\n        }\n\n        // If the first bit is set, a native offer item was encountered on an\n        // order that is not a contract order. If the 231st bit is set in the\n        // error buffer, the current function is not matchOrders or\n        // matchAdvancedOrders. If the value is 1 + (1 << 230), then both the\n        // 1st and 231st bits were set; in that case, revert with an error.\n        if (\n            invalidNativeOfferItemErrorBuffer ==\n            NonMatchSelector_InvalidErrorValue\n        ) {\n            _revertInvalidNativeOfferItem();\n        }\n\n        // Apply criteria resolvers to each order as applicable.\n        _applyCriteriaResolvers(advancedOrders, criteriaResolvers);\n\n        // Emit an event for each order signifying that it has been fulfilled.\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            bytes32 orderHash;\n\n            // Iterate over each order.\n            for (uint256 i = OneWord; i < terminalMemoryOffset; i += OneWord) {\n                assembly {\n                    orderHash := mload(add(orderHashes, i))\n                }\n\n                // Do not emit an event if no order hash is present.\n                if (orderHash == bytes32(0)) {\n                    continue;\n                }\n\n                // Retrieve order using assembly to bypass out-of-range check.\n                assembly {\n                    advancedOrder := mload(add(advancedOrders, i))\n                }\n\n                // Retrieve parameters for the order in question.\n                OrderParameters memory orderParameters = (\n                    advancedOrder.parameters\n                );\n\n                // Emit an OrderFulfilled event.\n                _emitOrderFulfilledEvent(\n                    orderHash,\n                    orderParameters.offerer,\n                    orderParameters.zone,\n                    recipient,\n                    orderParameters.offer,\n                    orderParameters.consideration\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Internal function to fulfill a group of validated orders, fully or\n     *      partially, with an arbitrary number of items for offer and\n     *      consideration per order and to execute transfers. Any order that is\n     *      not currently active, has already been fully filled, or has been\n     *      cancelled will be omitted. Remaining offer and consideration items\n     *      will then be aggregated where possible as indicated by the supplied\n     *      offer and consideration component arrays and aggregated items will\n     *      be transferred to the fulfiller or to each intended recipient,\n     *      respectively. Note that a failing item transfer or an issue with\n     *      order formatting will cause the entire batch to fail.\n     *\n     * @param advancedOrders            The orders to fulfill along with the\n     *                                  fraction of those orders to attempt to\n     *                                  fill. Note that both the offerer and the\n     *                                  fulfiller must first approve this\n     *                                  contract (or the conduit if indicated by\n     *                                  the order) to transfer any relevant\n     *                                  tokens on their behalf and that\n     *                                  contracts must implement\n     *                                  `onERC1155Received` in order to receive\n     *                                  ERC1155 tokens as consideration. Also\n     *                                  note that all offer and consideration\n     *                                  components must have no remainder after\n     *                                  multiplication of the respective amount\n     *                                  with the supplied fraction for an\n     *                                  order's partial fill amount to be\n     *                                  considered valid.\n     * @param offerFulfillments         An array of FulfillmentComponent arrays\n     *                                  indicating which offer items to attempt\n     *                                  to aggregate when preparing executions.\n     * @param considerationFulfillments An array of FulfillmentComponent arrays\n     *                                  indicating which consideration items to\n     *                                  attempt to aggregate when preparing\n     *                                  executions.\n     * @param fulfillerConduitKey       A bytes32 value indicating what conduit,\n     *                                  if any, to source the fulfiller's token\n     *                                  approvals from. The zero hash signifies\n     *                                  that no conduit should be used, with\n     *                                  direct approvals set on Consideration.\n     * @param recipient                 The intended recipient for all items\n     *                                  that do not already have a designated\n     *                                  recipient and are not already used as\n     *                                  part of a provided fulfillment.\n     * @param orderHashes               An array of order hashes for each order.\n     * @param containsNonOpen           A boolean indicating whether any\n     *                                  restricted or contract orders are\n     *                                  present within the provided array of\n     *                                  advanced orders.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     * @return executions      An array of elements indicating the sequence of\n     *                         transfers performed as part of matching the given\n     *                         orders.\n     */\n    function _executeAvailableFulfillments(\n        AdvancedOrder[] memory advancedOrders,\n        FulfillmentComponent[][] memory offerFulfillments,\n        FulfillmentComponent[][] memory considerationFulfillments,\n        bytes32 fulfillerConduitKey,\n        address recipient,\n        bytes32[] memory orderHashes,\n        bool containsNonOpen\n    )\n        internal\n        returns (bool[] memory availableOrders, Execution[] memory executions)\n    {\n        // Retrieve length of offer fulfillments array and place on the stack.\n        uint256 totalOfferFulfillments = offerFulfillments.length;\n\n        // Retrieve length of consideration fulfillments array & place on stack.\n        uint256 totalConsiderationFulfillments = (\n            considerationFulfillments.length\n        );\n\n        // Allocate an execution for each offer and consideration fulfillment.\n        executions = new Execution[](\n            totalOfferFulfillments + totalConsiderationFulfillments\n        );\n\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Track number of filtered executions.\n            uint256 totalFilteredExecutions = 0;\n\n            // Iterate over each offer fulfillment.\n            for (uint256 i = 0; i < totalOfferFulfillments; ) {\n                // Derive aggregated execution corresponding with fulfillment.\n                Execution memory execution = _aggregateAvailable(\n                    advancedOrders,\n                    Side.OFFER,\n                    offerFulfillments[i],\n                    fulfillerConduitKey,\n                    recipient\n                );\n\n                // If the execution is filterable...\n                if (_isFilterableExecution(execution)) {\n                    // Increment total filtered executions.\n                    ++totalFilteredExecutions;\n                } else {\n                    // Otherwise, assign the execution to the executions array.\n                    executions[i - totalFilteredExecutions] = execution;\n                }\n\n                // Increment iterator.\n                ++i;\n            }\n\n            // Iterate over each consideration fulfillment.\n            for (uint256 i = 0; i < totalConsiderationFulfillments; ) {\n                // Derive aggregated execution corresponding with fulfillment.\n                Execution memory execution = _aggregateAvailable(\n                    advancedOrders,\n                    Side.CONSIDERATION,\n                    considerationFulfillments[i],\n                    fulfillerConduitKey,\n                    address(0) // unused\n                );\n\n                // If the execution is filterable...\n                if (_isFilterableExecution(execution)) {\n                    // Increment total filtered executions.\n                    ++totalFilteredExecutions;\n                } else {\n                    // Otherwise, assign the execution to the executions array.\n                    executions[\n                        i + totalOfferFulfillments - totalFilteredExecutions\n                    ] = execution;\n                }\n\n                // Increment iterator.\n                ++i;\n            }\n\n            // If some number of executions have been filtered...\n            if (totalFilteredExecutions != 0) {\n                // reduce the total length of the executions array.\n                assembly {\n                    mstore(\n                        executions,\n                        sub(mload(executions), totalFilteredExecutions)\n                    )\n                }\n            }\n        }\n\n        // Revert if no orders are available.\n        if (executions.length == 0) {\n            _revertNoSpecifiedOrdersAvailable();\n        }\n\n        // Perform final checks and return.\n        availableOrders = _performFinalChecksAndExecuteOrders(\n            advancedOrders,\n            executions,\n            orderHashes,\n            recipient,\n            containsNonOpen\n        );\n\n        return (availableOrders, executions);\n    }\n\n    /**\n     * @dev Internal function to perform a final check that each consideration\n     *      item for an arbitrary number of fulfilled orders has been met and to\n     *      trigger associated executions, transferring the respective items.\n     *\n     * @param advancedOrders  The orders to check and perform executions for.\n     * @param executions      An array of elements indicating the sequence of\n     *                        transfers to perform when fulfilling the given\n     *                        orders.\n     * @param orderHashes     An array of order hashes for each order.\n     * @param recipient       The intended recipient for all items that do not\n     *                        already have a designated recipient and are not\n     *                        used as part of a provided fulfillment.\n     * @param containsNonOpen A boolean indicating whether any restricted or\n     *                        contract orders are present within the provided\n     *                        array of advanced orders.\n     *\n     * @return availableOrders An array of booleans indicating if each order\n     *                         with an index corresponding to the index of the\n     *                         returned boolean was fulfillable or not.\n     */\n    function _performFinalChecksAndExecuteOrders(\n        AdvancedOrder[] memory advancedOrders,\n        Execution[] memory executions,\n        bytes32[] memory orderHashes,\n        address recipient,\n        bool containsNonOpen\n    ) internal returns (bool[] memory /* availableOrders */) {\n        // Retrieve the length of the advanced orders array and place on stack.\n        uint256 totalOrders = advancedOrders.length;\n\n        // Initialize array for tracking available orders.\n        bool[] memory availableOrders = new bool[](totalOrders);\n\n        // Initialize an accumulator array. From this point forward, no new\n        // memory regions can be safely allocated until the accumulator is no\n        // longer being utilized, as the accumulator operates in an open-ended\n        // fashion from this memory pointer; existing memory may still be\n        // accessed and modified, however.\n        bytes memory accumulator = new bytes(AccumulatorDisarmed);\n\n        {\n            // Declare a variable for the available native token balance.\n            uint256 nativeTokenBalance;\n\n            // Retrieve the length of the executions array and place on stack.\n            uint256 totalExecutions = executions.length;\n\n            // Iterate over each execution.\n            for (uint256 i = 0; i < totalExecutions; ) {\n                // Retrieve the execution and the associated received item.\n                Execution memory execution = executions[i];\n                ReceivedItem memory item = execution.item;\n\n                // If execution transfers native tokens, reduce value available.\n                if (item.itemType == ItemType.NATIVE) {\n                    // Get the current available balance of native tokens.\n                    assembly {\n                        nativeTokenBalance := selfbalance()\n                    }\n\n                    // Ensure that sufficient native tokens are still available.\n                    if (item.amount > nativeTokenBalance) {\n                        _revertInsufficientNativeTokensSupplied();\n                    }\n                }\n\n                // Transfer the item specified by the execution.\n                _transfer(\n                    item,\n                    execution.offerer,\n                    execution.conduitKey,\n                    accumulator\n                );\n\n                // Skip overflow check as for loop is indexed starting at zero.\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Iterate over each order.\n            for (uint256 i = 0; i < totalOrders; ++i) {\n                // Retrieve the order in question.\n                AdvancedOrder memory advancedOrder = advancedOrders[i];\n\n                // Skip the order in question if not being not fulfilled.\n                if (advancedOrder.numerator == 0) {\n                    // Explicitly set availableOrders at the given index to\n                    // guard against the possibility of dirtied memory.\n                    availableOrders[i] = false;\n                    continue;\n                }\n\n                // Mark the order as available.\n                availableOrders[i] = true;\n\n                // Retrieve the order parameters.\n                OrderParameters memory parameters = advancedOrder.parameters;\n\n                {\n                    // Retrieve offer items.\n                    OfferItem[] memory offer = parameters.offer;\n\n                    // Read length of offer array & place on the stack.\n                    uint256 totalOfferItems = offer.length;\n\n                    // Iterate over each offer item to restore it.\n                    for (uint256 j = 0; j < totalOfferItems; ++j) {\n                        // Retrieve the offer item in question.\n                        OfferItem memory offerItem = offer[j];\n\n                        // Transfer to recipient if unspent amount is not zero.\n                        // Note that the transfer will not be reflected in the\n                        // executions array.\n                        if (offerItem.startAmount != 0) {\n                            // Replace the endAmount parameter with the recipient to\n                            // make offerItem compatible with the ReceivedItem input\n                            // to _transfer and cache the original endAmount so it\n                            // can be restored after the transfer.\n                            uint256 originalEndAmount = _replaceEndAmountWithRecipient(\n                                    offerItem,\n                                    recipient\n                                );\n\n                            // Transfer excess offer item amount to recipient.\n                            _toOfferItemInput(_transfer)(\n                                offerItem,\n                                parameters.offerer,\n                                parameters.conduitKey,\n                                accumulator\n                            );\n\n                            // Restore the original endAmount in offerItem.\n                            assembly {\n                                mstore(\n                                    add(\n                                        offerItem,\n                                        ReceivedItem_recipient_offset\n                                    ),\n                                    originalEndAmount\n                                )\n                            }\n                        }\n\n                        // Restore original amount on the offer item.\n                        offerItem.startAmount = offerItem.endAmount;\n                    }\n                }\n\n                {\n                    // Read consideration items & ensure they are fulfilled.\n                    ConsiderationItem[] memory consideration = (\n                        parameters.consideration\n                    );\n\n                    // Read length of consideration array & place on stack.\n                    uint256 totalConsiderationItems = consideration.length;\n\n                    // Iterate over each consideration item.\n                    for (uint256 j = 0; j < totalConsiderationItems; ++j) {\n                        ConsiderationItem memory considerationItem = (\n                            consideration[j]\n                        );\n\n                        // Retrieve remaining amount on consideration item.\n                        uint256 unmetAmount = considerationItem.startAmount;\n\n                        // Revert if the remaining amount is not zero.\n                        if (unmetAmount != 0) {\n                            _revertConsiderationNotMet(i, j, unmetAmount);\n                        }\n\n                        // Utilize assembly to restore the original value.\n                        assembly {\n                            // Write recipient to startAmount.\n                            mstore(\n                                add(\n                                    considerationItem,\n                                    ReceivedItem_amount_offset\n                                ),\n                                mload(\n                                    add(\n                                        considerationItem,\n                                        ConsiderationItem_recipient_offset\n                                    )\n                                )\n                            )\n                        }\n                    }\n                }\n            }\n        }\n\n        // Trigger any accumulated transfers via call to the conduit.\n        _triggerIfArmed(accumulator);\n\n        // Determine whether any native token balance remains.\n        uint256 remainingNativeTokenBalance;\n        assembly {\n            remainingNativeTokenBalance := selfbalance()\n        }\n\n        // Return any remaining native token balance to the caller.\n        if (remainingNativeTokenBalance != 0) {\n            _transferNativeTokens(\n                payable(msg.sender),\n                remainingNativeTokenBalance\n            );\n        }\n\n        // If any restricted or contract orders are present in the group of\n        // orders being fulfilled, perform any validateOrder or ratifyOrder\n        // calls after all executions and related transfers are complete.\n        if (containsNonOpen) {\n            // Iterate over each order a second time.\n            for (uint256 i = 0; i < totalOrders; ) {\n                // Ensure the order in question is being fulfilled.\n                if (availableOrders[i]) {\n                    // Check restricted orders and contract orders.\n                    _assertRestrictedAdvancedOrderValidity(\n                        advancedOrders[i],\n                        orderHashes,\n                        orderHashes[i]\n                    );\n                }\n\n                // Skip overflow checks as for loop is indexed starting at zero.\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n\n        // Clear the reentrancy guard.\n        _clearReentrancyGuard();\n\n        // Return the array containing available orders.\n        return availableOrders;\n    }\n\n    /**\n     * @dev Internal function to emit an OrdersMatched event using the same\n     *      memory region as the existing order hash array.\n     *\n     * @param orderHashes An array of order hashes to include as an argument for\n     *                    the OrdersMatched event.\n     */\n    function _emitOrdersMatched(bytes32[] memory orderHashes) internal {\n        assembly {\n            // Load the array length from memory.\n            let length := mload(orderHashes)\n\n            // Get the full size of the event data - one word for the offset,\n            // one for the array length and one per hash.\n            let dataSize := add(TwoWords, shl(OneWordShift, length))\n\n            // Get pointer to start of data, reusing word before array length\n            // for the offset.\n            let dataPointer := sub(orderHashes, OneWord)\n\n            // Cache the existing word in memory at the offset pointer.\n            let cache := mload(dataPointer)\n\n            // Write an offset of 32.\n            mstore(dataPointer, OneWord)\n\n            // Emit the OrdersMatched event.\n            log1(dataPointer, dataSize, OrdersMatchedTopic0)\n\n            // Restore the cached word.\n            mstore(dataPointer, cache)\n        }\n    }\n\n    /**\n     * @dev Internal function to match an arbitrary number of full or partial\n     *      orders, each with an arbitrary number of items for offer and\n     *      consideration, supplying criteria resolvers containing specific\n     *      token identifiers and associated proofs as well as fulfillments\n     *      allocating offer components to consideration components.\n     *\n     * @param advancedOrders    The advanced orders to match. Note that both the\n     *                          offerer and fulfiller on each order must first\n     *                          approve this contract (or their conduit if\n     *                          indicated by the order) to transfer any relevant\n     *                          tokens on their behalf and each consideration\n     *                          recipient must implement `onERC1155Received` in\n     *                          order to receive ERC1155 tokens. Also note that\n     *                          the offer and consideration components for each\n     *                          order must have no remainder after multiplying\n     *                          the respective amount with the supplied fraction\n     *                          in order for the group of partial fills to be\n     *                          considered valid.\n     * @param criteriaResolvers An array where each element contains a reference\n     *                          to a specific order as well as that order's\n     *                          offer or consideration, a token identifier, and\n     *                          a proof that the supplied token identifier is\n     *                          contained in the order's merkle root. Note that\n     *                          an empty root indicates that any (transferable)\n     *                          token identifier is valid and that no associated\n     *                          proof needs to be supplied.\n     * @param fulfillments      An array of elements allocating offer components\n     *                          to consideration components. Note that each\n     *                          consideration component must be fully met in\n     *                          order for the match operation to be valid.\n     * @param recipient         The intended recipient for all unspent offer\n     *                          item amounts.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders.\n     */\n    function _matchAdvancedOrders(\n        AdvancedOrder[] memory advancedOrders,\n        CriteriaResolver[] memory criteriaResolvers,\n        Fulfillment[] memory fulfillments,\n        address recipient\n    ) internal returns (Execution[] memory /* executions */) {\n        // Validate orders, update order status, and determine item amounts.\n        (\n            bytes32[] memory orderHashes,\n            bool containsNonOpen\n        ) = _validateOrdersAndPrepareToFulfill(\n                advancedOrders,\n                criteriaResolvers,\n                true, // Signifies that invalid orders should revert.\n                advancedOrders.length,\n                recipient\n            );\n\n        // Emit OrdersMatched event, providing an array of matched order hashes.\n        _emitOrdersMatched(orderHashes);\n\n        // Fulfill the orders using the supplied fulfillments and recipient.\n        return\n            _fulfillAdvancedOrders(\n                advancedOrders,\n                fulfillments,\n                orderHashes,\n                recipient,\n                containsNonOpen\n            );\n    }\n\n    /**\n     * @dev Internal function to fulfill an arbitrary number of orders, either\n     *      full or partial, after validating, adjusting amounts, and applying\n     *      criteria resolvers.\n     *\n     * @param advancedOrders  The orders to match, including a fraction to\n     *                        attempt to fill for each order.\n     * @param fulfillments    An array of elements allocating offer components\n     *                        to consideration components. Note that the final\n     *                        amount of each consideration component must be\n     *                        zero for a match operation to be considered valid.\n     * @param orderHashes     An array of order hashes for each order.\n     * @param recipient       The intended recipient for all items that do not\n     *                        already have a designated recipient and are not\n     *                        used as part of a provided fulfillment.\n     * @param containsNonOpen A boolean indicating whether any restricted or\n     *                        contract orders are present within the provided\n     *                        array of advanced orders.\n     *\n     * @return executions An array of elements indicating the sequence of\n     *                    transfers performed as part of matching the given\n     *                    orders.\n     */\n    function _fulfillAdvancedOrders(\n        AdvancedOrder[] memory advancedOrders,\n        Fulfillment[] memory fulfillments,\n        bytes32[] memory orderHashes,\n        address recipient,\n        bool containsNonOpen\n    ) internal returns (Execution[] memory executions) {\n        // Retrieve fulfillments array length and place on the stack.\n        uint256 totalFulfillments = fulfillments.length;\n\n        // Allocate executions by fulfillment and apply them to each execution.\n        executions = new Execution[](totalFulfillments);\n\n        // Skip overflow checks as all for loops are indexed starting at zero.\n        unchecked {\n            // Track number of filtered executions.\n            uint256 totalFilteredExecutions = 0;\n\n            // Iterate over each fulfillment.\n            for (uint256 i = 0; i < totalFulfillments; ++i) {\n                /// Retrieve the fulfillment in question.\n                Fulfillment memory fulfillment = fulfillments[i];\n\n                // Derive the execution corresponding with the fulfillment.\n                Execution memory execution = _applyFulfillment(\n                    advancedOrders,\n                    fulfillment.offerComponents,\n                    fulfillment.considerationComponents,\n                    i\n                );\n\n                // If the execution is filterable...\n                if (_isFilterableExecution(execution)) {\n                    // Increment total filtered executions.\n                    ++totalFilteredExecutions;\n                } else {\n                    // Otherwise, assign the execution to the executions array.\n                    executions[i - totalFilteredExecutions] = execution;\n                }\n            }\n\n            // If some number of executions have been filtered...\n            if (totalFilteredExecutions != 0) {\n                // reduce the total length of the executions array.\n                assembly {\n                    mstore(\n                        executions,\n                        sub(mload(executions), totalFilteredExecutions)\n                    )\n                }\n            }\n        }\n\n        // Perform final checks and execute orders.\n        _performFinalChecksAndExecuteOrders(\n            advancedOrders,\n            executions,\n            orderHashes,\n            recipient,\n            containsNonOpen\n        );\n\n        // Return the executions array.\n        return executions;\n    }\n\n    /**\n     * @dev Internal pure function to determine whether a given execution is\n     *      filterable and may be removed from the executions array. The offerer\n     *      and the recipient must be the same address and the item type cannot\n     *      indicate a native token transfer.\n     *\n     * @param execution The execution to check for filterability.\n     *\n     * @return filterable A boolean indicating whether the execution in question\n     *                    can be filtered from the executions array.\n     */\n    function _isFilterableExecution(\n        Execution memory execution\n    ) internal pure returns (bool filterable) {\n        // Utilize assembly to efficiently determine if execution is filterable.\n        assembly {\n            // Retrieve the received item referenced by the execution.\n            let item := mload(execution)\n\n            // Determine whether the execution is filterable.\n            filterable := and(\n                // Determine if offerer and recipient are the same address.\n                eq(\n                    // Retrieve the recipient's address from the received item.\n                    mload(add(item, ReceivedItem_recipient_offset)),\n                    // Retrieve the offerer's address from the execution.\n                    mload(add(execution, Execution_offerer_offset))\n                ),\n                // Determine if received item's item type is non-zero, thereby\n                // indicating that the execution does not involve native tokens.\n                iszero(iszero(mload(item)))\n            )\n        }\n    }\n}\n"},"contracts/conduit/lib/ConduitStructs.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport { ConduitItemType } from \"./ConduitEnums.sol\";\n\n/**\n * @dev A ConduitTransfer is a struct that contains the information needed for a\n *      conduit to transfer an item from one address to another.\n */\nstruct ConduitTransfer {\n    ConduitItemType itemType;\n    address token;\n    address from;\n    address to;\n    uint256 identifier;\n    uint256 amount;\n}\n\n/**\n * @dev A ConduitBatch1155Transfer is a struct that contains the information\n *      needed for a conduit to transfer a batch of ERC-1155 tokens from one\n *      address to another.\n */\nstruct ConduitBatch1155Transfer {\n    address token;\n    address from;\n    address to;\n    uint256[] ids;\n    uint256[] amounts;\n}\n"},"contracts/Seaport.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { Consideration } from \"./lib/Consideration.sol\";\n\n/**\n * @title Seaport\n * @custom:version 1.5\n * @author 0age (0age.eth)\n * @custom:coauthor d1ll0n (d1ll0n.eth)\n * @custom:coauthor transmissions11 (t11s.eth)\n * @custom:coauthor James Wenzel (emo.eth)\n * @custom:contributor Kartik (slokh.eth)\n * @custom:contributor LeFevre (lefevre.eth)\n * @custom:contributor Joseph Schiarizzi (CupOJoseph.eth)\n * @custom:contributor Aspyn Palatnick (stuckinaboot.eth)\n * @custom:contributor Stephan Min (stephanm.eth)\n * @custom:contributor Ryan Ghods (ralxz.eth)\n * @custom:contributor Daniel Viau (snotrocket.eth)\n * @custom:contributor hack3r-0m (hack3r-0m.eth)\n * @custom:contributor Diego Estevez (antidiego.eth)\n * @custom:contributor Chomtana (chomtana.eth)\n * @custom:contributor Saw-mon and Natalie (sawmonandnatalie.eth)\n * @custom:contributor 0xBeans (0xBeans.eth)\n * @custom:contributor 0x4non (punkdev.eth)\n * @custom:contributor Laurence E. Day (norsefire.eth)\n * @custom:contributor vectorized.eth (vectorized.eth)\n * @custom:contributor karmacoma (karmacoma.eth)\n * @custom:contributor horsefacts (horsefacts.eth)\n * @custom:contributor UncarvedBlock (uncarvedblock.eth)\n * @custom:contributor Zoraiz Mahmood (zorz.eth)\n * @custom:contributor William Poulin (wpoulin.eth)\n * @custom:contributor Rajiv Patel-O'Connor (rajivpoc.eth)\n * @custom:contributor tserg (tserg.eth)\n * @custom:contributor cygaar (cygaar.eth)\n * @custom:contributor Meta0xNull (meta0xnull.eth)\n * @custom:contributor gpersoon (gpersoon.eth)\n * @custom:contributor Matt Solomon (msolomon.eth)\n * @custom:contributor Weikang Song (weikangs.eth)\n * @custom:contributor zer0dot (zer0dot.eth)\n * @custom:contributor Mudit Gupta (mudit.eth)\n * @custom:contributor leonardoalt (leoalt.eth)\n * @custom:contributor cmichel (cmichel.eth)\n * @custom:contributor PraneshASP (pranesh.eth)\n * @custom:contributor JasperAlexander (jasperalexander.eth)\n * @custom:contributor Ellahi (ellahi.eth)\n * @custom:contributor zaz (1zaz1.eth)\n * @custom:contributor berndartmueller (berndartmueller.eth)\n * @custom:contributor dmfxyz (dmfxyz.eth)\n * @custom:contributor daltoncoder (dontkillrobots.eth)\n * @custom:contributor 0xf4ce (0xf4ce.eth)\n * @custom:contributor phaze (phaze.eth)\n * @custom:contributor hrkrshnn (hrkrshnn.eth)\n * @custom:contributor axic (axic.eth)\n * @custom:contributor leastwood (leastwood.eth)\n * @custom:contributor 0xsanson (sanson.eth)\n * @custom:contributor blockdev (blockd3v.eth)\n * @custom:contributor fiveoutofnine (fiveoutofnine.eth)\n * @custom:contributor shuklaayush (shuklaayush.eth)\n * @custom:contributor dravee (dravee.eth)\n * @custom:contributor 0xPatissier\n * @custom:contributor pcaversaccio\n * @custom:contributor David Eiber\n * @custom:contributor csanuragjain\n * @custom:contributor sach1r0\n * @custom:contributor twojoy0\n * @custom:contributor ori_dabush\n * @custom:contributor Daniel Gelfand\n * @custom:contributor okkothejawa\n * @custom:contributor FlameHorizon\n * @custom:contributor vdrg\n * @custom:contributor dmitriia\n * @custom:contributor bokeh-eth\n * @custom:contributor asutorufos\n * @custom:contributor rfart(rfa)\n * @custom:contributor Riley Holterhus\n * @custom:contributor big-tech-sux\n * @notice Seaport is a generalized native token/ERC20/ERC721/ERC1155\n *         marketplace with lightweight methods for common routes as well as\n *         more flexible methods for composing advanced orders or groups of\n *         orders. Each order contains an arbitrary number of items that may be\n *         spent (the \"offer\") along with an arbitrary number of items that must\n *         be received back by the indicated recipients (the \"consideration\").\n */\ncontract Seaport is Consideration {\n    /**\n     * @notice Derive and set hashes, reference chainId, and associated domain\n     *         separator during deployment.\n     *\n     * @param conduitController A contract that deploys conduits, or proxies\n     *                          that may optionally be used to transfer approved\n     *                          ERC20/721/1155 tokens.\n     */\n    constructor(address conduitController) Consideration(conduitController) {}\n\n    /**\n     * @dev Internal pure function to retrieve and return the name of this\n     *      contract.\n     *\n     * @return The name of this contract.\n     */\n    function _name() internal pure override returns (string memory) {\n        // Return the name of the contract.\n        assembly {\n            mstore(0x20, 0x20)\n            mstore(0x47, 0x07536561706f7274)\n            return(0x20, 0x60)\n        }\n    }\n\n    /**\n     * @dev Internal pure function to retrieve the name of this contract as a\n     *      string that will be used to derive the name hash in the constructor.\n     *\n     * @return The name of this contract as a string.\n     */\n    function _nameString() internal pure override returns (string memory) {\n        // Return the name of the contract.\n        return \"Seaport\";\n    }\n}\n"}},"settings":{"libraries":{},"metadata":{"bytecodeHash":"none"},"optimizer":{"enabled":true,"runs":9999999},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}},"viaIR":true}},"ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduitController\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BadContractSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadFraction\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BadReturnValueFromERC20OnTransfer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"name\":\"BadSignatureV\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotCancelOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ConsiderationCriteriaResolverOutOfRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ConsiderationLengthNotEqualToTotalOriginal\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"considerationIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortfallAmount\",\"type\":\"uint256\"}],\"name\":\"ConsiderationNotMet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CriteriaNotEnabledForItem\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"identifiers\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"ERC1155BatchTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InexactFraction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientNativeTokensSupplied\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Invalid1155BatchTransferEncoding\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidBasicOrderParameterEncoding\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"InvalidCallToConduit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"conduit\",\"type\":\"address\"}],\"name\":\"InvalidConduit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"InvalidContractOrder\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InvalidERC721TransferAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFulfillmentComponentData\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"InvalidMsgValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidNativeOfferItem\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidProof\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"InvalidRestrictedOrder\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSigner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"InvalidTime\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fulfillmentIndex\",\"type\":\"uint256\"}],\"name\":\"MismatchedFulfillmentOfferAndConsiderationComponents\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"}],\"name\":\"MissingFulfillmentComponentOnAggregation\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingItemAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingOriginalConsiderationItems\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NativeTokenTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"NoContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoReentrantCalls\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoSpecifiedOrdersAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OfferAndConsiderationRequiredOnFulfillment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OfferCriteriaResolverOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderAlreadyFilled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"}],\"name\":\"OrderCriteriaResolverOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderIsCancelled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderPartiallyFilled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PartialFillsNotEnabledForOrder\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenTransferGenericFailure\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"considerationIndex\",\"type\":\"uint256\"}],\"name\":\"UnresolvedConsiderationCriteria\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerIndex\",\"type\":\"uint256\"}],\"name\":\"UnresolvedOfferCriteria\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnusedItemParameters\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCounter\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"}],\"name\":\"CounterIncremented\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct SpentItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"indexed\":false,\"internalType\":\"struct ReceivedItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"}],\"name\":\"OrderFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct OrderParameters\",\"name\":\"orderParameters\",\"type\":\"tuple\"}],\"name\":\"OrderValidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"orderHashes\",\"type\":\"bytes32[]\"}],\"name\":\"OrdersMatched\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderComponents[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"name\":\"cancel\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"cancelled\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"uint120\",\"name\":\"numerator\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"denominator\",\"type\":\"uint120\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct AdvancedOrder\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"criteriaProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CriteriaResolver[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"fulfillAdvancedOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"uint120\",\"name\":\"numerator\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"denominator\",\"type\":\"uint120\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct AdvancedOrder[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"criteriaProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CriteriaResolver[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"\",\"type\":\"tuple[][]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"\",\"type\":\"tuple[][]\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maximumFulfilled\",\"type\":\"uint256\"}],\"name\":\"fulfillAvailableAdvancedOrders\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"},{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Execution[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"\",\"type\":\"tuple[][]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[][]\",\"name\":\"\",\"type\":\"tuple[][]\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maximumFulfilled\",\"type\":\"uint256\"}],\"name\":\"fulfillAvailableOrders\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"},{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Execution[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"considerationToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"considerationIdentifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"considerationAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"offerToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerIdentifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum BasicOrderType\",\"name\":\"basicOrderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"offererConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalAdditionalRecipients\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct AdditionalRecipient[]\",\"name\":\"additionalRecipients\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct BasicOrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"fulfillBasicOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"considerationToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"considerationIdentifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"considerationAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"offerToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerIdentifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"offerAmount\",\"type\":\"uint256\"},{\"internalType\":\"enum BasicOrderType\",\"name\":\"basicOrderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"offererConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalAdditionalRecipients\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct AdditionalRecipient[]\",\"name\":\"additionalRecipients\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct BasicOrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"fulfillBasicOrder_efficient_6GL6yc\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"}],\"name\":\"fulfillOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractOfferer\",\"type\":\"address\"}],\"name\":\"getContractOffererNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"}],\"name\":\"getCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"counter\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderComponents\",\"name\":\"\",\"type\":\"tuple\"}],\"name\":\"getOrderHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"getOrderStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValidated\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isCancelled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalFilled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSize\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"incrementCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newCounter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"information\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"domainSeparator\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"conduitController\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"uint120\",\"name\":\"numerator\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"denominator\",\"type\":\"uint120\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct AdvancedOrder[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"criteriaProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CriteriaResolver[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"offerComponents\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"considerationComponents\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Fulfillment[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"matchAdvancedOrders\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Execution[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"offerComponents\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemIndex\",\"type\":\"uint256\"}],\"internalType\":\"struct FulfillmentComponent[]\",\"name\":\"considerationComponents\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Fulfillment[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"name\":\"matchOrders\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ReceivedItem\",\"name\":\"item\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"}],\"internalType\":\"struct Execution[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct Order[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"name\":\"validate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Seaport","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":1,"Runs":9999999,"ConstructorArguments":"0x00000000000000000000000000000000f9490004c11cef243f5400493c00ad63","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}