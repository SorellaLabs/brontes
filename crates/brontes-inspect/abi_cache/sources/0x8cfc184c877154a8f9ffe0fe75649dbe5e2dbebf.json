{"expiry":1699484678,"data":[{"SourceCode":{"language":"Solidity","sources":{"tellorflex/contracts/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}\n"},"tellorflex/contracts/TellorFlex.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport \"./interfaces/IERC20.sol\";\n\n/**\n @author Tellor Inc.\n @title TellorFlex\n @dev This is a streamlined Tellor oracle system which handles staking, reporting,\n * slashing, and user data getters in one contract. This contract is controlled\n * by a single address known as 'governance', which could be an externally owned\n * account or a contract, allowing for a flexible, modular design.\n*/\ncontract TellorFlex {\n    // Storage\n    IERC20 public immutable token; // token used for staking and rewards\n    address public governance; // address with ability to remove values and slash reporters\n    address public immutable owner; // contract deployer, can call init function once\n    uint256 public accumulatedRewardPerShare; // accumulated staking reward per staked token\n    uint256 public immutable minimumStakeAmount; // minimum amount of tokens required to stake\n    uint256 public immutable reportingLock; // base amount of time before a reporter is able to submit a value again\n    uint256 public rewardRate; // total staking rewards released per second\n    uint256 public stakeAmount; // minimum amount required to be a staker\n    uint256 public immutable stakeAmountDollarTarget; // amount of US dollars required to be a staker\n    uint256 public stakingRewardsBalance; // total amount of staking rewards\n    bytes32 public immutable stakingTokenPriceQueryId; // staking token SpotPrice queryId, used for updating stakeAmount\n    uint256 public constant timeBasedReward = 5e17; // amount of TB rewards released per 5 minutes\n    uint256 public timeOfLastAllocation; // time of last update to accumulatedRewardPerShare\n    uint256 public timeOfLastNewValue = block.timestamp; // time of the last new submitted value, originally set to the block timestamp\n    uint256 public totalRewardDebt; // staking reward debt, used to calculate real staking rewards balance\n    uint256 public totalStakeAmount; // total amount of tokens locked in contract (via stake)\n    uint256 public totalStakers; // total number of stakers with at least stakeAmount staked, not exact\n    uint256 public toWithdraw; //amountLockedForWithdrawal\n\n    mapping(bytes32 => Report) private reports; // mapping of query IDs to a report\n    mapping(address => StakeInfo) private stakerDetails; // mapping from a persons address to their staking info\n\n    // Structs\n    struct Report {\n        uint256[] timestamps; // array of all newValueTimestamps reported\n        mapping(uint256 => uint256) timestampIndex; // mapping of timestamps to respective indices\n        mapping(uint256 => bytes) valueByTimestamp; // mapping of timestamps to values\n        mapping(uint256 => address) reporterByTimestamp; // mapping of timestamps to reporters\n        mapping(uint256 => bool) isDisputed;\n    }\n\n    struct StakeInfo {\n        uint256 startDate; // stake or withdrawal request start date\n        uint256 stakedBalance; // staked token balance\n        uint256 lockedBalance; // amount locked for withdrawal\n        uint256 rewardDebt; // used for staking reward calculation\n        uint256 reporterLastTimestamp; // timestamp of reporter's last reported value\n        uint256 reportsSubmitted; // total number of reports submitted by reporter\n        uint256 startVoteCount; // total number of governance votes when stake deposited\n        uint256 startVoteTally; // staker vote tally when stake deposited\n        bool staked; // used to keep track of total stakers\n    }\n\n    // Events\n    event NewReport(\n        bytes32 indexed _queryId,\n        uint256 indexed _time,\n        bytes _value,\n        uint256 _nonce,\n        bytes _queryData,\n        address indexed _reporter\n    );\n    event NewStakeAmount(uint256 _newStakeAmount);\n    event NewStaker(address indexed _staker, uint256 indexed _amount);\n    event ReporterSlashed(\n        address indexed _reporter,\n        address _recipient,\n        uint256 _slashAmount\n    );\n    event StakeWithdrawn(address _staker);\n    event StakeWithdrawRequested(address _staker, uint256 _amount);\n    event ValueRemoved(bytes32 _queryId, uint256 _timestamp);\n\n    // Functions\n    /**\n     * @dev Initializes system parameters\n     * @param _token address of token used for staking and rewards\n     * @param _reportingLock base amount of time (seconds) before reporter is able to report again\n     * @param _stakeAmountDollarTarget fixed USD amount that stakeAmount targets on updateStakeAmount\n     * @param _stakingTokenPrice current price of staking token in USD (18 decimals)\n     * @param _stakingTokenPriceQueryId queryId where staking token price is reported\n     */\n    constructor(\n        address _token,\n        uint256 _reportingLock,\n        uint256 _stakeAmountDollarTarget,\n        uint256 _stakingTokenPrice,\n        uint256 _minimumStakeAmount,\n        bytes32 _stakingTokenPriceQueryId\n    ) {\n        require(_token != address(0), \"must set token address\");\n        require(_stakingTokenPrice > 0, \"must set staking token price\");\n        require(_reportingLock > 0, \"must set reporting lock\");\n        require(_stakingTokenPriceQueryId != bytes32(0), \"must set staking token price queryId\");\n        token = IERC20(_token);\n        owner = msg.sender;\n        reportingLock = _reportingLock;\n        stakeAmountDollarTarget = _stakeAmountDollarTarget;\n        minimumStakeAmount = _minimumStakeAmount;\n        uint256 _potentialStakeAmount = (_stakeAmountDollarTarget * 1e18) / _stakingTokenPrice;\n        if(_potentialStakeAmount < _minimumStakeAmount) {\n            stakeAmount = _minimumStakeAmount;\n        } else {\n            stakeAmount = _potentialStakeAmount;\n        }\n        stakingTokenPriceQueryId = _stakingTokenPriceQueryId;\n    }\n\n    /**\n     * @dev Allows the owner to initialize the governance (flex addy needed for governance deployment)\n     * @param _governanceAddress address of governance contract (github.com/tellor-io/governance)\n     */\n    function init(address _governanceAddress) external {\n        require(msg.sender == owner, \"only owner can set governance address\");\n        require(governance == address(0), \"governance address already set\");\n        require(\n            _governanceAddress != address(0),\n            \"governance address can't be zero address\"\n        );\n        governance = _governanceAddress;\n    }\n\n    /**\n     * @dev Funds the Flex contract with staking rewards (paid by autopay and minting)\n     * @param _amount amount of tokens to fund contract with\n     */\n    function addStakingRewards(uint256 _amount) external {\n        require(token.transferFrom(msg.sender, address(this), _amount));\n        _updateRewards();\n        stakingRewardsBalance += _amount;\n        // update reward rate = real staking rewards balance / 30 days\n        rewardRate =\n            (stakingRewardsBalance -\n                ((accumulatedRewardPerShare * totalStakeAmount) /\n                    1e18 -\n                    totalRewardDebt)) /\n            30 days;\n    }\n\n    /**\n     * @dev Allows a reporter to submit stake\n     * @param _amount amount of tokens to stake\n     */\n    function depositStake(uint256 _amount) external {\n        require(governance != address(0), \"governance address not set\");\n        StakeInfo storage _staker = stakerDetails[msg.sender];\n        uint256 _stakedBalance = _staker.stakedBalance;\n        uint256 _lockedBalance = _staker.lockedBalance;\n        if (_lockedBalance > 0) {\n            if (_lockedBalance >= _amount) {\n                // if staker's locked balance covers full _amount, use that\n                _staker.lockedBalance -= _amount;\n                toWithdraw -= _amount;\n            } else {\n                // otherwise, stake the whole locked balance and transfer the\n                // remaining amount from the staker's address\n                require(\n                    token.transferFrom(\n                        msg.sender,\n                        address(this),\n                        _amount - _lockedBalance\n                    )\n                );\n                toWithdraw -= _staker.lockedBalance;\n                _staker.lockedBalance = 0;\n            }\n        } else {\n            if (_stakedBalance == 0) {\n                // if staked balance and locked balance equal 0, save current vote tally.\n                // voting participation used for calculating rewards\n                (bool _success, bytes memory _returnData) = governance.call(\n                    abi.encodeWithSignature(\"getVoteCount()\")\n                );\n                if (_success) {\n                    _staker.startVoteCount = uint256(abi.decode(_returnData, (uint256)));\n                }\n                (_success,_returnData) = governance.call(\n                    abi.encodeWithSignature(\"getVoteTallyByAddress(address)\",msg.sender)\n                );\n                if(_success){\n                    _staker.startVoteTally =  abi.decode(_returnData,(uint256));\n                }\n            }\n            require(token.transferFrom(msg.sender, address(this), _amount));\n        }\n        _updateStakeAndPayRewards(msg.sender, _stakedBalance + _amount);\n        _staker.startDate = block.timestamp; // This resets the staker start date to now\n        emit NewStaker(msg.sender, _amount);\n    }\n\n    /**\n     * @dev Removes a value from the oracle.\n     * Note: this function is only callable by the Governance contract.\n     * @param _queryId is ID of the specific data feed\n     * @param _timestamp is the timestamp of the data value to remove\n     */\n    function removeValue(bytes32 _queryId, uint256 _timestamp) external {\n        require(msg.sender == governance, \"caller must be governance address\");\n        Report storage _report = reports[_queryId];\n        require(!_report.isDisputed[_timestamp], \"value already disputed\");\n        uint256 _index = _report.timestampIndex[_timestamp];\n        require(_timestamp == _report.timestamps[_index], \"invalid timestamp\");\n        _report.valueByTimestamp[_timestamp] = \"\";\n        _report.isDisputed[_timestamp] = true;\n        emit ValueRemoved(_queryId, _timestamp);\n    }\n\n    /**\n     * @dev Allows a reporter to request to withdraw their stake\n     * @param _amount amount of staked tokens requesting to withdraw\n     */\n    function requestStakingWithdraw(uint256 _amount) external {\n        StakeInfo storage _staker = stakerDetails[msg.sender];\n        require(\n            _staker.stakedBalance >= _amount,\n            \"insufficient staked balance\"\n        );\n        _updateStakeAndPayRewards(msg.sender, _staker.stakedBalance - _amount);\n        _staker.startDate = block.timestamp;\n        _staker.lockedBalance += _amount;\n        toWithdraw += _amount;\n        emit StakeWithdrawRequested(msg.sender, _amount);\n    }\n\n    /**\n     * @dev Slashes a reporter and transfers their stake amount to the given recipient\n     * Note: this function is only callable by the governance address.\n     * @param _reporter is the address of the reporter being slashed\n     * @param _recipient is the address receiving the reporter's stake\n     * @return _slashAmount uint256 amount of token slashed and sent to recipient address\n     */\n    function slashReporter(address _reporter, address _recipient)\n        external\n        returns (uint256 _slashAmount)\n    {\n        require(msg.sender == governance, \"only governance can slash reporter\");\n        StakeInfo storage _staker = stakerDetails[_reporter];\n        uint256 _stakedBalance = _staker.stakedBalance;\n        uint256 _lockedBalance = _staker.lockedBalance;\n        require(_stakedBalance + _lockedBalance > 0, \"zero staker balance\");\n        if (_lockedBalance >= stakeAmount) {\n            // if locked balance is at least stakeAmount, slash from locked balance\n            _slashAmount = stakeAmount;\n            _staker.lockedBalance -= stakeAmount;\n            toWithdraw -= stakeAmount;\n        } else if (_lockedBalance + _stakedBalance >= stakeAmount) {\n            // if locked balance + staked balance is at least stakeAmount,\n            // slash from locked balance and slash remainder from staked balance\n            _slashAmount = stakeAmount;\n            _updateStakeAndPayRewards(\n                _reporter,\n                _stakedBalance - (stakeAmount - _lockedBalance)\n            );\n            toWithdraw -= _lockedBalance;\n            _staker.lockedBalance = 0;\n        } else {\n            // if sum(locked balance + staked balance) is less than stakeAmount,\n            // slash sum\n            _slashAmount = _stakedBalance + _lockedBalance;\n            toWithdraw -= _lockedBalance;\n            _updateStakeAndPayRewards(_reporter, 0);\n            _staker.lockedBalance = 0;\n        }\n        require(token.transfer(_recipient, _slashAmount));\n        emit ReporterSlashed(_reporter, _recipient, _slashAmount);\n    }\n\n    /**\n     * @dev Allows a reporter to submit a value to the oracle\n     * @param _queryId is ID of the specific data feed. Equals keccak256(_queryData) for non-legacy IDs\n     * @param _value is the value the user submits to the oracle\n     * @param _nonce is the current value count for the query id\n     * @param _queryData is the data used to fulfill the data query\n     */\n    function submitValue(\n        bytes32 _queryId,\n        bytes calldata _value,\n        uint256 _nonce,\n        bytes calldata _queryData\n    ) external {\n        require(keccak256(_value) != keccak256(\"\"), \"value must be submitted\");\n        Report storage _report = reports[_queryId];\n        require(\n            _nonce == _report.timestamps.length || _nonce == 0,\n            \"nonce must match timestamp index\"\n        );\n        StakeInfo storage _staker = stakerDetails[msg.sender];\n        require(\n            _staker.stakedBalance >= stakeAmount,\n            \"balance must be greater than stake amount\"\n        );\n        // Require reporter to abide by given reporting lock\n        require(\n            (block.timestamp - _staker.reporterLastTimestamp) * 1000 >\n                (reportingLock * 1000) / (_staker.stakedBalance / stakeAmount),\n            \"still in reporter time lock, please wait!\"\n        );\n        require(\n            _queryId == keccak256(_queryData),\n            \"query id must be hash of query data\"\n        );\n        _staker.reporterLastTimestamp = block.timestamp;\n        // Checks for no double reporting of timestamps\n        require(\n            _report.reporterByTimestamp[block.timestamp] == address(0),\n            \"timestamp already reported for\"\n        );\n        // Update number of timestamps, value for given timestamp, and reporter for timestamp\n        _report.timestampIndex[block.timestamp] = _report.timestamps.length;\n        _report.timestamps.push(block.timestamp);\n        _report.valueByTimestamp[block.timestamp] = _value;\n        _report.reporterByTimestamp[block.timestamp] = msg.sender;\n        // Disperse Time Based Reward\n        uint256 _reward = ((block.timestamp - timeOfLastNewValue) * timeBasedReward) / 300; //.5 TRB per 5 minutes\n        uint256 _totalTimeBasedRewardsBalance =\n            token.balanceOf(address(this)) -\n            (totalStakeAmount + stakingRewardsBalance + toWithdraw);\n        if (_totalTimeBasedRewardsBalance > 0 && _reward > 0) {\n            if (_totalTimeBasedRewardsBalance < _reward) {\n                token.transfer(msg.sender, _totalTimeBasedRewardsBalance);\n            } else {\n                token.transfer(msg.sender, _reward);\n            }\n        }\n        // Update last oracle value and number of values submitted by a reporter\n        timeOfLastNewValue = block.timestamp;\n        unchecked{\n            _staker.reportsSubmitted++;\n        }\n        emit NewReport(\n            _queryId,\n            block.timestamp,\n            _value,\n            _nonce,\n            _queryData,\n            msg.sender\n        );\n    }\n\n    /**\n     * @dev Updates the stake amount after retrieving the latest\n     * 12+-hour-old staking token price from the oracle\n     */\n    function updateStakeAmount() external {\n        // get staking token price\n        (bool _valFound, bytes memory _val, ) = getDataBefore(\n            stakingTokenPriceQueryId,\n            block.timestamp - 12 hours\n        );\n        if (_valFound) {\n            uint256 _stakingTokenPrice = abi.decode(_val, (uint256));\n            require(\n                _stakingTokenPrice >= 0.01 ether && _stakingTokenPrice < 1000000 ether,\n                \"invalid staking token price\"\n            );\n\n            uint256 _adjustedStakeAmount = (stakeAmountDollarTarget * 1e18) / _stakingTokenPrice;\n            if(_adjustedStakeAmount < minimumStakeAmount) {\n                stakeAmount = minimumStakeAmount;\n            } else {\n                stakeAmount = _adjustedStakeAmount;\n            }\n            emit NewStakeAmount(stakeAmount);\n        }\n    }\n\n    /**\n     * @dev Withdraws a reporter's stake after the lock period expires\n     */\n    function withdrawStake() external {\n        StakeInfo storage _staker = stakerDetails[msg.sender];\n        // Ensure reporter is locked and that enough time has passed\n        require(\n            block.timestamp - _staker.startDate >= 7 days,\n            \"7 days didn't pass\"\n        );\n        require(\n            _staker.lockedBalance > 0,\n            \"reporter not locked for withdrawal\"\n        );\n        require(token.transfer(msg.sender, _staker.lockedBalance));\n        toWithdraw -= _staker.lockedBalance;\n        _staker.lockedBalance = 0;\n        emit StakeWithdrawn(msg.sender);\n    }\n\n    // *****************************************************************************\n    // *                                                                           *\n    // *                               Getters                                     *\n    // *                                                                           *\n    // *****************************************************************************\n\n    /**\n     * @dev Returns the current value of a data feed given a specific ID\n     * @param _queryId is the ID of the specific data feed\n     * @return _value the latest submitted value for the given queryId\n     */\n    function getCurrentValue(bytes32 _queryId)\n        external\n        view\n        returns (bytes memory _value)\n    {\n        bool _didGet;\n        (_didGet, _value, ) = getDataBefore(_queryId, block.timestamp + 1);\n        if(!_didGet){revert();}\n    }\n\n    /**\n     * @dev Retrieves the latest value for the queryId before the specified timestamp\n     * @param _queryId is the queryId to look up the value for\n     * @param _timestamp before which to search for latest value\n     * @return _ifRetrieve bool true if able to retrieve a non-zero value\n     * @return _value the value retrieved\n     * @return _timestampRetrieved the value's timestamp\n     */\n    function getDataBefore(bytes32 _queryId, uint256 _timestamp)\n        public\n        view\n        returns (\n            bool _ifRetrieve,\n            bytes memory _value,\n            uint256 _timestampRetrieved\n        )\n    {\n        (bool _found, uint256 _index) = getIndexForDataBefore(\n            _queryId,\n            _timestamp\n        );\n        if (!_found) return (false, bytes(\"\"), 0);\n        _timestampRetrieved = getTimestampbyQueryIdandIndex(_queryId, _index);\n        _value = retrieveData(_queryId, _timestampRetrieved);\n        return (true, _value, _timestampRetrieved);\n    }\n\n    /**\n     * @dev Returns governance address\n     * @return address governance\n     */\n    function getGovernanceAddress() external view returns (address) {\n        return governance;\n    }\n\n    /**\n     * @dev Counts the number of values that have been submitted for the request.\n     * @param _queryId the id to look up\n     * @return uint256 count of the number of values received for the id\n     */\n    function getNewValueCountbyQueryId(bytes32 _queryId)\n        public\n        view\n        returns (uint256)\n    {\n        return reports[_queryId].timestamps.length;\n    }\n\n    /**\n     * @dev Returns the pending staking reward for a given address\n     * @param _stakerAddress staker address to look up\n     * @return _pendingReward - pending reward for given staker\n     */\n    function getPendingRewardByStaker(address _stakerAddress)\n        external\n        returns (uint256 _pendingReward)\n    {\n        StakeInfo storage _staker = stakerDetails[_stakerAddress];\n        _pendingReward = (_staker.stakedBalance *\n            _getUpdatedAccumulatedRewardPerShare()) /\n            1e18 -\n            _staker.rewardDebt;\n        (bool _success, bytes memory _returnData) = governance.call(\n            abi.encodeWithSignature(\"getVoteCount()\")\n        );\n        uint256 _numberOfVotes;\n        if (_success) {\n                _numberOfVotes = uint256(abi.decode(_returnData, (uint256))) - _staker.startVoteCount;\n        }\n        if (_numberOfVotes > 0) {\n                (_success,_returnData) = governance.call(\n                    abi.encodeWithSignature(\"getVoteTallyByAddress(address)\",_stakerAddress)\n                );\n                if(_success){\n                    _pendingReward =\n                        (_pendingReward * (abi.decode(_returnData,(uint256)) - _staker.startVoteTally)) \n                        / _numberOfVotes;\n                }\n        }\n    }\n\n    /**\n     * @dev Returns the real staking rewards balance after accounting for unclaimed rewards\n     * @return uint256 real staking rewards balance\n     */\n    function getRealStakingRewardsBalance() external view returns (uint256) {\n        uint256 _pendingRewards = (_getUpdatedAccumulatedRewardPerShare() *\n            totalStakeAmount) /\n            1e18 -\n            totalRewardDebt;\n        return (stakingRewardsBalance - _pendingRewards);\n    }\n\n    /**\n     * @dev Returns reporter address and whether a value was removed for a given queryId and timestamp\n     * @param _queryId the id to look up\n     * @param _timestamp is the timestamp of the value to look up\n     * @return address reporter who submitted the value\n     * @return bool true if the value was removed\n     */\n    function getReportDetails(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (address, bool)\n    {\n        return (reports[_queryId].reporterByTimestamp[_timestamp], reports[_queryId].isDisputed[_timestamp]);\n    }\n\n    /**\n     * @dev Returns the address of the reporter who submitted a value for a data ID at a specific time\n     * @param _queryId is ID of the specific data feed\n     * @param _timestamp is the timestamp to find a corresponding reporter for\n     * @return address of the reporter who reported the value for the data ID at the given timestamp\n     */\n    function getReporterByTimestamp(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (address)\n    {\n        return reports[_queryId].reporterByTimestamp[_timestamp];\n    }\n\n    /**\n     * @dev Returns the timestamp of the reporter's last submission\n     * @param _reporter is address of the reporter\n     * @return uint256 timestamp of the reporter's last submission\n     */\n    function getReporterLastTimestamp(address _reporter)\n        external\n        view\n        returns (uint256)\n    {\n        return stakerDetails[_reporter].reporterLastTimestamp;\n    }\n\n    /**\n     * @dev Returns the reporting lock time, the amount of time a reporter must wait to submit again\n     * @return uint256 reporting lock time\n     */\n    function getReportingLock() external view returns (uint256) {\n        return reportingLock;\n    }\n\n    /**\n     * @dev Returns the number of values submitted by a specific reporter address\n     * @param _reporter is the address of a reporter\n     * @return uint256 the number of values submitted by the given reporter\n     */\n    function getReportsSubmittedByAddress(address _reporter)\n        external\n        view\n        returns (uint256)\n    {\n        return stakerDetails[_reporter].reportsSubmitted;\n    }\n\n    /**\n     * @dev Returns amount required to report oracle values\n     * @return uint256 stake amount\n     */\n    function getStakeAmount() external view returns (uint256) {\n        return stakeAmount;\n    }\n\n    /**\n     * @dev Returns all information about a staker\n     * @param _stakerAddress address of staker inquiring about\n     * @return uint startDate of staking\n     * @return uint current amount staked\n     * @return uint current amount locked for withdrawal\n     * @return uint reward debt used to calculate staking rewards\n     * @return uint reporter's last reported timestamp\n     * @return uint total number of reports submitted by reporter\n     * @return uint governance vote count when first staked\n     * @return uint number of votes cast by staker when first staked\n     * @return bool whether staker is counted in totalStakers\n     */\n    function getStakerInfo(address _stakerAddress)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        StakeInfo storage _staker = stakerDetails[_stakerAddress];\n        return (\n            _staker.startDate,\n            _staker.stakedBalance,\n            _staker.lockedBalance,\n            _staker.rewardDebt,\n            _staker.reporterLastTimestamp,\n            _staker.reportsSubmitted,\n            _staker.startVoteCount,\n            _staker.startVoteTally,\n            _staker.staked\n        );\n    }\n\n    /**\n     * @dev Returns the timestamp for the last value of any ID from the oracle\n     * @return uint256 timestamp of the last oracle value\n     */\n    function getTimeOfLastNewValue() external view returns (uint256) {\n        return timeOfLastNewValue;\n    }\n\n    /**\n     * @dev Gets the timestamp for the value based on their index\n     * @param _queryId is the id to look up\n     * @param _index is the value index to look up\n     * @return uint256 timestamp\n     */\n    function getTimestampbyQueryIdandIndex(bytes32 _queryId, uint256 _index)\n        public\n        view\n        returns (uint256)\n    {\n        return reports[_queryId].timestamps[_index];\n    }\n\n    /**\n     * @dev Retrieves latest array index of data before the specified timestamp for the queryId\n     * @param _queryId is the queryId to look up the index for\n     * @param _timestamp is the timestamp before which to search for the latest index\n     * @return _found whether the index was found\n     * @return _index the latest index found before the specified timestamp\n     */\n    // slither-disable-next-line calls-loop\n    function getIndexForDataBefore(bytes32 _queryId, uint256 _timestamp)\n        public\n        view\n        returns (bool _found, uint256 _index)\n    {\n        uint256 _count = getNewValueCountbyQueryId(_queryId);\n        if (_count > 0) {\n            uint256 _middle;\n            uint256 _start = 0;\n            uint256 _end = _count - 1;\n            uint256 _time;\n            //Checking Boundaries to short-circuit the algorithm\n            _time = getTimestampbyQueryIdandIndex(_queryId, _start);\n            if (_time >= _timestamp) return (false, 0);\n            _time = getTimestampbyQueryIdandIndex(_queryId, _end);\n            if (_time < _timestamp) {\n                while(isInDispute(_queryId, _time) && _end > 0) {\n                    _end--;\n                    _time = getTimestampbyQueryIdandIndex(_queryId, _end);\n                }\n                if(_end == 0 && isInDispute(_queryId, _time)) {\n                    return (false, 0);\n                }\n                return (true, _end);\n            }\n            //Since the value is within our boundaries, do a binary search\n            while (true) {\n                _middle = (_end - _start) / 2 + 1 + _start;\n                _time = getTimestampbyQueryIdandIndex(_queryId, _middle);\n                if (_time < _timestamp) {\n                    //get immediate next value\n                    uint256 _nextTime = getTimestampbyQueryIdandIndex(\n                        _queryId,\n                        _middle + 1\n                    );\n                    if (_nextTime >= _timestamp) {\n                        if(!isInDispute(_queryId, _time)) {\n                            // _time is correct\n                            return (true, _middle);\n                        } else {\n                            // iterate backwards until we find a non-disputed value\n                            while(isInDispute(_queryId, _time) && _middle > 0) {\n                                _middle--;\n                                _time = getTimestampbyQueryIdandIndex(_queryId, _middle);\n                            }\n                            if(_middle == 0 && isInDispute(_queryId, _time)) {\n                                return (false, 0);\n                            }\n                            // _time is correct\n                            return (true, _middle);\n                        }\n                    } else {\n                        //look from middle + 1(next value) to end\n                        _start = _middle + 1;\n                    }\n                } else {\n                    uint256 _prevTime = getTimestampbyQueryIdandIndex(\n                        _queryId,\n                        _middle - 1\n                    );\n                    if (_prevTime < _timestamp) {\n                        if(!isInDispute(_queryId, _prevTime)) {\n                            // _prevTime is correct\n                            return (true, _middle - 1);\n                        } else {\n                            // iterate backwards until we find a non-disputed value\n                            _middle--;\n                            while(isInDispute(_queryId, _prevTime) && _middle > 0) {\n                                _middle--;\n                                _prevTime = getTimestampbyQueryIdandIndex(\n                                    _queryId,\n                                    _middle\n                                );\n                            }\n                            if(_middle == 0 && isInDispute(_queryId, _prevTime)) {\n                                return (false, 0);\n                            }\n                            // _prevtime is correct\n                            return (true, _middle);\n                        }\n                    } else {\n                        //look from start to middle -1(prev value)\n                        _end = _middle - 1;\n                    }\n                }\n            }\n        }\n        return (false, 0);\n    }\n\n    /**\n     * @dev Returns the index of a reporter timestamp in the timestamp array for a specific data ID\n     * @param _queryId is ID of the specific data feed\n     * @param _timestamp is the timestamp to find in the timestamps array\n     * @return uint256 of the index of the reporter timestamp in the array for specific ID\n     */\n    function getTimestampIndexByTimestamp(bytes32 _queryId, uint256 _timestamp)\n        external\n        view\n        returns (uint256)\n    {\n        return reports[_queryId].timestampIndex[_timestamp];\n    }\n\n    /**\n     * @dev Returns the address of the token used for staking\n     * @return address of the token used for staking\n     */\n    function getTokenAddress() external view returns (address) {\n        return address(token);\n    }\n\n    /**\n     * @dev Returns total amount of token staked for reporting\n     * @return uint256 total amount of token staked\n     */\n    function getTotalStakeAmount() external view returns (uint256) {\n        return totalStakeAmount;\n    }\n\n    /**\n     * @dev Returns total number of current stakers. Reporters with stakedBalance less than stakeAmount are excluded from this total\n     * @return uint256 total stakers\n     */\n    function getTotalStakers() external view returns (uint256) {\n        return totalStakers;\n    }\n\n    /**\n     * @dev Returns total balance of time based rewards in contract\n     * @return uint256 amount of trb\n     */\n    function getTotalTimeBasedRewardsBalance() external view returns (uint256) {\n        return token.balanceOf(address(this)) - (totalStakeAmount + stakingRewardsBalance + toWithdraw);\n    }\n\n    /**\n     * @dev Returns whether a given value is disputed\n     * @param _queryId unique ID of the data feed\n     * @param _timestamp timestamp of the value\n     * @return bool whether the value is disputed\n     */\n    function isInDispute(bytes32 _queryId, uint256 _timestamp)\n        public\n        view\n        returns (bool)\n    {\n        return reports[_queryId].isDisputed[_timestamp];\n    }\n\n    /**\n     * @dev Retrieve value from oracle based on timestamp\n     * @param _queryId being requested\n     * @param _timestamp to retrieve data/value from\n     * @return bytes value for timestamp submitted\n     */\n    function retrieveData(bytes32 _queryId, uint256 _timestamp)\n        public\n        view\n        returns (bytes memory)\n    {\n        return reports[_queryId].valueByTimestamp[_timestamp];\n    }\n\n    /**\n     * @dev Used during the upgrade process to verify valid Tellor contracts\n     * @return bool value used to verify valid Tellor contracts\n     */\n    function verify() external pure returns (uint256) {\n        return 9999;\n    }\n\n    // *****************************************************************************\n    // *                                                                           *\n    // *                          Internal functions                               *\n    // *                                                                           *\n    // *****************************************************************************\n\n    /**\n     * @dev Updates accumulated staking rewards per staked token\n     */\n    function _updateRewards() internal {\n        if (timeOfLastAllocation == block.timestamp) {\n            return;\n        }\n        if (totalStakeAmount == 0 || rewardRate == 0) {\n            timeOfLastAllocation = block.timestamp;\n            return;\n        }\n        // calculate accumulated reward per token staked\n        uint256 _newAccumulatedRewardPerShare = accumulatedRewardPerShare +\n            ((block.timestamp - timeOfLastAllocation) * rewardRate * 1e18) /\n            totalStakeAmount;\n        // calculate accumulated reward with _newAccumulatedRewardPerShare\n        uint256 _accumulatedReward = (_newAccumulatedRewardPerShare *\n            totalStakeAmount) /\n            1e18 -\n            totalRewardDebt;\n        if (_accumulatedReward >= stakingRewardsBalance) {\n            // if staking rewards run out, calculate remaining reward per staked\n            // token and set rewardRate to 0\n            uint256 _newPendingRewards = stakingRewardsBalance -\n                ((accumulatedRewardPerShare * totalStakeAmount) /\n                    1e18 -\n                    totalRewardDebt);\n            accumulatedRewardPerShare +=\n                (_newPendingRewards * 1e18) /\n                totalStakeAmount;\n            rewardRate = 0;\n        } else {\n            accumulatedRewardPerShare = _newAccumulatedRewardPerShare;\n        }\n        timeOfLastAllocation = block.timestamp;\n    }\n\n    /**\n     * @dev Called whenever a user's stake amount changes. First updates staking rewards,\n     * transfers pending rewards to user's address, and finally updates user's stake amount\n     * and other relevant variables.\n     * @param _stakerAddress address of user whose stake is being updated\n     * @param _newStakedBalance new staked balance of user\n     */\n    function _updateStakeAndPayRewards(\n        address _stakerAddress,\n        uint256 _newStakedBalance\n    ) internal {\n        _updateRewards();\n        StakeInfo storage _staker = stakerDetails[_stakerAddress];\n        if (_staker.stakedBalance > 0) {\n            // if address already has a staked balance, calculate and transfer pending rewards\n            uint256 _pendingReward = (_staker.stakedBalance *\n                accumulatedRewardPerShare) /\n                1e18 -\n                _staker.rewardDebt;\n            // get staker voting participation rate\n            uint256 _numberOfVotes;\n            (bool _success, bytes memory _returnData) = governance.call(\n                abi.encodeWithSignature(\"getVoteCount()\")\n            );\n            if (_success) {\n                _numberOfVotes =\n                    uint256(abi.decode(_returnData, (uint256))) -\n                    _staker.startVoteCount;\n            }\n            if (_numberOfVotes > 0) {\n                // staking reward = pending reward * voting participation rate\n                (_success, _returnData) = governance.call(\n                    abi.encodeWithSignature(\"getVoteTallyByAddress(address)\",_stakerAddress)\n                );\n                if(_success){\n                    uint256 _voteTally = abi.decode(_returnData,(uint256));\n                    uint256 _tempPendingReward =\n                        (_pendingReward *\n                            (_voteTally - _staker.startVoteTally)) /\n                        _numberOfVotes;\n                    if (_tempPendingReward < _pendingReward) {\n                        _pendingReward = _tempPendingReward;\n                    }\n                }\n            }\n            stakingRewardsBalance -= _pendingReward;\n            require(token.transfer(msg.sender, _pendingReward));\n            totalRewardDebt -= _staker.rewardDebt;\n            totalStakeAmount -= _staker.stakedBalance;\n        }\n        _staker.stakedBalance = _newStakedBalance;\n        // Update total stakers\n        if (_staker.stakedBalance >= stakeAmount) {\n            if (_staker.staked == false) {\n                totalStakers++;\n            }\n            _staker.staked = true;\n        } else {\n            if (_staker.staked == true && totalStakers > 0) {\n                totalStakers--;\n            }\n            _staker.staked = false;\n        }\n        // tracks rewards accumulated before stake amount updated\n        _staker.rewardDebt =\n            (_staker.stakedBalance * accumulatedRewardPerShare) /\n            1e18;\n        totalRewardDebt += _staker.rewardDebt;\n        totalStakeAmount += _staker.stakedBalance;\n        // update reward rate if staking rewards are available \n        // given staker's updated parameters\n        if(rewardRate == 0) {\n            rewardRate =\n            (stakingRewardsBalance -\n                ((accumulatedRewardPerShare * totalStakeAmount) /\n                    1e18 -\n                    totalRewardDebt)) /\n            30 days;\n        }\n    }\n\n    /**\n     * @dev Internal function retrieves updated accumulatedRewardPerShare\n     * @return uint256 up-to-date accumulated reward per share\n     */\n    function _getUpdatedAccumulatedRewardPerShare()\n        internal\n        view\n        returns (uint256)\n    {\n        if (totalStakeAmount == 0) {\n            return accumulatedRewardPerShare;\n        }\n        uint256 _newAccumulatedRewardPerShare = accumulatedRewardPerShare +\n            ((block.timestamp - timeOfLastAllocation) * rewardRate * 1e18) /\n            totalStakeAmount;\n        uint256 _accumulatedReward = (_newAccumulatedRewardPerShare *\n            totalStakeAmount) /\n            1e18 -\n            totalRewardDebt;\n        if (_accumulatedReward >= stakingRewardsBalance) {\n            uint256 _newPendingRewards = stakingRewardsBalance -\n                ((accumulatedRewardPerShare * totalStakeAmount) /\n                    1e18 -\n                    totalRewardDebt);\n            _newAccumulatedRewardPerShare =\n                accumulatedRewardPerShare +\n                (_newPendingRewards * 1e18) /\n                totalStakeAmount;\n        }\n        return _newAccumulatedRewardPerShare;\n    }\n}\n"}},"settings":{"libraries":{},"optimizer":{"enabled":true,"runs":300},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}}},"ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_reportingLock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakeAmountDollarTarget\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_stakingTokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minimumStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_stakingTokenPriceQueryId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_value\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_queryData\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_reporter\",\"type\":\"address\"}],\"name\":\"NewReport\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newStakeAmount\",\"type\":\"uint256\"}],\"name\":\"NewStakeAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"NewStaker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_reporter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_slashAmount\",\"type\":\"uint256\"}],\"name\":\"ReporterSlashed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"StakeWithdrawRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"StakeWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"ValueRemoved\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accumulatedRewardPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addStakingRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"}],\"name\":\"getCurrentValue\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"_value\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getDataBefore\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_ifRetrieve\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"_value\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_timestampRetrieved\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGovernanceAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getIndexForDataBefore\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_found\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"}],\"name\":\"getNewValueCountbyQueryId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakerAddress\",\"type\":\"address\"}],\"name\":\"getPendingRewardByStaker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_pendingReward\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRealStakingRewardsBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getReportDetails\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getReporterByTimestamp\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reporter\",\"type\":\"address\"}],\"name\":\"getReporterLastTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReportingLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reporter\",\"type\":\"address\"}],\"name\":\"getReportsSubmittedByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakerAddress\",\"type\":\"address\"}],\"name\":\"getStakerInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTimeOfLastNewValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"getTimestampIndexByTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getTimestampbyQueryIdandIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStakeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalStakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalTimeBasedRewardsBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governanceAddress\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"isInDispute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumStakeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"removeValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reportingLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"requestStakingWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"retrieveData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_reporter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"slashReporter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_slashAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeAmountDollarTarget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingRewardsBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingTokenPriceQueryId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_queryId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_value\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_queryData\",\"type\":\"bytes\"}],\"name\":\"submitValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeBasedReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeOfLastAllocation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeOfLastNewValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRewardDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateStakeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"TellorFlex","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":1,"Runs":300,"ConstructorArguments":"0x00000000000000000000000088df592f8eb5d7bd38bfef7deb0fbc02cf3778a0000000000000000000000000000000000000000000000000000000000000a8c000000000000000000000000000000000000000000000005150ae84a8cdf0000000000000000000000000000000000000000000000000000324e964b3eca800000000000000000000000000000000000000000000000000056bc75e2d631000005c13cd9c97dbb98f2429c101a2a8150e6c7a0ddaff6124ee176a3a411067ded0","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}