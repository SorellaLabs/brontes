{"expiry":1699495174,"data":[{"SourceCode":{"language":"Solidity","sources":{"contracts/Dependencies/SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\n/**\n * Based on OpenZeppelin's SafeMath:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\n *\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"},"contracts/Dependencies/TellorCaller.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\nimport \"../Interfaces/ITellorCaller.sol\";\nimport \"./ITellor.sol\";\nimport \"./SafeMath.sol\";\n/*\n* This contract has a single external function that calls Tellor: getTellorCurrentValue(). \n*\n* The function is called by the Liquity contract PriceFeed.sol. If any of its inner calls to Tellor revert, \n* this function will revert, and PriceFeed will catch the failure and handle it accordingly.\n*\n* The function comes from Tellor's own wrapper contract, 'UsingTellor.sol':\n* https://github.com/tellor-io/usingtellor/blob/master/contracts/UsingTellor.sol\n*\n*/\ncontract TellorCaller is ITellorCaller {\n    using SafeMath for uint256;\n\n    ITellor public tellor;\n\n    constructor (address _tellorMasterAddress) public {\n        tellor = ITellor(_tellorMasterAddress);\n    }\n\n    /*\n    * getTellorCurrentValue(): identical to getCurrentValue() in UsingTellor.sol\n    *\n    * @dev Allows the user to get the latest value for the requestId specified\n    * @param _requestId is the requestId to look up the value for\n    * @return ifRetrieve bool true if it is able to retrieve a value, the value, and the value's timestamp\n    * @return value the value retrieved\n    * @return _timestampRetrieved the value's timestamp\n    */\n    function getTellorCurrentValue(uint256 _requestId)\n        external\n        view\n        override\n        returns (\n            bool ifRetrieve,\n            uint256 value,\n            uint256 _timestampRetrieved\n        )\n    {\n        uint256 _count = tellor.getNewValueCountbyRequestId(_requestId);\n        uint256 _time =\n            tellor.getTimestampbyRequestIDandIndex(_requestId, _count.sub(1));\n        uint256 _value = tellor.retrieveData(_requestId, _time);\n        if (_value > 0) return (true, _value, _time);\n        return (false, 0, _time);\n    }\n}\n"},"contracts/Interfaces/ITellorCaller.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.11;\n\ninterface ITellorCaller {\n    function getTellorCurrentValue(uint256 _requestId) external view returns (bool, uint256, uint256);\n}"},"contracts/Dependencies/ITellor.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.6.11;\n\ninterface ITellor {\n    /**\n     * @dev Helps initialize a dispute by assigning it a disputeId\n     * when a miner returns a false on the validate array(in Tellor.ProofOfWork) it sends the\n     * invalidated value information to POS voting\n     * @param _requestId being disputed\n     * @param _timestamp being disputed\n     * @param _minerIndex the index of the miner that submitted the value being disputed. Since each official value\n     * requires 5 miners to submit a value.\n     */\n    function beginDispute(\n        uint256 _requestId,\n        uint256 _timestamp,\n        uint256 _minerIndex\n    ) external;\n\n    /**\n     * @dev Allows token holders to vote\n     * @param _disputeId is the dispute id\n     * @param _supportsDispute is the vote (true=the dispute has basis false = vote against dispute)\n     */\n    function vote(uint256 _disputeId, bool _supportsDispute) external;\n\n    /**\n     * @dev tallies the votes.\n     * @param _disputeId is the dispute id\n     */\n    function tallyVotes(uint256 _disputeId) external;\n\n    /**\n     * @dev Allows for a fork to be proposed\n     * @param _propNewTellorAddress address for new proposed Tellor\n     */\n    function proposeFork(address _propNewTellorAddress) external;\n\n    /**\n     * @dev Add tip to Request value from oracle\n     * @param _requestId being requested to be mined\n     * @param _tip amount the requester is willing to pay to be get on queue. Miners\n     * mine the onDeckQueryHash, or the api with the highest payout pool\n     */\n    function addTip(uint256 _requestId, uint256 _tip) external;\n\n    /**\n     * @dev This is called by the miner when they submit the PoW solution (proof of work and value)\n     * @param _nonce uint submitted by miner\n     * @param _requestId the apiId being mined\n     * @param _value of api query\n     *\n     */\n    function submitMiningSolution(\n        string calldata _nonce,\n        uint256 _requestId,\n        uint256 _value\n    ) external;\n\n    /**\n     * @dev This is called by the miner when they submit the PoW solution (proof of work and value)\n     * @param _nonce uint submitted by miner\n     * @param _requestId is the array of the 5 PSR's being mined\n     * @param _value is an array of 5 values\n     */\n    function submitMiningSolution(\n        string calldata _nonce,\n        uint256[5] calldata _requestId,\n        uint256[5] calldata _value\n    ) external;\n\n    /**\n     * @dev Allows the current owner to propose transfer control of the contract to a\n     * newOwner and the ownership is pending until the new owner calls the claimOwnership\n     * function\n     * @param _pendingOwner The address to transfer ownership to.\n     */\n    function proposeOwnership(address payable _pendingOwner) external;\n\n    /**\n     * @dev Allows the new owner to claim control of the contract\n     */\n    function claimOwnership() external;\n\n    /**\n     * @dev This function allows miners to deposit their stake.\n     */\n    function depositStake() external;\n\n    /**\n     * @dev This function allows stakers to request to withdraw their stake (no longer stake)\n     * once they lock for withdraw(stakes.currentStatus = 2) they are locked for 7 days before they\n     * can withdraw the stake\n     */\n    function requestStakingWithdraw() external;\n\n    /**\n     * @dev This function allows users to withdraw their stake after a 7 day waiting period from request\n     */\n    function withdrawStake() external;\n\n    /**\n     * @dev This function approves a _spender an _amount of tokens to use\n     * @param _spender address\n     * @param _amount amount the spender is being approved for\n     * @return true if spender appproved successfully\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool);\n\n    /**\n     * @dev Allows for a transfer of tokens to _to\n     * @param _to The address to send tokens to\n     * @param _amount The amount of tokens to send\n     * @return true if transfer is successful\n     */\n    function transfer(address _to, uint256 _amount) external returns (bool);\n\n    /**\n     * @dev Sends _amount tokens to _to from _from on the condition it\n     * is approved by _from\n     * @param _from The address holding the tokens being transferred\n     * @param _to The address of the recipient\n     * @param _amount The amount of tokens to be transferred\n     * @return True if the transfer was successful\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external returns (bool);\n\n    /**\n     * @dev Allows users to access the token's name\n     */\n    function name() external pure returns (string memory);\n\n    /**\n     * @dev Allows users to access the token's symbol\n     */\n    function symbol() external pure returns (string memory);\n\n    /**\n     * @dev Allows users to access the number of decimals\n     */\n    function decimals() external pure returns (uint8);\n\n    /**\n     * @dev Getter for the current variables that include the 5 requests Id's\n     * @return _challenge _requestIds _difficultky _tip the challenge, 5 requestsId, difficulty and tip\n     */\n    function getNewCurrentVariables()\n        external\n        view\n        returns (\n            bytes32 _challenge,\n            uint256[5] memory _requestIds,\n            uint256 _difficutly,\n            uint256 _tip\n        );\n\n    /**\n     * @dev Getter for the top tipped 5 requests Id's\n     * @return _requestIds the 5 requestsId\n     */\n    function getTopRequestIDs()\n        external\n        view\n        returns (uint256[5] memory _requestIds);\n\n    /**\n     * @dev Getter for the 5 requests Id's next in line to get mined\n     * @return idsOnDeck tipsOnDeck  the 5 requestsId\n     */\n    function getNewVariablesOnDeck()\n        external\n        view\n        returns (uint256[5] memory idsOnDeck, uint256[5] memory tipsOnDeck);\n\n    /**\n     * @dev Updates the Tellor address after a proposed fork has\n     * passed the vote and day has gone by without a dispute\n     * @param _disputeId the disputeId for the proposed fork\n     */\n    function updateTellor(uint256 _disputeId) external;\n\n    /**\n     * @dev Allows disputer to unlock the dispute fee\n     * @param _disputeId to unlock fee from\n     */\n    function unlockDisputeFee(uint256 _disputeId) external;\n\n    /**\n     * @param _user address\n     * @param _spender address\n     * @return Returns the remaining allowance of tokens granted to the _spender from the _user\n     */\n    function allowance(address _user, address _spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev This function returns whether or not a given user is allowed to trade a given amount\n     * @param _user address\n     * @param _amount uint of amount\n     * @return true if the user is alloed to trade the amount specified\n     */\n    function allowedToTrade(address _user, uint256 _amount)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Gets balance of owner specified\n     * @param _user is the owner address used to look up the balance\n     * @return Returns the balance associated with the passed in _user\n     */\n    function balanceOf(address _user) external view returns (uint256);\n\n    /**\n     * @dev Queries the balance of _user at a specific _blockNumber\n     * @param _user The address from which the balance will be retrieved\n     * @param _blockNumber The block number when the balance is queried\n     * @return The balance at _blockNumber\n     */\n    function balanceOfAt(address _user, uint256 _blockNumber)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev This function tells you if a given challenge has been completed by a given miner\n     * @param _challenge the challenge to search for\n     * @param _miner address that you want to know if they solved the challenge\n     * @return true if the _miner address provided solved the\n     */\n    function didMine(bytes32 _challenge, address _miner)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Checks if an address voted in a given dispute\n     * @param _disputeId to look up\n     * @param _address to look up\n     * @return bool of whether or not party voted\n     */\n    function didVote(uint256 _disputeId, address _address)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev allows Tellor to read data from the addressVars mapping\n     * @param _data is the keccak256(\"variable_name\") of the variable that is being accessed.\n     * These are examples of how the variables are saved within other functions:\n     * addressVars[keccak256(\"_owner\")]\n     * addressVars[keccak256(\"tellorContract\")]\n     * return address\n     */\n    function getAddressVars(bytes32 _data) external view returns (address);\n\n    /**\n     * @dev Gets all dispute variables\n     * @param _disputeId to look up\n     * @return bytes32 hash of dispute\n     * @return bool executed where true if it has been voted on\n     * @return bool disputeVotePassed\n     * @return bool isPropFork true if the dispute is a proposed fork\n     * @return address of reportedMiner\n     * @return address of reportingParty\n     * @return address of proposedForkAddress\n     *    uint of requestId\n     *    uint of timestamp\n     *    uint of value\n     *    uint of minExecutionDate\n     *    uint of numberOfVotes\n     *    uint of blocknumber\n     *    uint of minerSlot\n     *    uint of quorum\n     *    uint of fee\n     * @return int count of the current tally\n     */\n    function getAllDisputeVars(uint256 _disputeId)\n        external\n        view\n        returns (\n            bytes32,\n            bool,\n            bool,\n            bool,\n            address,\n            address,\n            address,\n            uint256[9] memory,\n            int256\n        );\n\n    /**\n     * @dev Getter function for variables for the requestId being currently mined(currentRequestId)\n     * @return current challenge, curretnRequestId, level of difficulty, api/query string, and granularity(number of decimals requested), total tip for the request\n     */\n    function getCurrentVariables()\n        external\n        view\n        returns (\n            bytes32,\n            uint256,\n            uint256,\n            string memory,\n            uint256,\n            uint256\n        );\n\n    /**\n     * @dev Checks if a given hash of miner,requestId has been disputed\n     * @param _hash is the sha256(abi.encodePacked(_miners[2],_requestId));\n     * @return uint disputeId\n     */\n    function getDisputeIdByDisputeHash(bytes32 _hash)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Checks for uint variables in the disputeUintVars mapping based on the disuputeId\n     * @param _disputeId is the dispute id;\n     * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\n     * the variables/strings used to save the data in the mapping. The variables names are\n     * commented out under the disputeUintVars under the Dispute struct\n     * @return uint value for the bytes32 data submitted\n     */\n    function getDisputeUintVars(uint256 _disputeId, bytes32 _data)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Gets the a value for the latest timestamp available\n     * @return value for timestamp of last proof of work submited\n     * @return true if the is a timestamp for the lastNewValue\n     */\n    function getLastNewValue() external view returns (uint256, bool);\n\n    /**\n     * @dev Gets the a value for the latest timestamp available\n     * @param _requestId being requested\n     * @return value for timestamp of last proof of work submited and if true if it exist or 0 and false if it doesn't\n     */\n    function getLastNewValueById(uint256 _requestId)\n        external\n        view\n        returns (uint256, bool);\n\n    /**\n     * @dev Gets blocknumber for mined timestamp\n     * @param _requestId to look up\n     * @param _timestamp is the timestamp to look up blocknumber\n     * @return uint of the blocknumber which the dispute was mined\n     */\n    function getMinedBlockNum(uint256 _requestId, uint256 _timestamp)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\n     * @param _requestId to look up\n     * @param _timestamp is the timestamp to look up miners for\n     * @return the 5 miners' addresses\n     */\n    function getMinersByRequestIdAndTimestamp(\n        uint256 _requestId,\n        uint256 _timestamp\n    ) external view returns (address[5] memory);\n\n    /**\n     * @dev Counts the number of values that have been submited for the request\n     * if called for the currentRequest being mined it can tell you how many miners have submitted a value for that\n     * request so far\n     * @param _requestId the requestId to look up\n     * @return uint count of the number of values received for the requestId\n     */\n    function getNewValueCountbyRequestId(uint256 _requestId)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Getter function for the specified requestQ index\n     * @param _index to look up in the requestQ array\n     * @return uint of reqeuestId\n     */\n    function getRequestIdByRequestQIndex(uint256 _index)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Getter function for requestId based on timestamp\n     * @param _timestamp to check requestId\n     * @return uint of reqeuestId\n     */\n    function getRequestIdByTimestamp(uint256 _timestamp)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Getter function for requestId based on the queryHash\n     * @param _request is the hash(of string api and granularity) to check if a request already exists\n     * @return uint requestId\n     */\n    function getRequestIdByQueryHash(bytes32 _request)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Getter function for the requestQ array\n     * @return the requestQ arrray\n     */\n    function getRequestQ() external view returns (uint256[51] memory);\n\n    /**\n     * @dev Allowes access to the uint variables saved in the apiUintVars under the requestDetails struct\n     * for the requestId specified\n     * @param _requestId to look up\n     * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\n     * the variables/strings used to save the data in the mapping. The variables names are\n     * commented out under the apiUintVars under the requestDetails struct\n     * @return uint value of the apiUintVars specified in _data for the requestId specified\n     */\n    function getRequestUintVars(uint256 _requestId, bytes32 _data)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Gets the API struct variables that are not mappings\n     * @param _requestId to look up\n     * @return string of api to query\n     * @return string of symbol of api to query\n     * @return bytes32 hash of string\n     * @return bytes32 of the granularity(decimal places) requested\n     * @return uint of index in requestQ array\n     * @return uint of current payout/tip for this requestId\n     */\n    function getRequestVars(uint256 _requestId)\n        external\n        view\n        returns (\n            string memory,\n            string memory,\n            bytes32,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    /**\n     * @dev This function allows users to retireve all information about a staker\n     * @param _staker address of staker inquiring about\n     * @return uint current state of staker\n     * @return uint startDate of staking\n     */\n    function getStakerInfo(address _staker)\n        external\n        view\n        returns (uint256, uint256);\n\n    /**\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\n     * @param _requestId to look up\n     * @param _timestamp is the timestampt to look up miners for\n     * @return address[5] array of 5 addresses ofminers that mined the requestId\n     */\n    function getSubmissionsByTimestamp(uint256 _requestId, uint256 _timestamp)\n        external\n        view\n        returns (uint256[5] memory);\n\n    /**\n     * @dev Gets the timestamp for the value based on their index\n     * @param _requestID is the requestId to look up\n     * @param _index is the value index to look up\n     * @return uint timestamp\n     */\n    function getTimestampbyRequestIDandIndex(uint256 _requestID, uint256 _index)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Getter for the variables saved under the TellorStorageStruct uintVars variable\n     * @param _data the variable to pull from the mapping. _data = keccak256(\"variable_name\") where variable_name is\n     * the variables/strings used to save the data in the mapping. The variables names are\n     * commented out under the uintVars under the TellorStorageStruct struct\n     * This is an example of how data is saved into the mapping within other functions:\n     * self.uintVars[keccak256(\"stakerCount\")]\n     * @return uint of specified variable\n     */\n    function getUintVar(bytes32 _data) external view returns (uint256);\n\n    /**\n     * @dev Getter function for next requestId on queue/request with highest payout at time the function is called\n     * @return onDeck/info on request with highest payout-- RequestId, Totaltips, and API query string\n     */\n    function getVariablesOnDeck()\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            string memory\n        );\n\n    /**\n     * @dev Gets the 5 miners who mined the value for the specified requestId/_timestamp\n     * @param _requestId to look up\n     * @param _timestamp is the timestamp to look up miners for\n     * @return bool true if requestId/timestamp is under dispute\n     */\n    function isInDispute(uint256 _requestId, uint256 _timestamp)\n        external\n        view\n        returns (bool);\n\n    /**\n     * @dev Retreive value from oracle based on timestamp\n     * @param _requestId being requested\n     * @param _timestamp to retreive data/value from\n     * @return value for timestamp submitted\n     */\n    function retrieveData(uint256 _requestId, uint256 _timestamp)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Getter for the total_supply of oracle tokens\n     * @return uint total supply\n     */\n    function totalSupply() external view returns (uint256);\n}"}},"settings":{"libraries":{},"optimizer":{"enabled":true,"runs":100},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","abi"]}}}},"ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tellorMasterAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getTellorCurrentValue\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ifRetrieve\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestampRetrieved\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tellor\",\"outputs\":[{\"internalType\":\"contract ITellor\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"TellorCaller","CompilerVersion":"v0.6.11+commit.5ef660b1","OptimizationUsed":1,"Runs":100,"ConstructorArguments":"0x00000000000000000000000088df592f8eb5d7bd38bfef7deb0fbc02cf3778a0","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}