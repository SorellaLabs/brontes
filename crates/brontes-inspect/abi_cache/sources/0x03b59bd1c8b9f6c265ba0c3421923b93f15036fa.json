{"expiry":1699494229,"data":[{"SourceCode":"// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.8.0;\r\n\r\n// Sources flattened with hardhat v2.10.1 https://hardhat.org\r\n\r\n// File contracts/Fraxswap/core/interfaces/IUniswapV2PairPartialV5.sol\r\n\r\n\r\ninterface IUniswapV2PairPartialV5 {\r\n    //    event Approval(address indexed owner, address indexed spender, uint value);\r\n    //    event Transfer(address indexed from, address indexed to, uint value);\r\n    //\r\n    //    function name() external pure returns (string memory);\r\n    //    function symbol() external pure returns (string memory);\r\n    //    function decimals() external pure returns (uint8);\r\n    //    function totalSupply() external view returns (uint);\r\n    //    function balanceOf(address owner) external view returns (uint);\r\n    //    function allowance(address owner, address spender) external view returns (uint);\r\n    //\r\n    //    function approve(address spender, uint value) external returns (bool);\r\n    //    function transfer(address to, uint value) external returns (bool);\r\n    //    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    //\r\n    //    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    //    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    //    function nonces(address owner) external view returns (uint);\r\n    //\r\n    //    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n    function fee() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n    function initialize(address, address, uint) external;\r\n\r\n    // TWAMM\r\n\r\n    function longTermSwapFrom0To1(uint256 amount0In, uint256 numberOfTimeIntervals) external returns (uint256 orderId);\r\n    function longTermSwapFrom1To0(uint256 amount1In, uint256 numberOfTimeIntervals) external returns (uint256 orderId);\r\n    function cancelLongTermSwap(uint256 orderId) external;\r\n    function withdrawProceedsFromLongTermSwap(uint256 orderId) external returns (bool is_expired, address rewardTkn, uint256 totalReward);\r\n    function executeVirtualOrders(uint256 blockTimestamp) external;\r\n\r\n    function getAmountOut(uint amountIn, address tokenIn) external view returns (uint);\r\n    function getAmountIn(uint amountOut, address tokenOut) external view returns (uint);\r\n\r\n    function orderTimeInterval() external returns (uint256);\r\n    function getTWAPHistoryLength() external view returns (uint);\r\n    function getTwammReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast, uint112 _twammReserve0, uint112 _twammReserve1, uint256 _fee);\r\n    function getReserveAfterTwamm(uint256 blockTimestamp) external view returns (uint112 _reserve0, uint112 _reserve1, uint256 lastVirtualOrderTimestamp, uint112 _twammReserve0, uint112 _twammReserve1);\r\n    function getNextOrderID() external view returns (uint256);\r\n    function getOrderIDsForUser(address user) external view returns (uint256[] memory);\r\n    function getOrderIDsForUserLength(address user) external view returns (uint256);\r\n    //    function getDetailedOrdersForUser(address user, uint256 offset, uint256 limit) external view returns (LongTermOrdersLib.Order[] memory detailed_orders);\r\n    function twammUpToDate() external view returns (bool);\r\n    function getTwammState() external view returns (uint256 token0Rate, uint256 token1Rate, uint256 lastVirtualOrderTimestamp, uint256 orderTimeInterval_rtn, uint256 rewardFactorPool0, uint256 rewardFactorPool1);\r\n    function getTwammSalesRateEnding(uint256 _blockTimestamp) external view returns (uint256 orderPool0SalesRateEnding, uint256 orderPool1SalesRateEnding);\r\n    function getTwammRewardFactor(uint256 _blockTimestamp) external view returns (uint256 rewardFactorPool0AtTimestamp, uint256 rewardFactorPool1AtTimestamp);\r\n    function getTwammOrder(uint256 orderId) external view returns (uint256 id, uint256 creationTimestamp, uint256 expirationTimestamp, uint256 saleRate, address owner, address sellTokenAddr, address buyTokenAddr);\r\n    function getTwammOrderProceedsView(uint256 orderId, uint256 blockTimestamp) external view returns (bool orderExpired, uint256 totalReward);\r\n    function getTwammOrderProceeds(uint256 orderId) external returns (bool orderExpired, uint256 totalReward);\r\n\r\n\r\n    function togglePauseNewSwaps() external;\r\n}\r\n\r\n\r\n// File contracts/Fraxswap/core/interfaces/IUniswapV2ERC20V5.sol\r\n\r\n\r\ninterface IUniswapV2ERC20V5 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}\r\n\r\n\r\n// File contracts/Fraxswap/core/FraxswapERC20.sol\r\n\r\n\r\n// ====================================================================\r\n// |     ______                   _______                             |\r\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\r\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\r\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\r\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\r\n// |                                                                  |\r\n// ====================================================================\r\n// ========================== FraxswapERC20 ===========================\r\n// ====================================================================\r\n// Fraxswap ERC-20\r\n// Inspired by https://www.paradigm.xyz/2021/07/twamm\r\n// https://github.com/para-dave/twamm\r\n\r\n// Frax Finance: https://github.com/FraxFinance\r\n\r\n// Primary Author(s)\r\n// Rich Gee: https://github.com/zer0blockchain\r\n// Dennis: https://github.com/denett\r\n\r\n// Logic / Algorithm Ideas\r\n// FrankieIsLost: https://github.com/FrankieIsLost\r\n\r\n// Reviewer(s) / Contributor(s)\r\n// Travis Moore: https://github.com/FortisFortuna\r\n// Sam Kazemian: https://github.com/samkazemian\r\n// Drake Evans: https://github.com/DrakeEvans\r\n// Jack Corddry: https://github.com/corddry\r\n// Justin Moore: https://github.com/0xJM\r\ncontract FraxswapERC20 is IUniswapV2ERC20V5 {\r\n\r\n    string public constant override name = 'Fraxswap V2';\r\n    string public constant override symbol = 'FS-V2';\r\n    uint8 public constant override decimals = 18;\r\n    uint  public override totalSupply;\r\n    mapping(address => uint) public override balanceOf;\r\n    mapping(address => mapping(address => uint)) public override allowance;\r\n\r\n    bytes32 public override DOMAIN_SEPARATOR;\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n    bytes32 public constant override PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n    mapping(address => uint) public override nonces;\r\n\r\n    constructor() public {\r\n        uint chainId = block.chainid;\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes('1')),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    function _mint(address to, uint value) internal {\r\n        totalSupply = totalSupply + value;\r\n        balanceOf[to] = balanceOf[to] + value;\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint value) internal {\r\n        balanceOf[from] = balanceOf[from] - value;\r\n        totalSupply = totalSupply - value;\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint value) private {\r\n        allowance[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint value) private {\r\n        balanceOf[from] = balanceOf[from] - value;\r\n        balanceOf[to] = balanceOf[to] + value;\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function approve(address spender, uint value) external override returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint value) external override returns (bool) {\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint value) external override returns (bool) {\r\n        if (allowance[from][msg.sender] != type(uint).max) {\r\n            allowance[from][msg.sender] = allowance[from][msg.sender] - value;\r\n        }\r\n        _transfer(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external override {\r\n        require(deadline >= block.timestamp); // EXPIRED\r\n        bytes32 digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n            )\r\n        );\r\n        address recoveredAddress = ecrecover(digest, v, r, s);\r\n        require(recoveredAddress != address(0) && recoveredAddress == owner); // INVALID_SIGNATURE\r\n        _approve(owner, spender, value);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Fraxswap/core/libraries/Math.sol\r\n\r\n\r\n// a library for performing various math operations\r\n\r\nlibrary Math {\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        z = x < y ? x : y;\r\n    }\r\n\r\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Fraxswap/core/libraries/UQ112x112.sol\r\n\r\n\r\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\r\n\r\n// range: [0, 2**112 - 1]\r\n// resolution: 1 / 2**112\r\n\r\nlibrary UQ112x112 {\r\n    uint224 constant Q112 = 2**112;\r\n\r\n    // encode a uint112 as a UQ112x112\r\n    function encode(uint112 y) internal pure returns (uint224 z) {\r\n        z = uint224(y) * Q112; // never overflows\r\n    }\r\n\r\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\r\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\r\n        z = x / uint224(y);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Fraxswap/core/interfaces/IERC20V5.sol\r\n\r\n\r\ninterface IERC20V5 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n\r\n\r\n// File contracts/Fraxswap/core/interfaces/IUniswapV2FactoryV5.sol\r\n\r\n\r\ninterface IUniswapV2FactoryV5 {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function globalPause() external view returns (bool);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function createPair(address tokenA, address tokenB, uint fee) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n    function toggleGlobalPause() external;\r\n}\r\n\r\n\r\n// File contracts/Fraxswap/core/interfaces/IUniswapV2CalleeV5.sol\r\n\r\n\r\ninterface IUniswapV2CalleeV5 {\r\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\r\n}\r\n\r\n\r\n// File contracts/Fraxswap/twamm/LongTermOrders.sol\r\n\r\n\r\n// ====================================================================\r\n// |     ______                   _______                             |\r\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\r\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\r\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\r\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\r\n// |                                                                  |\r\n// ====================================================================\r\n// ========================= LongTermOrdersLib ========================\r\n// ====================================================================\r\n// TWAMM long term order execution logic\r\n// Inspired by https://www.paradigm.xyz/2021/07/twamm\r\n// https://github.com/para-dave/twamm\r\n\r\n// Frax Finance: https://github.com/FraxFinance\r\n\r\n// Primary Author(s)\r\n// Rich Gee: https://github.com/zer0blockchain\r\n// Dennis: https://github.com/denett\r\n\r\n// Logic / Algorithm Ideas\r\n// FrankieIsLost: https://github.com/FrankieIsLost\r\n\r\n// Reviewer(s) / Contributor(s)\r\n// Travis Moore: https://github.com/FortisFortuna\r\n// Sam Kazemian: https://github.com/samkazemian\r\n// Drake Evans: https://github.com/DrakeEvans\r\n// Jack Corddry: https://github.com/corddry\r\n// Justin Moore: https://github.com/0xJM\r\n\r\n///@notice This library handles the state and execution of long term orders. \r\nlibrary LongTermOrdersLib {\r\n\r\n    using LongTermOrdersLib for OrderPool;\r\n\r\n    /// ---------------------------\r\n    /// ---------- Events ---------\r\n    /// ---------------------------\r\n\r\n    ///@notice An event emitted when virtual orders are executed\r\n    event VirtualOrderExecution(\r\n        uint256 blockTimestamp,\r\n        uint256 blockTimestampElapsed,\r\n        uint256 newReserve0,\r\n        uint256 newReserve1,\r\n        uint256 newTwammReserve0,\r\n        uint256 newTwammReserve1,\r\n        uint256 token0Bought,\r\n        uint256 token1Bought,\r\n        uint256 token0Sold,\r\n        uint256 token1Sold\r\n    );\r\n\r\n    /// ---------------------------\r\n    /// ----- LongTerm Orders -----\r\n    /// ---------------------------\r\n\r\n    uint112 internal constant SELL_RATE_ADDITIONAL_PRECISION = 1000000;\r\n    uint256 internal constant Q112 = 2**112;\r\n    uint256 internal constant orderTimeInterval = 3600; // sync with FraxswapPair.sol\r\n\r\n    ///@notice information associated with a long term order\r\n    ///fields should NOT be changed after Order struct is created\r\n    struct Order {\r\n        uint256 id;\r\n        uint256 creationTimestamp;\r\n        uint256 expirationTimestamp;\r\n        uint256 saleRate;\r\n        address owner;\r\n        address sellTokenAddr;\r\n        address buyTokenAddr;\r\n        bool isComplete;\r\n    }\r\n\r\n    ///@notice structure contains full state related to long term orders\r\n    struct LongTermOrders {\r\n\r\n        ///@notice last virtual orders were executed immediately before this block.timestamp\r\n        uint256 lastVirtualOrderTimestamp;\r\n\r\n        ///@notice token0 being traded in amm\r\n        address token0;\r\n\r\n        ///@notice mapping from token address to pool that is selling that token\r\n        ///we maintain two order pools, one for each token that is tradable in the AMM\r\n        OrderPool OrderPool0;\r\n        OrderPool OrderPool1;\r\n\r\n        ///@notice incrementing counter for order ids, this is the next order id\r\n        uint256 orderId;\r\n\r\n        ///@notice mapping from order ids to Orders\r\n        mapping(uint256 => Order) orderMap;\r\n    }\r\n\r\n    struct ExecuteVirtualOrdersResult {\r\n        uint112 newReserve0;\r\n        uint112 newReserve1;\r\n        uint256 newTwammReserve0;\r\n        uint256 newTwammReserve1;\r\n        uint256 fee;\r\n    }\r\n\r\n    ///@notice initialize state\r\n    function initialize(LongTermOrders storage longTermOrders, address token0) internal {\r\n        longTermOrders.token0 = token0;\r\n        longTermOrders.lastVirtualOrderTimestamp = block.timestamp;\r\n    }\r\n\r\n    ///@notice get the OrderPool for this token\r\n    function getOrderPool(LongTermOrders storage longTermOrders, address token) internal view returns (OrderPool storage orderPool) {\r\n        orderPool = token == longTermOrders.token0 ? longTermOrders.OrderPool0 : longTermOrders.OrderPool1;\r\n    }\r\n\r\n    ///@notice adds long term swap to order pool\r\n    function performLongTermSwap(LongTermOrders storage longTermOrders, address from, address to, uint256 amount, uint256 numberOfTimeIntervals) internal returns (uint256) {\r\n        // make sure to update virtual order state (before calling this function)\r\n\r\n        //determine the selling rate based on number of blocks to expiry and total amount\r\n        uint256 currentTime = block.timestamp;\r\n        uint256 lastExpiryTimestamp = currentTime - (currentTime % orderTimeInterval);\r\n        uint256 orderExpiry = orderTimeInterval * (numberOfTimeIntervals + 1) + lastExpiryTimestamp;\r\n        uint256 sellingRate = SELL_RATE_ADDITIONAL_PRECISION * amount / (orderExpiry - currentTime);\r\n\r\n        require(sellingRate > 0); // tokenRate cannot be zero\r\n\r\n        //add order to correct pool\r\n        OrderPool storage orderPool = getOrderPool(longTermOrders, from);\r\n        orderPoolDepositOrder(orderPool, longTermOrders.orderId, sellingRate, orderExpiry);\r\n\r\n        //add to order map\r\n        longTermOrders.orderMap[longTermOrders.orderId] = Order(longTermOrders.orderId, currentTime, orderExpiry, sellingRate, msg.sender, from, to, false);\r\n        return longTermOrders.orderId++;\r\n    }\r\n\r\n    ///@notice cancel long term swap, pay out unsold tokens and well as purchased tokens\r\n    function cancelLongTermSwap(LongTermOrders storage longTermOrders, uint256 orderId) internal returns (address sellToken, uint256 unsoldAmount, address buyToken, uint256 purchasedAmount) {\r\n        // make sure to update virtual order state (before calling this function)\r\n\r\n        Order storage order = longTermOrders.orderMap[orderId];\r\n        buyToken = order.buyTokenAddr;\r\n        sellToken = order.sellTokenAddr;\r\n\r\n        OrderPool storage orderPool = getOrderPool(longTermOrders, sellToken);\r\n        (unsoldAmount, purchasedAmount) = orderPoolCancelOrder(orderPool, orderId, longTermOrders.lastVirtualOrderTimestamp);\r\n\r\n        require(order.owner == msg.sender && (unsoldAmount > 0 || purchasedAmount > 0)); // owner and amounts check\r\n\r\n    }\r\n\r\n    ///@notice withdraw proceeds from a long term swap (can be expired or ongoing)\r\n    function withdrawProceedsFromLongTermSwap(LongTermOrders storage longTermOrders, uint256 orderId) internal returns (address proceedToken, uint256 proceeds, bool orderExpired) {\r\n        // make sure to update virtual order state (before calling this function)\r\n\r\n        Order storage order = longTermOrders.orderMap[orderId];\r\n        proceedToken = order.buyTokenAddr;\r\n\r\n        OrderPool storage orderPool = getOrderPool(longTermOrders, order.sellTokenAddr);\r\n        (proceeds, orderExpired) = orderPoolWithdrawProceeds(orderPool, orderId, longTermOrders.lastVirtualOrderTimestamp);\r\n\r\n        require(order.owner == msg.sender && proceeds > 0); // owner and amounts check\r\n    }\r\n\r\n    ///@notice computes the result of virtual trades by the token pools\r\n    function computeVirtualBalances(\r\n        uint256 token0Start,\r\n        uint256 token1Start,\r\n        uint256 token0In,\r\n        uint256 token1In,\r\n        uint256 fee)\r\n    internal pure returns (uint256 token0Out, uint256 token1Out)\r\n    {\r\n        token0Out = 0;\r\n        token1Out = 0;\r\n        //if no tokens are sold to the pool, we don't need to execute any orders\r\n        if (token0In < 2 && token1In < 2) {\r\n            // do nothing\r\n        }\r\n        //in the case where only one pool is selling, we just perform a normal swap\r\n        else if (token0In < 2) {\r\n            //constant product formula\r\n            uint token1InWithFee = token1In * fee;\r\n            token0Out = token0Start * token1InWithFee / ((token1Start * 10000) + token1InWithFee);\r\n        }\r\n        else if (token1In < 2) {\r\n            //contant product formula\r\n            uint token0InWithFee = token0In * fee;\r\n            token1Out = token1Start * token0InWithFee / ((token0Start * 10000) + token0InWithFee);\r\n        }\r\n        //when both pools sell, we use the TWAMM formula\r\n        else {\r\n            uint256 newToken0 = token0Start + (token0In * fee / 10000);\r\n            uint256 newToken1 = token1Start + (token1In * fee / 10000);\r\n            token0Out = newToken0 - (token1Start * (newToken0) / (newToken1));\r\n            token1Out = newToken1 - (token0Start * (newToken1) / (newToken0));\r\n        }\r\n    }\r\n\r\n    ///@notice executes all virtual orders between current lastVirtualOrderTimestamp and blockTimestamp\r\n    //also handles orders that expire at end of final blockTimestamp. This assumes that no orders expire inside the given interval\r\n    function executeVirtualTradesAndOrderExpiries(\r\n        ExecuteVirtualOrdersResult memory reserveResult,\r\n        uint256 token0SellAmount,\r\n        uint256 token1SellAmount\r\n    ) private view returns (uint256 token0Out, uint256 token1Out) {\r\n\r\n        //initial amm balance\r\n        uint256 bal0 = reserveResult.newReserve0 + reserveResult.newTwammReserve0;\r\n        uint256 bal1 = reserveResult.newReserve1 + reserveResult.newTwammReserve1;\r\n\r\n        //updated balances from sales\r\n        (token0Out, token1Out) = computeVirtualBalances(\r\n            reserveResult.newReserve0,\r\n            reserveResult.newReserve1,\r\n            token0SellAmount,\r\n            token1SellAmount,\r\n            reserveResult.fee\r\n        );\r\n\r\n        //update balances reserves\r\n        reserveResult.newTwammReserve0 = reserveResult.newTwammReserve0 + token0Out - token0SellAmount;\r\n        reserveResult.newTwammReserve1 = reserveResult.newTwammReserve1 + token1Out - token1SellAmount;\r\n        reserveResult.newReserve0 = uint112(bal0 - reserveResult.newTwammReserve0); // calculate reserve0 incl LP fees\r\n        reserveResult.newReserve1 = uint112(bal1 - reserveResult.newTwammReserve1); // calculate reserve1 incl LP fees\r\n    }\r\n\r\n    ///@notice executes all virtual orders until blockTimestamp is reached.\r\n    function executeVirtualOrdersUntilTimestamp(LongTermOrders storage longTermOrders, uint256 blockTimestamp, ExecuteVirtualOrdersResult memory reserveResult) internal {\r\n\r\n        uint256 lastVirtualOrderTimestampLocal = longTermOrders.lastVirtualOrderTimestamp; // save gas\r\n        uint256 nextExpiryBlockTimestamp = lastVirtualOrderTimestampLocal - (lastVirtualOrderTimestampLocal % orderTimeInterval) + orderTimeInterval;\r\n        //iterate through time intervals eligible for order expiries, moving state forward\r\n\r\n        OrderPool storage orderPool0 = longTermOrders.OrderPool0;\r\n        OrderPool storage orderPool1 = longTermOrders.OrderPool1;\r\n\r\n        while (nextExpiryBlockTimestamp <= blockTimestamp) {\r\n            // Optimization for skipping blocks with no expiry\r\n            if (orderPool0.salesRateEndingPerTimeInterval[nextExpiryBlockTimestamp] > 0\r\n                || orderPool1.salesRateEndingPerTimeInterval[nextExpiryBlockTimestamp] > 0) {\r\n\r\n                //amount sold from virtual trades\r\n                uint256 blockTimestampElapsed = nextExpiryBlockTimestamp - lastVirtualOrderTimestampLocal;\r\n                uint256 token0SellAmount = orderPool0.currentSalesRate * blockTimestampElapsed / SELL_RATE_ADDITIONAL_PRECISION;\r\n                uint256 token1SellAmount = orderPool1.currentSalesRate * blockTimestampElapsed / SELL_RATE_ADDITIONAL_PRECISION;\r\n\r\n                (uint256 token0Out, uint256 token1Out) = executeVirtualTradesAndOrderExpiries(reserveResult, token0SellAmount, token1SellAmount);\r\n\r\n                //distribute proceeds to pools. make sure to call this before orderPoolUpdateStateFromTimestampExpiry.\r\n                orderPoolDistributePayment(orderPool0, token1Out);\r\n                orderPoolDistributePayment(orderPool1, token0Out);\r\n\r\n                //handle orders expiring at end of interval. call orderPoolDistributePayment before calling this.\r\n                orderPoolUpdateStateFromTimestampExpiry(orderPool0, nextExpiryBlockTimestamp);\r\n                orderPoolUpdateStateFromTimestampExpiry(orderPool1, nextExpiryBlockTimestamp);\r\n\r\n                emit VirtualOrderExecution(\r\n                    nextExpiryBlockTimestamp,\r\n                    blockTimestampElapsed,\r\n                    reserveResult.newReserve0,\r\n                    reserveResult.newReserve1,\r\n                    reserveResult.newTwammReserve0,\r\n                    reserveResult.newTwammReserve1,\r\n                    token0Out,\r\n                    token1Out,\r\n                    token0SellAmount,\r\n                    token1SellAmount\r\n                );\r\n\r\n                lastVirtualOrderTimestampLocal = nextExpiryBlockTimestamp;\r\n            }\r\n            nextExpiryBlockTimestamp += orderTimeInterval;\r\n        }\r\n        //finally, move state to current blockTimestamp if necessary\r\n        if (lastVirtualOrderTimestampLocal != blockTimestamp) {\r\n\r\n            //amount sold from virtual trades\r\n            uint256 blockTimestampElapsed = blockTimestamp - lastVirtualOrderTimestampLocal;\r\n            uint256 token0SellAmount = orderPool0.currentSalesRate * blockTimestampElapsed / SELL_RATE_ADDITIONAL_PRECISION;\r\n            uint256 token1SellAmount = orderPool1.currentSalesRate * blockTimestampElapsed / SELL_RATE_ADDITIONAL_PRECISION;\r\n\r\n            (uint256 token0Out, uint256 token1Out) = executeVirtualTradesAndOrderExpiries(reserveResult, token0SellAmount, token1SellAmount);\r\n\r\n            emit VirtualOrderExecution(\r\n                blockTimestamp,\r\n                blockTimestampElapsed,\r\n                reserveResult.newReserve0,\r\n                reserveResult.newReserve1,\r\n                reserveResult.newTwammReserve0,\r\n                reserveResult.newTwammReserve1,\r\n                token0Out,\r\n                token1Out,\r\n                token0SellAmount,\r\n                token1SellAmount\r\n            );\r\n            \r\n            //distribute proceeds to pools\r\n            orderPoolDistributePayment(orderPool0, token1Out);\r\n            orderPoolDistributePayment(orderPool1, token0Out);\r\n\r\n            // skip call to orderPoolUpdateStateFromTimestampExpiry, this will not be an expiry timestamp. save gas\r\n        }\r\n\r\n        longTermOrders.lastVirtualOrderTimestamp = blockTimestamp;\r\n    }\r\n\r\n    ///@notice executes all virtual orders until blockTimestamp is reached (AS A VIEW)\r\n    function executeVirtualOrdersUntilTimestampView(LongTermOrders storage longTermOrders, uint256 blockTimestamp, ExecuteVirtualOrdersResult memory reserveResult) internal view {\r\n\r\n        uint256 lastVirtualOrderTimestampLocal = longTermOrders.lastVirtualOrderTimestamp; // save gas\r\n        uint256 nextExpiryBlockTimestamp = lastVirtualOrderTimestampLocal - (lastVirtualOrderTimestampLocal % orderTimeInterval) + orderTimeInterval;\r\n        //iterate through time intervals eligible for order expiries, moving state forward\r\n\r\n        OrderPool storage orderPool0 = longTermOrders.OrderPool0;\r\n        OrderPool storage orderPool1 = longTermOrders.OrderPool1;\r\n\r\n        // currentSales for each pool is mutated in the non-view (mutate locally)\r\n        uint256 currentSalesRate0 = orderPool0.currentSalesRate;\r\n        uint256 currentSalesRate1 = orderPool1.currentSalesRate;\r\n\r\n        while (nextExpiryBlockTimestamp <= blockTimestamp) {\r\n            // Optimization for skipping blocks with no expiry\r\n            if (orderPool0.salesRateEndingPerTimeInterval[nextExpiryBlockTimestamp] > 0\r\n                || orderPool1.salesRateEndingPerTimeInterval[nextExpiryBlockTimestamp] > 0) {\r\n\r\n                //amount sold from virtual trades\r\n                uint256 blockTimestampElapsed = nextExpiryBlockTimestamp - lastVirtualOrderTimestampLocal;\r\n                uint256 token0SellAmount = currentSalesRate0 * blockTimestampElapsed / SELL_RATE_ADDITIONAL_PRECISION;\r\n                uint256 token1SellAmount = currentSalesRate1 * blockTimestampElapsed / SELL_RATE_ADDITIONAL_PRECISION;\r\n\r\n                executeVirtualTradesAndOrderExpiries(reserveResult, token0SellAmount, token1SellAmount);\r\n\r\n                currentSalesRate0 -= orderPool0.salesRateEndingPerTimeInterval[nextExpiryBlockTimestamp];\r\n                currentSalesRate1 -= orderPool1.salesRateEndingPerTimeInterval[nextExpiryBlockTimestamp];\r\n\r\n                lastVirtualOrderTimestampLocal = nextExpiryBlockTimestamp;\r\n            }\r\n            nextExpiryBlockTimestamp += orderTimeInterval;\r\n        }\r\n        //finally, move state to current blockTimestamp if necessary\r\n        if (lastVirtualOrderTimestampLocal != blockTimestamp) {\r\n\r\n            //amount sold from virtual trades\r\n            uint256 blockTimestampElapsed = blockTimestamp - lastVirtualOrderTimestampLocal;\r\n            uint256 token0SellAmount = currentSalesRate0 * blockTimestampElapsed / SELL_RATE_ADDITIONAL_PRECISION;\r\n            uint256 token1SellAmount = currentSalesRate1 * blockTimestampElapsed / SELL_RATE_ADDITIONAL_PRECISION;\r\n\r\n            executeVirtualTradesAndOrderExpiries(reserveResult, token0SellAmount, token1SellAmount);\r\n\r\n        }\r\n    }\r\n\r\n    /// ---------------------------\r\n    /// -------- OrderPool --------\r\n    /// ---------------------------\r\n\r\n    ///@notice An Order Pool is an abstraction for a pool of long term orders that sells a token at a constant rate to the embedded AMM.\r\n    ///the order pool handles the logic for distributing the proceeds from these sales to the owners of the long term orders through a modified\r\n    ///version of the staking algorithm from  https://uploads-ssl.webflow.com/5ad71ffeb79acc67c8bcdaba/5ad8d1193a40977462982470_scalable-reward-distribution-paper.pdf\r\n\r\n    ///@notice you can think of this as a staking pool where all long term orders are staked.\r\n    /// The pool is paid when virtual long term orders are executed, and each order is paid proportionally\r\n    /// by the order's sale rate per time intervals\r\n    struct OrderPool {\r\n        ///@notice current rate that tokens are being sold (per time interval)\r\n        uint256 currentSalesRate;\r\n\r\n        ///@notice sum of (salesProceeds_k / salesRate_k) over every period k. Stored as a fixed precision floating point number\r\n        uint256 rewardFactor;\r\n\r\n        ///@notice this maps time interval numbers to the cumulative sales rate of orders that expire on that block (time interval)\r\n        mapping(uint256 => uint256) salesRateEndingPerTimeInterval;\r\n\r\n        ///@notice map order ids to the block timestamp in which they expire\r\n        mapping(uint256 => uint256) orderExpiry;\r\n\r\n        ///@notice map order ids to their sales rate\r\n        mapping(uint256 => uint256) salesRate;\r\n\r\n        ///@notice reward factor per order at time of submission\r\n        mapping(uint256 => uint256) rewardFactorAtSubmission;\r\n\r\n        ///@notice reward factor at a specific time interval\r\n        mapping(uint256 => uint256) rewardFactorAtTimestamp;\r\n    }\r\n\r\n    ///@notice distribute payment amount to pool (in the case of TWAMM, proceeds from trades against amm)\r\n    function orderPoolDistributePayment(OrderPool storage orderPool, uint256 amount) internal {\r\n        if (orderPool.currentSalesRate != 0) {\r\n            unchecked { // Addition is with overflow\r\n                orderPool.rewardFactor += amount * Q112 * SELL_RATE_ADDITIONAL_PRECISION / orderPool.currentSalesRate;\r\n            }\r\n        }\r\n    }\r\n\r\n    ///@notice deposit an order into the order pool.\r\n    function orderPoolDepositOrder(OrderPool storage orderPool, uint256 orderId, uint256 amountPerInterval, uint256 orderExpiry) internal {\r\n        orderPool.currentSalesRate += amountPerInterval;\r\n        orderPool.rewardFactorAtSubmission[orderId] = orderPool.rewardFactor;\r\n        orderPool.orderExpiry[orderId] = orderExpiry;\r\n        orderPool.salesRate[orderId] = amountPerInterval;\r\n        orderPool.salesRateEndingPerTimeInterval[orderExpiry] += amountPerInterval;\r\n    }\r\n\r\n    ///@notice when orders expire after a given timestamp, we need to update the state of the pool\r\n    function orderPoolUpdateStateFromTimestampExpiry(OrderPool storage orderPool, uint256 blockTimestamp) internal {\r\n        orderPool.currentSalesRate -= orderPool.salesRateEndingPerTimeInterval[blockTimestamp];\r\n        orderPool.rewardFactorAtTimestamp[blockTimestamp] = orderPool.rewardFactor;\r\n    }\r\n\r\n    ///@notice cancel order and remove from the order pool\r\n    function orderPoolCancelOrder(OrderPool storage orderPool, uint256 orderId, uint256 blockTimestamp) internal returns (uint256 unsoldAmount, uint256 purchasedAmount) {\r\n        uint256 expiry = orderPool.orderExpiry[orderId];\r\n        require(expiry > blockTimestamp);\r\n\r\n        //calculate amount that wasn't sold, and needs to be returned\r\n        uint256 salesRate = orderPool.salesRate[orderId];\r\n        unsoldAmount = (expiry - blockTimestamp) * salesRate / SELL_RATE_ADDITIONAL_PRECISION;\r\n\r\n        //calculate amount of other token that was purchased\r\n        unchecked { // subtraction is with underflow\r\n            purchasedAmount = ((orderPool.rewardFactor - orderPool.rewardFactorAtSubmission[orderId]) * salesRate / SELL_RATE_ADDITIONAL_PRECISION) / Q112;\r\n        }\r\n\r\n        //update state\r\n        orderPool.currentSalesRate -= salesRate;\r\n        orderPool.salesRate[orderId] = 0;\r\n        orderPool.orderExpiry[orderId] = 0;\r\n        orderPool.salesRateEndingPerTimeInterval[expiry] -= salesRate;\r\n    }\r\n\r\n    ///@notice withdraw proceeds from pool for a given order. This can be done before or after the order has expired.\r\n    //If the order has expired, we calculate the reward factor at time of expiry. If order has not yet expired, we\r\n    //use current reward factor, and update the reward factor at time of staking (effectively creating a new order)\r\n    function orderPoolWithdrawProceeds(OrderPool storage orderPool, uint256 orderId, uint256 blockTimestamp) internal returns (uint256 totalReward, bool orderExpired) {\r\n        (orderExpired, totalReward) = orderPoolGetProceeds(orderPool, orderId, blockTimestamp);\r\n\r\n        if (orderExpired) {\r\n            //remove stake\r\n            orderPool.salesRate[orderId] = 0;\r\n        }\r\n        //if order has not yet expired, we just adjust the start\r\n        else {\r\n            orderPool.rewardFactorAtSubmission[orderId] = orderPool.rewardFactor;\r\n        }\r\n    }\r\n\r\n    ///@notice view function for getting the current proceeds for the given order\r\n    function orderPoolGetProceeds(OrderPool storage orderPool, uint256 orderId, uint256 blockTimestamp) internal view returns (bool orderExpired, uint256 totalReward) {\r\n        uint256 stakedAmount = orderPool.salesRate[orderId];\r\n        require(stakedAmount > 0);\r\n        uint256 orderExpiry = orderPool.orderExpiry[orderId];\r\n        uint256 rewardFactorAtSubmission = orderPool.rewardFactorAtSubmission[orderId];\r\n\r\n        //if order has expired, we need to calculate the reward factor at expiry\r\n        if (blockTimestamp >= orderExpiry) {\r\n            uint256 rewardFactorAtExpiry = orderPool.rewardFactorAtTimestamp[orderExpiry];\r\n            unchecked { // subtraction is with underflow\r\n                totalReward = ((rewardFactorAtExpiry - rewardFactorAtSubmission) * stakedAmount / SELL_RATE_ADDITIONAL_PRECISION) / Q112;\r\n            }\r\n            orderExpired = true;\r\n        }\r\n        else {\r\n            unchecked { // subtraction is with underflow\r\n                totalReward = ((orderPool.rewardFactor - rewardFactorAtSubmission) * stakedAmount / SELL_RATE_ADDITIONAL_PRECISION) / Q112;\r\n            }\r\n            orderExpired = false;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Fraxswap/core/FraxswapPair.sol\r\n\r\n\r\n// ====================================================================\r\n// |     ______                   _______                             |\r\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\r\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\r\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\r\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\r\n// |                                                                  |\r\n// ====================================================================\r\n// =========================== FraxswapPair ===========================\r\n// ====================================================================\r\n// TWAMM LP Pair Token\r\n// Inspired by https://www.paradigm.xyz/2021/07/twamm\r\n// https://github.com/para-dave/twamm\r\n\r\n// Frax Finance: https://github.com/FraxFinance\r\n\r\n// Primary Author(s)\r\n// Rich Gee: https://github.com/zer0blockchain\r\n// Dennis: https://github.com/denett\r\n\r\n// Logic / Algorithm Ideas\r\n// FrankieIsLost: https://github.com/FrankieIsLost\r\n\r\n// Reviewer(s) / Contributor(s)\r\n// Travis Moore: https://github.com/FortisFortuna\r\n// Sam Kazemian: https://github.com/samkazemian\r\n// Drake Evans: https://github.com/DrakeEvans\r\n// Jack Corddry: https://github.com/corddry\r\n// Justin Moore: https://github.com/0xJM\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract FraxswapPair is IUniswapV2PairPartialV5, FraxswapERC20 {\r\n    using UQ112x112 for uint224;\r\n    using LongTermOrdersLib for LongTermOrdersLib.LongTermOrders;\r\n    using LongTermOrdersLib for LongTermOrdersLib.ExecuteVirtualOrdersResult;\r\n\r\n    /// ---------------------------\r\n    /// -----TWAMM Parameters -----\r\n    /// ---------------------------\r\n\r\n    // address public owner_address;\r\n\r\n    ///@notice time interval that are eligible for order expiry (to align expiries)\r\n    uint256 constant public orderTimeInterval = 3600; // sync with LongTermOrders.sol\r\n\r\n    ///@notice data structure to handle long term orders\r\n    LongTermOrdersLib.LongTermOrders internal longTermOrders;\r\n\r\n    uint112 public twammReserve0;\r\n    uint112 public twammReserve1;\r\n\r\n    uint256 public override fee;\r\n\r\n    bool public newSwapsPaused;\r\n\r\n    modifier execVirtualOrders() {\r\n        executeVirtualOrdersInternal(block.timestamp);\r\n        _;\r\n    }\r\n\r\n    /// ---------------------------\r\n    /// -------- Modifiers --------\r\n    /// ---------------------------\r\n\r\n    ///@notice Throws if called by any account other than the owner.\r\n    modifier onlyOwnerOrFactory() {\r\n        require(factory == msg.sender || IUniswapV2FactoryV5(factory).feeToSetter() == msg.sender); // NOT OWNER OR FACTORY\r\n        _;\r\n    }\r\n\r\n    ///@notice Checks if new swaps are paused. If they are, only allow closing of existing ones.\r\n    modifier isNotPaused() {\r\n        require(newSwapsPaused == false); // NEW LT ORDERS PAUSED\r\n        _;\r\n    }\r\n\r\n    modifier feeCheck(uint256 newFee) {\r\n        require(newFee > 0 && newFee < 101); // fee can't be zero and can't be more than 1%\r\n        _;\r\n    }\r\n\r\n    /// ---------------------------\r\n    /// --------- Events ----------\r\n    /// ---------------------------\r\n\r\n    ///@notice An event emitted when a long term swap from token0 to token1 is performed\r\n    event LongTermSwap0To1(address indexed addr, uint256 orderId, uint256 amount0In, uint256 numberOfTimeIntervals);\r\n\r\n    ///@notice An event emitted when a long term swap from token1 to token0 is performed\r\n    event LongTermSwap1To0(address indexed addr, uint256 orderId, uint256 amount1In, uint256 numberOfTimeIntervals);\r\n\r\n    ///@notice An event emitted when a long term swap is cancelled\r\n    event CancelLongTermOrder(address indexed addr, uint256 orderId, address sellToken, uint256 unsoldAmount, address buyToken, uint256 purchasedAmount);\r\n\r\n    ///@notice An event emitted when a long term swap is withdrawn\r\n    event WithdrawProceedsFromLongTermOrder(address indexed addr, uint256 orderId, address indexed proceedToken, uint256 proceeds, bool orderExpired);\r\n\r\n    ///@notice An event emitted when lp fee is updated\r\n    event LpFeeUpdated(uint256 fee);\r\n\r\n    /// ---------------------------\r\n    /// --------- Errors ----------\r\n    /// ---------------------------\r\n\r\n    error InvalidToToken();\r\n    error Uint112Overflow();\r\n    error KConstantError();\r\n    error InsufficientInputAmount();\r\n    error InsufficientOutputAmount();\r\n    error InsufficientLiquidity(uint112 reserve0, uint112 reserve1);\r\n\r\n    /// -------------------------------\r\n    /// -----UNISWAPV2 Parameters -----\r\n    /// -------------------------------\r\n\r\n    uint public constant override MINIMUM_LIQUIDITY = 10 ** 3;\r\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n\r\n    address public override factory;\r\n    address public override token0;\r\n    address public override token1;\r\n\r\n    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\r\n    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\r\n\r\n    uint32  private blockTimestampLast; // uses single storage slot, accessible via getReserves\r\n\r\n    uint public override kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\r\n\r\n    // Track order IDs\r\n    mapping(address => uint256[]) public orderIDsForUser;\r\n\r\n    TWAPObservation[] public TWAPObservationHistory;\r\n\r\n    struct TWAPObservation {\r\n        uint timestamp;\r\n        uint price0CumulativeLast;\r\n        uint price1CumulativeLast;\r\n    }\r\n    function price0CumulativeLast() public view override returns (uint){\r\n        return TWAPObservationHistory.length > 0 ? TWAPObservationHistory[TWAPObservationHistory.length - 1].price0CumulativeLast : 0;\r\n    }\r\n    function price1CumulativeLast() public view override returns (uint){\r\n        return TWAPObservationHistory.length > 0 ? TWAPObservationHistory[TWAPObservationHistory.length - 1].price1CumulativeLast : 0;\r\n    }\r\n    function getTWAPHistoryLength() public view override returns (uint){\r\n        return TWAPObservationHistory.length;\r\n    }\r\n\r\n    uint private unlocked = 1;\r\n    modifier lock() {\r\n        require(unlocked == 1); // LOCKED\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n    function getOrderIDsForUser(address user) external view returns (uint256[] memory) {\r\n        return orderIDsForUser[user];\r\n    }\r\n\r\n    function getOrderIDsForUserLength(address user) external view returns (uint256) {\r\n        return orderIDsForUser[user].length;\r\n    }\r\n\r\n    function getDetailedOrdersForUser(address user, uint256 offset, uint256 limit) external view returns (LongTermOrdersLib.Order[] memory detailed_orders) {\r\n        uint256[] memory order_ids = orderIDsForUser[user];\r\n        uint256 limit_to_use = Math.min(limit, order_ids.length - offset);\r\n        detailed_orders = new LongTermOrdersLib.Order[](limit_to_use);\r\n\r\n        for (uint256 i = 0; i < limit_to_use; i++){ \r\n            detailed_orders[i] = longTermOrders.orderMap[order_ids[offset + i]];\r\n        }\r\n    }\r\n\r\n    function getReserves() public override view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {\r\n        return (reserve0, reserve1, blockTimestampLast);\r\n    }\r\n\r\n    function getTwammReserves() public override view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast, uint112 _twammReserve0, uint112 _twammReserve1, uint256 _fee) {\r\n        return (reserve0, reserve1, blockTimestampLast, twammReserve0, twammReserve1, 10000-fee);\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(uint amountIn, address tokenIn) external view returns (uint) { \r\n        (uint112 reserveIn, uint112 reserveOut) = tokenIn == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n        require(amountIn > 0 && reserveIn > 0 && reserveOut > 0); // INSUFFICIENT_INPUT_AMOUNT, INSUFFICIENT_LIQUIDITY\r\n        uint amountInWithFee = amountIn * fee;\r\n        uint numerator = amountInWithFee * reserveOut;\r\n        uint denominator = (reserveIn * 10000) + amountInWithFee;\r\n        return numerator / denominator;\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(uint amountOut, address tokenOut) external view returns (uint) {\r\n        (uint112 reserveIn, uint112 reserveOut) = tokenOut == token0 ? (reserve1, reserve0) : (reserve0, reserve1);\r\n        require(amountOut > 0 && reserveIn > 0 && reserveOut > 0); // INSUFFICIENT_OUTPUT_AMOUNT, INSUFFICIENT_LIQUIDITY\r\n        uint numerator = reserveIn * amountOut * 10000;\r\n        uint denominator = (reserveOut - amountOut) * fee;\r\n        return (numerator / denominator) + 1;\r\n    }\r\n\r\n    function _safeTransfer(address token, address to, uint value) private {\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool)))); // TRANSFER_FAILED\r\n    }\r\n\r\n    constructor() {\r\n        factory = msg.sender;\r\n    }\r\n\r\n    // called once by the factory at time of deployment. will revert if fee is bad\r\n    function initialize(address _token0, address _token1, uint256 _fee) feeCheck(_fee) external override {\r\n        require(msg.sender == factory); // FORBIDDEN\r\n        // sufficient check\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n        fee = 10000 - _fee;\r\n\r\n        // TWAMM\r\n        longTermOrders.initialize(_token0);\r\n        \r\n        emit LpFeeUpdated(_fee);\r\n    }\r\n\r\n    function _getTimeElapsed() private view returns (uint32) {\r\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\r\n\r\n        uint32 timeElapsed;\r\n        unchecked{\r\n            timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\r\n        }\r\n        return timeElapsed;\r\n    }\r\n\r\n    // update reserves and, on the first call per block, price accumulators\r\n    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1, uint32 timeElapsed) private {\r\n        if (!(balance0 + twammReserve0 <= type(uint112).max && balance1 + twammReserve1 <= type(uint112).max)) revert Uint112Overflow(); // OVERFLOW\r\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\r\n\r\n        unchecked{\r\n            if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\r\n                // * never overflows, and + overflow is desired\r\n                TWAPObservationHistory.push(\r\n                    TWAPObservation(\r\n                        blockTimestamp,\r\n                        price0CumulativeLast() + uint(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed,\r\n                        price1CumulativeLast() + uint(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed\r\n                    )\r\n                );\r\n            }\r\n        }\r\n\r\n        reserve0 = uint112(balance0);\r\n        reserve1 = uint112(balance1);\r\n\r\n        blockTimestampLast = blockTimestamp;\r\n        emit Sync(reserve0, reserve1);\r\n    }\r\n\r\n    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)\r\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {\r\n        address feeTo = IUniswapV2FactoryV5(factory).feeTo();\r\n        feeOn = feeTo != address(0);\r\n        uint _kLast = kLast; // gas savings\r\n        if (feeOn) {\r\n            if (_kLast != 0) {\r\n                uint rootK = Math.sqrt(uint(_reserve0) * _reserve1);\r\n                uint rootKLast = Math.sqrt(_kLast);\r\n                if (rootK > rootKLast) {\r\n                    uint numerator = totalSupply * (rootK - rootKLast);\r\n                    uint denominator = (rootK * 5) + rootKLast;\r\n                    uint liquidity = numerator / denominator;\r\n                    if (liquidity > 0) _mint(feeTo, liquidity);\r\n                }\r\n            }\r\n        } else if (_kLast != 0) {\r\n            kLast = 0;\r\n        }\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function mint(address to) external override lock execVirtualOrders returns (uint liquidity) {\r\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\r\n        uint balance0 = IERC20V5(token0).balanceOf(address(this)) - twammReserve0;\r\n        uint balance1 = IERC20V5(token1).balanceOf(address(this)) - twammReserve1;\r\n        uint amount0 = balance0 - _reserve0;\r\n        uint amount1 = balance1 - _reserve1;\r\n\r\n        bool feeOn = _mintFee(_reserve0, _reserve1);\r\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\r\n        if (_totalSupply == 0) {\r\n            liquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;\r\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\r\n        } else {\r\n            liquidity = Math.min(amount0 * _totalSupply / _reserve0, amount1 * _totalSupply / _reserve1);\r\n        }\r\n        require(liquidity > 0); // INSUFFICIENT_LIQUIDITY_MINTED\r\n        _mint(to, liquidity);\r\n\r\n        _update(balance0, balance1, _reserve0, _reserve1, _getTimeElapsed());\r\n        if (feeOn) kLast = uint(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date\r\n        emit Mint(msg.sender, amount0, amount1);\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function burn(address to) external override lock execVirtualOrders returns (uint amount0, uint amount1) {\r\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\r\n        address _token0 = token0; // gas savings\r\n        address _token1 = token1; // gas savings\r\n        uint balance0 = IERC20V5(_token0).balanceOf(address(this)) - twammReserve0;\r\n        uint balance1 = IERC20V5(_token1).balanceOf(address(this)) - twammReserve1;\r\n        uint liquidity = balanceOf[address(this)];\r\n\r\n        bool feeOn = _mintFee(_reserve0, _reserve1);\r\n        uint _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee\r\n        amount0 = liquidity * balance0 / _totalSupply; // using balances ensures pro-rata distribution\r\n        amount1 = liquidity * balance1 / _totalSupply; // using balances ensures pro-rata distribution\r\n        require(amount0 > 0 && amount1 > 0); // INSUFFICIENT_LIQUIDITY_BURNED\r\n        _burn(address(this), liquidity);\r\n        _safeTransfer(_token0, to, amount0);\r\n        _safeTransfer(_token1, to, amount1);\r\n        balance0 = IERC20V5(_token0).balanceOf(address(this)) - twammReserve0;\r\n        balance1 = IERC20V5(_token1).balanceOf(address(this)) - twammReserve1;\r\n\r\n        _update(balance0, balance1, _reserve0, _reserve1, _getTimeElapsed());\r\n        if (feeOn) kLast = uint(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date\r\n        emit Burn(msg.sender, amount0, amount1, to);\r\n    }\r\n\r\n    // this low-level function should be called from a contract which performs important safety checks\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external override lock execVirtualOrders {\r\n        if(!(amount0Out > 0 || amount1Out > 0)) revert InsufficientOutputAmount(); // INSUFFICIENT_OUTPUT_AMOUNT\r\n        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings\r\n        if(!(amount0Out < _reserve0 && amount1Out < _reserve1)) revert InsufficientLiquidity(_reserve0, _reserve1); // INSUFFICIENT_LIQUIDITY\r\n\r\n        uint balance0;\r\n        uint balance1;\r\n        {// scope for _token{0,1}, avoids stack too deep errors\r\n            address _token0 = token0;\r\n            address _token1 = token1;\r\n            if(!(to != _token0 && to != _token1)) revert InvalidToToken(); // INVALID_TO\r\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\r\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\r\n            if (data.length > 0) IUniswapV2CalleeV5(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);\r\n            balance0 = IERC20V5(_token0).balanceOf(address(this)) - twammReserve0;\r\n            balance1 = IERC20V5(_token1).balanceOf(address(this)) - twammReserve1;\r\n        }\r\n        uint amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;\r\n        uint amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;\r\n        if(!(amount0In > 0 || amount1In > 0)) revert InsufficientInputAmount(); // INSUFFICIENT_INPUT_AMOUNT\r\n        {// scope for reserve{0,1}Adjusted, avoids stack too deep errors\r\n            uint minusFee = 10000 - fee;\r\n            uint balance0Adjusted = (balance0 * 10000) - (amount0In * minusFee);\r\n            uint balance1Adjusted = (balance1 * 10000) - (amount1In * minusFee);\r\n            if (!(balance0Adjusted * balance1Adjusted >= uint(_reserve0) * _reserve1 * (10000 ** 2))) revert KConstantError(); // K\r\n        }\r\n\r\n        _update(balance0, balance1, _reserve0, _reserve1, _getTimeElapsed());\r\n        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);\r\n    }\r\n\r\n    // force balances to match reserves\r\n    function skim(address to) external override lock execVirtualOrders {\r\n        address _token0 = token0; // gas savings\r\n        address _token1 = token1; // gas savings\r\n        _safeTransfer(_token0, to, IERC20V5(_token0).balanceOf(address(this)) - (reserve0 + twammReserve0));\r\n        _safeTransfer(_token1, to, IERC20V5(_token1).balanceOf(address(this)) - (reserve1 + twammReserve1));\r\n    }\r\n\r\n    // force reserves to match balances\r\n    function sync() external override lock execVirtualOrders {\r\n        _update(\r\n            IERC20V5(token0).balanceOf(address(this)) - twammReserve0,\r\n            IERC20V5(token1).balanceOf(address(this)) - twammReserve1,\r\n            reserve0, reserve1,\r\n            _getTimeElapsed()\r\n        );\r\n    }\r\n\r\n    // TWAMM\r\n\r\n    ///@notice calculate the amount in for token using the balance diff to handle feeOnTransfer tokens\r\n    function transferAmountIn(address token, uint amountIn) internal returns(uint256){\r\n        // prev balance\r\n        uint bal = IERC20V5(token).balanceOf(address(this));\r\n        // transfer amount to contract\r\n\r\n        // safeTransferFrom\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, msg.sender, address(this), amountIn));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n\r\n        // balance change\r\n        return IERC20V5(token).balanceOf(address(this)) - bal;\r\n    }\r\n\r\n    ///@notice create a long term order to swap from token0\r\n    ///@param amount0In total amount of token0 to swap\r\n    ///@param numberOfTimeIntervals number of time intervals over which to execute long term order\r\n    function longTermSwapFrom0To1(uint256 amount0In, uint256 numberOfTimeIntervals) external lock isNotPaused execVirtualOrders returns (uint256 orderId) {\r\n        uint amount0 = transferAmountIn(token0, amount0In);\r\n        twammReserve0 += uint112(amount0);\r\n        require(uint256(reserve0) + twammReserve0 <= type(uint112).max); // OVERFLOW\r\n        orderId = longTermOrders.performLongTermSwap(token0, token1, amount0, numberOfTimeIntervals);\r\n        orderIDsForUser[msg.sender].push(orderId);\r\n        emit LongTermSwap0To1(msg.sender, orderId, amount0, numberOfTimeIntervals);\r\n    }\r\n\r\n    ///@notice create a long term order to swap from token1\r\n    ///@param amount1In total amount of token1 to swap\r\n    ///@param numberOfTimeIntervals number of time intervals over which to execute long term order\r\n    function longTermSwapFrom1To0(uint256 amount1In, uint256 numberOfTimeIntervals) external lock isNotPaused execVirtualOrders returns (uint256 orderId) {\r\n        uint amount1 = transferAmountIn(token1, amount1In);\r\n        twammReserve1 += uint112(amount1);\r\n        require(uint256(reserve1) + twammReserve1 <= type(uint112).max); // OVERFLOW\r\n        orderId = longTermOrders.performLongTermSwap(token1, token0, amount1, numberOfTimeIntervals);\r\n        orderIDsForUser[msg.sender].push(orderId);\r\n        emit LongTermSwap1To0(msg.sender, orderId, amount1, numberOfTimeIntervals);\r\n    }\r\n\r\n    ///@notice stop the execution of a long term order\r\n    function cancelLongTermSwap(uint256 orderId) external lock execVirtualOrders {\r\n        (address sellToken, uint256 unsoldAmount, address buyToken, uint256 purchasedAmount) = longTermOrders.cancelLongTermSwap(orderId);\r\n\r\n        bool buyToken0 = buyToken == token0;\r\n        twammReserve0 -= uint112(buyToken0 ? purchasedAmount : unsoldAmount);\r\n        twammReserve1 -= uint112(buyToken0 ? unsoldAmount : purchasedAmount);\r\n\r\n        // update order. Used for tracking / informational\r\n        longTermOrders.orderMap[orderId].isComplete = true;\r\n\r\n        // transfer to owner of order\r\n        _safeTransfer(buyToken, msg.sender, purchasedAmount);\r\n        _safeTransfer(sellToken, msg.sender, unsoldAmount);\r\n\r\n        emit CancelLongTermOrder(msg.sender, orderId, sellToken, unsoldAmount, buyToken, purchasedAmount);\r\n    }\r\n\r\n    ///@notice withdraw proceeds from a long term swap\r\n    function withdrawProceedsFromLongTermSwap(uint256 orderId) external lock execVirtualOrders returns (bool is_expired, address rewardTkn, uint256 totalReward) {\r\n        (address proceedToken, uint256 proceeds, bool orderExpired) = longTermOrders.withdrawProceedsFromLongTermSwap(orderId);\r\n        if (proceedToken == token0) {\r\n            twammReserve0 -= uint112(proceeds);\r\n        } else {\r\n            twammReserve1 -= uint112(proceeds);\r\n        }\r\n\r\n        // update order. Used for tracking / informational\r\n        if (orderExpired) longTermOrders.orderMap[orderId].isComplete = true;\r\n\r\n        // transfer to owner of order\r\n        _safeTransfer(proceedToken, msg.sender, proceeds);\r\n\r\n        emit WithdrawProceedsFromLongTermOrder(msg.sender, orderId, proceedToken, proceeds, orderExpired);\r\n\r\n        return (orderExpired, proceedToken, proceeds);\r\n    }\r\n\r\n    ///@notice execute virtual orders in the twamm, bring it up to the blockNumber passed in\r\n    ///updates the TWAP if it is the first amm tx of the block\r\n    function executeVirtualOrdersInternal(uint256 blockTimestamp) internal {\r\n\r\n        if(newSwapsPaused) return; // skip twamm executions\r\n        if(twammUpToDate()) return; // save gas\r\n\r\n        LongTermOrdersLib.ExecuteVirtualOrdersResult memory result = LongTermOrdersLib.ExecuteVirtualOrdersResult(\r\n            reserve0,\r\n            reserve1,\r\n            twammReserve0,\r\n            twammReserve1,\r\n            fee\r\n        );\r\n\r\n        longTermOrders.executeVirtualOrdersUntilTimestamp(blockTimestamp, result);\r\n\r\n        twammReserve0 = uint112(result.newTwammReserve0);\r\n        twammReserve1 = uint112(result.newTwammReserve1);\r\n        \r\n        uint112 newReserve0 = uint112(result.newReserve0);\r\n        uint112 newReserve1 = uint112(result.newReserve1);\r\n\r\n        uint32 timeElapsed = _getTimeElapsed();\r\n        // update reserve0 and reserve1\r\n        if ( timeElapsed > 0 && (newReserve0 != reserve0 || newReserve1 != reserve1)) {\r\n            _update(newReserve0, newReserve1, reserve0, reserve1, timeElapsed);\r\n        } else {\r\n            reserve0 = newReserve0;\r\n            reserve1 = newReserve1;\r\n        }\r\n    }\r\n\r\n    ///@notice convenience function to execute virtual orders. Note that this already happens\r\n    ///before most interactions with the AMM\r\n    function executeVirtualOrders(uint256 blockTimestamp) public override lock {\r\n        // blockTimestamp is valid then execute the long term orders otherwise noop\r\n        if(longTermOrders.lastVirtualOrderTimestamp < blockTimestamp && blockTimestamp <= block.timestamp){\r\n            executeVirtualOrdersInternal(blockTimestamp);\r\n        }\r\n    }\r\n\r\n    /// ---------------------------\r\n    /// ------- TWAMM Views -------\r\n    /// ---------------------------\r\n\r\n    ///@notice util function for getting the next orderId\r\n    function getNextOrderID() public override view returns (uint256){\r\n        return longTermOrders.orderId;\r\n    }\r\n\r\n    ///@notice util function for checking if the twamm is up to date\r\n    function twammUpToDate() public override view returns (bool) {\r\n        return block.timestamp == longTermOrders.lastVirtualOrderTimestamp;\r\n    }\r\n\r\n    function getReserveAfterTwamm(uint256 blockTimestamp) public view returns (\r\n        uint112 _reserve0, uint112 _reserve1,\r\n        uint256 lastVirtualOrderTimestamp,\r\n        uint112 _twammReserve0, uint112 _twammReserve1\r\n    ) {\r\n\r\n        lastVirtualOrderTimestamp = longTermOrders.lastVirtualOrderTimestamp;\r\n\r\n        uint112 bal0 = reserve0 + twammReserve0; // save the balance of token0\r\n        uint112 bal1 = reserve1 + twammReserve1; // save the balance of token1\r\n\r\n        LongTermOrdersLib.ExecuteVirtualOrdersResult memory result = LongTermOrdersLib.ExecuteVirtualOrdersResult(\r\n            reserve0,\r\n            reserve1,\r\n            twammReserve0,\r\n            twammReserve1,\r\n            fee\r\n        );\r\n\r\n        longTermOrders.executeVirtualOrdersUntilTimestampView(blockTimestamp, result);\r\n\r\n        _reserve0 = uint112(bal0 - result.newTwammReserve0);\r\n        _reserve1 = uint112(bal1 - result.newTwammReserve1);\r\n        _twammReserve0 = uint112(result.newTwammReserve0);\r\n        _twammReserve1 = uint112(result.newTwammReserve1);\r\n    }\r\n\r\n    ///@notice returns the current state of the twamm\r\n    function getTwammState() public override view returns (\r\n        uint256 token0Rate,\r\n        uint256 token1Rate,\r\n        uint256 lastVirtualOrderTimestamp,\r\n        uint256 orderTimeInterval_rtn,\r\n        uint256 rewardFactorPool0,\r\n        uint256 rewardFactorPool1\r\n    ){\r\n        token0Rate = longTermOrders.OrderPool0.currentSalesRate;\r\n        token1Rate = longTermOrders.OrderPool1.currentSalesRate;\r\n        lastVirtualOrderTimestamp = longTermOrders.lastVirtualOrderTimestamp;\r\n        orderTimeInterval_rtn = orderTimeInterval;\r\n        rewardFactorPool0 = longTermOrders.OrderPool0.rewardFactor;\r\n        rewardFactorPool1 = longTermOrders.OrderPool1.rewardFactor;\r\n    }\r\n\r\n    ///@notice returns salesRates ending on this blockTimestamp\r\n    function getTwammSalesRateEnding(uint256 _blockTimestamp) public override view returns (\r\n        uint256 orderPool0SalesRateEnding,\r\n        uint256 orderPool1SalesRateEnding\r\n    ){\r\n        uint256 lastExpiryTimestamp = _blockTimestamp - (_blockTimestamp % orderTimeInterval);\r\n        orderPool0SalesRateEnding = longTermOrders.OrderPool0.salesRateEndingPerTimeInterval[lastExpiryTimestamp];\r\n        orderPool1SalesRateEnding = longTermOrders.OrderPool1.salesRateEndingPerTimeInterval[lastExpiryTimestamp];\r\n    }\r\n\r\n    ///@notice returns reward factors at this blockTimestamp\r\n    function getTwammRewardFactor(uint256 _blockTimestamp) public override view returns (\r\n        uint256 rewardFactorPool0AtTimestamp,\r\n        uint256 rewardFactorPool1AtTimestamp\r\n    ){\r\n        uint256 lastExpiryTimestamp = _blockTimestamp - (_blockTimestamp % orderTimeInterval);\r\n        rewardFactorPool0AtTimestamp = longTermOrders.OrderPool0.rewardFactorAtTimestamp[lastExpiryTimestamp];\r\n        rewardFactorPool1AtTimestamp = longTermOrders.OrderPool1.rewardFactorAtTimestamp[lastExpiryTimestamp];\r\n    }\r\n\r\n    ///@notice returns the twamm Order struct\r\n    function getTwammOrder(uint256 orderId) public override view returns (\r\n        uint256 id,\r\n        uint256 creationTimestamp,\r\n        uint256 expirationTimestamp,\r\n        uint256 saleRate,\r\n        address owner,\r\n        address sellTokenAddr,\r\n        address buyTokenAddr\r\n    ){\r\n        require(orderId < longTermOrders.orderId); // INVALID ORDERID\r\n        LongTermOrdersLib.Order storage order = longTermOrders.orderMap[orderId];\r\n        return (order.id, order.creationTimestamp, order.expirationTimestamp, order.saleRate, order.owner, order.sellTokenAddr, order.buyTokenAddr);\r\n    }\r\n\r\n    ///@notice returns the twamm Order withdrawable proceeds\r\n    // IMPORTANT: Can be stale. Should call executeVirtualOrders first or use getTwammOrderProceeds below.\r\n    // You can also .call() withdrawProceedsFromLongTermSwap\r\n    // blockTimestamp should be <= current\r\n    function getTwammOrderProceedsView(uint256 orderId, uint256 blockTimestamp) public override view returns (\r\n        bool orderExpired,\r\n        uint256 totalReward\r\n    ){\r\n        require(orderId < longTermOrders.orderId); // INVALID ORDERID\r\n        LongTermOrdersLib.OrderPool storage orderPool = LongTermOrdersLib.getOrderPool(longTermOrders, longTermOrders.orderMap[orderId].sellTokenAddr);\r\n        (orderExpired, totalReward) = LongTermOrdersLib.orderPoolGetProceeds(orderPool, orderId, blockTimestamp);\r\n    }\r\n\r\n    ///@notice returns the twamm Order withdrawable proceeds\r\n    // Need to update the virtual orders first\r\n    function getTwammOrderProceeds(uint256 orderId) public override returns (\r\n        bool orderExpired,\r\n        uint256 totalReward\r\n    ){\r\n        executeVirtualOrders(block.timestamp);\r\n        return getTwammOrderProceedsView(orderId, block.timestamp);\r\n    }\r\n\r\n    ///@notice Pauses the execution of existing twamm orders and the creation of new twamm orders\r\n    // Only callable once by anyone once the pause is toggled on the factory\r\n    function togglePauseNewSwaps() external override {\r\n        require(!newSwapsPaused && IUniswapV2FactoryV5(factory).globalPause()); // globalPause is enabled\r\n        // Pause new swaps\r\n        newSwapsPaused = true;\r\n    }\r\n\r\n    /* ========== RESTRICTED FUNCTIONS - Owner only ========== */\r\n\r\n    ///@notice sets the pool's lp fee\r\n    function setFee(uint256 newFee) execVirtualOrders feeCheck(newFee) external onlyOwnerOrFactory {\r\n        fee = 10000 - newFee; // newFee should be in basis points (100th of a pecent). 30 = 0.3%\r\n        emit LpFeeUpdated(newFee);\r\n    }\r\n\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InsufficientInputAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint112\",\"name\":\"reserve0\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"reserve1\",\"type\":\"uint112\"}],\"name\":\"InsufficientLiquidity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientOutputAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidToToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"KConstantError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Uint112Overflow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unsoldAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"purchasedAmount\",\"type\":\"uint256\"}],\"name\":\"CancelLongTermOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numberOfTimeIntervals\",\"type\":\"uint256\"}],\"name\":\"LongTermSwap0To1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numberOfTimeIntervals\",\"type\":\"uint256\"}],\"name\":\"LongTermSwap1To0\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"LpFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0Out\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"reserve0\",\"type\":\"uint112\"},{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"reserve1\",\"type\":\"uint112\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proceedToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"proceeds\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"orderExpired\",\"type\":\"bool\"}],\"name\":\"WithdrawProceedsFromLongTermOrder\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINIMUM_LIQUIDITY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"TWAPObservationHistory\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price0CumulativeLast\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price1CumulativeLast\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"cancelLongTermSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"executeVirtualOrders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"getDetailedOrdersForUser\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saleRate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sellTokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyTokenAddr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isComplete\",\"type\":\"bool\"}],\"internalType\":\"struct LongTermOrdersLib.Order[]\",\"name\":\"detailed_orders\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextOrderID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getOrderIDsForUser\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getOrderIDsForUserLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"getReserveAfterTwamm\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"_reserve0\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"_reserve1\",\"type\":\"uint112\"},{\"internalType\":\"uint256\",\"name\":\"lastVirtualOrderTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint112\",\"name\":\"_twammReserve0\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"_twammReserve1\",\"type\":\"uint112\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"_reserve0\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"_reserve1\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"_blockTimestampLast\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTWAPHistoryLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"getTwammOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"creationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saleRate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sellTokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyTokenAddr\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"getTwammOrderProceeds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"orderExpired\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalReward\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"getTwammOrderProceedsView\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"orderExpired\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTwammReserves\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"_reserve0\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"_reserve1\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"_blockTimestampLast\",\"type\":\"uint32\"},{\"internalType\":\"uint112\",\"name\":\"_twammReserve0\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"_twammReserve1\",\"type\":\"uint112\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"getTwammRewardFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardFactorPool0AtTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardFactorPool1AtTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"getTwammSalesRateEnding\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderPool0SalesRateEnding\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"orderPool1SalesRateEnding\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTwammState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"token0Rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"token1Rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastVirtualOrderTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"orderTimeInterval_rtn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardFactorPool0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardFactorPool1\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0In\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfTimeIntervals\",\"type\":\"uint256\"}],\"name\":\"longTermSwapFrom0To1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount1In\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numberOfTimeIntervals\",\"type\":\"uint256\"}],\"name\":\"longTermSwapFrom1To0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newSwapsPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderIDsForUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orderTimeInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price0CumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price1CumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"skim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0Out\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"togglePauseNewSwaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"twammReserve0\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"twammReserve1\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"twammUpToDate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"withdrawProceedsFromLongTermSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"is_expired\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"rewardTkn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalReward\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"FraxswapPair","CompilerVersion":"v0.8.15+commit.e14f2714","OptimizationUsed":1,"Runs":100000,"ConstructorArguments":"0x","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv2","Proxy":0,"SwarmSource":"ipfs://ff0f1e271603a9d47de68d4f1859e01970ca59682c13062be4eb53695c552a14"}]}