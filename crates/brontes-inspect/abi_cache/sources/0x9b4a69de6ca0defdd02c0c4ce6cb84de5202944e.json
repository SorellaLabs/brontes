{"expiry":1699494170,"data":[{"SourceCode":{"language":"Solidity","sources":{"@openzeppelin/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"contracts/interfaces/IUniswapV2Router02.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.19;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    )\n        external\n        payable\n        returns (uint amountToken, uint amountETH, uint liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint amountOut,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    function quote(\n        uint amountA,\n        uint reserveA,\n        uint reserveB\n    ) external pure returns (uint amountB);\n\n    function getAmountOut(\n        uint amountIn,\n        uint reserveIn,\n        uint reserveOut\n    ) external pure returns (uint amountOut);\n\n    function getAmountIn(\n        uint amountOut,\n        uint reserveIn,\n        uint reserveOut\n    ) external pure returns (uint amountIn);\n\n    function getAmountsOut(\n        uint amountIn,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n\n    function getAmountsIn(\n        uint amountOut,\n        address[] calldata path\n    ) external view returns (uint[] memory amounts);\n}\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"},"contracts/interfaces/IProofToken.sol":{"content":"// SPDX-License-Identifier: None\npragma solidity ^0.8.19;\n\ninterface IProofToken {\n    struct Tax {\n        uint16 revenueRate;\n        uint16 stakingRate;\n        uint16 ventureFundRate;\n    }\n\n    /// @notice Enable/Disable trading.\n    /// @dev Only owner can call this function.\n    function enableTrading(bool _enable) external;\n\n    /// @notice Set maxWallet amount.\n    /// @dev ONly owner can call this function.\n    function setMaxWallet(uint256 _maxWallet) external;\n\n    /// @notice Set maxTransfer amount.\n    /// @dev Only owner can call this function.\n    function setMaxTransfer(uint256 _maxTransfer) external;\n\n    /// @notice Set revenue address.\n    /// @dev Only owner can call this function.\n    function setRevenue(address _revenue) external;\n\n    /// @notice Set Staking contract address.\n    /// @dev Only owner can call this function.\n    function setStakingContract(address _staking) external;\n\n    /// @notice Set venture fund address.\n    /// @dev Only owner can call this function.\n    function setVentureFund(address _ventureFund) external;\n\n    /// @notice Set tax for buy.\n    /// @dev Only owner can call this function.\n    function setTaxForBuy(Tax memory _tax) external;\n\n    /// @notice Set tax for sell.\n    /// @dev Only owner can call this function.\n    function setTaxForSell(Tax memory _tax) external;\n\n    /// @notice Withdraw rest Proof token after airdrop.\n    /// @dev This can be called by only owner.\n    function withdrawRestAmount(uint256 _amount) external;\n\n    /// @notice Set new SwapThreshold amount and enable swap flag.\n    /// @dev Only owner can call this function.\n    function setSwapBackSettings(\n        uint256 _swapThreshold,\n        bool _swapEnable\n    ) external;\n\n    /// @notice Exclude wallets from TxLimit.\n    /// @dev Only owner can call this function.\n    function excludeWalletsFromTxLimit(\n        address[] memory _wallets,\n        bool _exclude\n    ) external;\n\n    /// @notice Exclude wallets from MaxWallet.\n    /// @dev Only owner can call this function.\n    function excludeWalletsFromMaxWallet(\n        address[] memory _wallets,\n        bool _exclude\n    ) external;\n\n    /// @notice Exclude wallets from Tax Fees.\n    /// @dev Only owner can call this function.\n    function excludeWalletsFromFees(\n        address[] memory _wallets,\n        bool _exclude\n    ) external;\n}\n"},"@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"contracts/ProofToken.sol":{"content":"// SPDX-License-Identifier: None\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport \"./interfaces/IProofToken.sol\";\nimport \"./interfaces/IUniswapV2Router02.sol\";\nimport \"./interfaces/IUniswapV2Factory.sol\";\n\ncontract ProofToken is Ownable, Pausable, IERC20, IProofToken {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    mapping(address => bool) public excludedFromTxLimit;\n    mapping(address => bool) public excludedFromMaxWallet;\n    mapping(address => bool) public excludedFromFees;\n    // mapping(address => bool) public airdropped;\n\n    uint256 private constant _totalSupply = 100_000_000 * 10 ** _decimals;\n    uint256 public maxTransfer;\n    uint256 public maxWallet;\n    // uint256 public airdroppedAmount;\n    uint256 public immutable launchTime;\n    uint256 public swapThreshold;\n\n    uint256 public accAmountForStaking;\n    uint256 public accAmountForRevenue;\n    uint256 public accAmountForVentureFund;\n    // uint256 public airdropReleaseTime;\n    // uint256 public minHLDAmountForAirdrop;\n\n    address public revenue;\n    address public stakingContract;\n    address public ventureFund;\n    address public pair;\n    // address public constant DEAD = 0x000000000000000000000000000000000000dEaD;\n\n    Tax public taxForBuy;\n    Tax public taxForSell;\n\n    address public immutable router;\n\n    bool public tradingEnable;\n    bool private inSwapLiquidity;\n    bool public swapEnable;\n\n    string private constant _name = \"PROOF\";\n    string private constant _symbol = \"PROOF\";\n\n    uint8 private constant _decimals = 9;\n    uint16 public constant FIXED_POINT = 1000;\n\n    /// @dev Status flag to show airdrop is already processed or not.\n    // bool public airdropProcessed;\n\n    constructor(\n        address _router,\n        address _revenue,\n        address _ventureFund,\n        address _stakingContract,\n        Tax memory _taxForBuy,\n        Tax memory _taxForSell\n    ) {\n        require(_router != address(0), \"zero router address\");\n        require(_revenue != address(0), \"zero revenue address\");\n        require(_ventureFund != address(0), \"zero ventureFund address\");\n\n        revenue = _revenue;\n        ventureFund = _ventureFund;\n        stakingContract = _stakingContract;\n\n        _balances[address(this)] = _totalSupply;\n        emit Transfer(address(0), address(this), _totalSupply);\n\n        maxWallet = _totalSupply / 100; // 1%\n        maxTransfer = (_totalSupply * 5) / 1000; // 0.5%\n\n        router = _router;\n        _createPair();\n\n        swapThreshold = _totalSupply / 10000; // 0.01%\n\n        excludedFromTxLimit[msg.sender] = true;\n        excludedFromTxLimit[pair] = true;\n        excludedFromTxLimit[address(this)] = true;\n\n        excludedFromMaxWallet[msg.sender] = true;\n        excludedFromMaxWallet[pair] = true;\n        excludedFromMaxWallet[address(this)] = true;\n        excludedFromMaxWallet[revenue] = true;\n        excludedFromMaxWallet[stakingContract] = true;\n        excludedFromMaxWallet[ventureFund] = true;\n\n        excludedFromFees[msg.sender] = true;\n        excludedFromFees[_revenue] = true;\n        excludedFromFees[_ventureFund] = true;\n        excludedFromFees[stakingContract] = true;\n\n        taxForBuy = _taxForBuy;\n        taxForSell = _taxForSell;\n        swapEnable = true;\n\n        launchTime = block.timestamp;\n    }\n\n    // !---------------- functions for ERC20 token ----------------!\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() external pure returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function airdrop(address[] memory users, uint256[] memory amounts) external onlyOwner {\n        uint256 len = users.length;\n        require(len == amounts.length, \"lists must be equal\");\n        for (uint256 i = 0; i < len; i++) {\n            _basicTransfer(amounts[i], address(this), users[i]);\n            emit Transfer(address(this), users[i], amounts[i]);\n        }\n    }\n\n    function transfer(\n        address _recipient,\n        uint256 _amount\n    ) external override returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    function allowance(\n        address _owner,\n        address _spender\n    ) external view override returns (uint256) {\n        return _allowances[_owner][_spender];\n    }\n\n    function approve(\n        address _spender,\n        uint256 _amount\n    ) external override returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function transferFrom(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) external override returns (bool) {\n        uint256 currentAllowance = _allowances[_sender][msg.sender];\n        require(currentAllowance >= _amount, \"Transfer > allowance\");\n        _approve(_sender, msg.sender, currentAllowance - _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    // !---------------- functions for ERC20 token ----------------!\n\n    /// @inheritdoc IProofToken\n    function excludeWalletsFromTxLimit(\n        address[] memory _wallets,\n        bool _exclude\n    ) external override onlyOwner {\n        uint256 length = _wallets.length;\n        require(length > 0, \"invalid array\");\n\n        for (uint256 i = 0; i < length; i++) {\n            excludedFromTxLimit[_wallets[i]] = _exclude;\n        }\n    }\n\n    /// @inheritdoc IProofToken\n    function excludeWalletsFromMaxWallet(\n        address[] memory _wallets,\n        bool _exclude\n    ) external override onlyOwner {\n        uint256 length = _wallets.length;\n        require(length > 0, \"invalid array\");\n        for (uint256 i = 0; i < length; i++) {\n            excludedFromMaxWallet[_wallets[i]] = _exclude;\n        }\n    }\n\n    /// @inheritdoc IProofToken\n    function excludeWalletsFromFees(\n        address[] memory _wallets,\n        bool _exclude\n    ) external override onlyOwner {\n        uint256 length = _wallets.length;\n        require(length > 0, \"invalid array\");\n        for (uint256 i = 0; i < length; i++) {\n            excludedFromFees[_wallets[i]] = _exclude;\n        }\n    }\n\n    /// @inheritdoc IProofToken\n    function enableTrading(bool _enable) external override onlyOwner {\n        tradingEnable = _enable;\n    }\n\n    /// @inheritdoc IProofToken\n    function setMaxWallet(uint256 _maxWallet) external override onlyOwner {\n        require(_maxWallet > 0, \"invalid maxWallet\");\n        maxWallet = _maxWallet;\n    }\n\n    /// @inheritdoc IProofToken\n    function setMaxTransfer(uint256 _maxTransfer) external override onlyOwner {\n        require(_maxTransfer > 0, \"invalid maxTransfer\");\n        maxTransfer = _maxTransfer;\n    }\n\n    /// @inheritdoc IProofToken\n    function setSwapBackSettings(\n        uint256 _swapThreshold,\n        bool _swapEnable\n    ) external override onlyOwner {\n        swapEnable = _swapEnable;\n        swapThreshold = _swapThreshold;\n    }\n\n    /// @inheritdoc IProofToken\n    function setRevenue(address _revenue) external override onlyOwner {\n        require(_revenue != address(0), \"zero revenue address\");\n        excludedFromFees[revenue] = false;\n        excludedFromFees[_revenue] = true;\n        revenue = _revenue;\n    }\n\n    /// @inheritdoc IProofToken\n    function setStakingContract(address _staking) external override onlyOwner {\n        require(_staking != address(0), \"zero staking contract address\");\n        if (stakingContract != address(0)) {\n            excludedFromFees[stakingContract] = false;\n        }\n        excludedFromMaxWallet[_staking] = true;\n        excludedFromFees[_staking] = true;\n        stakingContract = _staking;\n        \n    }\n\n    /// @inheritdoc IProofToken\n    function setVentureFund(address _ventureFund) external override onlyOwner {\n        require(_ventureFund != address(0), \"zero revenue address\");\n        excludedFromFees[ventureFund] = false;\n        excludedFromFees[_ventureFund] = true;\n        ventureFund = _ventureFund;\n    }\n\n    /// @inheritdoc IProofToken\n    function setTaxForBuy(Tax memory _tax) external override onlyOwner {\n        require((_tax.revenueRate + _tax.stakingRate + _tax.ventureFundRate) <= 120, \"12% max\");\n\n        taxForBuy = _tax;\n    }\n\n    /// @inheritdoc IProofToken\n    function setTaxForSell(Tax memory _tax) external override onlyOwner {\n        require((_tax.revenueRate + _tax.stakingRate + _tax.ventureFundRate) <= 170, \"17% max\");\n        taxForSell = _tax;\n    }\n\n    /// @inheritdoc IProofToken\n    function withdrawRestAmount(uint256 _amount) external override onlyOwner {\n        uint256 availableAmount = _balances[address(this)];\n        uint256 feeAmount = accAmountForRevenue +\n            accAmountForStaking +\n            accAmountForVentureFund;\n        availableAmount -= feeAmount;\n        require(availableAmount >= _amount, \"not enough balance to withdraw\");\n        _transfer(address(this), owner(), _amount);\n    }\n\n    receive() external payable {}\n\n    function _transfer(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) internal {\n        require(_sender != address(0), \"transfer from zero address\");\n        require(_recipient != address(0), \"transfer to zero address\");\n        require(_amount > 0, \"zero amount\");\n        require(_balances[_sender] >= _amount, \"not enough amount to transfer\");\n        require(\n            tradingEnable || (_recipient == stakingContract || _sender == stakingContract || _sender == owner() || _sender == address(this)),\n            \"trading is not enabled\"\n        );\n        if (inSwapLiquidity || !tradingEnable) { \n            _basicTransfer(_amount, _sender, _recipient);\n            emit Transfer(_sender, _recipient, _amount);\n            return;\n        }\n\n        require(\n            excludedFromTxLimit[_sender] || _amount <= maxTransfer,\n            \"over max transfer amount\"\n        );\n        require(\n            excludedFromMaxWallet[_recipient] ||\n                _balances[_recipient] + _amount <= maxWallet,\n            \"exceeds to max wallet\"\n        );\n\n        bool feelessTransfer = (excludedFromFees[_sender] ||\n            excludedFromFees[_recipient]);\n\n        if (_sender == pair) {\n            // buy\n            if (feelessTransfer) {\n                _basicTransfer(_amount, _sender, _recipient);\n            } else {\n                _takeFee(taxForBuy, _amount, _sender, _recipient);\n            }\n        } else {\n            _distributeFees();\n            // sell or wallet transfer\n            if (_recipient == pair) {\n                // sell\n                if (feelessTransfer) {\n                    _basicTransfer(_amount, _sender, _recipient);\n                } else {\n                    _takeFee(taxForSell, _amount, _sender, _recipient);\n                }\n            } else {\n                _basicTransfer(_amount, _sender, _recipient);\n            }\n        }\n\n        emit Transfer(_sender, _recipient, _amount);\n    }\n\n    function _basicTransfer(\n        uint256 _amount,\n        address _sender,\n        address _recipient\n    ) internal {\n        _balances[_sender] -= _amount;\n        _balances[_recipient] += _amount;\n    }\n\n    function _takeFee(\n        Tax memory _tax,\n        uint256 _amount,\n        address _sender,\n        address _recipient\n    ) internal {\n        uint16 totalFee = _tax.revenueRate + _tax.stakingRate + _tax.ventureFundRate;\n\n        uint256 feeAmount = (_amount * totalFee) / FIXED_POINT;\n        uint256 revenueFee = (_amount * _tax.revenueRate) / FIXED_POINT;\n        uint256 stakingFee = (_amount * _tax.stakingRate) / FIXED_POINT;\n        uint256 ventureFee = feeAmount - revenueFee - stakingFee;\n\n        accAmountForRevenue += revenueFee;\n        accAmountForStaking += stakingFee;\n        accAmountForVentureFund += ventureFee;\n\n        uint256 transferAmount = _amount - feeAmount;\n\n        _balances[address(this)] += feeAmount;\n        _balances[_sender] -= _amount;\n        _balances[_recipient] += transferAmount;\n    }\n\n    function _distributeFees() internal {\n        uint256 feeAmount = accAmountForRevenue +\n            accAmountForStaking +\n            accAmountForVentureFund;\n\n        if (feeAmount < swapThreshold || !swapEnable) {\n            return;\n        }\n\n        if (feeAmount > 0) {\n            inSwapLiquidity = true;\n            _swapTokensToETH(feeAmount);\n            uint256 swappedETHAmount = address(this).balance;\n            inSwapLiquidity = false;\n\n            uint256 revenueFee = (swappedETHAmount * accAmountForRevenue) /\n                feeAmount;\n            uint256 ventureFee = (swappedETHAmount * accAmountForVentureFund) /\n                feeAmount;\n            uint256 stakingFee = swappedETHAmount - revenueFee - ventureFee;\n\n            _transferETH(revenue, revenueFee);\n            _transferETH(stakingContract, stakingFee);\n            _transferETH(ventureFund, ventureFee);\n        }\n\n        accAmountForRevenue = 0;\n        accAmountForStaking = 0;\n        accAmountForVentureFund = 0;\n    }\n\n    function _swapTokensToETH(uint256 _amount) internal {\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = _getWrappedToken();\n\n        _approve(address(this), router, _amount);\n            IUniswapV2Router02(router)\n                .swapExactTokensForETHSupportingFeeOnTransferTokens(\n                    _amount,\n                    0,\n                    path,\n                    address(this),\n                    block.timestamp\n                );\n    }\n\n    function _transferETH(address _to, uint256 _amount) internal {\n        if (_amount == 0) return;\n\n        (bool sent, ) = _to.call{value: _amount}(\"\");\n        require(sent, \"sending ETH failed\");\n    }\n\n    function _approve(\n        address _owner,\n        address _spender,\n        uint256 _amount\n    ) private {\n        require(_owner != address(0), \"Approve from zero\");\n        require(_spender != address(0), \"Approve to zero\");\n        _allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    function _createPair() internal {\n        address WToken = _getWrappedToken();\n        pair = IUniswapV2Factory(IUniswapV2Router02(router).factory())\n            .createPair(WToken, address(this));\n    }\n\n    function _getWrappedToken() internal view returns (address) {\n        return\n            IUniswapV2Router02(router).WETH();\n    }\n}\n"},"contracts/interfaces/IUniswapV2Factory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ninterface IUniswapV2Factory {\n    event PairCreated(\n        address indexed token0,\n        address indexed token1,\n        address pair,\n        uint\n    );\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(\n        address tokenA,\n        address tokenB\n    ) external view returns (address pair);\n\n    function allPairs(uint) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint);\n\n    function createPair(\n        address tokenA,\n        address tokenB\n    ) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n"},"@openzeppelin/contracts/utils/structs/EnumerableSet.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"},"@openzeppelin/contracts/security/Pausable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"},"@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"}},"settings":{"libraries":{},"optimizer":{"details":{"yul":true},"enabled":true,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}},"viaIR":true}},"ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_revenue\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ventureFund\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakingContract\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"revenueRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"stakingRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"ventureFundRate\",\"type\":\"uint16\"}],\"internalType\":\"struct IProofToken.Tax\",\"name\":\"_taxForBuy\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"revenueRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"stakingRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"ventureFundRate\",\"type\":\"uint16\"}],\"internalType\":\"struct IProofToken.Tax\",\"name\":\"_taxForSell\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FIXED_POINT\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accAmountForRevenue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accAmountForStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accAmountForVentureFund\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_wallets\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_exclude\",\"type\":\"bool\"}],\"name\":\"excludeWalletsFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_wallets\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_exclude\",\"type\":\"bool\"}],\"name\":\"excludeWalletsFromMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_wallets\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_exclude\",\"type\":\"bool\"}],\"name\":\"excludeWalletsFromTxLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludedFromMaxWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludedFromTxLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTransfer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revenue\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxTransfer\",\"type\":\"uint256\"}],\"name\":\"setMaxTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxWallet\",\"type\":\"uint256\"}],\"name\":\"setMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_revenue\",\"type\":\"address\"}],\"name\":\"setRevenue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staking\",\"type\":\"address\"}],\"name\":\"setStakingContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapThreshold\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_swapEnable\",\"type\":\"bool\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"revenueRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"stakingRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"ventureFundRate\",\"type\":\"uint16\"}],\"internalType\":\"struct IProofToken.Tax\",\"name\":\"_tax\",\"type\":\"tuple\"}],\"name\":\"setTaxForBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"revenueRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"stakingRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"ventureFundRate\",\"type\":\"uint16\"}],\"internalType\":\"struct IProofToken.Tax\",\"name\":\"_tax\",\"type\":\"tuple\"}],\"name\":\"setTaxForSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ventureFund\",\"type\":\"address\"}],\"name\":\"setVentureFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxForBuy\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"revenueRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"stakingRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"ventureFundRate\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxForSell\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"revenueRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"stakingRate\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"ventureFundRate\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ventureFund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawRestAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"ProofToken","CompilerVersion":"v0.8.19+commit.7dd6d404","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d000000000000000000000000e9b4d32f829951a3ce145d2caa84cf66af56ca5e000000000000000000000000ffa594c9af7569fe3860e88d74963c1006c02ad6000000000000000000000000000000000000000000000000000000000000dead000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001e000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000001e","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}