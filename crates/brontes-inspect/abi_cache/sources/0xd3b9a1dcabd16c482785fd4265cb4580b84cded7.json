{"expiry":1699495175,"data":[{"SourceCode":{"language":"Solidity","sources":{"tellor360/contracts/NewTransition.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport \"./oldContracts/contracts/TellorVars.sol\";\nimport \"./oldContracts/contracts/interfaces/IOracle.sol\";\nimport \"./oldContracts/contracts/tellor3/TellorStorage.sol\";\n\n/**\n @author Tellor Inc.\n @title NewTransition\n* @dev The Transition contract links to the Oracle contract and\n* allows parties (like Liquity) to continue to use the master\n* address to access values which use legacy query IDs (request IDs). \n*/\ncontract NewTransition is TellorStorage, TellorVars {\n    // Functions\n    //Getters\n    /**\n     * @dev Allows Tellor to read data from the addressVars mapping\n     * @param _data is the keccak256(\"_VARIABLE_NAME\") of the variable that is being accessed.\n     * These are examples of how the variables are saved within other functions:\n     * addressVars[keccak256(\"_OWNER\")]\n     * addressVars[keccak256(\"_TELLOR_CONTRACT\")]\n     * @return address of the requested variable\n     */\n    function getAddressVars(bytes32 _data) external view returns (address) {\n        return addresses[_data];\n    }\n\n    /**\n     * @dev Returns the latest value for a specific request ID.\n     * @param _requestId the requestId to look up\n     * @return uint256 the latest value of the request ID\n     * @return bool whether or not the value was successfully retrieved\n     */\n    function getLastNewValueById(uint256 _requestId)\n        external\n        view\n        returns (uint256, bool)\n    {\n        uint256 _count = getNewValueCountbyRequestId(_requestId);\n        if (_count == 0) {\n            return (0, false);\n        }\n        uint256 _latestTimestamp = getTimestampbyRequestIDandIndex(\n            _requestId,\n            _count - 1\n        );\n        return (retrieveData(_requestId, _latestTimestamp), true);\n    }\n\n    /**\n     * @dev Function is solely for the parachute contract\n     */\n    function getNewCurrentVariables()\n        external\n        view\n        returns (\n            bytes32 _c,\n            uint256[5] memory _r,\n            uint256 _diff,\n            uint256 _tip\n        )\n    {\n        _r = [uint256(1), uint256(1), uint256(1), uint256(1), uint256(1)];\n        _diff = 0;\n        _tip = 0;\n        _c = keccak256(\n            abi.encode(\n                IOracle(addresses[_ORACLE_CONTRACT]).getTimeOfLastNewValue()\n            )\n        );\n    }\n\n    /**\n     * @dev Counts the number of values that have been submitted for the requestId.\n     * @param _requestId the requestId to look up\n     * @return uint256 count of the number of values received for the requestId\n     */\n    function getNewValueCountbyRequestId(uint256 _requestId)\n        public\n        view\n        returns (uint256)\n    {\n        (bytes32 _queryId, ) = _getQueryIdAndDecimals(_requestId);\n        IOracle _oracle = IOracle(addresses[_ORACLE_CONTRACT]);\n        // try the new oracle first\n        try _oracle.getNewValueCountbyQueryId(_queryId) returns (\n            uint256 _valueCount\n        ) {\n            if (_valueCount == 0) {\n                return 0;\n            }\n            // if last value is disputed, subtract 1 from the count until a non-disputed value is found\n            uint256 _timestamp = _oracle.getTimestampbyQueryIdandIndex(\n                _queryId,\n                _valueCount - 1\n            );\n            while (\n                _oracle.isInDispute(_queryId, _timestamp) &&\n                _valueCount > 1\n            ) {\n                _valueCount--;\n                _timestamp = _oracle.getTimestampbyQueryIdandIndex(\n                    _queryId,\n                    _valueCount - 1\n                );\n            }\n            if (\n                _valueCount == 1 &&\n                _oracle.isInDispute(_queryId, _timestamp)\n            ) {\n                return 0;\n            }\n            return _valueCount;\n        } catch {\n            return\n                IOracle(addresses[_ORACLE_CONTRACT]).getTimestampCountById(\n                    bytes32(_requestId)\n                );\n        }\n    }\n\n    /**\n     * @dev Gets the timestamp for the value based on its index\n     * @param _requestId is the requestId to look up\n     * @param _index is the value index to look up\n     * @return uint256 timestamp\n     */\n    function getTimestampbyRequestIDandIndex(uint256 _requestId, uint256 _index)\n        public\n        view\n        returns (uint256)\n    {\n        (bytes32 _queryId, ) = _getQueryIdAndDecimals(_requestId);\n        try\n            IOracle(addresses[_ORACLE_CONTRACT]).getTimestampbyQueryIdandIndex(\n                _queryId,\n                _index\n            )\n        returns (uint256 _val) {\n            if(_requestId == 1 && _val > block.timestamp - 15 minutes) {\n                ( , , _val) = IOracle(addresses[_ORACLE_CONTRACT]).getDataBefore(_queryId, block.timestamp - 15 minutes);\n            }\n            return _val;\n        } catch {\n            return\n                IOracle(addresses[_ORACLE_CONTRACT]).getReportTimestampByIndex(\n                    bytes32(_requestId),\n                    _index\n                );\n        }\n    }\n\n    /**\n     * @dev Getter for the variables saved under the TellorStorageStruct uints variable\n     * @param _data the variable to pull from the mapping. _data = keccak256(\"_VARIABLE_NAME\")\n     * where variable_name is the variables/strings used to save the data in the mapping.\n     * The variables names in the TellorVariables contract\n     * @return uint256 of specified variable\n     */\n    function getUintVar(bytes32 _data) external view returns (uint256) {\n        return uints[_data];\n    }\n\n    /**\n     * @dev Getter for if the party is migrated\n     * @param _addy address of party\n     * @return bool if the party is migrated\n     */\n    function isMigrated(address _addy) external view returns (bool) {\n        return migrated[_addy];\n    }\n\n    /**\n     * @dev Retrieve value from oracle based on timestamp\n     * @param _requestId being requested\n     * @param _timestamp to retrieve data/value from\n     * @return uint256 value for timestamp submitted\n     */\n    function retrieveData(uint256 _requestId, uint256 _timestamp)\n        public\n        view\n        returns (uint256)\n    {\n        (bytes32 _queryId, uint256 _decimalsAdjustment) = _getQueryIdAndDecimals(\n            _requestId\n        );\n        try\n            IOracle(addresses[_ORACLE_CONTRACT]).getValueByTimestamp(\n                bytes32(_requestId),\n                _timestamp\n            )\n        returns (bytes memory _val) {\n            return _sliceUint(_val);\n        } catch {\n            bytes memory _val;\n            if (_requestId == 1) {\n                (, _val, ) = IOracle(addresses[_ORACLE_CONTRACT])\n                    .getDataBefore(_queryId, block.timestamp - 15 minutes);\n            } else {\n                 _val = IOracle(addresses[_ORACLE_CONTRACT])\n                .retrieveData(_queryId, _timestamp);\n            }\n            return (_sliceUint(_val) / (10**_decimalsAdjustment));\n        }\n    }\n\n\n\n    // Internal functions\n    /**\n     * @dev Utilized to help slice a bytes variable into a uint\n     * @param _b is the bytes variable to be sliced\n     * @return _number of the sliced uint256\n     */\n    function _sliceUint(bytes memory _b)\n        internal\n        pure\n        returns (uint256 _number)\n    {\n        for (uint256 _i = 0; _i < _b.length; _i++) {\n            _number = _number * 2**8;\n            _number = _number + uint8(_b[_i]);\n        }\n    }\n\n    function _getQueryIdAndDecimals(uint256 _requestId) internal pure returns (bytes32, uint256) {\n        bytes32 _queryId;\n        uint256 _decimalsAdjustment;\n        if(_requestId == 1) {\n            _queryId = 0x83a7f3d48786ac2667503a61e8c415438ed2922eb86a2906e4ee66d9a2ce4992; // SpotPrice(eth, usd)\n            _decimalsAdjustment = 12;\n        } else if(_requestId == 10) {\n            _queryId = 0x0d12ad49193163bbbeff4e6db8294ced23ff8605359fd666799d4e25a3aa0e3a; // AmpleforthCustomSpotPrice(0x)\n            _decimalsAdjustment = 0;\n        } else if(_requestId == 41) {\n            _queryId = 0x612ec1d9cee860bb87deb6370ed0ae43345c9302c085c1dfc4c207cbec2970d7; // AmpleforthUSPCE(0x)\n            _decimalsAdjustment = 0;\n        } else {\n            _queryId = bytes32(_requestId);\n            _decimalsAdjustment = 0;\n        }\n        return(_queryId, _decimalsAdjustment);\n    }\n}\n"},"tellor360/contracts/oldContracts/contracts/tellor3/TellorStorage.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.7.4;\n\n/**\n  @author Tellor Inc.\n  @title TellorStorage\n  @dev Contains all the variables/structs used by Tellor\n*/\ncontract TellorStorage {\n    //Internal struct for use in proof-of-work submission\n    struct Details {\n        uint256 value;\n        address miner;\n    }\n    struct Dispute {\n        bytes32 hash; //unique hash of dispute: keccak256(_miner,_requestId,_timestamp)\n        int256 tally; //current tally of votes for - against measure\n        bool executed; //is the dispute settled\n        bool disputeVotePassed; //did the vote pass?\n        bool isPropFork; //true for fork proposal NEW\n        address reportedMiner; //miner who submitted the 'bad value' will get disputeFee if dispute vote fails\n        address reportingParty; //miner reporting the 'bad value'-pay disputeFee will get reportedMiner's stake if dispute vote passes\n        address proposedForkAddress; //new fork address (if fork proposal)\n        mapping(bytes32 => uint256) disputeUintVars;\n        mapping(address => bool) voted; //mapping of address to whether or not they voted\n    }\n    struct StakeInfo {\n        uint256 currentStatus; //0-not Staked, 1=Staked, 2=LockedForWithdraw 3= OnDispute 4=ReadyForUnlocking 5=Unlocked\n        uint256 startDate; //stake start date\n    }\n    //Internal struct to allow balances to be queried by blocknumber for voting purposes\n    struct Checkpoint {\n        uint128 fromBlock; // fromBlock is the block number that the value was generated from\n        uint128 value; // value is the amount of tokens at a specific block number\n    }\n    struct Request {\n        uint256[] requestTimestamps; //array of all newValueTimestamps requested\n        mapping(bytes32 => uint256) apiUintVars;\n        mapping(uint256 => uint256) minedBlockNum; //[apiId][minedTimestamp]=>block.number\n        //This the time series of finalValues stored by the contract where uint UNIX timestamp is mapped to value\n        mapping(uint256 => uint256) finalValues;\n        mapping(uint256 => bool) inDispute; //checks if API id is in dispute or finalized.\n        mapping(uint256 => address[5]) minersByValue;\n        mapping(uint256 => uint256[5]) valuesByTimestamp;\n    }\n    uint256[51] requestQ; //uint50 array of the top50 requests by payment amount\n    uint256[] public newValueTimestamps; //array of all timestamps requested\n    //This is a boolean that tells you if a given challenge has been completed by a given miner\n    mapping(uint256 => uint256) requestIdByTimestamp; //minedTimestamp to apiId\n    mapping(uint256 => uint256) requestIdByRequestQIndex; //link from payoutPoolIndex (position in payout pool array) to apiId\n    mapping(uint256 => Dispute) public disputesById; //disputeId=> Dispute details\n    mapping(bytes32 => uint256) public requestIdByQueryHash; // api bytes32 gets an id = to count of requests array\n    mapping(bytes32 => uint256) public disputeIdByDisputeHash; //maps a hash to an ID for each dispute\n    mapping(bytes32 => mapping(address => bool)) public minersByChallenge;\n    Details[5] public currentMiners; //This struct is for organizing the five mined values to find the median\n    mapping(address => StakeInfo) stakerDetails; //mapping from a persons address to their staking info\n    mapping(uint256 => Request) requestDetails;\n    mapping(bytes32 => uint256) public uints;\n    mapping(bytes32 => address) public addresses;\n    mapping(bytes32 => bytes32) public bytesVars;\n    //ERC20 storage\n    mapping(address => Checkpoint[]) public balances;\n    mapping(address => mapping(address => uint256)) public _allowances;\n    //Migration storage\n    mapping(address => bool) public migrated;\n}\n\n\n\n\n"},"tellor360/contracts/interfaces/ITellorFlex.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\ninterface ITellorFlex {\n    function addStakingRewards(uint256 _amount) external;\n}\n"},"tellor360/contracts/oldContracts/contracts/tellor3/TellorVariables.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.7.4;\n\n/**\n @author Tellor Inc.\n @title TellorVariables\n @dev Helper contract to store hashes of variables\n*/\ncontract TellorVariables {\n    bytes32 constant _BLOCK_NUMBER =\n        0x4b4cefd5ced7569ef0d091282b4bca9c52a034c56471a6061afd1bf307a2de7c; //keccak256(\"_BLOCK_NUMBER\");\n    bytes32 constant _CURRENT_CHALLENGE =\n        0xd54702836c9d21d0727ffacc3e39f57c92b5ae0f50177e593bfb5ec66e3de280; //keccak256(\"_CURRENT_CHALLENGE\");\n    bytes32 constant _CURRENT_REQUESTID =\n        0xf5126bb0ac211fbeeac2c0e89d4c02ac8cadb2da1cfb27b53c6c1f4587b48020; //keccak256(\"_CURRENT_REQUESTID\");\n    bytes32 constant _CURRENT_REWARD =\n        0xd415862fd27fb74541e0f6f725b0c0d5b5fa1f22367d9b78ec6f61d97d05d5f8; //keccak256(\"_CURRENT_REWARD\");\n    bytes32 constant _CURRENT_TOTAL_TIPS =\n        0x09659d32f99e50ac728058418d38174fe83a137c455ff1847e6fb8e15f78f77a; //keccak256(\"_CURRENT_TOTAL_TIPS\");\n    bytes32 constant _DEITY =\n        0x5fc094d10c65bc33cc842217b2eccca0191ff24148319da094e540a559898961; //keccak256(\"_DEITY\");\n    bytes32 constant _DIFFICULTY =\n        0xf758978fc1647996a3d9992f611883adc442931dc49488312360acc90601759b; //keccak256(\"_DIFFICULTY\");\n    bytes32 constant _DISPUTE_COUNT =\n        0x310199159a20c50879ffb440b45802138b5b162ec9426720e9dd3ee8bbcdb9d7; //keccak256(\"_DISPUTE_COUNT\");\n    bytes32 constant _DISPUTE_FEE =\n        0x675d2171f68d6f5545d54fb9b1fb61a0e6897e6188ca1cd664e7c9530d91ecfc; //keccak256(\"_DISPUTE_FEE\");\n    bytes32 constant _DISPUTE_ROUNDS =\n        0x6ab2b18aafe78fd59c6a4092015bddd9fcacb8170f72b299074f74d76a91a923; //keccak256(\"_DISPUTE_ROUNDS\");\n    bytes32 constant _EXTENSION =\n        0x2b2a1c876f73e67ebc4f1b08d10d54d62d62216382e0f4fd16c29155818207a4; //keccak256(\"_EXTENSION\");\n    bytes32 constant _FEE =\n        0x1da95f11543c9b03927178e07951795dfc95c7501a9d1cf00e13414ca33bc409; //keccak256(\"_FEE\");\n    bytes32 constant _FORK_EXECUTED =\n        0xda571dfc0b95cdc4a3835f5982cfdf36f73258bee7cb8eb797b4af8b17329875; //keccak256(\"_FORK_EXECUTED\");\n    bytes32 constant _LOCK =\n        0xd051321aa26ce60d202f153d0c0e67687e975532ab88ce92d84f18e39895d907;\n    bytes32 constant _MIGRATOR =\n        0xc6b005d45c4c789dfe9e2895b51df4336782c5ff6bd59a5c5c9513955aa06307; //keccak256(\"_MIGRATOR\");\n    bytes32 constant _MIN_EXECUTION_DATE =\n        0x46f7d53798d31923f6952572c6a19ad2d1a8238d26649c2f3493a6d69e425d28; //keccak256(\"_MIN_EXECUTION_DATE\");\n    bytes32 constant _MINER_SLOT =\n        0x6de96ee4d33a0617f40a846309c8759048857f51b9d59a12d3c3786d4778883d; //keccak256(\"_MINER_SLOT\");\n    bytes32 constant _NUM_OF_VOTES =\n        0x1da378694063870452ce03b189f48e04c1aa026348e74e6c86e10738514ad2c4; //keccak256(\"_NUM_OF_VOTES\");\n    bytes32 constant _OLD_TELLOR =\n        0x56e0987db9eaec01ed9e0af003a0fd5c062371f9d23722eb4a3ebc74f16ea371; //keccak256(\"_OLD_TELLOR\");\n    bytes32 constant _ORIGINAL_ID =\n        0xed92b4c1e0a9e559a31171d487ecbec963526662038ecfa3a71160bd62fb8733; //keccak256(\"_ORIGINAL_ID\");\n    bytes32 constant _OWNER =\n        0x7a39905194de50bde334d18b76bbb36dddd11641d4d50b470cb837cf3bae5def; //keccak256(\"_OWNER\");\n    bytes32 constant _PAID =\n        0x29169706298d2b6df50a532e958b56426de1465348b93650fca42d456eaec5fc; //keccak256(\"_PAID\");\n    bytes32 constant _PENDING_OWNER =\n        0x7ec081f029b8ac7e2321f6ae8c6a6a517fda8fcbf63cabd63dfffaeaafa56cc0; //keccak256(\"_PENDING_OWNER\");\n    bytes32 constant _REQUEST_COUNT =\n        0x3f8b5616fa9e7f2ce4a868fde15c58b92e77bc1acd6769bf1567629a3dc4c865; //keccak256(\"_REQUEST_COUNT\");\n    bytes32 constant _REQUEST_ID =\n        0x9f47a2659c3d32b749ae717d975e7962959890862423c4318cf86e4ec220291f; //keccak256(\"_REQUEST_ID\");\n    bytes32 constant _REQUEST_Q_POSITION =\n        0xf68d680ab3160f1aa5d9c3a1383c49e3e60bf3c0c031245cbb036f5ce99afaa1; //keccak256(\"_REQUEST_Q_POSITION\");\n    bytes32 constant _SLOT_PROGRESS =\n        0xdfbec46864bc123768f0d134913175d9577a55bb71b9b2595fda21e21f36b082; //keccak256(\"_SLOT_PROGRESS\");\n    bytes32 constant _STAKE_AMOUNT =\n        0x5d9fadfc729fd027e395e5157ef1b53ef9fa4a8f053043c5f159307543e7cc97; //keccak256(\"_STAKE_AMOUNT\");\n    bytes32 constant _STAKE_COUNT =\n        0x10c168823622203e4057b65015ff4d95b4c650b308918e8c92dc32ab5a0a034b; //keccak256(\"_STAKE_COUNT\");\n    bytes32 constant _T_BLOCK =\n        0xf3b93531fa65b3a18680d9ea49df06d96fbd883c4889dc7db866f8b131602dfb; //keccak256(\"_T_BLOCK\");\n    bytes32 constant _TALLY_DATE =\n        0xf9e1ae10923bfc79f52e309baf8c7699edb821f91ef5b5bd07be29545917b3a6; //keccak256(\"_TALLY_DATE\");\n    bytes32 constant _TARGET_MINERS =\n        0x0b8561044b4253c8df1d9ad9f9ce2e0f78e4bd42b2ed8dd2e909e85f750f3bc1; //keccak256(\"_TARGET_MINERS\");\n    bytes32 constant _TELLOR_CONTRACT =\n        0x0f1293c916694ac6af4daa2f866f0448d0c2ce8847074a7896d397c961914a08; //keccak256(\"_TELLOR_CONTRACT\");\n    bytes32 constant _TELLOR_GETTERS =\n        0xabd9bea65759494fe86471c8386762f989e1f2e778949e94efa4a9d1c4b3545a; //keccak256(\"_TELLOR_GETTERS\");\n    bytes32 constant _TIME_OF_LAST_NEW_VALUE =\n        0x2c8b528fbaf48aaf13162a5a0519a7ad5a612da8ff8783465c17e076660a59f1; //keccak256(\"_TIME_OF_LAST_NEW_VALUE\");\n    bytes32 constant _TIME_TARGET =\n        0xd4f87b8d0f3d3b7e665df74631f6100b2695daa0e30e40eeac02172e15a999e1; //keccak256(\"_TIME_TARGET\");\n    bytes32 constant _TIMESTAMP =\n        0x2f9328a9c75282bec25bb04befad06926366736e0030c985108445fa728335e5; //keccak256(\"_TIMESTAMP\");\n    bytes32 constant _TOTAL_SUPPLY =\n        0xe6148e7230ca038d456350e69a91b66968b222bfac9ebfbea6ff0a1fb7380160; //keccak256(\"_TOTAL_SUPPLY\");\n    bytes32 constant _TOTAL_TIP =\n        0x1590276b7f31dd8e2a06f9a92867333eeb3eddbc91e73b9833e3e55d8e34f77d; //keccak256(\"_TOTAL_TIP\");\n    bytes32 constant _VALUE =\n        0x9147231ab14efb72c38117f68521ddef8de64f092c18c69dbfb602ffc4de7f47; //keccak256(\"_VALUE\");\n    bytes32 constant _EIP_SLOT =\n        0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\n}\n"},"tellor360/contracts/oldContracts/contracts/interfaces/IOracle.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.3;\r\n\r\ninterface IOracle{\r\n    function getReportTimestampByIndex(bytes32 _queryId, uint256 _index) external view returns(uint256);\r\n    function getNewValueCountbyQueryId(bytes32 _queryId) external view returns(uint256);\r\n    function getValueByTimestamp(bytes32 _queryId, uint256 _timestamp) external view returns(bytes memory);\r\n    function getBlockNumberByTimestamp(bytes32 _queryId, uint256 _timestamp) external view returns(uint256);\r\n    function getReporterByTimestamp(bytes32 _queryId, uint256 _timestamp) external view returns(address);\r\n    function getReporterLastTimestamp(address _reporter) external view returns(uint256);\r\n    function reportingLock() external view returns(uint256);\r\n    function removeValue(bytes32 _queryId, uint256 _timestamp) external;\r\n    function getReportsSubmittedByAddress(address _reporter) external view returns(uint256);\r\n    function getTipsByUser(address _user) external view returns(uint256);\r\n    function tipQuery(bytes32 _queryId, uint256 _tip, bytes memory _queryData) external;\r\n    function submitValue(bytes32 _queryId, bytes calldata _value, uint256 _nonce, bytes memory _queryData) external;\r\n    function burnTips() external;\r\n    function verify() external pure returns(uint);\r\n    function changeReportingLock(uint256 _newReportingLock) external;\r\n    function changeTimeBasedReward(uint256 _newTimeBasedReward) external;\r\n    function getTipsById(bytes32 _queryId) external view returns(uint256);\r\n    function getTimestampCountById(bytes32 _queryId) external view returns(uint256);\r\n    function getTimestampIndexByTimestamp(bytes32 _queryId, uint256 _timestamp) external view returns(uint256);\r\n    function getCurrentValue(bytes32 _queryId) external view returns(bytes memory);\r\n    function getTimeOfLastNewValue() external view returns(uint256);\r\n    function getTimestampbyQueryIdandIndex(bytes32 _queryId, uint256 _index) external view returns(uint256);\r\n    function getDataBefore(bytes32 _queryId, uint256 _timestamp) external view returns(bool, bytes memory, uint256);\r\n    function getTokenAddress() external view returns(address);\r\n    function getStakeAmount() external view returns(uint256);\r\n    function isInDispute(bytes32 _queryId, uint256 _timestamp) external view returns(bool);\r\n    function slashReporter(address _reporter, address _recipient) external returns(uint256);\r\n    function retrieveData(bytes32 _queryId, uint256 _timestamp)\r\n        external\r\n        view\r\n        returns (bytes memory);\r\n    function getStakerInfo(address _stakerAddress)\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        );\r\n\r\n    \r\n}\r\n\r\n"},"tellor360/contracts/BaseToken.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport \"./oldContracts/contracts/TellorVars.sol\";\nimport \"./oldContracts/contracts/interfaces/IGovernance.sol\";\nimport \"./oldContracts/contracts/tellor3/TellorStorage.sol\";\n\n/**\n @author Tellor Inc.\n @title BaseToken\n @dev Contains the methods related to ERC20 transfers, allowance, and storage\n*/\ncontract BaseToken is TellorStorage, TellorVars {\n    // Events\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    ); // ERC20 Approval event\n    event Transfer(address indexed _from, address indexed _to, uint256 _value); // ERC20 Transfer Event\n\n    // Functions\n    /**\n     * @dev This function approves a _spender an _amount of tokens to use\n     * @param _spender address receiving the allowance\n     * @param _amount amount the spender is being approved for\n     * @return bool true if spender approved successfully\n     */\n    function approve(address _spender, uint256 _amount)\n        external\n        returns (bool)\n    {\n        require(_spender != address(0), \"ERC20: approve to the zero address\");\n        _allowances[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Allows tellor team to transfer stake of disputed TellorX reporter\n     * NOTE: this does not affect TellorFlex stakes, only disputes during 360 transition period\n     * @param _from the staker address holding the tokens being transferred\n     * @param _to the address of the recipient\n     */\n    function teamTransferDisputedStake(address _from, address _to) external {\n        require(\n            msg.sender == addresses[_OWNER],\n            \"only owner can transfer disputed staked\"\n        );\n        require(\n            stakerDetails[_from].currentStatus == 3,\n            \"_from address not disputed\"\n        );\n        stakerDetails[_from].currentStatus = 0;\n        _doTransfer(_from, _to, uints[_STAKE_AMOUNT]);\n    }\n\n    /**\n     * @dev Transfers _amount tokens from message sender to _to address\n     * @param _to token recipient\n     * @param _amount amount of tokens to send\n     * @return success whether the transfer was successful\n     */\n    function transfer(address _to, uint256 _amount)\n        external\n        returns (bool success)\n    {\n        _doTransfer(msg.sender, _to, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Send _amount tokens to _to from _from on the condition it\n     * is approved by _from\n     * @param _from the address holding the tokens being transferred\n     * @param _to the address of the recipient\n     * @param _amount the amount of tokens to be transferred\n     * @return success whether the transfer was successful\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external returns (bool success) {\n        require(\n            _allowances[_from][msg.sender] >= _amount,\n            \"Allowance is wrong\"\n        );\n        _allowances[_from][msg.sender] -= _amount;\n        _doTransfer(_from, _to, _amount);\n        return true;\n    }\n\n    // Getters\n    /**\n     * @dev Getter function for remaining spender balance\n     * @param _user address of party with the balance\n     * @param _spender address of spender of said user's balance\n     * @return uint256 the remaining allowance of tokens granted to the _spender from the _user\n     */\n    function allowance(address _user, address _spender)\n        external\n        view\n        returns (uint256)\n    {\n        return _allowances[_user][_spender];\n    }\n\n    /**\n     * @dev This function returns whether or not a given user is allowed to trade a given amount\n     * and removes the staked amount if they are staked in TellorX and disputed\n     * @param _user address of user\n     * @param _amount to check if the user can spend\n     * @return bool true if they are allowed to spend the amount being checked\n     */\n    function allowedToTrade(address _user, uint256 _amount)\n        public\n        view\n        returns (bool)\n    {\n        if (stakerDetails[_user].currentStatus == 3) {\n            // Subtracts the stakeAmount from balance if the _user is staked and disputed in TellorX\n            return (balanceOf(_user) - uints[_STAKE_AMOUNT] >= _amount);\n        }\n        return (balanceOf(_user) >= _amount); // Else, check if balance is greater than amount they want to spend\n    }\n\n    /**\n     * @dev Gets the balance of a given address\n     * @param _user the address whose balance to look up\n     * @return uint256 the balance of the given _user address\n     */\n    function balanceOf(address _user) public view returns (uint256) {\n        return balanceOfAt(_user, block.number);\n    }\n\n    /**\n     * @dev Gets the historic balance of a given _user address at a specific _blockNumber\n     * @param _user the address whose balance to look up\n     * @param _blockNumber the block number at which the balance is queried\n     * @return uint256 the balance of the _user address at the _blockNumber specified\n     */\n    function balanceOfAt(address _user, uint256 _blockNumber)\n        public\n        view\n        returns (uint256)\n    {\n        TellorStorage.Checkpoint[] storage checkpoints = balances[_user];\n        if (\n            checkpoints.length == 0 || checkpoints[0].fromBlock > _blockNumber\n        ) {\n            return 0;\n        } else {\n            if (_blockNumber >= checkpoints[checkpoints.length - 1].fromBlock)\n                return checkpoints[checkpoints.length - 1].value;\n            // Binary search of the value in the array\n            uint256 _min = 0;\n            uint256 _max = checkpoints.length - 2;\n            while (_max > _min) {\n                uint256 _mid = (_max + _min + 1) / 2;\n                if (checkpoints[_mid].fromBlock == _blockNumber) {\n                    return checkpoints[_mid].value;\n                } else if (checkpoints[_mid].fromBlock < _blockNumber) {\n                    _min = _mid;\n                } else {\n                    _max = _mid - 1;\n                }\n            }\n            return checkpoints[_min].value;\n        }\n    }\n\n    /**\n     * @dev Allows users to access the number of decimals\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev Allows users to access the token's name\n     */\n    function name() external pure returns (string memory) {\n        return \"Tellor Tributes\";\n    }\n\n    /**\n     * @dev Allows users to access the token's symbol\n     */\n    function symbol() external pure returns (string memory) {\n        return \"TRB\";\n    }\n\n    /**\n     * @dev Getter for the total_supply of tokens\n     * @return uint256 total supply\n     */\n    function totalSupply() external view returns (uint256) {\n        return uints[_TOTAL_SUPPLY];\n    }\n\n    // Internal functions\n    /**\n     * @dev Helps mint new TRB\n     * @param _to is the address to send minted amount to\n     * @param _amount is the amount of TRB to mint and send\n     */\n    function _doMint(address _to, uint256 _amount) internal {\n        // Ensure to address and mint amount are valid\n        require(_amount != 0, \"Tried to mint non-positive amount\");\n        require(_to != address(0), \"Receiver is 0 address\");\n        uint128 _previousBalance = uint128(balanceOf(_to));\n        uint128 _sizedAmount = uint128(_amount);\n        // Update total supply and balance of _to address\n        uints[_TOTAL_SUPPLY] += _amount;\n        _updateBalanceAtNow(_to, _previousBalance + _sizedAmount);\n        emit Transfer(address(0), _to, _amount);\n    }\n\n    /**\n     * @dev Completes transfers by updating the balances at the current block number\n     * and ensuring the amount does not contain tokens locked for tellorX disputes\n     * @param _from address to transfer from\n     * @param _to address to transfer to\n     * @param _amount amount of tokens to transfer\n     */\n    function _doTransfer(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        if (_amount == 0) {\n            return;\n        }\n        require(\n            allowedToTrade(_from, _amount),\n            \"Should have sufficient balance to trade\"\n        );\n        // Update balance of _from address\n        uint128 _previousBalance = uint128(balanceOf(_from));\n        uint128 _sizedAmount = uint128(_amount);\n        _updateBalanceAtNow(_from, _previousBalance - _sizedAmount);\n        // Update balance of _to address\n        _previousBalance = uint128(balanceOf(_to));\n        _updateBalanceAtNow(_to, _previousBalance + _sizedAmount);\n        emit Transfer(_from, _to, _amount);\n    }\n\n    /**\n     * @dev Updates balance checkpoint _amount for a given _user address at the current block number\n     * @param _user is the address whose balance to update\n     * @param _value is the new balance\n     */\n    function _updateBalanceAtNow(address _user, uint128 _value) internal {\n        Checkpoint[] storage checkpoints = balances[_user];\n        // Checks if no checkpoints exist, or if checkpoint block is not current block\n        if (\n            checkpoints.length == 0 ||\n            checkpoints[checkpoints.length - 1].fromBlock != block.number\n        ) {\n            // If yes, push a new checkpoint into the array\n            checkpoints.push(\n                TellorStorage.Checkpoint({\n                    fromBlock: uint128(block.number),\n                    value: _value\n                })\n            );\n        } else {\n            // Else, update old checkpoint\n            TellorStorage.Checkpoint storage oldCheckPoint = checkpoints[\n                checkpoints.length - 1\n            ];\n            oldCheckPoint.value = _value;\n        }\n    }\n}\n"},"tellor360/contracts/oldContracts/contracts/interfaces/IGovernance.sol":{"content":"// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.3;\r\n\r\ninterface IGovernance{\r\n    enum VoteResult {FAILED,PASSED,INVALID}\r\n    function setApprovedFunction(bytes4 _func, bool _val) external;\r\n    function beginDispute(bytes32 _queryId,uint256 _timestamp) external;\r\n    function delegate(address _delegate) external;\r\n    function delegateOfAt(address _user, uint256 _blockNumber) external view returns (address);\r\n    function executeVote(uint256 _disputeId) external;\r\n    function proposeVote(address _contract,bytes4 _function, bytes calldata _data, uint256 _timestamp) external;\r\n    function tallyVotes(uint256 _disputeId) external;\r\n    function updateMinDisputeFee() external;\r\n    function verify() external pure returns(uint);\r\n    function vote(uint256 _disputeId, bool _supports, bool _invalidQuery) external;\r\n    function voteFor(address[] calldata _addys,uint256 _disputeId, bool _supports, bool _invalidQuery) external;\r\n    function getDelegateInfo(address _holder) external view returns(address,uint);\r\n    function isApprovedGovernanceContract(address _contract) external view returns(bool);\r\n    function isFunctionApproved(bytes4 _func) external view returns(bool);\r\n    function getVoteCount() external view returns(uint256);\r\n    function getVoteRounds(bytes32 _hash) external view returns(uint256[] memory);\r\n    function getVoteInfo(uint256 _disputeId) external view returns(bytes32,uint256[8] memory,bool[2] memory,VoteResult,bytes memory,bytes4,address[2] memory);\r\n    function getDisputeInfo(uint256 _disputeId) external view returns(uint256,uint256,bytes memory, address);\r\n    function getOpenDisputesOnId(uint256 _queryId) external view returns(uint256);\r\n    function didVote(uint256 _disputeId, address _voter) external view returns(bool);\r\n    function getVoteTallyByAddress(address _voter) external view returns (uint256);\r\n    //testing\r\n    function testMin(uint256 a, uint256 b) external pure returns (uint256);\r\n}\r\n"},"tellor360/contracts/Tellor360.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport \"./BaseToken.sol\";\nimport \"./NewTransition.sol\";\nimport \"./interfaces/ITellorFlex.sol\";\n\n/**\n @author Tellor Inc.\n @title Tellor360\n @dev This is the controller contract which defines the functionality for\n * changing the oracle contract address, as well as minting and migrating tokens\n*/\ncontract Tellor360 is BaseToken, NewTransition {\n    // Events\n    event NewOracleAddress(address _newOracle, uint256 _timestamp);\n    event NewProposedOracleAddress(\n        address _newProposedOracle,\n        uint256 _timestamp\n    );\n\n    // Functions\n    /**\n     * @dev Constructor used to store new flex oracle address\n     * @param _flexAddress is the new oracle contract which will replace the\n     * tellorX oracle\n     */\n    constructor(address _flexAddress) {\n        require(_flexAddress != address(0), \"oracle address must be non-zero\");\n        addresses[keccak256(\"_ORACLE_CONTRACT_FOR_INIT\")] = _flexAddress;\n    }\n\n    /**\n     * @dev Use this function to initiate the contract\n     */\n    function init() external {\n        require(uints[keccak256(\"_INIT\")] == 0, \"should only happen once\");\n        uints[keccak256(\"_INIT\")] = 1;\n        // retrieve new oracle address from Tellor360 contract address storage\n        NewTransition _newController = NewTransition(\n            addresses[_TELLOR_CONTRACT]\n        );\n        address _flexAddress = _newController.getAddressVars(\n            keccak256(\"_ORACLE_CONTRACT_FOR_INIT\")\n        );\n        //on switch over, require tellorFlex values are over 12 hours old\n        //then when we switch, the governance switch can be instantaneous\n        bytes32 _id = 0x83a7f3d48786ac2667503a61e8c415438ed2922eb86a2906e4ee66d9a2ce4992;\n        uint256 _firstTimestamp = IOracle(_flexAddress)\n            .getTimestampbyQueryIdandIndex(_id, 0);\n        require(\n            block.timestamp - _firstTimestamp >= 12 hours,\n            \"contract should be at least 12 hours old\"\n        );\n        addresses[_ORACLE_CONTRACT] = _flexAddress; //used by Liquity+AMPL for this contract's reads\n        //init minting uints (timestamps)\n        uints[keccak256(\"_LAST_RELEASE_TIME_TEAM\")] = block.timestamp;\n        uints[keccak256(\"_LAST_RELEASE_TIME_DAO\")] = block.timestamp - 12 weeks;\n        // transfer dispute fees collected during transition period to team\n        _doTransfer(\n            addresses[_GOVERNANCE_CONTRACT],\n            addresses[_OWNER],\n            balanceOf(addresses[_GOVERNANCE_CONTRACT])\n        );\n    }\n\n    /**\n     * @dev Mints tokens of the sender from the old contract to the sender\n     */\n    function migrate() external {\n        require(!migrated[msg.sender], \"Already migrated\");\n        _doMint(\n            msg.sender,\n            BaseToken(addresses[_OLD_TELLOR]).balanceOf(msg.sender)\n        );\n        migrated[msg.sender] = true;\n    }\n\n    /**\n     * @dev Use this function to withdraw released tokens to the oracle\n     */\n    function mintToOracle() external {\n        require(uints[keccak256(\"_INIT\")] == 1, \"tellor360 not initiated\");\n        // X - 0.02X = 144 daily time based rewards. X = 146.94\n        uint256 _releasedAmount = (146.94 ether *\n            (block.timestamp - uints[keccak256(\"_LAST_RELEASE_TIME_DAO\")])) /\n            86400;\n        uints[keccak256(\"_LAST_RELEASE_TIME_DAO\")] = block.timestamp;\n        uint256 _stakingRewards = (_releasedAmount * 2) / 100;\n        _doMint(addresses[_ORACLE_CONTRACT], _releasedAmount - _stakingRewards);\n        // Send staking rewards\n        _doMint(address(this), _stakingRewards);\n        _allowances[address(this)][\n            addresses[_ORACLE_CONTRACT]\n        ] = _stakingRewards;\n        ITellorFlex(addresses[_ORACLE_CONTRACT]).addStakingRewards(\n            _stakingRewards\n        );\n    }\n\n    /**\n     * @dev Use this function to withdraw released tokens to the team\n     */\n    function mintToTeam() external {\n        require(uints[keccak256(\"_INIT\")] == 1, \"tellor360 not initiated\");\n        uint256 _releasedAmount = (146.94 ether *\n            (block.timestamp - uints[keccak256(\"_LAST_RELEASE_TIME_TEAM\")])) /\n            (86400);\n        uints[keccak256(\"_LAST_RELEASE_TIME_TEAM\")] = block.timestamp;\n        _doMint(addresses[_OWNER], _releasedAmount);\n    }\n\n    /**\n     * @dev This function allows team to gain control of any tokens sent directly to this\n     * contract (and send them back))\n     */\n    function transferOutOfContract() external {\n        _doTransfer(address(this), addresses[_OWNER], balanceOf(address(this)));\n    }\n\n    /**\n     * @dev Use this function to update the oracle contract\n     */\n    function updateOracleAddress() external {\n        bytes32 _queryID = keccak256(\n            abi.encode(\"TellorOracleAddress\", abi.encode(bytes(\"\")))\n        );\n        bytes memory _proposedOracleAddressBytes;\n        (, _proposedOracleAddressBytes, ) = IOracle(addresses[_ORACLE_CONTRACT])\n            .getDataBefore(_queryID, block.timestamp - 12 hours);\n        address _proposedOracle = abi.decode(\n            _proposedOracleAddressBytes,\n            (address)\n        );\n        // If the oracle address being reported is the same as the proposed oracle then update the oracle contract\n        // only if 7 days have passed since the new oracle address was made official\n        // and if 12 hours have passed since query id 1 was first reported on the new oracle contract\n        if (_proposedOracle == addresses[keccak256(\"_PROPOSED_ORACLE\")]) {\n            require(\n                block.timestamp >\n                    uints[keccak256(\"_TIME_PROPOSED_UPDATED\")] + 7 days,\n                \"must wait 7 days after proposing new oracle\"\n            );\n            bytes32 _id = 0x83a7f3d48786ac2667503a61e8c415438ed2922eb86a2906e4ee66d9a2ce4992;\n            uint256 _firstTimestamp = IOracle(_proposedOracle)\n                .getTimestampbyQueryIdandIndex(_id, 0);\n            require(\n                block.timestamp - _firstTimestamp >= 12 hours,\n                \"contract should be at least 12 hours old\"\n            );\n            addresses[_ORACLE_CONTRACT] = _proposedOracle;\n            emit NewOracleAddress(_proposedOracle, block.timestamp);\n        }\n        // Otherwise if the current reported oracle is not the proposed oracle, then propose it and\n        // start the clock on the 7 days before it can be made official\n        else {\n            require(_isValid(_proposedOracle), \"invalid oracle address\");\n            addresses[keccak256(\"_PROPOSED_ORACLE\")] = _proposedOracle;\n            uints[keccak256(\"_TIME_PROPOSED_UPDATED\")] = block.timestamp;\n            emit NewProposedOracleAddress(_proposedOracle, block.timestamp);\n        }\n    }\n\n    /**\n     * @dev Used during the upgrade process to verify valid Tellor Contracts\n     */\n    function verify() external pure returns (uint256) {\n        return 9999;\n    }\n\n    /**Internal Functions */\n    /**\n     * @dev Used during the upgrade process to verify valid Tellor Contracts and ensure\n     * they have the right signature\n     * @param _contract is the address of the Tellor contract to verify\n     * @return bool of whether or not the address is a valid Tellor contract\n     */\n    function _isValid(address _contract) internal returns (bool) {\n        (bool _success, bytes memory _data) = address(_contract).call(\n            abi.encodeWithSelector(0xfc735e99, \"\") // verify() signature\n        );\n        require(\n            _success && abi.decode(_data, (uint256)) > 9000, // An arbitrary number to ensure that the contract is valid\n            \"New contract is invalid\"\n        );\n        return true;\n    }\n}\n"},"tellor360/contracts/oldContracts/contracts/TellorVars.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.3;\n\nimport \"./tellor3/TellorVariables.sol\";\n\n/**\n @author Tellor Inc.\n @title TellorVariables\n @dev Helper contract to store hashes of variables.\n * For each of the bytes32 constants, the values are equal to\n * keccak256([VARIABLE NAME])\n*/\ncontract TellorVars is TellorVariables {\n    // Storage\n    address constant TELLOR_ADDRESS =\n        0x88dF592F8eb5D7Bd38bFeF7dEb0fBc02cf3778a0; // Address of main Tellor Contract\n    // Hashes for each pertinent contract\n    bytes32 constant _GOVERNANCE_CONTRACT =\n        0xefa19baa864049f50491093580c5433e97e8d5e41f8db1a61108b4fa44cacd93;\n    bytes32 constant _ORACLE_CONTRACT =\n        0xfa522e460446113e8fd353d7fa015625a68bc0369712213a42e006346440891e;\n    bytes32 constant _TREASURY_CONTRACT =\n        0x1436a1a60dca0ebb2be98547e57992a0fa082eb479e7576303cbd384e934f1fa;\n    bytes32 constant _SWITCH_TIME =\n        0x6c0e91a96227393eb6e42b88e9a99f7c5ebd588098b549c949baf27ac9509d8f;\n    bytes32 constant _MINIMUM_DISPUTE_FEE =\n        0x7335d16d7e7f6cb9f532376441907fe76aa2ea267285c82892601f4755ed15f0;\n}\n"}},"settings":{"libraries":{},"optimizer":{"enabled":true,"runs":300},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}}},"ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_flexAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newOracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"NewOracleAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newProposedOracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"NewProposedOracleAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_allowances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"addresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"allowedToTrade\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"balanceOfAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"fromBlock\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"value\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"bytesVars\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"currentMiners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"miner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"disputeIdByDisputeHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"disputesById\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"int256\",\"name\":\"tally\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"disputeVotePassed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPropFork\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"reportedMiner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reportingParty\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proposedForkAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"getAddressVars\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getLastNewValueById\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNewCurrentVariables\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"_c\",\"type\":\"bytes32\"},{\"internalType\":\"uint256[5]\",\"name\":\"_r\",\"type\":\"uint256[5]\"},{\"internalType\":\"uint256\",\"name\":\"_diff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tip\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getNewValueCountbyRequestId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getTimestampbyRequestIDandIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"getUintVar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addy\",\"type\":\"address\"}],\"name\":\"isMigrated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"migrated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minersByChallenge\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintToOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintToTeam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"newValueTimestamps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"requestIdByQueryHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"retrieveData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"teamTransferDisputedStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferOutOfContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"uints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateOracleAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"Tellor360","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":1,"Runs":300,"ConstructorArguments":"0x000000000000000000000000b3b662644f8d3138df63d2f43068ea621e2981f9","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}