{"expiry":1699495173,"data":[{"SourceCode":{"language":"Solidity","sources":{"contract/OffchainAggregator.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./AccessControllerInterface.sol\";\nimport \"./AggregatorV2V3Interface.sol\";\nimport \"./AggregatorValidatorInterface.sol\";\nimport \"./LinkTokenInterface.sol\";\nimport \"./Owned.sol\";\nimport \"./OffchainAggregatorBilling.sol\";\nimport \"./TypeAndVersionInterface.sol\";\n\n/**\n  * @notice Onchain verification of reports from the offchain reporting protocol\n\n  * @dev For details on its operation, see the offchain reporting protocol design\n  * @dev doc, which refers to this contract as simply the \"contract\".\n*/\ncontract OffchainAggregator is Owned, OffchainAggregatorBilling, AggregatorV2V3Interface, TypeAndVersionInterface {\n\n  uint256 constant private maxUint32 = (1 << 32) - 1;\n\n  // Storing these fields used on the hot path in a HotVars variable reduces the\n  // retrieval of all of them to a single SLOAD. If any further fields are\n  // added, make sure that storage of the struct still takes at most 32 bytes.\n  struct HotVars {\n    // Provides 128 bits of security against 2nd pre-image attacks, but only\n    // 64 bits against collisions. This is acceptable, since a malicious owner has\n    // easier way of messing up the protocol than to find hash collisions.\n    bytes16 latestConfigDigest;\n    uint40 latestEpochAndRound; // 32 most sig bits for epoch, 8 least sig bits for round\n    // Current bound assumed on number of faulty/dishonest oracles participating\n    // in the protocol, this value is referred to as f in the design\n    uint8 threshold;\n    // Chainlink Aggregators expose a roundId to consumers. The offchain reporting\n    // protocol does not use this id anywhere. We increment it whenever a new\n    // transmission is made to provide callers with contiguous ids for successive\n    // reports.\n    uint32 latestAggregatorRoundId;\n  }\n  HotVars internal s_hotVars;\n\n  // Transmission records the median answer from the transmit transaction at\n  // time timestamp\n  struct Transmission {\n    int192 answer; // 192 bits ought to be enough for anyone\n    uint64 timestamp;\n  }\n  mapping(uint32 /* aggregator round ID */ => Transmission) internal s_transmissions;\n\n  // incremented each time a new config is posted. This count is incorporated\n  // into the config digest, to prevent replay attacks.\n  uint32 internal s_configCount;\n  uint32 internal s_latestConfigBlockNumber; // makes it easier for offchain systems\n                                             // to extract config from logs.\n\n  // Lowest answer the system is allowed to report in response to transmissions\n  int192 immutable public minAnswer;\n  // Highest answer the system is allowed to report in response to transmissions\n  int192 immutable public maxAnswer;\n\n  /*\n   * @param _maximumGasPrice highest gas price for which transmitter will be compensated\n   * @param _reasonableGasPrice transmitter will receive reward for gas prices under this value\n   * @param _microLinkPerEth reimbursement per ETH of gas cost, in 1e-6LINK units\n   * @param _linkGweiPerObservation reward to oracle for contributing an observation to a successfully transmitted report, in 1e-9LINK units\n   * @param _linkGweiPerTransmission reward to transmitter of a successful report, in 1e-9LINK units\n   * @param _link address of the LINK contract\n   * @param _minAnswer lowest answer the median of a report is allowed to be\n   * @param _maxAnswer highest answer the median of a report is allowed to be\n   * @param _billingAccessController access controller for billing admin functions\n   * @param _requesterAccessController access controller for requesting new rounds\n   * @param _decimals answers are stored in fixed-point format, with this many digits of precision\n   * @param _description short human-readable description of observable this contract's answers pertain to\n   */\n  constructor(\n    uint32 _maximumGasPrice,\n    uint32 _reasonableGasPrice,\n    uint32 _microLinkPerEth,\n    uint32 _linkGweiPerObservation,\n    uint32 _linkGweiPerTransmission,\n    LinkTokenInterface _link,\n    int192 _minAnswer,\n    int192 _maxAnswer,\n    AccessControllerInterface _billingAccessController,\n    AccessControllerInterface _requesterAccessController,\n    uint8 _decimals,\n    string memory _description\n  )\n    OffchainAggregatorBilling(_maximumGasPrice, _reasonableGasPrice, _microLinkPerEth,\n      _linkGweiPerObservation, _linkGweiPerTransmission, _link,\n      _billingAccessController\n    )\n  {\n    decimals = _decimals;\n    s_description = _description;\n    setRequesterAccessController(_requesterAccessController);\n    setValidatorConfig(AggregatorValidatorInterface(0x0), 0);\n    minAnswer = _minAnswer;\n    maxAnswer = _maxAnswer;\n  }\n\n  /*\n   * Versioning\n   */\n  function typeAndVersion()\n    external\n    override\n    pure\n    virtual\n    returns (string memory)\n  {\n    return \"OffchainAggregator 4.0.0\";\n  }\n\n  /*\n   * Config logic\n   */\n\n  /**\n   * @notice triggers a new run of the offchain reporting protocol\n   * @param previousConfigBlockNumber block in which the previous config was set, to simplify historic analysis\n   * @param configCount ordinal number of this config setting among all config settings over the life of this contract\n   * @param signers ith element is address ith oracle uses to sign a report\n   * @param transmitters ith element is address ith oracle uses to transmit a report via the transmit method\n   * @param threshold maximum number of faulty/dishonest oracles the protocol can tolerate while still working correctly\n   * @param encodedConfigVersion version of the serialization format used for \"encoded\" parameter\n   * @param encoded serialized data used by oracles to configure their offchain operation\n   */\n  event ConfigSet(\n    uint32 previousConfigBlockNumber,\n    uint64 configCount,\n    address[] signers,\n    address[] transmitters,\n    uint8 threshold,\n    uint64 encodedConfigVersion,\n    bytes encoded\n  );\n\n  // Reverts transaction if config args are invalid\n  modifier checkConfigValid (\n    uint256 _numSigners, uint256 _numTransmitters, uint256 _threshold\n  ) {\n    require(_numSigners <= maxNumOracles, \"too many signers\");\n    require(_threshold > 0, \"threshold must be positive\");\n    require(\n      _numSigners == _numTransmitters,\n      \"oracle addresses out of registration\"\n    );\n    require(_numSigners > 3*_threshold, \"faulty-oracle threshold too high\");\n    _;\n  }\n\n  /**\n   * @notice sets offchain reporting protocol configuration incl. participating oracles\n   * @param _signers addresses with which oracles sign the reports\n   * @param _transmitters addresses oracles use to transmit the reports\n   * @param _threshold number of faulty oracles the system can tolerate\n   * @param _encodedConfigVersion version number for offchainEncoding schema\n   * @param _encoded encoded off-chain oracle configuration\n   */\n  function setConfig(\n    address[] calldata _signers,\n    address[] calldata _transmitters,\n    uint8 _threshold,\n    uint64 _encodedConfigVersion,\n    bytes calldata _encoded\n  )\n    external\n    checkConfigValid(_signers.length, _transmitters.length, _threshold)\n    onlyOwner()\n  {\n    while (s_signers.length != 0) { // remove any old signer/transmitter addresses\n      uint lastIdx = s_signers.length - 1;\n      address signer = s_signers[lastIdx];\n      address transmitter = s_transmitters[lastIdx];\n      payOracle(transmitter);\n      delete s_oracles[signer];\n      delete s_oracles[transmitter];\n      s_signers.pop();\n      s_transmitters.pop();\n    }\n\n    for (uint i = 0; i < _signers.length; i++) { // add new signer/transmitter addresses\n      require(\n        s_oracles[_signers[i]].role == Role.Unset,\n        \"repeated signer address\"\n      );\n      s_oracles[_signers[i]] = Oracle(uint8(i), Role.Signer);\n      require(s_payees[_transmitters[i]] != address(0), \"payee must be set\");\n      require(\n        s_oracles[_transmitters[i]].role == Role.Unset,\n        \"repeated transmitter address\"\n      );\n      s_oracles[_transmitters[i]] = Oracle(uint8(i), Role.Transmitter);\n      s_signers.push(_signers[i]);\n      s_transmitters.push(_transmitters[i]);\n    }\n    s_hotVars.threshold = _threshold;\n    uint32 previousConfigBlockNumber = s_latestConfigBlockNumber;\n    s_latestConfigBlockNumber = uint32(block.number);\n    s_configCount += 1;\n    uint64 configCount = s_configCount;\n    {\n      s_hotVars.latestConfigDigest = configDigestFromConfigData(\n        address(this),\n        configCount,\n        _signers,\n        _transmitters,\n        _threshold,\n        _encodedConfigVersion,\n        _encoded\n      );\n      s_hotVars.latestEpochAndRound = 0;\n    }\n    emit ConfigSet(\n      previousConfigBlockNumber,\n      configCount,\n      _signers,\n      _transmitters,\n      _threshold,\n      _encodedConfigVersion,\n      _encoded\n    );\n  }\n\n  function configDigestFromConfigData(\n    address _contractAddress,\n    uint64 _configCount,\n    address[] calldata _signers,\n    address[] calldata _transmitters,\n    uint8 _threshold,\n    uint64 _encodedConfigVersion,\n    bytes calldata _encodedConfig\n  ) internal pure returns (bytes16) {\n    return bytes16(keccak256(abi.encode(_contractAddress, _configCount,\n      _signers, _transmitters, _threshold, _encodedConfigVersion, _encodedConfig\n    )));\n  }\n\n  /**\n   * @notice information about current offchain reporting protocol configuration\n\n   * @return configCount ordinal number of current config, out of all configs applied to this contract so far\n   * @return blockNumber block at which this config was set\n   * @return configDigest domain-separation tag for current config (see configDigestFromConfigData)\n   */\n  function latestConfigDetails()\n    external\n    view\n    returns (\n      uint32 configCount,\n      uint32 blockNumber,\n      bytes16 configDigest\n    )\n  {\n    return (s_configCount, s_latestConfigBlockNumber, s_hotVars.latestConfigDigest);\n  }\n\n  /**\n   * @return list of addresses permitted to transmit reports to this contract\n\n   * @dev The list will match the order used to specify the transmitter during setConfig\n   */\n  function transmitters()\n    external\n    view\n    returns(address[] memory)\n  {\n      return s_transmitters;\n  }\n\n  /*\n   * On-chain validation logc\n   */\n\n  // Configuration for validator\n  struct ValidatorConfig {\n    AggregatorValidatorInterface validator;\n    uint32 gasLimit;\n  }\n  ValidatorConfig private s_validatorConfig;\n\n  /**\n   * @notice indicates that the validator configuration has been set\n   * @param previousValidator previous validator contract\n   * @param previousGasLimit previous gas limit for validate calls\n   * @param currentValidator current validator contract\n   * @param currentGasLimit current gas limit for validate calls\n   */\n  event ValidatorConfigSet(\n    AggregatorValidatorInterface indexed previousValidator,\n    uint32 previousGasLimit,\n    AggregatorValidatorInterface indexed currentValidator,\n    uint32 currentGasLimit\n  );\n\n  /**\n   * @notice validator configuration\n   * @return validator validator contract\n   * @return gasLimit gas limit for validate calls\n   */\n  function validatorConfig()\n    external\n    view\n    returns (AggregatorValidatorInterface validator, uint32 gasLimit)\n  {\n    ValidatorConfig memory vc = s_validatorConfig;\n    return (vc.validator, vc.gasLimit);\n  }\n\n  /**\n   * @notice sets validator configuration\n   * @dev set _newValidator to 0x0 to disable validate calls\n   * @param _newValidator address of the new validator contract\n   * @param _newGasLimit new gas limit for validate calls\n   */\n  function setValidatorConfig(AggregatorValidatorInterface _newValidator, uint32 _newGasLimit)\n    public\n    onlyOwner()\n  {\n    ValidatorConfig memory previous = s_validatorConfig;\n\n    if (previous.validator != _newValidator || previous.gasLimit != _newGasLimit) {\n      s_validatorConfig = ValidatorConfig({\n        validator: _newValidator,\n        gasLimit: _newGasLimit\n      });\n\n      emit ValidatorConfigSet(previous.validator, previous.gasLimit, _newValidator, _newGasLimit);\n    }\n  }\n\n  function validateAnswer(\n    uint32 _aggregatorRoundId,\n    int256 _answer\n  )\n    private\n  {\n    ValidatorConfig memory vc = s_validatorConfig;\n\n    if (address(vc.validator) == address(0)) {\n      return;\n    }\n\n    uint32 prevAggregatorRoundId = _aggregatorRoundId - 1;\n    int256 prevAggregatorRoundAnswer = s_transmissions[prevAggregatorRoundId].answer;\n    require(\n      callWithExactGasEvenIfTargetIsNoContract(\n        vc.gasLimit,\n        address(vc.validator),\n        abi.encodeWithSignature(\n          \"validate(uint256,int256,uint256,int256)\",\n          uint256(prevAggregatorRoundId),\n          prevAggregatorRoundAnswer,\n          uint256(_aggregatorRoundId),\n          _answer\n        )\n      ),\n      \"insufficient gas\"\n    );\n  }\n\n  uint256 private constant CALL_WITH_EXACT_GAS_CUSHION = 5_000;\n\n  /**\n   * @dev calls target address with exactly gasAmount gas and data as calldata\n   * or reverts if at least gasAmount gas is not available.\n   */\n  function callWithExactGasEvenIfTargetIsNoContract(\n    uint256 _gasAmount,\n    address _target,\n    bytes memory _data\n  )\n    private\n    returns (bool sufficientGas)\n  {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      let g := gas()\n      // Compute g -= CALL_WITH_EXACT_GAS_CUSHION and check for underflow. We\n      // need the cushion since the logic following the above call to gas also\n      // costs gas which we cannot account for exactly. So cushion is a\n      // conservative upper bound for the cost of this logic.\n      if iszero(lt(g, CALL_WITH_EXACT_GAS_CUSHION)) {\n        g := sub(g, CALL_WITH_EXACT_GAS_CUSHION)\n        // If g - g//64 <= _gasAmount, we don't have enough gas. (We subtract g//64\n        // because of EIP-150.)\n        if gt(sub(g, div(g, 64)), _gasAmount) {\n          // Call and ignore success/return data. Note that we did not check\n          // whether a contract actually exists at the _target address.\n          pop(call(_gasAmount, _target, 0, add(_data, 0x20), mload(_data), 0, 0))\n          sufficientGas := true\n        }\n      }\n    }\n  }\n\n  /*\n   * requestNewRound logic\n   */\n\n  AccessControllerInterface internal s_requesterAccessController;\n\n  /**\n   * @notice emitted when a new requester access controller contract is set\n   * @param old the address prior to the current setting\n   * @param current the address of the new access controller contract\n   */\n  event RequesterAccessControllerSet(AccessControllerInterface old, AccessControllerInterface current);\n\n  /**\n   * @notice emitted to immediately request a new round\n   * @param requester the address of the requester\n   * @param configDigest the latest transmission's configDigest\n   * @param epoch the latest transmission's epoch\n   * @param round the latest transmission's round\n   */\n  event RoundRequested(address indexed requester, bytes16 configDigest, uint32 epoch, uint8 round);\n\n  /**\n   * @notice address of the requester access controller contract\n   * @return requester access controller address\n   */\n  function requesterAccessController()\n    external\n    view\n    returns (AccessControllerInterface)\n  {\n    return s_requesterAccessController;\n  }\n\n  /**\n   * @notice sets the requester access controller\n   * @param _requesterAccessController designates the address of the new requester access controller\n   */\n  function setRequesterAccessController(AccessControllerInterface _requesterAccessController)\n    public\n    onlyOwner()\n  {\n    AccessControllerInterface oldController = s_requesterAccessController;\n    if (_requesterAccessController != oldController) {\n      s_requesterAccessController = AccessControllerInterface(_requesterAccessController);\n      emit RequesterAccessControllerSet(oldController, _requesterAccessController);\n    }\n  }\n\n  /**\n   * @notice immediately requests a new round\n   * @return the aggregatorRoundId of the next round. Note: The report for this round may have been\n   * transmitted (but not yet mined) *before* requestNewRound() was even called. There is *no*\n   * guarantee of causality between the request and the report at aggregatorRoundId.\n   */\n  function requestNewRound() external returns (uint80) {\n    require(msg.sender == owner || s_requesterAccessController.hasAccess(msg.sender, msg.data),\n      \"Only owner&requester can call\");\n\n    HotVars memory hotVars = s_hotVars;\n\n    emit RoundRequested(\n      msg.sender,\n      hotVars.latestConfigDigest,\n      uint32(s_hotVars.latestEpochAndRound >> 8),\n      uint8(s_hotVars.latestEpochAndRound)\n    );\n    return hotVars.latestAggregatorRoundId + 1;\n  }\n\n  /*\n   * Transmission logic\n   */\n\n  /**\n   * @notice indicates that a new report was transmitted\n   * @param aggregatorRoundId the round to which this report was assigned\n   * @param answer median of the observations attached this report\n   * @param transmitter address from which the report was transmitted\n   * @param observations observations transmitted with this report\n   * @param rawReportContext signature-replay-prevention domain-separation tag\n   */\n  event NewTransmission(\n    uint32 indexed aggregatorRoundId,\n    int192 answer,\n    address transmitter,\n    int192[] observations,\n    bytes observers,\n    bytes32 rawReportContext\n  );\n\n  // decodeReport is used to check that the solidity and go code are using the\n  // same format. See TestOffchainAggregator.testDecodeReport and TestReportParsing\n  function decodeReport(bytes memory _report)\n    internal\n    pure\n    returns (\n      bytes32 rawReportContext,\n      bytes32 rawObservers,\n      int192[] memory observations\n    )\n  {\n    (rawReportContext, rawObservers, observations) = abi.decode(_report,\n      (bytes32, bytes32, int192[]));\n  }\n\n  // Used to relieve stack pressure in transmit\n  struct ReportData {\n    HotVars hotVars; // Only read from storage once\n    bytes observers; // ith element is the index of the ith observer\n    int192[] observations; // ith element is the ith observation\n    bytes vs; // jth element is the v component of the jth signature\n    bytes32 rawReportContext;\n  }\n\n  /*\n   * @notice details about the most recent report\n\n   * @return configDigest domain separation tag for the latest report\n   * @return epoch epoch in which the latest report was generated\n   * @return round OCR round in which the latest report was generated\n   * @return latestAnswer median value from latest report\n   * @return latestTimestamp when the latest report was transmitted\n   */\n  function latestTransmissionDetails()\n    external\n    view\n    returns (\n      bytes16 configDigest,\n      uint32 epoch,\n      uint8 round,\n      int192 latestAnswer,\n      uint64 latestTimestamp\n    )\n  {\n    require(msg.sender == tx.origin, \"Only callable by EOA\");\n    return (\n      s_hotVars.latestConfigDigest,\n      uint32(s_hotVars.latestEpochAndRound >> 8),\n      uint8(s_hotVars.latestEpochAndRound),\n      s_transmissions[s_hotVars.latestAggregatorRoundId].answer,\n      s_transmissions[s_hotVars.latestAggregatorRoundId].timestamp\n    );\n  }\n\n  // The constant-length components of the msg.data sent to transmit.\n  // See the \"If we wanted to call sam\" example on for example reasoning\n  // https://solidity.readthedocs.io/en/v0.7.2/abi-spec.html\n  uint16 private constant TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT =\n    4 + // function selector\n    32 + // word containing start location of abiencoded _report value\n    32 + // word containing location start of abiencoded  _rs value\n    32 + // word containing start location of abiencoded _ss value\n    32 + // _rawVs value\n    32 + // word containing length of _report\n    32 + // word containing length _rs\n    32 + // word containing length of _ss\n    0; // placeholder\n\n  function expectedMsgDataLength(\n    bytes calldata _report, bytes32[] calldata _rs, bytes32[] calldata _ss\n  ) private pure returns (uint256 length)\n  {\n    // calldata will never be big enough to make this overflow\n    return uint256(TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT) +\n      _report.length + // one byte pure entry in _report\n      _rs.length * 32 + // 32 bytes per entry in _rs\n      _ss.length * 32 + // 32 bytes per entry in _ss\n      0; // placeholder\n  }\n\n  /**\n   * @notice transmit is called to post a new report to the contract\n   * @param _report serialized report, which the signatures are signing. See parsing code below for format. The ith element of the observers component must be the index in s_signers of the address for the ith signature\n   * @param _rs ith element is the R components of the ith signature on report. Must have at most maxNumOracles entries\n   * @param _ss ith element is the S components of the ith signature on report. Must have at most maxNumOracles entries\n   * @param _rawVs ith element is the the V component of the ith signature\n   */\n  function transmit(\n    // NOTE: If these parameters are changed, expectedMsgDataLength and/or\n    // TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT need to be changed accordingly\n    bytes calldata _report,\n    bytes32[] calldata _rs, bytes32[] calldata _ss, bytes32 _rawVs // signatures\n  )\n    external\n  {\n    uint256 initialGas = gasleft(); // This line must come first\n    // Make sure the transmit message-length matches the inputs. Otherwise, the\n    // transmitter could append an arbitrarily long (up to gas-block limit)\n    // string of 0 bytes, which we would reimburse at a rate of 16 gas/byte, but\n    // which would only cost the transmitter 4 gas/byte. (Appendix G of the\n    // yellow paper, p. 25, for G_txdatazero and EIP 2028 for G_txdatanonzero.)\n    // This could amount to reimbursement profit of 36 million gas, given a 3MB\n    // zero tail.\n    require(msg.data.length == expectedMsgDataLength(_report, _rs, _ss),\n      \"transmit message too long\");\n    ReportData memory r; // Relieves stack pressure\n    {\n      r.hotVars = s_hotVars; // cache read from storage\n\n      bytes32 rawObservers;\n      (r.rawReportContext, rawObservers, r.observations) = abi.decode(\n        _report, (bytes32, bytes32, int192[])\n      );\n\n      // rawReportContext consists of:\n      // 11-byte zero padding\n      // 16-byte configDigest\n      // 4-byte epoch\n      // 1-byte round\n\n      bytes16 configDigest = bytes16(r.rawReportContext << 88);\n      require(\n        r.hotVars.latestConfigDigest == configDigest,\n        \"configDigest mismatch\"\n      );\n\n      uint40 epochAndRound = uint40(uint256(r.rawReportContext));\n\n      // direct numerical comparison works here, because\n      //\n      //   ((e,r) <= (e',r')) implies (epochAndRound <= epochAndRound')\n      //\n      // because alphabetic ordering implies e <= e', and if e = e', then r<=r',\n      // so e*256+r <= e'*256+r', because r, r' < 256\n      require(r.hotVars.latestEpochAndRound < epochAndRound, \"stale report\");\n\n      require(_rs.length > r.hotVars.threshold, \"not enough signatures\");\n      require(_rs.length <= maxNumOracles, \"too many signatures\");\n      require(_ss.length == _rs.length, \"signatures out of registration\");\n      require(r.observations.length <= maxNumOracles,\n              \"num observations out of bounds\");\n      require(r.observations.length > 2 * r.hotVars.threshold,\n              \"too few values to trust median\");\n\n      // Copy signature parities in bytes32 _rawVs to bytes r.v\n      r.vs = new bytes(_rs.length);\n      for (uint8 i = 0; i < _rs.length; i++) {\n        r.vs[i] = _rawVs[i];\n      }\n\n      // Copy observer identities in bytes32 rawObservers to bytes r.observers\n      r.observers = new bytes(r.observations.length);\n      bool[maxNumOracles] memory seen;\n      for (uint8 i = 0; i < r.observations.length; i++) {\n        uint8 observerIdx = uint8(rawObservers[i]);\n        require(!seen[observerIdx], \"observer index repeated\");\n        seen[observerIdx] = true;\n        r.observers[i] = rawObservers[i];\n      }\n\n      Oracle memory transmitter = s_oracles[msg.sender];\n      require( // Check that sender is authorized to report\n        transmitter.role == Role.Transmitter &&\n        msg.sender == s_transmitters[transmitter.index],\n        \"unauthorized transmitter\"\n      );\n      // record epochAndRound here, so that we don't have to carry the local\n      // variable in transmit. The change is reverted if something fails later.\n      r.hotVars.latestEpochAndRound = epochAndRound;\n    }\n\n    { // Verify signatures attached to report\n      bytes32 h = keccak256(_report);\n      bool[maxNumOracles] memory signed;\n\n      Oracle memory o;\n      for (uint i = 0; i < _rs.length; i++) {\n        address signer = ecrecover(h, uint8(r.vs[i])+27, _rs[i], _ss[i]);\n        o = s_oracles[signer];\n        require(o.role == Role.Signer, \"address not authorized to sign\");\n        require(!signed[o.index], \"non-unique signature\");\n        signed[o.index] = true;\n      }\n    }\n\n    { // Check the report contents, and record the result\n      for (uint i = 0; i < r.observations.length - 1; i++) {\n        bool inOrder = r.observations[i] <= r.observations[i+1];\n        require(inOrder, \"observations not sorted\");\n      }\n\n      int192 median = r.observations[r.observations.length/2];\n      require(minAnswer <= median && median <= maxAnswer, \"median is out of min-max range\");\n      r.hotVars.latestAggregatorRoundId++;\n      s_transmissions[r.hotVars.latestAggregatorRoundId] =\n        Transmission(median, uint64(block.timestamp));\n\n      emit NewTransmission(\n        r.hotVars.latestAggregatorRoundId,\n        median,\n        msg.sender,\n        r.observations,\n        r.observers,\n        r.rawReportContext\n      );\n      // Emit these for backwards compatability with offchain consumers\n      // that only support legacy events\n      emit NewRound(\n        r.hotVars.latestAggregatorRoundId,\n        address(0x0), // use zero address since we don't have anybody \"starting\" the round here\n        block.timestamp\n      );\n      emit AnswerUpdated(\n        median,\n        r.hotVars.latestAggregatorRoundId,\n        block.timestamp\n      );\n\n      validateAnswer(r.hotVars.latestAggregatorRoundId, median);\n    }\n    s_hotVars = r.hotVars;\n    assert(initialGas < maxUint32);\n    reimburseAndRewardOracles(uint32(initialGas), r.observers);\n  }\n\n  /*\n   * v2 Aggregator interface\n   */\n\n  /**\n   * @notice median from the most recent report\n   */\n  function latestAnswer()\n    public\n    override\n    view\n    virtual\n    returns (int256)\n  {\n    return s_transmissions[s_hotVars.latestAggregatorRoundId].answer;\n  }\n\n  /**\n   * @notice timestamp of block in which last report was transmitted\n   */\n  function latestTimestamp()\n    public\n    override\n    view\n    virtual\n    returns (uint256)\n  {\n    return s_transmissions[s_hotVars.latestAggregatorRoundId].timestamp;\n  }\n\n  /**\n   * @notice Aggregator round (NOT OCR round) in which last report was transmitted\n   */\n  function latestRound()\n    public\n    override\n    view\n    virtual\n    returns (uint256)\n  {\n    return s_hotVars.latestAggregatorRoundId;\n  }\n\n  /**\n   * @notice median of report from given aggregator round (NOT OCR round)\n   * @param _roundId the aggregator round of the target report\n   */\n  function getAnswer(uint256 _roundId)\n    public\n    override\n    view\n    virtual\n    returns (int256)\n  {\n    if (_roundId > 0xFFFFFFFF) { return 0; }\n    return s_transmissions[uint32(_roundId)].answer;\n  }\n\n  /**\n   * @notice timestamp of block in which report from given aggregator round was transmitted\n   * @param _roundId aggregator round (NOT OCR round) of target report\n   */\n  function getTimestamp(uint256 _roundId)\n    public\n    override\n    view\n    virtual\n    returns (uint256)\n  {\n    if (_roundId > 0xFFFFFFFF) { return 0; }\n    return s_transmissions[uint32(_roundId)].timestamp;\n  }\n\n  /*\n   * v3 Aggregator interface\n   */\n\n  string constant private V3_NO_DATA_ERROR = \"No data present\";\n\n  /**\n   * @return answers are stored in fixed-point format, with this many digits of precision\n   */\n  uint8 immutable public override decimals;\n\n  /**\n   * @notice aggregator contract version\n   */\n  uint256 constant public override version = 4;\n\n  string internal s_description;\n\n  /**\n   * @notice human-readable description of observable this contract is reporting on\n   */\n  function description()\n    public\n    override\n    view\n    virtual\n    returns (string memory)\n  {\n    return s_description;\n  }\n\n  /**\n   * @notice details for the given aggregator round\n   * @param _roundId target aggregator round (NOT OCR round). Must fit in uint32\n   * @return roundId _roundId\n   * @return answer median of report from given _roundId\n   * @return startedAt timestamp of block in which report from given _roundId was transmitted\n   * @return updatedAt timestamp of block in which report from given _roundId was transmitted\n   * @return answeredInRound _roundId\n   */\n  function getRoundData(uint80 _roundId)\n    public\n    override\n    view\n    virtual\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    require(_roundId <= 0xFFFFFFFF, V3_NO_DATA_ERROR);\n    Transmission memory transmission = s_transmissions[uint32(_roundId)];\n    return (\n      _roundId,\n      transmission.answer,\n      transmission.timestamp,\n      transmission.timestamp,\n      _roundId\n    );\n  }\n\n  /**\n   * @notice aggregator details for the most recently transmitted report\n   * @return roundId aggregator round of latest report (NOT OCR round)\n   * @return answer median of latest report\n   * @return startedAt timestamp of block containing latest report\n   * @return updatedAt timestamp of block containing latest report\n   * @return answeredInRound aggregator round of latest report\n   */\n  function latestRoundData()\n    public\n    override\n    view\n    virtual\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    roundId = s_hotVars.latestAggregatorRoundId;\n\n    // Skipped for compatability with existing FluxAggregator in which latestRoundData never reverts.\n    // require(roundId != 0, V3_NO_DATA_ERROR);\n\n    Transmission memory transmission = s_transmissions[uint32(roundId)];\n    return (\n      roundId,\n      transmission.answer,\n      transmission.timestamp,\n      transmission.timestamp,\n      roundId\n    );\n  }\n}\n"},"contract/AggregatorInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n  function latestTimestamp() external view returns (uint256);\n  function latestRound() external view returns (uint256);\n  function getAnswer(uint256 roundId) external view returns (int256);\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"},"contract/AggregatorV2V3Interface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\n{\n}"},"contract/AccessControlledOffchainAggregator.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./OffchainAggregator.sol\";\nimport \"./SimpleReadAccessController.sol\";\n\n/**\n * @notice Wrapper of OffchainAggregator which checks read access on Aggregator-interface methods\n */\ncontract AccessControlledOffchainAggregator is OffchainAggregator, SimpleReadAccessController {\n\n  constructor(\n    uint32 _maximumGasPrice,\n    uint32 _reasonableGasPrice,\n    uint32 _microLinkPerEth,\n    uint32 _linkGweiPerObservation,\n    uint32 _linkGweiPerTransmission,\n    LinkTokenInterface _link,\n    int192 _minAnswer,\n    int192 _maxAnswer,\n    AccessControllerInterface _billingAccessController,\n    AccessControllerInterface _requesterAccessController,\n    uint8 _decimals,\n    string memory description\n  )\n    OffchainAggregator(\n      _maximumGasPrice,\n      _reasonableGasPrice,\n      _microLinkPerEth,\n      _linkGweiPerObservation,\n      _linkGweiPerTransmission,\n      _link,\n      _minAnswer,\n      _maxAnswer,\n      _billingAccessController,\n      _requesterAccessController,\n      _decimals,\n      description\n    ) {\n    }\n\n  /*\n   * Versioning\n   */\n\n  function typeAndVersion()\n    external\n    override\n    pure\n    virtual\n    returns (string memory)\n  {\n    return \"AccessControlledOffchainAggregator 4.0.0\";\n  }\n\n\n  /*\n   * v2 Aggregator interface\n   */\n\n  /// @inheritdoc OffchainAggregator\n  function latestAnswer()\n    public\n    override\n    view\n    checkAccess()\n    returns (int256)\n  {\n    return super.latestAnswer();\n  }\n\n  /// @inheritdoc OffchainAggregator\n  function latestTimestamp()\n    public\n    override\n    view\n    checkAccess()\n    returns (uint256)\n  {\n    return super.latestTimestamp();\n  }\n\n  /// @inheritdoc OffchainAggregator\n  function latestRound()\n    public\n    override\n    view\n    checkAccess()\n    returns (uint256)\n  {\n    return super.latestRound();\n  }\n\n  /// @inheritdoc OffchainAggregator\n  function getAnswer(uint256 _roundId)\n    public\n    override\n    view\n    checkAccess()\n    returns (int256)\n  {\n    return super.getAnswer(_roundId);\n  }\n\n  /// @inheritdoc OffchainAggregator\n  function getTimestamp(uint256 _roundId)\n    public\n    override\n    view\n    checkAccess()\n    returns (uint256)\n  {\n    return super.getTimestamp(_roundId);\n  }\n\n  /*\n   * v3 Aggregator interface\n   */\n\n  /// @inheritdoc OffchainAggregator\n  function description()\n    public\n    override\n    view\n    checkAccess()\n    returns (string memory)\n  {\n    return super.description();\n  }\n\n  /// @inheritdoc OffchainAggregator\n  function getRoundData(uint80 _roundId)\n    public\n    override\n    view\n    checkAccess()\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return super.getRoundData(_roundId);\n  }\n\n  /// @inheritdoc OffchainAggregator\n  function latestRoundData()\n    public\n    override\n    view\n    checkAccess()\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return super.latestRoundData();\n  }\n\n}\n"},"contract/AggregatorV3Interface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"},"contract/LinkTokenInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n  function approve(address spender, uint256 value) external returns (bool success);\n  function balanceOf(address owner) external view returns (uint256 balance);\n  function decimals() external view returns (uint8 decimalPlaces);\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n  function name() external view returns (string memory tokenName);\n  function symbol() external view returns (string memory tokenSymbol);\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n  function transfer(address to, uint256 value) external returns (bool success);\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n"},"contract/AccessControllerInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface AccessControllerInterface {\n  function hasAccess(address user, bytes calldata data) external view returns (bool);\n}\n"},"contract/AggregatorValidatorInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\ninterface AggregatorValidatorInterface {\n  function validate(\n    uint256 previousRoundId,\n    int256 previousAnswer,\n    uint256 currentRoundId,\n    int256 currentAnswer\n  ) external returns (bool);\n}"},"contract/OffchainAggregatorBilling.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./AccessControllerInterface.sol\";\nimport \"./LinkTokenInterface.sol\";\nimport \"./Owned.sol\";\n\n/**\n * @notice tracks administration of oracle-reward and gas-reimbursement parameters.\n\n * @dev\n * If you read or change this, be sure to read or adjust the comments. They\n * track the units of the values under consideration, and are crucial to\n * the readability of the operations it specifies.\n\n * @notice\n * Trust Model:\n\n * Nothing in this contract prevents a billing admin from setting insane\n * values for the billing parameters in setBilling. Oracles\n * participating in this contract should regularly check that the\n * parameters make sense. Similarly, the outstanding obligations of this\n * contract to the oracles can exceed the funds held by the contract.\n * Oracles participating in this contract should regularly check that it\n * holds sufficient funds and stop interacting with it if funding runs\n * out.\n\n * This still leaves oracles with some risk due to TOCTOU issues.\n * However, since the sums involved are pretty small (Ethereum\n * transactions aren't that expensive in the end) and an oracle would\n * likely stop participating in a contract it repeatedly lost money on,\n * this risk is deemed acceptable. Oracles should also regularly\n * withdraw any funds in the contract to prevent issues where the\n * contract becomes underfunded at a later time, and different oracles\n * are competing for the left-over funds.\n\n * Finally, note that any change to the set of oracles or to the billing\n * parameters will trigger payout of all oracles first (using the old\n * parameters), a billing admin cannot take away funds that are already\n * marked for payment.\n*/\ncontract OffchainAggregatorBilling is Owned {\n\n  // Maximum number of oracles the offchain reporting protocol is designed for\n  uint256 constant internal maxNumOracles = 31;\n\n  // Parameters for oracle payments\n  struct Billing {\n\n    // Highest compensated gas price, in ETH-gwei uints\n    uint32 maximumGasPrice;\n\n    // If gas price is less (in ETH-gwei units), transmitter gets half the savings\n    uint32 reasonableGasPrice;\n\n    // Pay transmitter back this much LINK per unit eth spent on gas\n    // (1e-6LINK/ETH units)\n    uint32 microLinkPerEth;\n\n    // Fixed LINK reward for each observer, in LINK-gwei units\n    uint32 linkGweiPerObservation;\n\n    // Fixed reward for transmitter, in linkGweiPerObservation units\n    uint32 linkGweiPerTransmission;\n  }\n  Billing internal s_billing;\n\n  // We assume that the token contract is correct. This contract is not written\n  // to handle misbehaving ERC20 tokens!\n  LinkTokenInterface internal s_linkToken;\n\n  AccessControllerInterface internal s_billingAccessController;\n\n  // ith element is number of observation rewards due to ith process, plus one.\n  // This is expected to saturate after an oracle has submitted 65,535\n  // observations, or about 65535/(3*24*20) = 45 days, given a transmission\n  // every 3 minutes.\n  //\n  // This is always one greater than the actual value, so that when the value is\n  // reset to zero, we don't end up with a zero value in storage (which would\n  // result in a higher gas cost, the next time the value is incremented.)\n  // Calculations using this variable need to take that offset into account.\n  uint16[maxNumOracles] internal s_oracleObservationsCounts;\n\n  // Addresses at which oracles want to receive payments, by transmitter address\n  mapping (address /* transmitter */ => address /* payment address */)\n    internal\n    s_payees;\n\n  // Payee addresses which must be approved by the owner\n  mapping (address /* transmitter */ => address /* payment address */)\n    internal\n    s_proposedPayees;\n\n  // LINK-wei-denominated reimbursements for gas used by transmitters.\n  //\n  // This is always one greater than the actual value, so that when the value is\n  // reset to zero, we don't end up with a zero value in storage (which would\n  // result in a higher gas cost, the next time the value is incremented.)\n  // Calculations using this variable need to take that offset into account.\n  //\n  // Argument for overflow safety:\n  // We have the following maximum intermediate values:\n  // - 2**40 additions to this variable (epochAndRound is a uint40)\n  // - 2**32 gas price in ethgwei/gas\n  // - 1e9 ethwei/ethgwei\n  // - 2**32 gas since the block gas limit is at ~20 million\n  // - 2**32 (microlink/eth)\n  // And we have 2**40 * 2**32 * 1e9 * 2**32 * 2**32 < 2**166\n  // (we also divide in some places, but that only makes the value smaller)\n  // We can thus safely use uint256 intermediate values for the computation\n  // updating this variable.\n  uint256[maxNumOracles] internal s_gasReimbursementsLinkWei;\n\n  // Used for s_oracles[a].role, where a is an address, to track the purpose\n  // of the address, or to indicate that the address is unset.\n  enum Role {\n    // No oracle role has been set for address a\n    Unset,\n    // Signing address for the s_oracles[a].index'th oracle. I.e., report\n    // signatures from this oracle should ecrecover back to address a.\n    Signer,\n    // Transmission address for the s_oracles[a].index'th oracle. I.e., if a\n    // report is received by OffchainAggregator.transmit in which msg.sender is\n    // a, it is attributed to the s_oracles[a].index'th oracle.\n    Transmitter\n  }\n\n  struct Oracle {\n    uint8 index; // Index of oracle in s_signers/s_transmitters\n    Role role;   // Role of the address which mapped to this struct\n  }\n\n  mapping (address /* signer OR transmitter address */ => Oracle)\n    internal s_oracles;\n\n  // s_signers contains the signing address of each oracle\n  address[] internal s_signers;\n\n  // s_transmitters contains the transmission address of each oracle,\n  // i.e. the address the oracle actually sends transactions to the contract from\n  address[] internal s_transmitters;\n\n  uint256 constant private  maxUint16 = (1 << 16) - 1;\n  uint256 constant internal maxUint128 = (1 << 128) - 1;\n\n  constructor(\n    uint32 _maximumGasPrice,\n    uint32 _reasonableGasPrice,\n    uint32 _microLinkPerEth,\n    uint32 _linkGweiPerObservation,\n    uint32 _linkGweiPerTransmission,\n    LinkTokenInterface _link,\n    AccessControllerInterface _billingAccessController\n  )\n  {\n    setBillingInternal(_maximumGasPrice, _reasonableGasPrice, _microLinkPerEth,\n      _linkGweiPerObservation, _linkGweiPerTransmission);\n    s_linkToken = _link;\n    emit LinkTokenSet(LinkTokenInterface(address(0)), _link);\n    setBillingAccessControllerInternal(_billingAccessController);\n    uint16[maxNumOracles] memory counts; // See s_oracleObservationsCounts docstring\n    uint256[maxNumOracles] memory gas; // see s_gasReimbursementsLinkWei docstring\n    for (uint8 i = 0; i < maxNumOracles; i++) {\n      counts[i] = 1;\n      gas[i] = 1;\n    }\n    s_oracleObservationsCounts = counts;\n    s_gasReimbursementsLinkWei = gas;\n  }\n\n  /*\n   * @notice emitted when the LINK token contract is set\n   * @param _oldLinkToken the address of the old LINK token contract\n   * @param _newLinkToken the address of the new LINK token contract\n   */\n  event LinkTokenSet(\n    LinkTokenInterface indexed _oldLinkToken,\n    LinkTokenInterface indexed _newLinkToken\n  );\n\n  /*\n   * @notice sets the LINK token contract used for paying oracles\n   * @param _linkToken the address of the LINK token contract\n   * @param _recipient remaining funds from the previous token contract are transfered\n   * here\n   * @dev this function will return early (without an error) without changing any state\n   * if _linkToken equals getLinkToken().\n   * @dev this will trigger a payout so that a malicious owner cannot take from oracles\n   * what is already owed to them.\n   * @dev we assume that the token contract is correct. This contract is not written\n   * to handle misbehaving ERC20 tokens!\n   */\n  function setLinkToken(\n    LinkTokenInterface _linkToken,\n    address _recipient\n  ) external\n    onlyOwner()\n  {\n    LinkTokenInterface oldLinkToken = s_linkToken;\n    if (_linkToken == oldLinkToken) {\n      // No change, nothing to be done\n      return;\n    }\n    // call balanceOf as a sanity check on whether we're talking to a token\n    // contract\n    _linkToken.balanceOf(address(this));\n    // we break CEI here, but that's okay because we're dealing with a correct\n    // token contract (by assumption).\n    payOracles();\n    uint256 remainingBalance = oldLinkToken.balanceOf(address(this));\n    require(oldLinkToken.transfer(_recipient, remainingBalance), \"transfer remaining funds failed\");\n    s_linkToken = _linkToken;\n    emit LinkTokenSet(oldLinkToken, _linkToken);\n  }\n\n  /*\n   * @notice gets the LINK token contract used for paying oracles\n   * @return linkToken the address of the LINK token contract\n   */\n  function getLinkToken()\n    external\n    view\n    returns(LinkTokenInterface linkToken)\n  {\n    return s_linkToken;\n  }\n\n  /**\n   * @notice emitted when billing parameters are set\n   * @param maximumGasPrice highest gas price for which transmitter will be compensated\n   * @param reasonableGasPrice transmitter will receive reward for gas prices under this value\n   * @param microLinkPerEth reimbursement per ETH of gas cost, in 1e-6LINK units\n   * @param linkGweiPerObservation reward to oracle for contributing an observation to a successfully transmitted report, in 1e-9LINK units\n   * @param linkGweiPerTransmission reward to transmitter of a successful report, in 1e-9LINK units\n   */\n  event BillingSet(\n    uint32 maximumGasPrice,\n    uint32 reasonableGasPrice,\n    uint32 microLinkPerEth,\n    uint32 linkGweiPerObservation,\n    uint32 linkGweiPerTransmission\n  );\n\n  function setBillingInternal(\n    uint32 _maximumGasPrice,\n    uint32 _reasonableGasPrice,\n    uint32 _microLinkPerEth,\n    uint32 _linkGweiPerObservation,\n    uint32 _linkGweiPerTransmission\n  )\n    internal\n  {\n    s_billing = Billing(_maximumGasPrice, _reasonableGasPrice, _microLinkPerEth,\n      _linkGweiPerObservation, _linkGweiPerTransmission);\n    emit BillingSet(_maximumGasPrice, _reasonableGasPrice, _microLinkPerEth,\n      _linkGweiPerObservation, _linkGweiPerTransmission);\n  }\n\n  /**\n   * @notice sets billing parameters\n   * @param _maximumGasPrice highest gas price for which transmitter will be compensated\n   * @param _reasonableGasPrice transmitter will receive reward for gas prices under this value\n   * @param _microLinkPerEth reimbursement per ETH of gas cost, in 1e-6LINK units\n   * @param _linkGweiPerObservation reward to oracle for contributing an observation to a successfully transmitted report, in 1e-9LINK units\n   * @param _linkGweiPerTransmission reward to transmitter of a successful report, in 1e-9LINK units\n   * @dev access control provided by billingAccessController\n   */\n  function setBilling(\n    uint32 _maximumGasPrice,\n    uint32 _reasonableGasPrice,\n    uint32 _microLinkPerEth,\n    uint32 _linkGweiPerObservation,\n    uint32 _linkGweiPerTransmission\n  )\n    external\n  {\n    AccessControllerInterface access = s_billingAccessController;\n    require(msg.sender == owner || access.hasAccess(msg.sender, msg.data),\n      \"Only owner&billingAdmin can call\");\n    payOracles();\n    setBillingInternal(_maximumGasPrice, _reasonableGasPrice, _microLinkPerEth,\n      _linkGweiPerObservation, _linkGweiPerTransmission);\n  }\n\n  /**\n   * @notice gets billing parameters\n   * @param maximumGasPrice highest gas price for which transmitter will be compensated\n   * @param reasonableGasPrice transmitter will receive reward for gas prices under this value\n   * @param microLinkPerEth reimbursement per ETH of gas cost, in 1e-6LINK units\n   * @param linkGweiPerObservation reward to oracle for contributing an observation to a successfully transmitted report, in 1e-9LINK units\n   * @param linkGweiPerTransmission reward to transmitter of a successful report, in 1e-9LINK units\n   */\n  function getBilling()\n    external\n    view\n    returns (\n      uint32 maximumGasPrice,\n      uint32 reasonableGasPrice,\n      uint32 microLinkPerEth,\n      uint32 linkGweiPerObservation,\n      uint32 linkGweiPerTransmission\n    )\n  {\n    Billing memory billing = s_billing;\n    return (\n      billing.maximumGasPrice,\n      billing.reasonableGasPrice,\n      billing.microLinkPerEth,\n      billing.linkGweiPerObservation,\n      billing.linkGweiPerTransmission\n    );\n  }\n\n  /**\n   * @notice emitted when a new access-control contract is set\n   * @param old the address prior to the current setting\n   * @param current the address of the new access-control contract\n   */\n  event BillingAccessControllerSet(AccessControllerInterface old, AccessControllerInterface current);\n\n  function setBillingAccessControllerInternal(AccessControllerInterface _billingAccessController)\n    internal\n  {\n    AccessControllerInterface oldController = s_billingAccessController;\n    if (_billingAccessController != oldController) {\n      s_billingAccessController = _billingAccessController;\n      emit BillingAccessControllerSet(\n        oldController,\n        _billingAccessController\n      );\n    }\n  }\n\n  /**\n   * @notice sets billingAccessController\n   * @param _billingAccessController new billingAccessController contract address\n   * @dev only owner can call this\n   */\n  function setBillingAccessController(AccessControllerInterface _billingAccessController)\n    external\n    onlyOwner\n  {\n    setBillingAccessControllerInternal(_billingAccessController);\n  }\n\n  /**\n   * @notice gets billingAccessController\n   * @return address of billingAccessController contract\n   */\n  function billingAccessController()\n    external\n    view\n    returns (AccessControllerInterface)\n  {\n    return s_billingAccessController;\n  }\n\n  /**\n   * @notice withdraws an oracle's payment from the contract\n   * @param _transmitter the transmitter address of the oracle\n   * @dev must be called by oracle's payee address\n   */\n  function withdrawPayment(address _transmitter)\n    external\n  {\n    require(msg.sender == s_payees[_transmitter], \"Only payee can withdraw\");\n    payOracle(_transmitter);\n  }\n\n  /**\n   * @notice query an oracle's payment amount\n   * @param _transmitter the transmitter address of the oracle\n   */\n  function owedPayment(address _transmitter)\n    public\n    view\n    returns (uint256)\n  {\n    Oracle memory oracle = s_oracles[_transmitter];\n    if (oracle.role == Role.Unset) { return 0; }\n    Billing memory billing = s_billing;\n    uint256 linkWeiAmount =\n      uint256(s_oracleObservationsCounts[oracle.index] - 1) *\n      uint256(billing.linkGweiPerObservation) *\n      (1 gwei);\n    linkWeiAmount += s_gasReimbursementsLinkWei[oracle.index] - 1;\n    return linkWeiAmount;\n  }\n\n  /**\n   * @notice emitted when an oracle has been paid LINK\n   * @param transmitter address from which the oracle sends reports to the transmit method\n   * @param payee address to which the payment is sent\n   * @param amount amount of LINK sent\n   * @param linkToken address of the LINK token contract\n   */\n  event OraclePaid(\n    address indexed transmitter,\n    address indexed payee,\n    uint256 amount,\n    LinkTokenInterface indexed linkToken\n  );\n\n  // payOracle pays out _transmitter's balance to the corresponding payee, and zeros it out\n  function payOracle(address _transmitter)\n    internal\n  {\n    Oracle memory oracle = s_oracles[_transmitter];\n    uint256 linkWeiAmount = owedPayment(_transmitter);\n    if (linkWeiAmount > 0) {\n      address payee = s_payees[_transmitter];\n      // Poses no re-entrancy issues, because LINK.transfer does not yield\n      // control flow.\n      require(s_linkToken.transfer(payee, linkWeiAmount), \"insufficient funds\");\n      s_oracleObservationsCounts[oracle.index] = 1; // \"zero\" the counts. see var's docstring\n      s_gasReimbursementsLinkWei[oracle.index] = 1; // \"zero\" the counts. see var's docstring\n      emit OraclePaid(_transmitter, payee, linkWeiAmount, s_linkToken);\n    }\n  }\n\n  // payOracles pays out all transmitters, and zeros out their balances.\n  //\n  // It's much more gas-efficient to do this as a single operation, to avoid\n  // hitting storage too much.\n  function payOracles()\n    internal\n  {\n    Billing memory billing = s_billing;\n    LinkTokenInterface linkToken = s_linkToken;\n    uint16[maxNumOracles] memory observationsCounts = s_oracleObservationsCounts;\n    uint256[maxNumOracles] memory gasReimbursementsLinkWei =\n      s_gasReimbursementsLinkWei;\n    address[] memory transmitters = s_transmitters;\n    for (uint transmitteridx = 0; transmitteridx < transmitters.length; transmitteridx++) {\n      uint256 reimbursementAmountLinkWei = gasReimbursementsLinkWei[transmitteridx] - 1;\n      uint256 obsCount = observationsCounts[transmitteridx] - 1;\n      uint256 linkWeiAmount =\n        obsCount * uint256(billing.linkGweiPerObservation) * (1 gwei) + reimbursementAmountLinkWei;\n      if (linkWeiAmount > 0) {\n          address payee = s_payees[transmitters[transmitteridx]];\n          // Poses no re-entrancy issues, because LINK.transfer does not yield\n          // control flow.\n          require(linkToken.transfer(payee, linkWeiAmount), \"insufficient funds\");\n          observationsCounts[transmitteridx] = 1;       // \"zero\" the counts.\n          gasReimbursementsLinkWei[transmitteridx] = 1; // \"zero\" the counts.\n          emit OraclePaid(transmitters[transmitteridx], payee, linkWeiAmount, linkToken);\n        }\n    }\n    // \"Zero\" the accounting storage variables\n    s_oracleObservationsCounts = observationsCounts;\n    s_gasReimbursementsLinkWei = gasReimbursementsLinkWei;\n  }\n\n  function oracleRewards(\n    bytes memory observers,\n    uint16[maxNumOracles] memory observations\n  )\n    internal\n    pure\n    returns (uint16[maxNumOracles] memory)\n  {\n    // reward each observer-participant with the observer reward\n    for (uint obsIdx = 0; obsIdx < observers.length; obsIdx++) {\n      uint8 observer = uint8(observers[obsIdx]);\n      observations[observer] = saturatingAddUint16(observations[observer], 1);\n    }\n    return observations;\n  }\n\n  // This value needs to change if maxNumOracles is increased, or the accounting\n  // calculations at the bottom of reimburseAndRewardOracles change.\n  //\n  // To recalculate it, run the profiler as described in\n  // ../../profile/README.md, and add up the gas-usage values reported for the\n  // lines in reimburseAndRewardOracles following the \"gasLeft = gasleft()\"\n  // line. E.g., you will see output like this:\n  //\n  //      7        uint256 gasLeft = gasleft();\n  //     29        uint256 gasCostEthWei = transmitterGasCostEthWei(\n  //      9          uint256(initialGas),\n  //      3          gasPrice,\n  //      3          callDataGasCost,\n  //      3          gasLeft\n  //      .\n  //      .\n  //      .\n  //     59        uint256 gasCostLinkWei = (gasCostEthWei * billing.microLinkPerEth)/ 1e6;\n  //      .\n  //      .\n  //      .\n  //   5047        s_gasReimbursementsLinkWei[txOracle.index] =\n  //    856          s_gasReimbursementsLinkWei[txOracle.index] + gasCostLinkWei +\n  //     26          uint256(billing.linkGweiPerTransmission) * (1 gwei);\n  //\n  // If those were the only lines to be accounted for, you would add up\n  // 29+9+3+3+3+59+5047+856+26=6035.\n  uint256 internal constant accountingGasCost = 6035;\n\n  // Uncomment the following declaration to compute the remaining gas cost after\n  // above gasleft(). (This must exist in a base class to OffchainAggregator, so\n  // it can't go in TestOffchainAggregator.)\n  //\n  // uint256 public gasUsedInAccounting;\n\n  // Gas price at which the transmitter should be reimbursed, in ETH-gwei/gas\n  function impliedGasPrice(\n    uint256 txGasPrice,         // ETH-gwei/gas units\n    uint256 reasonableGasPrice, // ETH-gwei/gas units\n    uint256 maximumGasPrice     // ETH-gwei/gas units\n  )\n    internal\n    pure\n    returns (uint256)\n  {\n    // Reward the transmitter for choosing an efficient gas price: if they manage\n    // to come in lower than considered reasonable, give them half the savings.\n    //\n    // The following calculations are all in units of gwei/gas, i.e. 1e-9ETH/gas\n    uint256 gasPrice = txGasPrice;\n    if (txGasPrice < reasonableGasPrice) {\n      // Give transmitter half the savings for coming in under the reasonable gas price\n      gasPrice += (reasonableGasPrice - txGasPrice) / 2;\n    }\n    // Don't reimburse a gas price higher than maximumGasPrice\n    return min(gasPrice, maximumGasPrice);\n  }\n\n  // gas reimbursement due the transmitter, in ETH-wei\n  //\n  // If this function is changed, accountingGasCost needs to change, too. See\n  // its docstring\n  function transmitterGasCostEthWei(\n    uint256 initialGas,\n    uint256 gasPrice, // ETH-gwei/gas units\n    uint256 callDataCost, // gas units\n    uint256 gasLeft\n  )\n    internal\n    pure\n    returns (uint128 gasCostEthWei)\n  {\n    require(initialGas >= gasLeft, \"gasLeft cannot exceed initialGas\");\n    uint256 gasUsed = // gas units\n      initialGas - gasLeft + // observed gas usage\n      callDataCost + accountingGasCost; // estimated gas usage\n    // gasUsed is in gas units, gasPrice is in ETH-gwei/gas units; convert to ETH-wei\n    uint256 fullGasCostEthWei = gasUsed * gasPrice * (1 gwei);\n    assert(fullGasCostEthWei < maxUint128); // the entire ETH supply fits in a uint128...\n    return uint128(fullGasCostEthWei);\n  }\n\n  /**\n   * @notice withdraw any available funds left in the contract, up to _amount, after accounting for the funds due to participants in past reports\n   * @param _recipient address to send funds to\n   * @param _amount maximum amount to withdraw, denominated in LINK-wei.\n   * @dev access control provided by billingAccessController\n   */\n  function withdrawFunds(address _recipient, uint256 _amount)\n    external\n  {\n    require(msg.sender == owner || s_billingAccessController.hasAccess(msg.sender, msg.data),\n      \"Only owner&billingAdmin can call\");\n    uint256 linkDue = totalLINKDue();\n    uint256 linkBalance = s_linkToken.balanceOf(address(this));\n    require(linkBalance >= linkDue, \"insufficient balance\");\n    require(s_linkToken.transfer(_recipient, min(linkBalance - linkDue, _amount)), \"insufficient funds\");\n  }\n\n  // Total LINK due to participants in past reports.\n  function totalLINKDue()\n    internal\n    view\n    returns (uint256 linkDue)\n  {\n    // Argument for overflow safety: We do all computations in\n    // uint256s. The inputs to linkDue are:\n    // - the <= 31 observation rewards each of which has less than\n    //   64 bits (32 bits for billing.linkGweiPerObservation, 32 bits\n    //   for wei/gwei conversion). Hence 69 bits are sufficient for this part.\n    // - the <= 31 gas reimbursements, each of which consists of at most 166\n    //   bits (see s_gasReimbursementsLinkWei docstring). Hence 171 bits are\n    //   sufficient for this part\n    // In total, 172 bits are enough.\n    uint16[maxNumOracles] memory observationCounts = s_oracleObservationsCounts;\n    for (uint i = 0; i < maxNumOracles; i++) {\n      linkDue += observationCounts[i] - 1; // Stored value is one greater than actual value\n    }\n    Billing memory billing = s_billing;\n    // Convert linkGweiPerObservation to uint256, or this overflows!\n    linkDue *= uint256(billing.linkGweiPerObservation) * (1 gwei);\n    address[] memory transmitters = s_transmitters;\n    uint256[maxNumOracles] memory gasReimbursementsLinkWei =\n      s_gasReimbursementsLinkWei;\n    for (uint i = 0; i < transmitters.length; i++) {\n      linkDue += uint256(gasReimbursementsLinkWei[i]-1); // Stored value is one greater than actual value\n    }\n  }\n\n  /**\n   * @notice allows oracles to check that sufficient LINK balance is available\n   * @return availableBalance LINK available on this contract, after accounting for outstanding obligations. can become negative\n   */\n  function linkAvailableForPayment()\n    external\n    view\n    returns (int256 availableBalance)\n  {\n    // there are at most one billion LINK, so this cast is safe\n    int256 balance = int256(s_linkToken.balanceOf(address(this)));\n    // according to the argument in the definition of totalLINKDue,\n    // totalLINKDue is never greater than 2**172, so this cast is safe\n    int256 due = int256(totalLINKDue());\n    // safe from overflow according to above sizes\n    return int256(balance) - int256(due);\n  }\n\n  /**\n   * @notice number of observations oracle is due to be reimbursed for\n   * @param _signerOrTransmitter address used by oracle for signing or transmitting reports\n   */\n  function oracleObservationCount(address _signerOrTransmitter)\n    external\n    view\n    returns (uint16)\n  {\n    Oracle memory oracle = s_oracles[_signerOrTransmitter];\n    if (oracle.role == Role.Unset) { return 0; }\n    return s_oracleObservationsCounts[oracle.index] - 1;\n  }\n\n\n  function reimburseAndRewardOracles(\n    uint32 initialGas,\n    bytes memory observers\n  )\n    internal\n  {\n    Oracle memory txOracle = s_oracles[msg.sender];\n    Billing memory billing = s_billing;\n    // Reward oracles for providing observations. Oracles are not rewarded\n    // for providing signatures, because signing is essentially free.\n    s_oracleObservationsCounts =\n      oracleRewards(observers, s_oracleObservationsCounts);\n    // Reimburse transmitter of the report for gas usage\n    require(txOracle.role == Role.Transmitter,\n      \"sent by undesignated transmitter\"\n    );\n    uint256 gasPrice = impliedGasPrice(\n      tx.gasprice / (1 gwei), // convert to ETH-gwei units\n      billing.reasonableGasPrice,\n      billing.maximumGasPrice\n    );\n    // The following is only an upper bound, as it ignores the cheaper cost for\n    // 0 bytes. Safe from overflow, because calldata just isn't that long.\n    uint256 callDataGasCost = 16 * msg.data.length;\n    // If any changes are made to subsequent calculations, accountingGasCost\n    // needs to change, too.\n    uint256 gasLeft = gasleft();\n    uint256 gasCostEthWei = transmitterGasCostEthWei(\n      uint256(initialGas),\n      gasPrice,\n      callDataGasCost,\n      gasLeft\n    );\n\n    // microLinkPerEth is 1e-6LINK/ETH units, gasCostEthWei is 1e-18ETH units\n    // (ETH-wei), product is 1e-24LINK-wei units, dividing by 1e6 gives\n    // 1e-18LINK units, i.e. LINK-wei units\n    // Safe from over/underflow, since all components are non-negative,\n    // gasCostEthWei will always fit into uint128 and microLinkPerEth is a\n    // uint32 (128+32 < 256!).\n    uint256 gasCostLinkWei = (gasCostEthWei * billing.microLinkPerEth)/ 1e6;\n\n    // Safe from overflow, because gasCostLinkWei < 2**160 and\n    // billing.linkGweiPerTransmission * (1 gwei) < 2**64 and we increment\n    // s_gasReimbursementsLinkWei[txOracle.index] at most 2**40 times.\n    s_gasReimbursementsLinkWei[txOracle.index] =\n      s_gasReimbursementsLinkWei[txOracle.index] + gasCostLinkWei +\n      uint256(billing.linkGweiPerTransmission) * (1 gwei); // convert from linkGwei to linkWei\n\n    // Uncomment next line to compute the remaining gas cost after above gasleft().\n    // See OffchainAggregatorBilling.accountingGasCost docstring for more information.\n    //\n    // gasUsedInAccounting = gasLeft - gasleft();\n  }\n\n  /*\n   * Payee management\n   */\n\n  /**\n   * @notice emitted when a transfer of an oracle's payee address has been initiated\n   * @param transmitter address from which the oracle sends reports to the transmit method\n   * @param current the payeee address for the oracle, prior to this setting\n   * @param proposed the proposed new payee address for the oracle\n   */\n  event PayeeshipTransferRequested(\n    address indexed transmitter,\n    address indexed current,\n    address indexed proposed\n  );\n\n  /**\n   * @notice emitted when a transfer of an oracle's payee address has been completed\n   * @param transmitter address from which the oracle sends reports to the transmit method\n   * @param current the payeee address for the oracle, prior to this setting\n   */\n  event PayeeshipTransferred(\n    address indexed transmitter,\n    address indexed previous,\n    address indexed current\n  );\n\n  /**\n   * @notice sets the payees for transmitting addresses\n   * @param _transmitters addresses oracles use to transmit the reports\n   * @param _payees addresses of payees corresponding to list of transmitters\n   * @dev must be called by owner\n   * @dev cannot be used to change payee addresses, only to initially populate them\n   */\n  function setPayees(\n    address[] calldata _transmitters,\n    address[] calldata _payees\n  )\n    external\n    onlyOwner()\n  {\n    require(_transmitters.length == _payees.length, \"transmitters.size != payees.size\");\n\n    for (uint i = 0; i < _transmitters.length; i++) {\n      address transmitter = _transmitters[i];\n      address payee = _payees[i];\n      address currentPayee = s_payees[transmitter];\n      bool zeroedOut = currentPayee == address(0);\n      require(zeroedOut || currentPayee == payee, \"payee already set\");\n      s_payees[transmitter] = payee;\n\n      if (currentPayee != payee) {\n        emit PayeeshipTransferred(transmitter, currentPayee, payee);\n      }\n    }\n  }\n\n  /**\n   * @notice first step of payeeship transfer (safe transfer pattern)\n   * @param _transmitter transmitter address of oracle whose payee is changing\n   * @param _proposed new payee address\n   * @dev can only be called by payee address\n   */\n  function transferPayeeship(\n    address _transmitter,\n    address _proposed\n  )\n    external\n  {\n      require(msg.sender == s_payees[_transmitter], \"only current payee can update\");\n      require(msg.sender != _proposed, \"cannot transfer to self\");\n\n      address previousProposed = s_proposedPayees[_transmitter];\n      s_proposedPayees[_transmitter] = _proposed;\n\n      if (previousProposed != _proposed) {\n        emit PayeeshipTransferRequested(_transmitter, msg.sender, _proposed);\n      }\n  }\n\n  /**\n   * @notice second step of payeeship transfer (safe transfer pattern)\n   * @param _transmitter transmitter address of oracle whose payee is changing\n   * @dev can only be called by proposed new payee address\n   */\n  function acceptPayeeship(\n    address _transmitter\n  )\n    external\n  {\n    require(msg.sender == s_proposedPayees[_transmitter], \"only proposed payees can accept\");\n\n    address currentPayee = s_payees[_transmitter];\n    s_payees[_transmitter] = msg.sender;\n    s_proposedPayees[_transmitter] = address(0);\n\n    emit PayeeshipTransferred(_transmitter, currentPayee, msg.sender);\n  }\n\n  /*\n   * Helper functions\n   */\n\n  function saturatingAddUint16(uint16 _x, uint16 _y)\n    internal\n    pure\n    returns (uint16)\n  {\n    return uint16(min(uint256(_x)+uint256(_y), maxUint16));\n  }\n\n  function min(uint256 a, uint256 b)\n    internal\n    pure\n    returns (uint256)\n  {\n    if (a < b) { return a; }\n    return b;\n  }\n}\n"},"contract/Owned.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\n/**\n * @title The Owned contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract Owned {\n\n  address payable public owner;\n  address private pendingOwner;\n\n  event OwnershipTransferRequested(\n    address indexed from,\n    address indexed to\n  );\n  event OwnershipTransferred(\n    address indexed from,\n    address indexed to\n  );\n\n  constructor() {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(address _to)\n    external\n    onlyOwner()\n  {\n    pendingOwner = _to;\n\n    emit OwnershipTransferRequested(owner, _to);\n  }\n\n  /**\n   * @dev Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership()\n    external\n  {\n    require(msg.sender == pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = owner;\n    owner = msg.sender;\n    pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @dev Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"Only callable by owner\");\n    _;\n  }\n\n}\n"},"contract/SimpleWriteAccessController.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./Owned.sol\";\nimport \"./AccessControllerInterface.sol\";\n\n/**\n * @title SimpleWriteAccessController\n * @notice Gives access to accounts explicitly added to an access list by the\n * controller's owner.\n * @dev does not make any special permissions for externally, see\n * SimpleReadAccessController for that.\n */\ncontract SimpleWriteAccessController is AccessControllerInterface, Owned {\n\n  bool public checkEnabled;\n  mapping(address => bool) internal accessList;\n\n  event AddedAccess(address user);\n  event RemovedAccess(address user);\n  event CheckAccessEnabled();\n  event CheckAccessDisabled();\n\n  constructor()\n  {\n    checkEnabled = true;\n  }\n\n  /**\n   * @notice Returns the access of an address\n   * @param _user The address to query\n   */\n  function hasAccess(\n    address _user,\n    bytes memory\n  )\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return accessList[_user] || !checkEnabled;\n  }\n\n  /**\n   * @notice Adds an address to the access list\n   * @param _user The address to add\n   */\n  function addAccess(address _user) external onlyOwner() {\n    addAccessInternal(_user);\n  }\n\n  function addAccessInternal(address _user) internal {\n    if (!accessList[_user]) {\n      accessList[_user] = true;\n      emit AddedAccess(_user);\n    }\n  }\n\n  /**\n   * @notice Removes an address from the access list\n   * @param _user The address to remove\n   */\n  function removeAccess(address _user)\n    external\n    onlyOwner()\n  {\n    if (accessList[_user]) {\n      accessList[_user] = false;\n\n      emit RemovedAccess(_user);\n    }\n  }\n\n  /**\n   * @notice makes the access check enforced\n   */\n  function enableAccessCheck()\n    external\n    onlyOwner()\n  {\n    if (!checkEnabled) {\n      checkEnabled = true;\n\n      emit CheckAccessEnabled();\n    }\n  }\n\n  /**\n   * @notice makes the access check unenforced\n   */\n  function disableAccessCheck()\n    external\n    onlyOwner()\n  {\n    if (checkEnabled) {\n      checkEnabled = false;\n\n      emit CheckAccessDisabled();\n    }\n  }\n\n  /**\n   * @dev reverts if the caller does not have access\n   */\n  modifier checkAccess() {\n    require(hasAccess(msg.sender, msg.data), \"No access\");\n    _;\n  }\n}\n"},"contract/TypeAndVersionInterface.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n\nabstract contract TypeAndVersionInterface{\n  function typeAndVersion()\n    external\n    pure\n    virtual\n    returns (string memory);\n}"},"contract/SimpleReadAccessController.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.7.6;\n\nimport \"./SimpleWriteAccessController.sol\";\n\n/**\n * @title SimpleReadAccessController\n * @notice Gives access to:\n * - any externally owned account (note that offchain actors can always read\n * any contract storage regardless of onchain access control measures, so this\n * does not weaken the access control while improving usability)\n * - accounts explicitly added to an access list\n * @dev SimpleReadAccessController is not suitable for access controlling writes\n * since it grants any externally owned account access! See\n * SimpleWriteAccessController for that.\n */\ncontract SimpleReadAccessController is SimpleWriteAccessController {\n\n  /**\n   * @notice Returns the access of an address\n   * @param _user The address to query\n   */\n  function hasAccess(\n    address _user,\n    bytes memory _calldata\n  )\n    public\n    view\n    virtual\n    override\n    returns (bool)\n  {\n    return super.hasAccess(_user, _calldata) || _user == tx.origin;\n  }\n\n}\n"}},"settings":{"evmVersion":"istanbul","libraries":{},"metadata":{"bytecodeHash":"ipfs"},"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}}},"ABI":"[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_maximumGasPrice\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_reasonableGasPrice\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_microLinkPerEth\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_linkGweiPerObservation\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_linkGweiPerTransmission\",\"type\":\"uint32\"},{\"internalType\":\"contract LinkTokenInterface\",\"name\":\"_link\",\"type\":\"address\"},{\"internalType\":\"int192\",\"name\":\"_minAnswer\",\"type\":\"int192\"},{\"internalType\":\"int192\",\"name\":\"_maxAnswer\",\"type\":\"int192\"},{\"internalType\":\"contract AccessControllerInterface\",\"name\":\"_billingAccessController\",\"type\":\"address\"},{\"internalType\":\"contract AccessControllerInterface\",\"name\":\"_requesterAccessController\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"AddedAccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"name\":\"AnswerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract AccessControllerInterface\",\"name\":\"old\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract AccessControllerInterface\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"BillingAccessControllerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"maximumGasPrice\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"reasonableGasPrice\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"microLinkPerEth\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"linkGweiPerObservation\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"linkGweiPerTransmission\",\"type\":\"uint32\"}],\"name\":\"BillingSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CheckAccessDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CheckAccessEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"previousConfigBlockNumber\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"configCount\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"signers\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"transmitters\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"threshold\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"encodedConfigVersion\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"}],\"name\":\"ConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract LinkTokenInterface\",\"name\":\"_oldLinkToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract LinkTokenInterface\",\"name\":\"_newLinkToken\",\"type\":\"address\"}],\"name\":\"LinkTokenSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"startedBy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"}],\"name\":\"NewRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"aggregatorRoundId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int192\",\"name\":\"answer\",\"type\":\"int192\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"transmitter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int192[]\",\"name\":\"observations\",\"type\":\"int192[]\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"observers\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"rawReportContext\",\"type\":\"bytes32\"}],\"name\":\"NewTransmission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"transmitter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"contract LinkTokenInterface\",\"name\":\"linkToken\",\"type\":\"address\"}],\"name\":\"OraclePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"transmitter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposed\",\"type\":\"address\"}],\"name\":\"PayeeshipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"transmitter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"PayeeshipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"RemovedAccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract AccessControllerInterface\",\"name\":\"old\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract AccessControllerInterface\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"RequesterAccessControllerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"configDigest\",\"type\":\"bytes16\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"}],\"name\":\"RoundRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"previousValidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"previousGasLimit\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"currentValidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"currentGasLimit\",\"type\":\"uint32\"}],\"name\":\"ValidatorConfigSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_transmitter\",\"type\":\"address\"}],\"name\":\"acceptPayeeship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"addAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"billingAccessController\",\"outputs\":[{\"internalType\":\"contract AccessControllerInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableAccessCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableAccessCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"getAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBilling\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"maximumGasPrice\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"reasonableGasPrice\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"microLinkPerEth\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"linkGweiPerObservation\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"linkGweiPerTransmission\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLinkToken\",\"outputs\":[{\"internalType\":\"contract LinkTokenInterface\",\"name\":\"linkToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"_roundId\",\"type\":\"uint80\"}],\"name\":\"getRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"getTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"hasAccess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestConfigDetails\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"configCount\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"},{\"internalType\":\"bytes16\",\"name\":\"configDigest\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestTransmissionDetails\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"configDigest\",\"type\":\"bytes16\"},{\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"},{\"internalType\":\"int192\",\"name\":\"latestAnswer\",\"type\":\"int192\"},{\"internalType\":\"uint64\",\"name\":\"latestTimestamp\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"linkAvailableForPayment\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"availableBalance\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxAnswer\",\"outputs\":[{\"internalType\":\"int192\",\"name\":\"\",\"type\":\"int192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAnswer\",\"outputs\":[{\"internalType\":\"int192\",\"name\":\"\",\"type\":\"int192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signerOrTransmitter\",\"type\":\"address\"}],\"name\":\"oracleObservationCount\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_transmitter\",\"type\":\"address\"}],\"name\":\"owedPayment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"removeAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestNewRound\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requesterAccessController\",\"outputs\":[{\"internalType\":\"contract AccessControllerInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_maximumGasPrice\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_reasonableGasPrice\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_microLinkPerEth\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_linkGweiPerObservation\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_linkGweiPerTransmission\",\"type\":\"uint32\"}],\"name\":\"setBilling\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AccessControllerInterface\",\"name\":\"_billingAccessController\",\"type\":\"address\"}],\"name\":\"setBillingAccessController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_transmitters\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"_threshold\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"_encodedConfigVersion\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_encoded\",\"type\":\"bytes\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract LinkTokenInterface\",\"name\":\"_linkToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"setLinkToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_transmitters\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_payees\",\"type\":\"address[]\"}],\"name\":\"setPayees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AccessControllerInterface\",\"name\":\"_requesterAccessController\",\"type\":\"address\"}],\"name\":\"setRequesterAccessController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"_newValidator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_newGasLimit\",\"type\":\"uint32\"}],\"name\":\"setValidatorConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_transmitter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_proposed\",\"type\":\"address\"}],\"name\":\"transferPayeeship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_report\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"_rs\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_ss\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"_rawVs\",\"type\":\"bytes32\"}],\"name\":\"transmit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transmitters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatorConfig\",\"outputs\":[{\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"validator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_transmitter\",\"type\":\"address\"}],\"name\":\"withdrawPayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AccessControlledOffchainAggregator","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x0000000000000000000000000000000000000000000000000000000000000bb8000000000000000000000000000000000000000000000000000000000000003c000000000000000000000000000000000000000000000000000000000d8dfe8f000000000000000000000000000000000000000000000000000000000572a3d00000000000000000000000000000000000000000000000000000000020afcb97000000000000000000000000514910771af9ca656af840dff83e8264ecf986ca00000000000000000000000000000000000000000000000000000000000f4240000000000000000000000000000000000000000000000000000000174876e8000000000000000000000000009db83cef9f68b63989e4e82d65d549e7ff2acda9000000000000000000000000641b698ad1c6e503470520b0eecb472c0589dfe6000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000001800000000000000000000000000000000000000000000000000000000000000009464549202f205553440000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":0,"SwarmSource":""}]}