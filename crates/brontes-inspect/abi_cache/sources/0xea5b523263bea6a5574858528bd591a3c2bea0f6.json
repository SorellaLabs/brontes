{"expiry":1699495186,"data":[{"SourceCode":{"language":"Solidity","sources":{"@nominex/stable-swap/contracts/interfaces/INomiswapFactory.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\ninterface INomiswapFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n    function INIT_CODE_HASH() external view returns (bytes32);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n    function setSwapFee(address pair, uint32 swapFee) external;\n}\n"},"@nominex/stable-swap/contracts/interfaces/INomiswapERC20.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface INomiswapERC20 is IERC20Metadata {\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n"},"@nominex/stable-swap/contracts/interfaces/INomiswapStablePair.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./INomiswapPair.sol\";\npragma experimental ABIEncoderV2;\n\ninterface INomiswapStablePair is INomiswapPair {\n\n    event RampA(uint256 oldA, uint256 newA, uint256 initialTime, uint256 futureTime);\n    event StopRampA(uint256 A, uint256 t);\n\n    function devFee() external view returns (uint128);\n\n//    function burnSingle(address tokenOut, address recipient) external returns (uint256 amountOut);\n\n    function getA() external view returns (uint256);\n\n    function setSwapFee(uint32) external;\n    function setDevFee(uint128) external;\n\n    function rampA(uint32 _futureA, uint40 _futureTime) external;\n    function stopRampA() external;\n\n    function getAmountIn(address tokenIn, uint256 amountOut) external view returns (uint256);\n    function getAmountOut(address tokenIn, uint256 amountIn) external view returns (uint256);\n\n}\n"},"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"},"/stable-swap/NomiswapStableSwapOnlyRouter.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.15;\n\nimport '@nominex/stable-swap/contracts/interfaces/INomiswapFactory.sol';\nimport '@nominex/stable-swap/contracts/interfaces/INomiswapStablePair.sol';\n\ncontract NomiswapStableSwapOnlyRouter {\n\n    address public immutable stableSwapFactory;\n\n    constructor(address _stableSwapFactory) {\n        stableSwapFactory = _stableSwapFactory;\n    }\n    \n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, 'NomiswapRouter: EXPIRED');\n        _;\n    }\n\n    receive() external payable {\n        require(msg.sender == 0x0000000000000000000000000000000000000000, 'NomiswapRouter: no payments'); // accept no ETH via fallback\n    }\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external ensure(deadline) returns (uint[] memory) {\n        (address[] memory pairs, uint[] memory amounts) = getAmountsOut(amountIn, path, to);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'NomiswapRouter: INSUFFICIENT_OUTPUT_AMOUNT');\n        safeTransferFrom(path[0], msg.sender, pairs[0], amountIn);\n        _swap(pairs, amounts, path[0] < path[1]);\n        return amounts;\n    }\n\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(address[] memory pairs, uint[] memory amounts, bool swapToken0) private {\n        bytes memory data = new bytes(0);\n        for (uint i; i < pairs.length - 1; i++) {\n            INomiswapPair(pairs[i]).swap(swapToken0 ? 0 : amounts[i + 1], swapToken0 ? amounts[i + 1] : 0, pairs[i + 1], data);\n        }\n    }\n\n    function getAmountsOut(uint amountIn, address[] memory path, address to) private view returns (address[] memory pairs, uint[] memory amounts) {\n        require(path.length >= 2, 'NomiswapLibrary: INVALID_PATH');\n        pairs = new address[](path.length);\n        amounts = new uint[](path.length);\n        amounts[0] = amountIn;\n        for (uint i; i < path.length - 1; i++) {\n            pairs[i] = INomiswapFactory(stableSwapFactory).getPair(path[i], path[i + 1]);\n            amounts[i + 1] = INomiswapStablePair(pairs[i]).getAmountOut(path[i], amounts[i]);\n        }\n        pairs[path.length - 1] = to;\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) private {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n}\n"},"@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"},"@nominex/stable-swap/contracts/interfaces/INomiswapPair.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity ^0.8.0;\n\nimport \"./INomiswapERC20.sol\";\n\ninterface INomiswapPair is INomiswapERC20 {\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function swapFee() external view returns (uint32);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n}\n"}},"settings":{"evmVersion":"istanbul","libraries":{},"optimizer":{"enabled":true,"runs":1000},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}},"remappings":[]}},"ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stableSwapFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"stableSwapFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"NomiswapStableSwapOnlyRouter","CompilerVersion":"v0.8.15+commit.e14f2714","OptimizationUsed":1,"Runs":1000,"ConstructorArguments":"0x000000000000000000000000818339b4e536e707f14980219037c5046b049dd4","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}