{"expiry":1699495326,"data":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/utility/interfaces/IOwned.sol\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public view returns (address) {}\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}\r\n\r\n// File: contracts/utility/Owned.sol\r\n\r\n/*\r\n    Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\r\n\r\n    /**\r\n        @dev constructor\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev allows transferring the contract ownership\r\n        the new owner still needs to accept the transfer\r\n        can only be called by the contract owner\r\n\r\n        @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n        @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n// File: contracts/utility/Utils.sol\r\n\r\n/*\r\n    Utilities & Common Modifiers\r\n*/\r\ncontract Utils {\r\n    /**\r\n        constructor\r\n    */\r\n    constructor() public {\r\n    }\r\n\r\n    // verifies that an amount is greater than zero\r\n    modifier greaterThanZero(uint256 _amount) {\r\n        require(_amount > 0);\r\n        _;\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        require(_address != address(0));\r\n        _;\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n\r\n    // Overflow protected math functions\r\n\r\n    /**\r\n        @dev returns the sum of _x and _y, asserts if the calculation overflows\r\n\r\n        @param _x   value 1\r\n        @param _y   value 2\r\n\r\n        @return sum\r\n    */\r\n    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        assert(z >= _x);\r\n        return z;\r\n    }\r\n\r\n    /**\r\n        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\r\n\r\n        @param _x   minuend\r\n        @param _y   subtrahend\r\n\r\n        @return difference\r\n    */\r\n    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        assert(_x >= _y);\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\r\n\r\n        @param _x   factor 1\r\n        @param _y   factor 2\r\n\r\n        @return product\r\n    */\r\n    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x * _y;\r\n        assert(_x == 0 || z / _x == _y);\r\n        return z;\r\n    }\r\n}\r\n\r\n// File: contracts/utility/interfaces/IContractRegistry.sol\r\n\r\n/*\r\n    Contract Registry interface\r\n*/\r\ncontract IContractRegistry {\r\n    function addressOf(bytes32 _contractName) public view returns (address);\r\n\r\n    // deprecated, backward compatibility\r\n    function getAddress(bytes32 _contractName) public view returns (address);\r\n}\r\n\r\n// File: contracts/ContractIds.sol\r\n\r\n/**\r\n    Id definitions for bancor contracts\r\n\r\n    Can be used in conjunction with the contract registry to get contract addresses\r\n*/\r\ncontract ContractIds {\r\n    // generic\r\n    bytes32 public constant CONTRACT_FEATURES = \"ContractFeatures\";\r\n    bytes32 public constant CONTRACT_REGISTRY = \"ContractRegistry\";\r\n\r\n    // bancor logic\r\n    bytes32 public constant BANCOR_NETWORK = \"BancorNetwork\";\r\n    bytes32 public constant BANCOR_FORMULA = \"BancorFormula\";\r\n    bytes32 public constant BANCOR_GAS_PRICE_LIMIT = \"BancorGasPriceLimit\";\r\n    bytes32 public constant BANCOR_CONVERTER_UPGRADER = \"BancorConverterUpgrader\";\r\n    bytes32 public constant BANCOR_CONVERTER_FACTORY = \"BancorConverterFactory\";\r\n\r\n    // Ids of BNT converter and BNT token\r\n    bytes32 public constant BNT_TOKEN = \"BNTToken\";\r\n    bytes32 public constant BNT_CONVERTER = \"BNTConverter\";\r\n\r\n    // Id of BancorX contract\r\n    bytes32 public constant BANCOR_X = \"BancorX\";\r\n}\r\n\r\n// File: contracts/utility/ContractRegistry.sol\r\n\r\n/**\r\n    Contract Registry\r\n\r\n    The contract registry keeps contract addresses by name.\r\n    The owner can update contract addresses so that a contract name always points to the latest version\r\n    of the given contract.\r\n    Other contracts can query the registry to get updated addresses instead of depending on specific\r\n    addresses.\r\n\r\n    Note that contract names are limited to 32 bytes UTF8 encoded ASCII strings to optimize gas costs\r\n*/\r\ncontract ContractRegistry is IContractRegistry, Owned, Utils, ContractIds {\r\n    struct RegistryItem {\r\n        address contractAddress;    // contract address\r\n        uint256 nameIndex;          // index of the item in the list of contract names\r\n        bool isSet;                 // used to tell if the mapping element is defined\r\n    }\r\n\r\n    mapping (bytes32 => RegistryItem) private items;    // name -> RegistryItem mapping\r\n    string[] public contractNames;                      // list of all registered contract names\r\n\r\n    // triggered when an address pointed to by a contract name is modified\r\n    event AddressUpdate(bytes32 indexed _contractName, address _contractAddress);\r\n\r\n    /**\r\n        @dev constructor\r\n    */\r\n    constructor() public {\r\n        registerAddress(ContractIds.CONTRACT_REGISTRY, address(this));\r\n    }\r\n\r\n    /**\r\n        @dev returns the number of items in the registry\r\n\r\n        @return number of items\r\n    */\r\n    function itemCount() public view returns (uint256) {\r\n        return contractNames.length;\r\n    }\r\n\r\n    /**\r\n        @dev returns the address associated with the given contract name\r\n\r\n        @param _contractName    contract name\r\n\r\n        @return contract address\r\n    */\r\n    function addressOf(bytes32 _contractName) public view returns (address) {\r\n        return items[_contractName].contractAddress;\r\n    }\r\n\r\n    /**\r\n        @dev registers a new address for the contract name in the registry\r\n\r\n        @param _contractName     contract name\r\n        @param _contractAddress  contract address\r\n    */\r\n    function registerAddress(bytes32 _contractName, address _contractAddress)\r\n        public\r\n        ownerOnly\r\n        validAddress(_contractAddress)\r\n    {\r\n        require(_contractName.length > 0); // validate input\r\n\r\n        // update the address in the registry\r\n        items[_contractName].contractAddress = _contractAddress;\r\n\r\n        if (!items[_contractName].isSet) {\r\n            // mark the item as set\r\n            items[_contractName].isSet = true;\r\n            // add the contract name to the name list\r\n            uint256 i = contractNames.push(bytes32ToString(_contractName));\r\n            // update the item's index in the list\r\n            items[_contractName].nameIndex = i - 1;\r\n        }\r\n\r\n        // dispatch the address update event\r\n        emit AddressUpdate(_contractName, _contractAddress);\r\n    }\r\n\r\n    /**\r\n        @dev removes an existing contract address from the registry\r\n\r\n        @param _contractName contract name\r\n    */\r\n    function unregisterAddress(bytes32 _contractName) public ownerOnly {\r\n        require(_contractName.length > 0); // validate input\r\n\r\n        // remove the address from the registry\r\n        items[_contractName].contractAddress = address(0);\r\n\r\n        // if there are multiple items in the registry, move the last element to the deleted element's position\r\n        // and modify last element's registryItem.nameIndex in the items collection to point to the right position in contractNames\r\n        if (contractNames.length > 1) {\r\n            string memory lastContractNameString = contractNames[contractNames.length - 1];\r\n            uint256 unregisterIndex = items[_contractName].nameIndex;\r\n\r\n            contractNames[unregisterIndex] = lastContractNameString;\r\n            bytes32 lastContractName = stringToBytes32(lastContractNameString);\r\n            RegistryItem storage registryItem = items[lastContractName];\r\n            registryItem.nameIndex = unregisterIndex;\r\n        }\r\n\r\n        // remove the last element from the name list\r\n        contractNames.length--;\r\n        // zero the deleted element's index\r\n        items[_contractName].nameIndex = 0;\r\n\r\n        // dispatch the address update event\r\n        emit AddressUpdate(_contractName, address(0));\r\n    }\r\n\r\n    /**\r\n        @dev utility, converts bytes32 to a string\r\n        note that the bytes32 argument is assumed to be UTF8 encoded ASCII string\r\n\r\n        @return string representation of the given bytes32 argument\r\n    */\r\n    function bytes32ToString(bytes32 _bytes) private pure returns (string) {\r\n        bytes memory byteArray = new bytes(32);\r\n        for (uint256 i; i < 32; i++) {\r\n            byteArray[i] = _bytes[i];\r\n        }\r\n\r\n        return string(byteArray);\r\n    }\r\n\r\n    // @dev utility, converts string to bytes32\r\n    function stringToBytes32(string memory _string) private pure returns (bytes32) {\r\n        bytes32 result;\r\n        assembly {\r\n            result := mload(add(_string,32))\r\n        }\r\n        return result;\r\n    }\r\n\r\n    // deprecated, backward compatibility\r\n    function getAddress(bytes32 _contractName) public view returns (address) {\r\n        return addressOf(_contractName);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"BANCOR_CONVERTER_UPGRADER\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BNT_TOKEN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractName\",\"type\":\"bytes32\"}],\"name\":\"getAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_REGISTRY\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractName\",\"type\":\"bytes32\"}],\"name\":\"unregisterAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contractNames\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BANCOR_CONVERTER_FACTORY\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BNT_CONVERTER\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractName\",\"type\":\"bytes32\"},{\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"registerAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"itemCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BANCOR_FORMULA\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CONTRACT_FEATURES\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BANCOR_NETWORK\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BANCOR_GAS_PRICE_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contractName\",\"type\":\"bytes32\"}],\"name\":\"addressOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BANCOR_X\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_contractName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"AddressUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"ContractRegistry","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":"bzzr://cd3e000b182ad7232346065f3c16b88629e59a9c082589a00b58e7f1fca33cab"}]}