{"expiry":1699484765,"data":[{"SourceCode":{"language":"Solidity","sources":{"/contracts/common/SafeMathInt.sol":{"content":"// SPDX-License-Identifier: MIT                                                                               \n                                                    \npragma solidity 0.8.17;\n\nlibrary SafeMathInt {\n    int256 private constant MIN_INT256 = int256(1) << 255;\n    int256 private constant MAX_INT256 = ~(int256(1) << 255);\n\n    /**\n     * @dev Multiplies two int256 variables and fails on overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a * b;\n\n        // Detect overflow when multiplying MIN_INT256 with -1\n        require(c != MIN_INT256 || (a & MIN_INT256) != (b & MIN_INT256));\n        require((b == 0) || (c / b == a));\n        return c;\n    }\n\n    /**\n     * @dev Division of two int256 variables and fails on overflow.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        // Prevent overflow when dividing MIN_INT256 by -1\n        require(b != -1 || a != MIN_INT256);\n\n        // Solidity already throws when dividing by 0.\n        return a / b;\n    }\n\n    /**\n     * @dev Subtracts two int256 variables and fails on overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\n        return c;\n    }\n\n    /**\n     * @dev Adds two int256 variables and fails on overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\n        return c;\n    }\n\n    /**\n     * @dev Converts to absolute value, and fails on overflow.\n     */\n    function abs(int256 a) internal pure returns (int256) {\n        require(a != MIN_INT256);\n        return a < 0 ? -a : a;\n    }\n\n\n    function toUint256Safe(int256 a) internal pure returns (uint256) {\n        require(a >= 0);\n        return uint256(a);\n    }\n}"},"/contracts/common/ILpPair.sol":{"content":"// SPDX-License-Identifier: MIT                                                                               \n\npragma solidity 0.8.17;\n\ninterface ILpPair {\n    function sync() external;\n}"},"/contracts/common/ERC20.sol":{"content":"// SPDX-License-Identifier: MIT                                                                               \n                                                    \npragma solidity 0.8.17;\n\nimport './IERC20.sol';\nimport './Context.sol';\n\ncontract ERC20 is Context, IERC20 {\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n    uint256 private _totalSupply;\n    string private _name;\n    string private _symbol;\n\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _createInitialSupply(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n}"},"/contracts/common/TokenHandler.sol":{"content":"// SPDX-License-Identifier: MIT                                                                            \n                                                    \npragma solidity 0.8.17;\n\nimport './Ownable.sol';\nimport './IERC20.sol';\n\ncontract TokenHandler is Ownable {\n    function sendTokenToOwner(address token) external onlyOwner {\n        if(IERC20(token).balanceOf(address(this)) > 0){\n            IERC20(token).transfer(owner(), IERC20(token).balanceOf(address(this)));\n        }\n    }\n}\n"},"/contracts/common/IDexFactory.sol":{"content":"\n// SPDX-License-Identifier: MIT                                                                               \n                                                    \npragma solidity 0.8.17;\n\ninterface IDexFactory {\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n}\n"},"/contracts/common/SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT                                                                               \n                                                    \npragma solidity 0.8.17;\n\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheadar than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"},"/contracts/common/DividendPayingTokenOptionalInterface.sol":{"content":"// SPDX-License-Identifier: MIT                                                                               \n                                                    \npragma solidity 0.8.17;\n\ninterface DividendPayingTokenOptionalInterface {\n  /// @notice View the amount of dividend in wei that an address can withdraw.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\n  function withdrawableDividendOf(address _owner) external view returns(uint256);\n\n  /// @notice View the amount of dividend in wei that an address has withdrawn.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` has withdrawn.\n  function withdrawnDividendOf(address _owner) external view returns(uint256);\n\n  /// @notice View the amount of dividend in wei that an address has earned in total.\n  /// @dev accumulativeDividendOf(_owner) = withdrawableDividendOf(_owner) + withdrawnDividendOf(_owner)\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` has earned in total.\n  function accumulativeDividendOf(address _owner) external view returns(uint256);\n}\n"},"/contracts/common/EnumerableSet.sol":{"content":"// SPDX-License-Identifier: MIT                                                                               \n                                                    \npragma solidity 0.8.17;\n\nlibrary EnumerableSet {\n\n    struct Set {\n        bytes32[] _values;\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n                set._values[toDeleteIndex] = lastValue;\n                set._indexes[lastValue] = valueIndex;\n            }\n\n            set._values.pop();\n\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}"},"/contracts/common/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT                                                                               \n                                                    \npragma solidity 0.8.17;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"/contracts/common/DividendTracker.sol":{"content":"// SPDX-License-Identifier: MIT                                                                               \n                                                    \npragma solidity 0.8.17;\n\nimport './DividendPayingToken.sol';\n\ncontract DividendTracker is DividendPayingToken {\n    using SafeMath for uint256;\n    using SafeMathInt for int256;\n\n    Map private tokenHoldersMap;\n    uint256 public lastProcessedIndex;\n\n    mapping (address => bool) public excludedFromDividends;\n\n    mapping (address => uint256) public lastClaimTimes;\n\n    uint256 public claimWait;\n    uint256 public immutable minimumTokenBalanceForDividends;\n\n    event ExcludeFromDividends(address indexed account);\n    event IncludeInDividends(address indexed account);\n    event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);\n\n    event Claim(address indexed account, uint256 amount, bool indexed automatic);\n\n    constructor(address _token) {\n    \tclaimWait = 1200;\n        minimumTokenBalanceForDividends = 1;\n        token = _token;\n    }\n\n    struct Map {\n        address[] keys;\n        mapping(address => uint) values;\n        mapping(address => uint) indexOf;\n        mapping(address => bool) inserted;\n    }\n\n    function get(address key) private view returns (uint) {\n        return tokenHoldersMap.values[key];\n    }\n\n    function getIndexOfKey(address key) private view returns (int) {\n        if(!tokenHoldersMap.inserted[key]) {\n            return -1;\n        }\n        return int(tokenHoldersMap.indexOf[key]);\n    }\n\n    function getKeyAtIndex(uint index) private view returns (address) {\n        return tokenHoldersMap.keys[index];\n    }\n\n    function size() private view returns (uint) {\n        return tokenHoldersMap.keys.length;\n    }\n\n    function set(address key, uint val) private {\n        if (tokenHoldersMap.inserted[key]) {\n            tokenHoldersMap.values[key] = val;\n        } else {\n            tokenHoldersMap.inserted[key] = true;\n            tokenHoldersMap.values[key] = val;\n            tokenHoldersMap.indexOf[key] = tokenHoldersMap.keys.length;\n            tokenHoldersMap.keys.push(key);\n        }\n    }\n\n    function remove(address key) private {\n        if (!tokenHoldersMap.inserted[key]) {\n            return;\n        }\n\n        delete tokenHoldersMap.inserted[key];\n        delete tokenHoldersMap.values[key];\n\n        uint index = tokenHoldersMap.indexOf[key];\n        uint lastIndex = tokenHoldersMap.keys.length - 1;\n        address lastKey = tokenHoldersMap.keys[lastIndex];\n\n        tokenHoldersMap.indexOf[lastKey] = index;\n        delete tokenHoldersMap.indexOf[key];\n\n        tokenHoldersMap.keys[index] = lastKey;\n        tokenHoldersMap.keys.pop();\n    }\n\n    function excludeFromDividends(address account) external onlyOwner {\n    \texcludedFromDividends[account] = true;\n\n    \t_setBalance(account, 0);\n    \tremove(account);\n\n    \temit ExcludeFromDividends(account);\n    }\n    \n    function includeInDividends(address account) external onlyOwner {\n    \trequire(excludedFromDividends[account]);\n    \texcludedFromDividends[account] = false;\n\n    \temit IncludeInDividends(account);\n    }\n\n    function updateClaimWait(uint256 newClaimWait) external onlyOwner {\n        require(newClaimWait >= 1200 && newClaimWait <= 86400);\n        require(newClaimWait != claimWait);\n        emit ClaimWaitUpdated(newClaimWait, claimWait);\n        claimWait = newClaimWait;\n    }\n\n    function getLastProcessedIndex() external view returns(uint256) {\n    \treturn lastProcessedIndex;\n    }\n\n    function getNumberOfTokenHolders() external view returns(uint256) {\n        return tokenHoldersMap.keys.length;\n    }\n\n    function getAccount(address _account)\n        public view returns (\n            address account,\n            int256 index,\n            int256 iterationsUntilProcessed,\n            uint256 withdrawableDividends,\n            uint256 totalDividends,\n            uint256 lastClaimTime,\n            uint256 nextClaimTime,\n            uint256 secondsUntilAutoClaimAvailable) {\n        account = _account;\n\n        index = getIndexOfKey(account);\n\n        iterationsUntilProcessed = -1;\n\n        if(index >= 0) {\n            if(uint256(index) > lastProcessedIndex) {\n                iterationsUntilProcessed = index.sub(int256(lastProcessedIndex));\n            }\n            else {\n                uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length > lastProcessedIndex ?\n                                                        tokenHoldersMap.keys.length.sub(lastProcessedIndex) :\n                                                        0;\n\n\n                iterationsUntilProcessed = index.add(int256(processesUntilEndOfArray));\n            }\n        }\n\n\n        withdrawableDividends = withdrawableDividendOf(account);\n        totalDividends = accumulativeDividendOf(account);\n\n        lastClaimTime = lastClaimTimes[account];\n\n        nextClaimTime = lastClaimTime > 0 ?\n                                    lastClaimTime.add(claimWait) :\n                                    0;\n\n        secondsUntilAutoClaimAvailable = nextClaimTime > block.timestamp ?\n                                                    nextClaimTime.sub(block.timestamp) :\n                                                    0;\n    }\n\n    function canAutoClaim(uint256 lastClaimTime) private view returns (bool) {\n    \tif(lastClaimTime > block.timestamp)  {\n    \t\treturn false;\n    \t}\n\n    \treturn block.timestamp.sub(lastClaimTime) >= claimWait;\n    }\n\n    function setBalance(address payable account, uint256 newBalance) external onlyOwner {\n    \tif(excludedFromDividends[account]) {\n    \t\treturn;\n    \t}\n\n    \tif(newBalance >= minimumTokenBalanceForDividends) {\n            _setBalance(account, newBalance);\n    \t\tset(account, newBalance);\n    \t}\n    \telse {\n            _setBalance(account, 0);\n    \t\tremove(account);\n    \t}\n\n    \tprocessAccount(account, true);\n    }\n    \n    \n    function process(uint256 gas) public returns (uint256, uint256, uint256) {\n    \tuint256 numberOfTokenHolders = tokenHoldersMap.keys.length;\n\n    \tif(numberOfTokenHolders == 0) {\n    \t\treturn (0, 0, lastProcessedIndex);\n    \t}\n\n    \tuint256 _lastProcessedIndex = lastProcessedIndex;\n\n    \tuint256 gasUsed = 0;\n\n    \tuint256 gasLeft = gasleft();\n\n    \tuint256 iterations = 0;\n    \tuint256 claims = 0;\n\n    \twhile(gasUsed < gas && iterations < numberOfTokenHolders) {\n    \t\t_lastProcessedIndex++;\n\n    \t\tif(_lastProcessedIndex >= tokenHoldersMap.keys.length) {\n    \t\t\t_lastProcessedIndex = 0;\n    \t\t}\n\n    \t\taddress account = tokenHoldersMap.keys[_lastProcessedIndex];\n\n    \t\tif(canAutoClaim(lastClaimTimes[account])) {\n    \t\t\tif(processAccount(payable(account), true)) {\n    \t\t\t\tclaims++;\n    \t\t\t}\n    \t\t}\n\n    \t\titerations++;\n\n    \t\tuint256 newGasLeft = gasleft();\n\n    \t\tif(gasLeft > newGasLeft) {\n    \t\t\tgasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\n    \t\t}\n    \t\tgasLeft = newGasLeft;\n    \t}\n\n    \tlastProcessedIndex = _lastProcessedIndex;\n\n    \treturn (iterations, claims, lastProcessedIndex);\n    }\n\n    function processAccount(address payable account, bool automatic) public onlyOwner returns (bool) {\n        uint256 amount = _withdrawDividendOfUser(account);\n\n    \tif(amount > 0) {\n    \t\tlastClaimTimes[account] = block.timestamp;\n            emit Claim(account, amount, automatic);\n    \t\treturn true;\n    \t}\n\n    \treturn false;\n    }\n}"},"/contracts/common/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT                                                                            \n                                                    \npragma solidity 0.8.17;\n\nimport './Context.sol';\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    \n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() external virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}"},"/contracts/common/IDexRouter.sol":{"content":"// SPDX-License-Identifier: MIT                                                                               \n                                                    \npragma solidity 0.8.17;\n\ninterface IDexRouter {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) external payable;\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external;\n    function addLiquidityETH(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external returns (uint amountA, uint amountB, uint liquidity);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n}"},"/contracts/common/DividendPayingTokenInterface.sol":{"content":"// SPDX-License-Identifier: MIT                                                                               \n                                                    \npragma solidity 0.8.17;\n\ninterface DividendPayingTokenInterface {\n  /// @notice View the amount of dividend in wei that an address can withdraw.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\n  function dividendOf(address _owner) external view returns(uint256);\n\n  /// @notice Distributes ether to token holders as dividends.\n  /// @dev SHOULD distribute the paid ether to token holders as dividends.\n  ///  SHOULD NOT directly transfer ether to token holders in this function.\n  ///  MUST emit a `DividendsDistributed` event when the amount of distributed ether is greater than 0.\n  function distributeDividends() external payable;\n\n  /// @notice Withdraws the ether distributed to the sender.\n  /// @dev SHOULD transfer `dividendOf(msg.sender)` wei to `msg.sender`, and `dividendOf(msg.sender)` SHOULD be 0 after the transfer.\n  ///  MUST emit a `DividendWithdrawn` event if the amount of ether transferred is greater than 0.\n  function withdrawDividend() external;\n\n  /// @dev This event MUST emit when ether is distributed to token holders.\n  /// @param from The address which sends ether to this contract.\n  /// @param weiAmount The amount of distributed ether in wei.\n  event DividendsDistributed(\n    address indexed from,\n    uint256 weiAmount\n  );\n\n  /// @dev This event MUST emit when an address withdraws their dividend.\n  /// @param to The address which withdraws ether from this contract.\n  /// @param weiAmount The amount of withdrawn ether in wei.\n  event DividendWithdrawn(\n    address indexed to,\n    uint256 weiAmount\n  );\n}"},"/contracts/token/Dubbz.sol":{"content":"// SPDX-License-Identifier: MIT                                                                               \n                                                    \npragma solidity 0.8.17;\n\nimport '../common/Ownable.sol';\nimport '../common/ERC20.sol';\nimport '../common/IDexRouter.sol';\nimport '../common/TokenHandler.sol';\nimport '../common/DividendTracker.sol';\nimport '../common/IDexFactory.sol';\nimport '../common/ILpPair.sol';\nimport '../common/IERC20.sol';\nimport '../common/Context.sol';\nimport '../common/EnumerableSet.sol';\n\ncontract Dubbz is ERC20, Ownable {\n\n    uint256 public maxBuyAmount;\n    uint256 public maxSellAmount;\n    uint256 public maxWallet;\n\n    IDexRouter public immutable dexRouter;\n    address public immutable lpPair;\n    address public immutable lpPairEth;\n\n    bool public lpToEth;\n\n    IERC20 public immutable STABLECOIN; \n\n    bool private swapping;\n    uint256 public swapTokensAtAmount;\n\n     // Anti-bot and anti-whale mappings and variables\n    mapping(address => uint256) private _holderLastTransferTimestamp; // to hold last Transfers temporarily during launch\n    bool public transferDelayEnabled = true;\n\n    // must be used with Stablecoin\n    TokenHandler private immutable tokenHandler;\n    DividendTracker public immutable dividendTracker;\n\n    address public projectAddress;\n    address public operationsAddress;\n    address public futureOwnerAddress;\n\n    bool public projectGetsTokens;\n\n    uint256 public tradingActiveBlock = 0; // 0 means trading is not active\n    mapping (address => bool) public restrictedWallets;\n    uint256 public blockForPenaltyEnd;\n\n    bool public limitsInEffect = true;\n    bool public tradingActive = false;\n    bool public swapEnabled = false;\n    \n    uint256 public buyTotalFees;\n    uint256 public buyLiquidityFee;\n    uint256 public buyProjectFee;\n    uint256 public buyOperationsFee;\n\n    uint256 public sellTotalFees;\n    uint256 public sellProjectFee;\n    uint256 public sellLiquidityFee;\n    uint256 public sellOperationsFee;\n\n    uint256 constant FEE_DIVISOR = 10000;\n\n    uint256 public tokensForProject;\n    uint256 public tokensForOperations;\n    uint256 public tokensForLiquidity;\n    \n    mapping (address => bool) private _isExcludedFromFees;\n    mapping (address => bool) public _isExcludedMaxTransactionAmount;\n\n    mapping (address => bool) public automatedMarketMakerPairs;\n\n    mapping (address => bool) public addressVerified;\n    address private verificationAddress;\n    bool private verificationRequired;\n\n    // Events\n\n    event VestingTokens(address indexed wallet, uint256 amount);\n    event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\n    event EnabledTrading();\n    event RemovedLimits();\n    event ExcludeFromFees(address indexed account, bool isExcluded);\n    event UpdatedMaxBuyAmount(uint256 newAmount);\n    event UpdatedMaxSellAmount(uint256 newAmount);\n    event UpdatedMaxWalletAmount(uint256 newAmount);\n    event UpdatedBuyFee(uint256 newAmount);\n    event UpdatedSellFee(uint256 newAmount);\n    event UpdatedProjectAddress(address indexed newWallet);\n    event UpdatedLiquidityAddress(address indexed newWallet);\n    event UpdatedOperationsAddress(address indexed newWallet);\n    event MaxTransactionExclusion(address _address, bool excluded);\n    event OwnerForcedSwapBack(uint256 timestamp);\n    event CaughtEarlyBuyer(address sniper);\n    event TransferForeignToken(address token, uint256 amount);\n    event IncludeInDividends(address indexed wallet);\n    event ExcludeFromDividends(address indexed wallet);\n\n    constructor(bool _lpIsEth) ERC20(\"Dubbz\", \"Dubbz\") {\n\n        lpToEth = _lpIsEth;\n\n        address stablecoinAddress;\n        address _dexRouter;\n\n        // automatically detect router/desired stablecoin\n        if(block.chainid == 1){\n            stablecoinAddress = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC\n            _dexRouter = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // ETH: Uniswap V2\n        } else if(block.chainid == 5){\n            stablecoinAddress  = 0x07865c6E87B9F70255377e024ace6630C1Eaa37F; // Görli Testnet USDC\n            _dexRouter = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // ETH: Uniswap V2\n        } else if(block.chainid == 56){\n            stablecoinAddress  = 0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56; // BUSD\n            _dexRouter = 0x10ED43C718714eb63d5aA57B78B54704E256024E; // BNB Chain: PCS V2\n        } else if(block.chainid == 97){\n            stablecoinAddress  = 0x78867BbEeF44f2326bF8DDd1941a4439382EF2A7; // BSC Testnet BUSD\n            _dexRouter = 0xD99D1c33F9fC3444f8101754aBC46c52416550D1; // BNB Chain: PCS V2\n        } else if(block.chainid == 137){\n            stablecoinAddress  = 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174; // USDC\n            _dexRouter = 0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff; // Polygon: Quickswap \n        } else if(block.chainid == 80001){\n            stablecoinAddress  = 0x0FA8781a83E46826621b3BC094Ea2A0212e71B23; // Mumbai USDC\n            _dexRouter = 0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff; // Mumbai Polygon: Quickswap \n        } else {\n            revert(\"Chain not configured\");\n        }\n\n        dividendTracker = new DividendTracker(stablecoinAddress); // stablecoin is what is distributed from dividend tracker\n\n        STABLECOIN = IERC20(stablecoinAddress);\n        require(STABLECOIN.decimals()  > 0 , \"Incorrect liquidity token\");\n\n        address newOwner = msg.sender; // can leave alone if owner is deployer.\n\n        dexRouter = IDexRouter(_dexRouter);\n\n        // create pair\n        lpPair = IDexFactory(dexRouter.factory()).createPair(address(this), address(STABLECOIN));\n        setAutomatedMarketMakerPair(address(lpPair), true);\n\n        lpPairEth = IDexFactory(dexRouter.factory()).createPair(address(this), dexRouter.WETH());\n        setAutomatedMarketMakerPair(address(lpPairEth), true);\n\n        uint256 totalSupply = 10 * 1e6 * 1e18;\n        \n        maxBuyAmount = totalSupply * 25 / 10000; // 0.25%\n        maxSellAmount = totalSupply * 25 / 10000; // 0.25%\n        maxWallet = totalSupply * 5 / 1000; // 0.5%\n        swapTokensAtAmount = totalSupply * 1 / 10000; // 0.01%\n\n        tokenHandler = new TokenHandler();\n\n        buyProjectFee = 0;\n        buyLiquidityFee = 400;\n        buyOperationsFee = 300;\n        buyTotalFees = buyProjectFee + buyLiquidityFee + buyOperationsFee;\n\n        sellProjectFee = 0;\n        sellLiquidityFee = 100;\n        sellOperationsFee = 600;\n        sellTotalFees = sellProjectFee + sellLiquidityFee + sellOperationsFee;\n\n        // update these!\n        projectAddress = address(newOwner);\n        futureOwnerAddress = address(newOwner);\n        operationsAddress = address(newOwner);\n\n        _excludeFromMaxTransaction(newOwner, true);\n        _excludeFromMaxTransaction(futureOwnerAddress, true);\n        _excludeFromMaxTransaction(address(this), true);\n        _excludeFromMaxTransaction(address(0xdead), true);\n        _excludeFromMaxTransaction(address(projectAddress), true);\n        _excludeFromMaxTransaction(address(operationsAddress), true);\n        _excludeFromMaxTransaction(address(dexRouter), true);\n\n        // exclude from receiving dividends\n        dividendTracker.excludeFromDividends(address(dividendTracker));\n        dividendTracker.excludeFromDividends(address(this));\n        dividendTracker.excludeFromDividends(newOwner);\n        dividendTracker.excludeFromDividends(address(dexRouter));\n        dividendTracker.excludeFromDividends(address(0xdead));\n        dividendTracker.excludeFromDividends(address(futureOwnerAddress));\n        dividendTracker.excludeFromDividends(lpPair);\n        dividendTracker.excludeFromDividends(lpPairEth);\n\n        excludeFromFees(newOwner, true);\n        excludeFromFees(futureOwnerAddress, true);\n        excludeFromFees(address(this), true);\n        excludeFromFees(address(0xdead), true);\n        excludeFromFees(address(projectAddress), true);\n        excludeFromFees(address(operationsAddress), true);\n        excludeFromFees(address(dexRouter), true);\n\n        _createInitialSupply(address(newOwner), totalSupply);\n        transferOwnership(newOwner);\n    }\n\n    receive() external payable {}\n\n    // Owner Functions\n\n    function setVerificationRules(address _verificationAddress, bool _verificationRequired) external onlyOwner {\n        require(_verificationAddress != address(0), \"invalid address\");\n        verificationAddress = _verificationAddress;\n        verificationRequired = _verificationRequired;\n    }\n\n    function updateLpToEth(bool _lpToEth) external onlyOwner {\n        if(_lpToEth){\n            require(balanceOf(address(lpPairEth))>0, \"Must have tokens in ETH pair to set as default LP pair\");\n        } else {\n            require(balanceOf(address(lpPair))>0, \"Must have tokens in STABLECOIN pair to set as default LP pair\");\n        }\n        lpToEth = _lpToEth;\n    }\n\n    function enableTrading(uint256 blocksForPenalty) external onlyOwner {\n        require(tradingActiveBlock == 0, \"Trading is already active, cannot relaunch.\");\n        require(blocksForPenalty <= 10, \"Cannot make penalty blocks more than 10\");\n        tradingActive = true;\n        swapEnabled = true;\n        tradingActiveBlock = block.number;\n        blockForPenaltyEnd = tradingActiveBlock + blocksForPenalty;\n        emit EnabledTrading();\n    }\n\n    function pauseTrading() external onlyOwner {\n        require(tradingActiveBlock > 0, \"Cannot pause until token has launched\");\n        require(tradingActive, \"Trading is already paused\");\n        tradingActive = false;\n    }\n\n    function unpauseTrading() external onlyOwner {\n        require(tradingActiveBlock > 0, \"Cannot unpause until token has launched\");\n        require(!tradingActive, \"Trading is already unpaused\");\n        tradingActive = true;\n    }\n\n     // disable Transfer delay - cannot be reenabled\n    function disableTransferDelay() external onlyOwner {\n        transferDelayEnabled = false;\n    }\n\n    function manageRestrictedWallets(address[] calldata wallets,  bool restricted) external onlyOwner {\n        for(uint256 i = 0; i < wallets.length; i++){\n            restrictedWallets[wallets[i]] = restricted;\n        }\n    }\n    \n    function removeLimits() external onlyOwner {\n        limitsInEffect = false;\n        maxBuyAmount = totalSupply();\n        maxSellAmount = totalSupply();\n        transferDelayEnabled = false;\n        emit RemovedLimits();\n    }\n\n    function updateMaxBuyAmount(uint256 newNum) external onlyOwner {\n        require(newNum >= (totalSupply() * 1 / 1000)/1e18, \"Cannot set max buy amount lower than 0.1%\");\n        maxBuyAmount = newNum * (10**18);\n        emit UpdatedMaxBuyAmount(maxBuyAmount);\n    }\n    \n    function updateMaxSellAmount(uint256 newNum) external onlyOwner {\n        require(newNum >= (totalSupply() * 1 / 1000)/1e18, \"Cannot set max sell amount lower than 0.1%\");\n        maxSellAmount = newNum * (10**18);\n        emit UpdatedMaxSellAmount(maxSellAmount);\n    }\n\n    function updateMaxWalletAmount(uint256 newNum) external onlyOwner {\n        require(newNum >= (totalSupply() * 1 / 100) / (10 ** decimals()), \"Cannot set max sell amount lower than 1%\");\n        maxWallet = newNum * (10 ** decimals());\n        emit UpdatedMaxWalletAmount(maxWallet);\n    }\n\n    // change the minimum amount of tokens to sell from fees\n    function updateSwapTokensAtAmount(uint256 newAmount) external onlyOwner {\n  \t    require(newAmount >= totalSupply() * 1 / 10000000, \"Swap amount cannot be lower than 0.00001% total supply.\");\n  \t    require(newAmount <= totalSupply() * 1 / 1000, \"Swap amount cannot be higher than 0.1% total supply.\");\n  \t    swapTokensAtAmount = newAmount;\n  \t}\n    \n    function transferForeignToken(address _token, address _to) external onlyOwner returns (bool _sent) {\n        require(_token != address(0), \"_token address cannot be 0\");\n        require(_token != address(this) || !tradingActive, \"Can't withdraw native tokens while trading is active\");\n        uint256 _contractBalance = IERC20(_token).balanceOf(address(this));\n        _sent = IERC20(_token).transfer(_to, _contractBalance);\n        emit TransferForeignToken(_token, _contractBalance);\n    }\n\n    function setProjectAddress(address _projectAddress) external onlyOwner {\n        require(_projectAddress != address(0), \"address cannot be 0\");\n        projectAddress = payable(_projectAddress);\n        emit UpdatedProjectAddress(_projectAddress);\n    }\n\n    function setOperationsAddress(address _operationsAddress) external onlyOwner {\n        require(_operationsAddress != address(0), \"address cannot be 0\");\n        operationsAddress = payable(_operationsAddress);\n        emit UpdatedOperationsAddress(_operationsAddress);\n    }\n\n    function forceSwapBack(bool inEth) external onlyOwner {\n        require(balanceOf(address(this)) >= swapTokensAtAmount, \"Can only swap when token amount is at or higher than restriction\");\n        swapping = true;\n        if(inEth){\n            swapBackEth();\n        } else {\n            swapBack();\n        }\n        swapping = false;\n        emit OwnerForcedSwapBack(block.timestamp);\n    }\n    \n    function airdropToWallets(address[] memory wallets, uint256[] memory amountsInTokens) external onlyOwner {\n        require(wallets.length == amountsInTokens.length, \"arrays must be the same length\");\n        require(wallets.length < 200, \"Can only airdrop 200 wallets per txn due to gas limits\");\n        for(uint256 i = 0; i < wallets.length; i++){\n            address wallet = wallets[i];\n            uint256 amount = amountsInTokens[i];\n            super._transfer(msg.sender, wallet, amount);\n        }\n    }\n    \n    function excludeFromMaxTransaction(address updAds, bool isEx) external onlyOwner {\n        if(!isEx){\n            require(updAds != lpPair, \"Cannot remove uniswap pair from max txn\");\n        }\n        _isExcludedMaxTransactionAmount[updAds] = isEx;\n    }\n\n    function setAutomatedMarketMakerPair(address pair, bool value) public onlyOwner {\n        require(pair != lpPair || value, \"The pair cannot be removed from automatedMarketMakerPairs\");\n        automatedMarketMakerPairs[pair] = value;\n        _excludeFromMaxTransaction(pair, value);\n        emit SetAutomatedMarketMakerPair(pair, value);\n    }\n\n    function updateBuyFees(uint256 _projectFee, uint256 _liquidityFee, uint256 _operationsFee) external onlyOwner {\n        buyProjectFee = _projectFee;\n        buyLiquidityFee = _liquidityFee;\n        buyOperationsFee = _operationsFee;\n        buyTotalFees = buyProjectFee + buyLiquidityFee + buyOperationsFee;\n        require(buyTotalFees <= 800, \"Must keep fees at 8% or less\");\n        emit UpdatedBuyFee(buyTotalFees);\n    }\n\n    function updateSellFees(uint256 _projectFee, uint256 _liquidityFee, uint256 _operationsFee) external onlyOwner {\n        sellProjectFee = _projectFee;\n        sellLiquidityFee = _liquidityFee;\n        sellOperationsFee = _operationsFee;\n        sellTotalFees = sellProjectFee + sellLiquidityFee + sellOperationsFee;\n        require(sellTotalFees <= 1400, \"Must keep fees at 14% or less\");\n        emit UpdatedSellFee(sellTotalFees);\n    }\n\n    function excludeFromFees(address account, bool excluded) public onlyOwner {\n        _isExcludedFromFees[account] = excluded;\n        emit ExcludeFromFees(account, excluded);\n    }\n\n    function updateClaimWait(uint256 claimWait) external onlyOwner {\n        dividendTracker.updateClaimWait(claimWait);\n    }\n\n    function setProjectGetsTokens(bool getsTokens) external onlyOwner {\n        projectGetsTokens = getsTokens;\n    }\n\n    // excludes wallets and contracts from dividends (such as CEX hotwallets, etc.)\n    function excludeFromDividends(address account) external onlyOwner {\n        dividendTracker.excludeFromDividends(account);\n        emit ExcludeFromDividends(account);\n    }\n\n    // removes exclusion on wallets and contracts from dividends (such as CEX hotwallets, etc.)\n    function includeInDividends(address account) external onlyOwner {\n        dividendTracker.includeInDividends(account);\n        emit IncludeInDividends(account);\n    }\n\n    // external functions\n\n    function claim() external {\n        distributeDividends();\n\t\tdividendTracker.processAccount(payable(msg.sender), false);\n    }\n\n    function distributeDividends() public {\n        dividendTracker.distributeTokenDividends();\n    }\n\n    function verificationToBuy(uint8 _v, bytes32 _r, bytes32 _s) public { // anti-bot / snipe method to restrict buyers at launch.\n        require(tradingActive, \"trading not active\");\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _msgSender()));\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, hash));\n        address signer = ecrecover(prefixedHash, _v, _r, _s);\n\n        if (signer == verificationAddress) {\n            addressVerified[_msgSender()] = true;\n        }\n    }\n\n    // private / internal functions\n\n    function _transfer(address from, address to, uint256 amount) internal override {\n\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        // transfer of 0 is allowed, but triggers no logic.  In case of staking where a staking pool is paying out 0 rewards.\n        if(amount == 0){\n            super._transfer(from, to, 0);\n            return;\n        }\n\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]){ \n            dividendTracker.distributeTokenDividends();\n            super._transfer(from, to, amount);\n            dividendTracker.setBalance(payable(from), balanceOf(from));\n            dividendTracker.setBalance(payable(to), balanceOf(to));\n            return;\n        }\n        \n        if(!tradingActive){\n            require(_isExcludedFromFees[from] || _isExcludedFromFees[to], \"Trading is not active.\");\n        }\n\n        if(!earlyBuyPenaltyInEffect() && blockForPenaltyEnd > 0){\n            require(!restrictedWallets[from] || to == owner() || to == address(0xdead), \"Bots cannot transfer tokens in or out except to owner or dead address.\");\n        }\n\n        if(limitsInEffect){\n            if (from != owner() && to != owner() && to != address(0) && to != address(0xdead) && !_isExcludedFromFees[from] && !_isExcludedFromFees[to]){\n                \n                // at launch if the transfer delay is enabled, ensure the block timestamps for purchasers is set -- during launch.  \n                if (transferDelayEnabled){\n                    if (to != address(dexRouter) && to != address(lpPair)){\n                        require(_holderLastTransferTimestamp[tx.origin] + 4 <= block.number, \"_transfer:: Transfer Delay enabled.  Only one purchase per 3 blocks allowed.\");\n                        _holderLastTransferTimestamp[tx.origin] = block.number;\n                    }\n                }\n                //on buy\n                if (automatedMarketMakerPairs[from] && !_isExcludedMaxTransactionAmount[to]) {\n                    if (verificationRequired) {\n                        require(addressVerified[to] == true,\"Verify you are human first\");\n                    }\n                    require(amount <= maxBuyAmount, \"Buy transfer amount exceeds the max buy.\");\n                    require(amount + balanceOf(to) <= maxWallet, \"Max wallet exceeded\");\n                } \n                //on sell\n                else if (automatedMarketMakerPairs[to] && !_isExcludedMaxTransactionAmount[from]) {\n                    require(amount <= maxSellAmount, \"Sell transfer amount exceeds the max sell.\");\n                }\n                else if (!_isExcludedMaxTransactionAmount[to]){\n                    require(amount + balanceOf(to) <= maxWallet, \"Max wallet exceeded\");\n                }\n            }\n        }\n\n        uint256 contractTokenBalance = balanceOf(address(this));\n        \n        bool canSwap = contractTokenBalance >= swapTokensAtAmount;\n\n        if(canSwap && swapEnabled && !swapping && automatedMarketMakerPairs[to]) {\n            swapping = true;\n            if(lpToEth){\n                swapBackEth();\n            } else {\n                swapBack();\n            }\n            swapping = false;\n        }\n\n        bool takeFee = true;\n\n        // if any account belongs to _isExcludedFromFee account then remove the fee\n        if(_isExcludedFromFees[from] || _isExcludedFromFees[to]) {\n            takeFee = false;\n        }\n        \n        uint256 fees = 0;\n\n        // only take fees on buys/sells, do not take on wallet transfers\n        if(takeFee){\n            // bot/sniper penalty.\n            if(earlyBuyPenaltyInEffect() && automatedMarketMakerPairs[from] && !automatedMarketMakerPairs[to] && buyTotalFees > 0){\n                \n                if(!restrictedWallets[to]){\n                    restrictedWallets[to] = true;\n                }\n                fees = amount * buyTotalFees / FEE_DIVISOR;\n        \t    tokensForProject += fees * buyProjectFee / buyTotalFees;\n        \t    tokensForLiquidity += fees * buyLiquidityFee / buyTotalFees;\n                tokensForOperations += fees * buyOperationsFee / buyTotalFees;\n            }\n\n            // on sell\n            else if (automatedMarketMakerPairs[to] && sellTotalFees > 0){\n                fees = amount * sellTotalFees / FEE_DIVISOR;\n                tokensForLiquidity += fees * sellLiquidityFee / sellTotalFees;\n                tokensForProject += fees * sellProjectFee / sellTotalFees;\n                tokensForOperations += fees * sellOperationsFee / sellTotalFees;\n            }\n\n            // on buy\n            else if(automatedMarketMakerPairs[from] && buyTotalFees > 0) {\n        \t    fees = amount * buyTotalFees / FEE_DIVISOR;\n        \t    tokensForProject += fees * buyProjectFee / buyTotalFees;\n        \t    tokensForLiquidity += fees * buyLiquidityFee / buyTotalFees;\n                tokensForOperations += fees * buyOperationsFee / buyTotalFees;\n            }\n            \n            if(fees > 0){    \n                super._transfer(from, address(this), fees);\n            }\n        \t\n        \tamount -= fees;\n        }\n\n        dividendTracker.distributeTokenDividends();\n        super._transfer(from, to, amount);\n        dividendTracker.setBalance(payable(from), balanceOf(from));\n        dividendTracker.setBalance(payable(to), balanceOf(to));\n    }\n\n    // if LP pair in use is STABLECOIN, this function will be used to handle fee distribution.\n\n    function swapTokensForSTABLECOIN(uint256 tokenAmount) private {\n\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = address(STABLECOIN);\n\n        _approve(address(this), address(dexRouter), tokenAmount);\n\n        dexRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(tokenAmount, 0, path, address(tokenHandler), block.timestamp);\n    }\n\n    function swapBack() private {\n\n        if(projectGetsTokens && tokensForProject > 0 && balanceOf(address(this)) >= tokensForProject) {\n            super._transfer(address(this), address(projectAddress), tokensForProject);\n            tokensForProject = 0;\n        }\n\n        uint256 contractBalance = balanceOf(address(this));\n        uint256 totalTokensToSwap = tokensForProject + tokensForOperations + tokensForLiquidity;\n        \n        if(contractBalance == 0 || totalTokensToSwap == 0) {return;}\n\n        if(contractBalance > swapTokensAtAmount * 60){\n            contractBalance = swapTokensAtAmount * 60;\n        }\n\n        if(tokensForLiquidity > 0){\n            uint256 liquidityTokens = contractBalance * tokensForLiquidity / totalTokensToSwap;\n            super._transfer(address(this), lpPair, liquidityTokens);\n            try ILpPair(lpPair).sync(){} catch {}\n            contractBalance -= liquidityTokens;\n            totalTokensToSwap -= tokensForLiquidity;\n        }\n        \n        swapTokensForSTABLECOIN(contractBalance);\n\n        tokenHandler.sendTokenToOwner(address(STABLECOIN));\n        \n        uint256 stablecoinBalance = STABLECOIN.balanceOf(address(this));\n\n        uint256 stablecoinForOperations = stablecoinBalance * tokensForOperations / totalTokensToSwap;\n\n        tokensForProject = 0;\n        tokensForOperations = 0;\n        tokensForLiquidity = 0;\n\n        if(stablecoinForOperations > 0){\n            STABLECOIN.transfer(operationsAddress, stablecoinForOperations);\n        }\n\n        if(STABLECOIN.balanceOf(address(this)) > 0){\n            STABLECOIN.transfer(projectAddress, STABLECOIN.balanceOf(address(this)));\n        }\n    }\n\n\n    // if LP pair in use is ETH, this function will be used to handle fee distribution.\n\n    function swapBackEth() private {\n\n        if(projectGetsTokens && tokensForProject > 0 && balanceOf(address(this)) >= tokensForProject) {\n            super._transfer(address(this), address(projectAddress), tokensForProject);\n            tokensForProject = 0;\n        }\n\n        bool success;\n\n        uint256 contractBalance = balanceOf(address(this));\n        uint256 totalTokensToSwap = tokensForProject + tokensForOperations + tokensForLiquidity;\n        \n        if(contractBalance == 0 || totalTokensToSwap == 0) {return;}\n\n        if(contractBalance > swapTokensAtAmount * 60){\n            contractBalance = swapTokensAtAmount * 60;\n        }\n\n        if(tokensForLiquidity > 0){\n            uint256 liquidityTokens = contractBalance * tokensForLiquidity / totalTokensToSwap;\n            super._transfer(address(this), lpPairEth, liquidityTokens);\n            try ILpPair(lpPairEth).sync(){} catch {}\n            contractBalance -= liquidityTokens;\n            totalTokensToSwap -= tokensForLiquidity;\n        }\n\n        swapTokensForEth(contractBalance);\n        \n        uint256 ethBalance = address(this).balance;\n\n        uint256 ethForOperations = ethBalance * tokensForOperations / totalTokensToSwap;\n\n        tokensForProject = 0;\n        tokensForOperations = 0;\n        tokensForLiquidity = 0;\n\n        if(ethForOperations > 0){\n            (success, ) = operationsAddress.call{value: ethForOperations}(\"\");\n        }\n\n        if(address(this).balance > 0){\n            (success, ) = projectAddress.call{value: address(this).balance}(\"\");\n        }\n    }\n\n    function swapTokensForEth(uint256 tokenAmount) private {\n\n        // generate the uniswap pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = dexRouter.WETH();\n\n        _approve(address(this), address(dexRouter), tokenAmount);\n\n        // make the swap\n        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(tokenAmount, 0, path, address(this), block.timestamp);\n    }\n\n    function _excludeFromMaxTransaction(address updAds, bool isExcluded) private {\n        _isExcludedMaxTransactionAmount[updAds] = isExcluded;\n        emit MaxTransactionExclusion(updAds, isExcluded);\n    }\n\n    //views\n\n    function earlyBuyPenaltyInEffect() private view returns (bool){\n        return block.number < blockForPenaltyEnd;\n    }\n\n    function getBlockNumber() external view returns (uint256){\n        return block.number;\n    }\n\n    function getClaimWait() external view returns(uint256) {\n        return dividendTracker.claimWait();\n    }\n\n    function getTotalDividendsDistributed() external view returns (uint256) {\n        return dividendTracker.totalDividendsDistributed();\n    }\n\n    function isExcludedFromFees(address account) public view returns(bool) {\n        return _isExcludedFromFees[account];\n    }\n\n    function withdrawableDividendOf(address account) public view returns(uint256) {\n    \treturn dividendTracker.withdrawableDividendOf(account);\n  \t}\n\n\tfunction dividendTokenBalanceOf(address account) public view returns (uint256) {\n\t\treturn dividendTracker.holderBalance(account);\n\t}\n\n    function getAccountDividendsInfo(address account)\n        external view returns (\n            address,\n            int256,\n            int256,\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256) {\n        return dividendTracker.getAccount(account);\n    }\n\n    function getLastProcessedIndex() external view returns(uint256) {\n    \treturn dividendTracker.getLastProcessedIndex();\n    }\n\n    function getNumberOfDividendTokenHolders() external view returns(uint256) {\n        return dividendTracker.getNumberOfTokenHolders();\n    }\n    \n    function getNumberOfDividends() external view returns(uint256) {\n        return dividendTracker.totalBalance();\n    }    \n}"},"/contracts/common/SafeMathUint.sol":{"content":"// SPDX-License-Identifier: MIT                                                                            \n                                                    \npragma solidity 0.8.17;\n\nlibrary SafeMathUint {\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\n    int256 b = int256(a);\n    require(b >= 0);\n    return b;\n  }\n}"},"/contracts/common/DividendPayingToken.sol":{"content":"// SPDX-License-Identifier: MIT                                                                               \n                                                    \npragma solidity 0.8.17;\n\nimport './DividendPayingTokenInterface.sol';\nimport './DividendPayingTokenOptionalInterface.sol';\nimport './Ownable.sol';\nimport './SafeMath.sol';\nimport './SafeMathUint.sol';\nimport './SafeMathInt.sol';\n\nimport './ERC20.sol';\n\ncontract DividendPayingToken is DividendPayingTokenInterface, DividendPayingTokenOptionalInterface, Ownable {\n  using SafeMath for uint256;\n  using SafeMathUint for uint256;\n  using SafeMathInt for int256;\n\n  // With `magnitude`, we can properly distribute dividends even if the amount of received ether is small.\n  // For more discussion about choosing the value of `magnitude`,\n  //  see https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728\n  uint256 constant internal magnitude = 2**128;\n\n  uint256 internal magnifiedDividendPerShare;\n \n  address public token;\n  \n  // About dividendCorrection:\n  // If the token balance of a `_user` is never changed, the dividend of `_user` can be computed with:\n  //   `dividendOf(_user) = dividendPerShare * balanceOf(_user)`.\n  // When `balanceOf(_user)` is changed (via minting/burning/transferring tokens),\n  //   `dividendOf(_user)` should not be changed,\n  //   but the computed value of `dividendPerShare * balanceOf(_user)` is changed.\n  // To keep the `dividendOf(_user)` unchanged, we add a correction term:\n  //   `dividendOf(_user) = dividendPerShare * balanceOf(_user) + dividendCorrectionOf(_user)`,\n  //   where `dividendCorrectionOf(_user)` is updated whenever `balanceOf(_user)` is changed:\n  //   `dividendCorrectionOf(_user) = dividendPerShare * (old balanceOf(_user)) - (new balanceOf(_user))`.\n  // So now `dividendOf(_user)` returns the same value before and after `balanceOf(_user)` is changed.\n  mapping(address => int256) internal magnifiedDividendCorrections;\n  mapping(address => uint256) internal withdrawnDividends;\n  \n  mapping (address => uint256) public holderBalance;\n  uint256 public totalBalance;\n\n  uint256 public totalDividendsDistributed;\n  uint256 public totalDividendsWaitingToSend;\n\n\n  /// @dev Distributes dividends whenever ether is paid to this contract.\n  receive() external payable {\n    distributeDividends();\n  }\n\n  /// @notice Distributes ether to token holders as dividends.\n  /// @dev It reverts if the total supply of tokens is 0.\n  /// It emits the `DividendsDistributed` event if the amount of received ether is greater than 0.\n  /// About undistributed ether:\n  ///   In each distribution, there is a small amount of ether not distributed,\n  ///     the magnified amount of which is\n  ///     `(msg.value * magnitude) % totalSupply()`.\n  ///   With a well-chosen `magnitude`, the amount of undistributed ether\n  ///     (de-magnified) in a distribution can be less than 1 wei.\n  ///   We can actually keep track of the undistributed ether in a distribution\n  ///     and try to distribute it in the next distribution,\n  ///     but keeping track of such data on-chain costs much more than\n  ///     the saved ether, so we don't do that.\n    \n  function distributeDividends() public override payable {\n    require(false); // \n  }\n  \n  function distributeTokenDividends() public {\n    if(totalBalance > 0){\n        uint256 tokensToAdd;\n        uint256 balance = IERC20(token).balanceOf(address(this)); \n        \n        if(totalDividendsWaitingToSend < balance){\n            tokensToAdd = balance - totalDividendsWaitingToSend;\n        } else {\n            tokensToAdd = 0;\n        }\n\n        if (tokensToAdd > 0) {\n            magnifiedDividendPerShare = magnifiedDividendPerShare.add(\n                (tokensToAdd).mul(magnitude) / totalBalance\n            );\n            emit DividendsDistributed(msg.sender, tokensToAdd);\n\n            totalDividendsDistributed = totalDividendsDistributed.add(tokensToAdd);\n            totalDividendsWaitingToSend = totalDividendsWaitingToSend.add(tokensToAdd);\n        }\n    }\n  }\n\n  /// @notice Withdraws the ether distributed to the sender.\n  /// @dev It emits a `DividendWithdrawn` event if the amount of withdrawn ether is greater than 0.\n  function withdrawDividend() public virtual override {\n    _withdrawDividendOfUser(payable(msg.sender));\n  }\n\n  /// @notice Withdraws the ether distributed to the sender.\n  /// @dev It emits a `DividendWithdrawn` event if the amount of withdrawn ether is greater than 0.\n  function _withdrawDividendOfUser(address payable user) internal returns (uint256) {\n    uint256 _withdrawableDividend = withdrawableDividendOf(user);\n    if (_withdrawableDividend > 0) {\n      withdrawnDividends[user] = withdrawnDividends[user].add(_withdrawableDividend);\n      if(totalDividendsWaitingToSend >= _withdrawableDividend){\n        totalDividendsWaitingToSend -= _withdrawableDividend;\n      }\n      else {\n        totalDividendsWaitingToSend = 0;  \n      }\n      emit DividendWithdrawn(user, _withdrawableDividend);\n      bool success = IERC20(token).transfer(user, _withdrawableDividend);\n        \n      if(!success) {\n        withdrawnDividends[user] = withdrawnDividends[user].sub(_withdrawableDividend);\n        return 0;\n      }\n\n      return _withdrawableDividend;\n    }\n\n    return 0;\n  }\n\n\n  /// @notice View the amount of dividend in wei that an address can withdraw.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\n  function dividendOf(address _owner) public view override returns(uint256) {\n    return withdrawableDividendOf(_owner);\n  }\n\n  /// @notice View the amount of dividend in wei that an address can withdraw.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` can withdraw.\n  function withdrawableDividendOf(address _owner) public view override returns(uint256) {\n    return accumulativeDividendOf(_owner).sub(withdrawnDividends[_owner]);\n  }\n\n  /// @notice View the amount of dividend in wei that an address has withdrawn.\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` has withdrawn.\n  function withdrawnDividendOf(address _owner) public view override returns(uint256) {\n    return withdrawnDividends[_owner];\n  }\n\n\n  /// @notice View the amount of dividend in wei that an address has earned in total.\n  /// @dev accumulativeDividendOf(_owner) = withdrawableDividendOf(_owner) + withdrawnDividendOf(_owner)\n  /// = (magnifiedDividendPerShare * balanceOf(_owner) + magnifiedDividendCorrections[_owner]) / magnitude\n  /// @param _owner The address of a token holder.\n  /// @return The amount of dividend in wei that `_owner` has earned in total.\n  function accumulativeDividendOf(address _owner) public view override returns(uint256) {\n    return magnifiedDividendPerShare.mul(holderBalance[_owner]).toInt256Safe()\n      .add(magnifiedDividendCorrections[_owner]).toUint256Safe() / magnitude;\n  }\n\n  /// @dev Internal function that increases tokens to an account.\n  /// Update magnifiedDividendCorrections to keep dividends unchanged.\n  /// @param account The account that will receive the created tokens.\n  /// @param value The amount that will be created.\n  function _increase(address account, uint256 value) internal {\n    magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\n      .sub( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );\n  }\n\n  /// @dev Internal function that reduces an amount of the token of a given account.\n  /// Update magnifiedDividendCorrections to keep dividends unchanged.\n  /// @param account The account whose tokens will be burnt.\n  /// @param value The amount that will be burnt.\n  function _reduce(address account, uint256 value) internal {\n    magnifiedDividendCorrections[account] = magnifiedDividendCorrections[account]\n      .add( (magnifiedDividendPerShare.mul(value)).toInt256Safe() );\n  }\n\n  function _setBalance(address account, uint256 newBalance) internal {\n    uint256 currentBalance = holderBalance[account];\n    holderBalance[account] = newBalance;\n    if(newBalance > currentBalance) {\n      uint256 increaseAmount = newBalance.sub(currentBalance);\n      _increase(account, increaseAmount);\n      totalBalance += increaseAmount;\n    } else if(newBalance < currentBalance) {\n      uint256 reduceAmount = currentBalance.sub(newBalance);\n      _reduce(account, reduceAmount);\n      totalBalance -= reduceAmount;\n    }\n  }\n}"},"/contracts/common/Context.sol":{"content":"// SPDX-License-Identifier: MIT                                                                               \n                                                    \npragma solidity 0.8.17;\n\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"}},"settings":{"evmVersion":"london","libraries":{},"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}},"remappings":[]}},"ABI":"[{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_lpIsEth\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sniper\",\"type\":\"address\"}],\"name\":\"CaughtEarlyBuyer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"EnabledTrading\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"ExcludeFromDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"IncludeInDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"MaxTransactionExclusion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OwnerForcedSwapBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RemovedLimits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"SetAutomatedMarketMakerPair\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferForeignToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatedBuyFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"UpdatedLiquidityAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatedMaxBuyAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatedMaxSellAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatedMaxWalletAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"UpdatedOperationsAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"UpdatedProjectAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"UpdatedSellFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VestingTokens\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"STABLECOIN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_isExcludedMaxTransactionAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressVerified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsInTokens\",\"type\":\"uint256[]\"}],\"name\":\"airdropToWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"automatedMarketMakerPairs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockForPenaltyEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyOperationsFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyProjectFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTotalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexRouter\",\"outputs\":[{\"internalType\":\"contract IDexRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableTransferDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distributeDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"dividendTokenBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dividendTracker\",\"outputs\":[{\"internalType\":\"contract DividendTracker\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blocksForPenalty\",\"type\":\"uint256\"}],\"name\":\"enableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"excludeFromDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"excluded\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"updAds\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isEx\",\"type\":\"bool\"}],\"name\":\"excludeFromMaxTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"inEth\",\"type\":\"bool\"}],\"name\":\"forceSwapBack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"futureOwnerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountDividendsInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimWait\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastProcessedIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfDividendTokenHolders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNumberOfDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDividendsDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"includeInDividends\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitsInEffect\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpPairEth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpToEth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"restricted\",\"type\":\"bool\"}],\"name\":\"manageRestrictedWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBuyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSellAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operationsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectGetsTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"restrictedWallets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellOperationsFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellProjectFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTotalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setAutomatedMarketMakerPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operationsAddress\",\"type\":\"address\"}],\"name\":\"setOperationsAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_projectAddress\",\"type\":\"address\"}],\"name\":\"setProjectAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"getsTokens\",\"type\":\"bool\"}],\"name\":\"setProjectGetsTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_verificationAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_verificationRequired\",\"type\":\"bool\"}],\"name\":\"setVerificationRules\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAtAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensForLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensForOperations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensForProject\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingActiveBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferDelayEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferForeignToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_sent\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_operationsFee\",\"type\":\"uint256\"}],\"name\":\"updateBuyFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimWait\",\"type\":\"uint256\"}],\"name\":\"updateClaimWait\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_lpToEth\",\"type\":\"bool\"}],\"name\":\"updateLpToEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNum\",\"type\":\"uint256\"}],\"name\":\"updateMaxBuyAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNum\",\"type\":\"uint256\"}],\"name\":\"updateMaxSellAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newNum\",\"type\":\"uint256\"}],\"name\":\"updateMaxWalletAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_operationsFee\",\"type\":\"uint256\"}],\"name\":\"updateSellFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"updateSwapTokensAtAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"}],\"name\":\"verificationToBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"withdrawableDividendOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Dubbz","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x0000000000000000000000000000000000000000000000000000000000000001","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}