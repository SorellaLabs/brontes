{"expiry":1699526809,"data":[{"SourceCode":{"language":"Solidity","sources":{"contracts/lib/MerkleVerifier.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/**\n * @title MerkleVerifier\n * @dev Utility functions for Merkle tree computations\n */\nlibrary MerkleVerifier {\n    error InvalidProof();\n\n    /**\n     * @dev Verify the merkle proof\n     * @param leaf leaf\n     * @param root root\n     * @param proof proof\n     */\n    function _verifyProof(\n        bytes32 leaf,\n        bytes32 root,\n        bytes32[] memory proof\n    ) public pure {\n        bytes32 computedRoot = _computeRoot(leaf, proof);\n        if (computedRoot != root) {\n            revert InvalidProof();\n        }\n    }\n\n    /**\n     * @dev Compute the merkle root\n     * @param leaf leaf\n     * @param proof proof\n     */\n    function _computeRoot(\n        bytes32 leaf,\n        bytes32[] memory proof\n    ) public pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            computedHash = _hashPair(computedHash, proofElement);\n        }\n        return computedHash;\n    }\n\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    function _efficientHash(\n        bytes32 a,\n        bytes32 b\n    ) private pure returns (bytes32 value) {\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"}},"settings":{"libraries":{},"metadata":{"bytecodeHash":"none"},"optimizer":{"enabled":true,"runs":800},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}}},"ABI":"[{\"inputs\":[],\"name\":\"InvalidProof\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"_computeRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"_verifyProof\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"MerkleVerifier","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":1,"Runs":800,"ConstructorArguments":"0x","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}