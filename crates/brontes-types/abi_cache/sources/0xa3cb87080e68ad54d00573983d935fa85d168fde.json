{"expiry":1699510026,"data":[{"SourceCode":"// SPDX-License-Identifier: AGPL-3.0-only\r\n// v2.0.03200148\r\n\r\n/*\r\n  _____        __ _       _ _         ____  _ _         _\r\n |_   _|      / _(_)     (_) |       |  _ \\(_) |       (_)\r\n   | |  _ __ | |_ _ _ __  _| |_ _   _| |_) |_| |_       _  ___\r\n   | | | '_ \\|  _| | '_ \\| | __| | | |  _ <| | __|     | |/ _ \\\r\n  _| |_| | | | | | | | | | | |_| |_| | |_) | | |_   _  | | (_) |\r\n |_____|_| |_|_| |_|_| |_|_|\\__|\\__, |____/|_|\\__| (_) |_|\\___/\r\n                                 __/ |\r\n                                |___/\r\n  v2\r\n*/\r\n// InfinityBit Token (IBIT) - v2\r\n// https://infinitybit.io\r\n// TG: https://t.me/infinitybit_io\r\n// Twitter: https://twitter.com/infinitybit_io\r\n\r\npragma solidity 0.8.18;\r\n\r\n\r\n// License: MIT\r\n// pragma solidity ^0.8.0;\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n// License: GPL-3.0\r\n// https://github.com/Uniswap\r\n\r\n// pragma solidity ^0.8.0;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\n// License: GPL-3.0\r\n// https://github.com/Uniswap\r\n\r\n// pragma solidity ^0.8.0;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(\r\n        address indexed token0,\r\n        address indexed token1,\r\n        address pair,\r\n        uint256\r\n    );\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB)\r\n    external\r\n    view\r\n    returns (address pair);\r\n\r\n    function allPairs(uint256) external view returns (address pair);\r\n\r\n    function allPairsLength() external view returns (uint256);\r\n\r\n    function createPair(address tokenA, address tokenB)\r\n    external\r\n    returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n\r\n// License: GPL-3.0\r\n// https://github.com/Uniswap\r\n\r\n// pragma solidity >=0.8.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n//\r\n// InfinityBit Token v2\r\n//\r\n// License: AGPL-3.0-only\r\n\r\n// pragma solidity 0.8.18;\r\n\r\ncontract InfinityBitTokenV2 is IERC20, Ownable {\r\n    using Address for address;\r\n\r\n    event TaxesAutoswap(uint256 amount_eth);\r\n\r\n    mapping(address => uint256) private _balances;\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals = 8;\r\n    uint256 private _deployHeight;\r\n    address private _contractDeployer;\r\n\r\n    // flags\r\n    bool private _maxWalletEnabled = true;\r\n    bool public _autoSwapTokens = true;\r\n    bool public _transfersEnabled = false;\r\n    bool public _sellFromTaxWallets = true;\r\n\r\n    // Maximum Supply is 5,700,000,000. This is immutable and cannot be changed.\r\n    uint256 private immutable _maxSupply = 5_700_000_000 * (10 ** uint256(_decimals));\r\n\r\n    // Maximum total tax rate. This is immutable and cannot be changed.\r\n    uint8 private immutable _maxTax = 50; // 5%\r\n    // Maximum wallet. This is immutable and cannot be changed.\r\n    uint256 private immutable _maxWallet = 125000000 * (10 ** uint256(_decimals));\r\n\r\n    // Marketing Tax - has one decimal.\r\n    uint8 private _marketingTax = 30; // 3%\r\n    address payable private _marketingWallet = payable(0xd1CB9007D51FB812805d80618A97418Fd388B0C5);\r\n    address payable immutable private _legacyMarketingWallet = payable(0xA6e18D5F6b20dFA84d7d245bb656561f1f9aff69);\r\n\r\n    // Developer Tax\r\n    uint8 private _devTax = 18; // 1.8%\r\n    address payable private _devWallet = payable(0x02DAb704810C40C87374eBD85927c3D8a9815Eb0);\r\n    address payable immutable private _legacyDevWallet = payable(0x9d0D8E5e651Ab7d54Af5B0F655b3978504E67E0C);\r\n\r\n    // LP Tax\r\n    uint8 private _lpTax = 0; // 0%\r\n\r\n    // Burn Address\r\n    address private immutable _burnAddress = 0x000000000000000000000000000000000000D34d;\r\n\r\n    // Deadline in seconds for UniswapV2 autoswap\r\n    uint8 private _autoSwapDeadlineSeconds = 0;\r\n\r\n    // Taxless Allow-List\r\n    //  This is a list of wallets which are exempt from taxes.\r\n    mapping(address=>bool) TaxlessAllowList;\r\n\r\n    // IgnoreMaxWallet Allow-List\r\n    //  This is a list of wallets which are exempt from the maximum wallet.\r\n    mapping(address=>bool) IgnoreMaxWalletAllowList;\r\n\r\n    // SwapThreshold - Amount that will be autoswapped- has one decimal.\r\n    uint8 public _swapLimit = 25; // 2.5%\r\n    uint8 public immutable _swapLimitMax = 50; // 5% hardcoded max\r\n    uint8 public _swapThreshold = 10; // 1%\r\n    uint8 public immutable _swapThresholdMax = 50; // 5% hardcoded max\r\n\r\n    // Required to recieve ETH from UniswapV2Router on automated token swaps\r\n    receive() external payable {}\r\n\r\n    // Uniswap V2\r\n    IUniswapV2Router02 public _uniswapV2Router;\r\n    address private _uniswapV2RouterAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    address private _uniswapUniversalRouter = 0x4648a43B2C14Da09FdF82B161150d3F634f40491;\r\n    address private _uniswapV2PairAddress;\r\n    IUniswapV2Factory public _uniswapV2Factory;\r\n\r\n    constructor() payable {\r\n        _name = \"InfinityBit Token\";\r\n        _symbol = \"IBIT\";\r\n        _decimals = 8;\r\n\r\n        IUniswapV2Router02 uniswapV2Router = IUniswapV2Router02(_uniswapV2RouterAddress);\r\n        _uniswapV2Router = uniswapV2Router;\r\n\r\n        // Create Uniswap V2 Pair\r\n        _uniswapV2Factory = IUniswapV2Factory(_uniswapV2Router.factory());\r\n        _uniswapV2PairAddress = _uniswapV2Factory.createPair(address(this), _uniswapV2Router.WETH());\r\n        _uniswapV2Router = uniswapV2Router;\r\n\r\n        // Mint Supply\r\n        _mint(msg.sender, _maxSupply);\r\n        _totalSupply = _maxSupply;\r\n\r\n        // IgnoreMaxWallet Allowlist\r\n        IgnoreMaxWalletAllowList[_uniswapUniversalRouter] = true;\r\n        IgnoreMaxWalletAllowList[_uniswapV2RouterAddress] = true;\r\n        IgnoreMaxWalletAllowList[_uniswapV2PairAddress] = true;\r\n        IgnoreMaxWalletAllowList[_marketingWallet] = true;\r\n        IgnoreMaxWalletAllowList[_devWallet] = true;\r\n        IgnoreMaxWalletAllowList[_legacyMarketingWallet] = true;\r\n        IgnoreMaxWalletAllowList[_legacyDevWallet] = true;\r\n        IgnoreMaxWalletAllowList[address(owner())] = true;\r\n\r\n        // Taxless Allowlist\r\n        TaxlessAllowList[_uniswapUniversalRouter] = true;\r\n        TaxlessAllowList[_uniswapV2RouterAddress] = true;\r\n        TaxlessAllowList[_marketingWallet] = true;\r\n        TaxlessAllowList[_devWallet] = true;\r\n        TaxlessAllowList[address(owner())] = true;\r\n    }\r\n\r\n    //\r\n    //\r\n    //\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    function decimals() public view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n    function transfer(address to, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n    function _approve(address from, address spender, uint256 amount) internal virtual {\r\n        require(from != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[from][spender] = amount;\r\n        emit Approval(from, spender, amount);\r\n    }\r\n    function _spendAllowance(address from, address spender, uint256 amount) internal virtual {\r\n        uint256 currentAllowance = allowance(from, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n        unchecked {\r\n            _approve(from, spender, currentAllowance - amount);\r\n        }\r\n        }\r\n    }\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(msg.sender, spender, allowance(msg.sender, spender) + addedValue);\r\n        return true;\r\n    }\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = allowance(msg.sender, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n    unchecked {\r\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\r\n    }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    //\r\n    //\r\n    //\r\n\r\n\r\n    function _mint(address to, uint value) internal {\r\n        _totalSupply = _totalSupply+value;\r\n        _balances[to] = _balances[to] + value;\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    // Once transfers are enabled, they cannot be disabled.\r\n    function enableTransfers() public onlyOwner() {\r\n        _transfersEnabled = true;\r\n    }\r\n\r\n    // Set the Dev Wallet Address\r\n    function setDevWallet(address devWallet) public onlyOwner {\r\n        require(devWallet != address(0), \"IBIT: cannot set to the zero address\");\r\n        _devWallet = payable(devWallet);\r\n    }\r\n\r\n    // Set the Marketing Wallet Address\r\n    function setMarketingWallet(address marketingWallet) public onlyOwner {\r\n        require(marketingWallet != address(0), \"IBIT: cannot set to the zero address\");\r\n        _marketingWallet = payable(marketingWallet);\r\n    }\r\n\r\n    function isSell(address sender, address recipient) private view returns (bool) {\r\n        if(sender == _uniswapV2RouterAddress || sender == _uniswapV2PairAddress || sender == _uniswapUniversalRouter) {\r\n            return false;\r\n        }\r\n\r\n        if(recipient == _uniswapV2PairAddress || recipient == address(_uniswapV2Router)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function isBuy(address sender) private view returns (bool) {\r\n        return sender == _uniswapV2PairAddress || sender == address(_uniswapV2Router);\r\n    }\r\n\r\n    event AutoswapFailed(uint256 amount);\r\n\r\n    function _swapTokensForETH(uint256 amount) private {\r\n        if(amount == 0) {\r\n            return;\r\n        }\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = _uniswapV2Router.WETH();\r\n\r\n        _approve(address(this), address(_uniswapV2Router), amount);\r\n\r\n        try _uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp+_autoSwapDeadlineSeconds\r\n        ) {\r\n\r\n        } catch {\r\n            emit AutoswapFailed(amount);\r\n        }\r\n    }\r\n\r\n    function addLiquidity(uint256 amount_tokens, uint256 amount_eth) private returns (bool) {\r\n        if(amount_tokens == 0 || amount_eth == 0) {\r\n            return true;\r\n        }\r\n\r\n        _approve(address(this), address(_uniswapV2Router), amount_tokens);\r\n        try _uniswapV2Router.addLiquidityETH{value: amount_eth}(\r\n            address(this),\r\n            amount_tokens,\r\n            0,\r\n            0,\r\n            owner(),\r\n            block.timestamp\r\n        ) {\r\n            return true;\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function getDevTax() public view returns (uint8) {\r\n        return _devTax;\r\n    }\r\n\r\n    function toggleAutoSwapTokens(bool enable) public onlyOwner {\r\n        _autoSwapTokens = enable;\r\n    }\r\n\r\n    function getLpTax() public view returns (uint8) {\r\n        return _lpTax;\r\n    }\r\n\r\n    function getMarketingTax() public view returns (uint8) {\r\n        return _marketingTax;\r\n    }\r\n\r\n    function setDevTax(uint8 tax) public onlyOwner {\r\n        require(_lpTax+_marketingTax+tax <= _maxTax, \"IBIT: total tax cannot exceed max tax\");\r\n        _devTax = tax;\r\n    }\r\n\r\n    function setLpTax(uint8 tax) public onlyOwner {\r\n        require((_devTax+_marketingTax+tax) <= _maxTax, \"IBIT: total tax cannot exceed max tax\");\r\n        _lpTax = tax;\r\n    }\r\n\r\n    function setMarketingTax(uint8 tax) public onlyOwner {\r\n        require(_devTax+_lpTax+tax <= _maxTax, \"IBIT: total tax cannot exceed max tax\");\r\n        _marketingTax = tax;\r\n    }\r\n\r\n    function setAutoswapDeadline(uint8 deadline_seconds) public onlyOwner {\r\n        _autoSwapDeadlineSeconds = deadline_seconds;\r\n    }\r\n\r\n    function DetectMaxWalletEnabled() public view returns (bool) {\r\n        return _maxWalletEnabled;\r\n    }\r\n\r\n    function ToggleMaxWallet(bool _enable) public onlyOwner {\r\n        _maxWalletEnabled = _enable;\r\n    }\r\n\r\n    function SetUniswapV2Pair(address _w) public onlyOwner {\r\n        _uniswapV2PairAddress = _w;\r\n    }\r\n\r\n    function GetUniswapV2Pair() public view returns (address) {\r\n        return _uniswapV2PairAddress;\r\n    }\r\n\r\n    // Add a wallet address to the taxless allow-list.\r\n    function SetTaxlessAllowList(address _w) public onlyOwner {\r\n        TaxlessAllowList[_w] = true;\r\n    }\r\n\r\n    // Remove a wallet address from the taxless allow-list.\r\n    function UnsetTaxlessAllowList(address _w) public onlyOwner {\r\n        TaxlessAllowList[_w] = false;\r\n    }\r\n\r\n    // Add a wallet address to the max wallet allow-list.\r\n    function SetMaxWalletAllowList(address _w) public onlyOwner {\r\n        IgnoreMaxWalletAllowList[_w] = true;\r\n    }\r\n\r\n    // Remove a wallet address from the max wallet allow-list.\r\n    function UnsetMaxWalletAllowList(address _w) public onlyOwner {\r\n        IgnoreMaxWalletAllowList[_w] = false;\r\n    }\r\n\r\n    // Returns true if the provided address is tax-exempt, otherwise returns false.\r\n    function isTaxExempt(address from, address to) public view returns(bool) {\r\n        if(TaxlessAllowList[from] || TaxlessAllowList[to])\r\n        {\r\n            return true;\r\n        }\r\n\r\n        if(from == owner() || to == owner())\r\n        {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // Returns true if the provided address is maxWallet-exempt, otherwise returns false.\r\n    function isMaxWalletExempt(address _w) public view returns (bool) {\r\n        if(_w == address(owner()))\r\n        {\r\n            return true;\r\n        }\r\n\r\n        return IgnoreMaxWalletAllowList[_w];\r\n    }\r\n\r\n    // Returns the total tax %\r\n    function totalTax() public view returns (uint8) {\r\n        return _lpTax+_devTax+_marketingTax;\r\n    }\r\n\r\n    // Sends Ether to specified 'to' address\r\n    function sendEther(address payable to, uint256 amount) private returns (bool) {\r\n        return to.send(amount);\r\n    }\r\n\r\n    // Returns the amount of IBIT tokens in the Liquidity Pool\r\n    function getLiquidityIBIT() public view returns (uint256) {\r\n        return _balances[_uniswapV2PairAddress];\r\n    }\r\n\r\n    // Limit the maximum autoswap based on _swapLimit percent\r\n    function getMaxAutoswap() public view returns (uint256 max_autoswap_limit) {\r\n        return (_swapLimit * getLiquidityIBIT()) / 1000;\r\n    }\r\n\r\n    // Returns the autoswap limit (ie, the maximum which will be autoswapped) as a percent with one decimal, i.e. 50 = 5%\r\n    function getAutoswapLimit() public view returns (uint8 autoswap_limit_percent) {\r\n        return _swapLimit;\r\n    }\r\n\r\n    function setAutoswapLimit(uint8 swapLimit) public onlyOwner {\r\n        require(swapLimit < _swapLimitMax, \"IBIT: swapLimit exceeds max\");\r\n        _swapLimit = swapLimit;\r\n    }\r\n\r\n    // Returns the autoswap threshold,  the minimum tokens which must be\r\n    // reached before an autoswap will occur. expressed as a percent with one decimal, i.e. 50 = 5%\r\n    function getAutoswapThreshold() public view returns (uint8 autoswap_threshold_percent) {\r\n        return _swapThreshold;\r\n    }\r\n\r\n    function setAutoswapThreshold(uint8 swapThreshold) public onlyOwner {\r\n        require(_swapThreshold < _swapThresholdMax, \"IBIT: swapThreshold exceeds max\");\r\n        _swapThreshold = swapThreshold;\r\n    }\r\n\r\n    event AutoLiquidityFailed(uint256 token_amount, uint256 eth_amount, uint256 tokens_collected, uint256 tokens_swapped, uint256 eth_collected);\r\n    event AutoLiquiditySuccess(uint256 token_amount, uint256 eth_amount, uint256 tokens_collected, uint256 tokens_swapped, uint256 eth_collected);\r\n    event DeductTaxes(uint256 dev_tax_amount, uint256 marketing_tax_amount, uint256 lp_tax_amount);\r\n\r\n    // Returns the maximum amount which can be autoswapped if everything is sold\r\n    function autoswapTotalTokensAvailable(uint256 amount) public view returns (uint256) {\r\n        return _calcLpTaxAmount(amount)/2 + _calcDevTaxAmount(amount) + _calcMarketingTaxAmount(amount) + _balances[_devWallet] + _balances[_marketingWallet];\r\n    }\r\n\r\n    function calcAutoswapAmount(uint256 sell_amount) public view returns (uint256) {\r\n        uint256 lp_tokens = _calcLpTaxAmount(sell_amount)/2;\r\n        return lp_tokens + _calcDevTaxAmount(sell_amount) + _calcMarketingTaxAmount(sell_amount);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 amount) private {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(_balances[from] >= amount, \"ERC20: transfer amount exceeds balance\");\r\n\r\n        if(!_transfersEnabled) {\r\n            require(from == owner() || to == owner(), \"IBIT: transfers disabled until initial LP\");\r\n        }\r\n\r\n        uint256 tax_amount;\r\n\r\n        // Begin Tax Check\r\n        if(isTaxExempt(from, to))\r\n        {\r\n            tax_amount = 0;\r\n        }\r\n        else\r\n        {\r\n            tax_amount = _calcTaxes(amount);\r\n        }\r\n\r\n        uint256 transfer_amount = amount - tax_amount;\r\n\r\n        // Begin Max Wallet Check, owner always ignores max wallet check.\r\n        if(!isMaxWalletExempt(to) && from != owner() && _maxWalletEnabled)\r\n        {\r\n            require((balanceOf(to) + transfer_amount) <= _maxWallet, \"IBIT: maximum wallet cannot be exceeded\");\r\n        }\r\n\r\n        if(tax_amount == 0)\r\n        {\r\n            _taxlessTransfer(from, to, amount);\r\n            return;\r\n        }\r\n\r\n        // Take taxes\r\n        _takeTaxes(from, tax_amount);\r\n        emit DeductTaxes(_calcDevTaxAmount(amount), _calcMarketingTaxAmount(amount), _calcLpTaxAmount(amount));\r\n\r\n        if(autoSwapConditionCheck(from, to, amount))\r\n        {\r\n            _autoSwapTaxForEth(from, to, amount);\r\n        }\r\n        else\r\n        {\r\n            // Distribute Taxes (Tokens)\r\n            _balances[_devWallet] += _calcDevTaxAmount(amount);\r\n            _balances[_marketingWallet] += _calcMarketingTaxAmount(amount);\r\n            _balances[address(this)] += _calcLpTaxAmount(amount);\r\n        }\r\n\r\n        // Emit\r\n        _taxlessTransfer(from, to, transfer_amount);\r\n    }\r\n\r\n    function _autoSwapTaxForEth(address from, address to, uint256 amount) private {\r\n        uint256 autoswap_amount = calcAutoswapAmount(amount);\r\n\r\n        if(autoswap_amount == 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        uint256 max_autoswap = getMaxAutoswap();\r\n\r\n        if(autoswap_amount < max_autoswap)\r\n        {\r\n            // Take tokens from marketing and dev wallets\r\n            uint256 max_extra_autoswap = max_autoswap-autoswap_amount;\r\n            autoswap_amount += _takeTokensFromMarketingAndDevWallets(max_extra_autoswap);\r\n        }\r\n        else if(autoswap_amount > max_autoswap)\r\n        {\r\n            autoswap_amount = max_autoswap;\r\n        }\r\n\r\n        // Execute autoswap\r\n        uint256 startingBalance = address(this).balance;\r\n        _swapTokensForETH(autoswap_amount);\r\n        uint256 ethCollected = address(this).balance - startingBalance;\r\n        emit TaxesAutoswap(ethCollected);\r\n\r\n        // Auto Liquidity (LP Tax)\r\n        if(_lpTax > 0 && !isTaxExempt(from, to))\r\n        {\r\n            uint256 tax_amount = _calcTaxes(amount);\r\n            uint256 lp_tokens = _calcLpTaxAmount(amount)/2;\r\n            if(to == _uniswapV2PairAddress && from != _uniswapV2RouterAddress && from != _uniswapUniversalRouter)\r\n            {\r\n                uint256 lp_tax_eth = _calcTaxDistribution(ethCollected, _lpTax);\r\n                if(!addLiquidity(lp_tokens, lp_tax_eth)) {\r\n                    emit AutoLiquidityFailed(lp_tokens, lp_tax_eth, tax_amount, autoswap_amount, ethCollected);\r\n                } else {\r\n                    emit AutoLiquiditySuccess(lp_tokens, lp_tax_eth, tax_amount, autoswap_amount, ethCollected);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Distribute Taxes (ETH)\r\n        uint256 marketing_tax_eth = _calcTaxDistribution(ethCollected, _marketingTax);\r\n        uint256 dev_tax_eth = _calcTaxDistribution(ethCollected, _devTax);\r\n\r\n        if(marketing_tax_eth > 0) {\r\n            sendEther(_marketingWallet, marketing_tax_eth);\r\n        }\r\n\r\n        if(dev_tax_eth > 0) {\r\n            sendEther(_devWallet, dev_tax_eth);\r\n        }\r\n    }\r\n\r\n    // Returns true if the conditions are met for an autoswap, otherwise returns false.\r\n    function autoSwapConditionCheck(address from, address to, uint256 amount) public view returns (bool) {\r\n        if(!_autoSwapTokens) {\r\n            return false;\r\n        }\r\n\r\n        if(!isSell(from, to)) {\r\n            return false;\r\n        }\r\n\r\n        if(_swapThreshold == 0) {\r\n            return true;\r\n        }\r\n\r\n        uint256 swapThresholdAmountTokens = (getLiquidityIBIT() * _swapThreshold)/1000;\r\n        if(autoswapTotalTokensAvailable(amount) >= swapThresholdAmountTokens) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function toggleSellFromTaxWallets(bool enable) public onlyOwner {\r\n        _sellFromTaxWallets = enable;\r\n    }\r\n\r\n    function takeTokensFromTaxWallets(uint256 max_amount) public onlyOwner returns (uint256 amount_taken) {\r\n        return _takeTokensFromMarketingAndDevWallets(max_amount);\r\n    }\r\n\r\n    // Try to take max_extra_autoswap from marketing and dev wallets\r\n    function _takeTokensFromMarketingAndDevWallets(uint256 max_extra_autoswap) private returns (uint256 amount_taken) {\r\n        if(_sellFromTaxWallets == false) {\r\n            return 0;\r\n        }\r\n\r\n        // Don't take tokens unless there are at least 100K\r\n        if(_balances[_marketingWallet] + _balances[_devWallet] < 10000000000000)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        uint256 extra_amount_taken = 0;\r\n\r\n        if(_balances[_marketingWallet] >= max_extra_autoswap)\r\n        {\r\n            unchecked {\r\n                _balances[_marketingWallet] -= max_extra_autoswap;\r\n                _balances[address(this)] += max_extra_autoswap;\r\n            }\r\n            return max_extra_autoswap;\r\n        }\r\n\r\n        if(_balances[_devWallet] >= max_extra_autoswap)\r\n        {\r\n            unchecked {\r\n                _balances[_devWallet] -= max_extra_autoswap;\r\n                _balances[address(this)] += max_extra_autoswap;\r\n            }\r\n            return max_extra_autoswap;\r\n        }\r\n\r\n        extra_amount_taken = _balances[_devWallet];\r\n\r\n        unchecked {\r\n            _balances[_devWallet] = 0;\r\n            _balances[address(this)] += extra_amount_taken;\r\n        }\r\n\r\n        if(extra_amount_taken >= max_extra_autoswap)\r\n        {\r\n            return max_extra_autoswap;\r\n        }\r\n\r\n        uint256 mwBalance;\r\n        if(extra_amount_taken + _balances[_marketingWallet] <= max_extra_autoswap)\r\n        {\r\n            mwBalance = _balances[_marketingWallet];\r\n\r\n            unchecked {\r\n                _balances[address(this)] += mwBalance;\r\n                _balances[_marketingWallet] = 0;\r\n            }\r\n            return extra_amount_taken + mwBalance;\r\n        }\r\n\r\n        uint256 left_to_take = max_extra_autoswap - amount_taken;\r\n        if(_balances[_marketingWallet] >= left_to_take)\r\n        {\r\n            unchecked {\r\n                _balances[_marketingWallet] -= left_to_take;\r\n                _balances[address(this)] += left_to_take;\r\n            }\r\n            return max_extra_autoswap;\r\n        }\r\n\r\n        mwBalance = _balances[_marketingWallet];\r\n        unchecked {\r\n            _balances[_marketingWallet] = 0;\r\n            _balances[address(this)] += mwBalance;\r\n        }\r\n        return extra_amount_taken + mwBalance;\r\n    }\r\n\r\n    function _calcTaxDistribution(uint256 eth_collected, uint256 tax_rate) private view returns(uint256 distribution_eth)\r\n    {\r\n        // Equivilent to (eth_collected * (tax_rate/totalTax))\r\n        return (eth_collected * tax_rate) / totalTax();\r\n    }\r\n\r\n    function _calcLpTaxAmount(uint256 amount) private view returns(uint256 tax)\r\n    {\r\n        return (amount * _lpTax) / 1000;\r\n    }\r\n    function _calcDevTaxAmount(uint256 amount) private view returns(uint256 tax)\r\n    {\r\n        return (amount * _devTax) / 1000;\r\n    }\r\n    function _calcMarketingTaxAmount(uint256 amount) private view returns(uint256 tax)\r\n    {\r\n        return (amount * _marketingTax) / 1000;\r\n    }\r\n\r\n    // Given an amount, calculate the taxes which would be collected. Excludes LP tax.\r\n    function _calcTaxes(uint256 amount) public view returns (uint256 tax_to_collect) {\r\n        return _calcDevTaxAmount(amount) + _calcMarketingTaxAmount(amount) + _calcLpTaxAmount(amount);\r\n    }\r\n\r\n    // Taxes taxes as specified by 'tax_amount'\r\n    function _takeTaxes(address from, uint256 tax_amount) private {\r\n        if(tax_amount == 0 || totalTax() == 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        // Remove tokens from sender\r\n    unchecked {\r\n        _balances[from] -= tax_amount;\r\n    }\r\n\r\n        // Collect taxes\r\n    unchecked {\r\n        _balances[address(this)] += tax_amount;\r\n    }\r\n    }\r\n\r\n    function _taxlessTransfer(address from, address to, uint256 amount) private {\r\n    unchecked {\r\n        _balances[from] -= amount;\r\n        _balances[to] += amount;\r\n    }\r\n        emit Transfer(from, to, amount);\r\n    }\r\n\r\n    // Migrate from Legacy\r\n    address[] _legacyHolders;\r\n    mapping(address=>uint256) _legacyHoldersBalances;\r\n\r\n    bool _holdersAirdropped = false;\r\n\r\n    function setLegacyHolder(address _w, uint256 balance) private {\r\n        if(_legacyHoldersBalances[_w] != 0) {\r\n            return; // duplicate\r\n        }\r\n\r\n        if(balance == 0) {\r\n            return;\r\n        }\r\n\r\n        _legacyHolders.push(_w);\r\n        _legacyHoldersBalances[_w] = balance;\r\n    }\r\n\r\n    // Airdrop Legacy Holders\r\n    function initialAirdrop() public onlyOwner {\r\n        require(_holdersAirdropped == false, \"IBIT: Holders can only be airdropped once\");\r\n        _holdersAirdropped = true;\r\n\r\n        setLegacyBalancesFromSnapshot();\r\n\r\n        for(uint i = 0; i < _legacyHolders.length; i++) {\r\n            address to = _legacyHolders[i];\r\n            uint256 balance = _legacyHoldersBalances[to];\r\n\r\n            _taxlessTransfer(owner(), to, balance);\r\n        }\r\n    }\r\n\r\n    function setLegacyBalancesFromSnapshot() private {\r\n\r\n        // NULS Partnership\r\n        // 0x649Fd8b99b1d61d8FE7A9C7eec86dcfF829633F0, 14210000100000000); // 142,100,001 IBIT\r\n        _taxlessTransfer(owner(), _legacyMarketingWallet, 14210000100000000);\r\n\r\n        // These wallets completed migration from legacy\r\n        setLegacyHolder(0x89Abd93CaBa3657919674a663D55E1C185A4CA25, 5000000000000000); // 50,000,000 IBIT\r\n        setLegacyHolder(0x2e9EdC685510F3B6B92B5aA8B14E66a18707F5aB, 5000000000000000); // 50,000,000 IBIT\r\n        setLegacyHolder(0xDB1C0B51328D40c11ebE5C9C7098477B88551e8d, 2500000000000000); // 25,000,000 IBIT\r\n        setLegacyHolder(0x52747Fd7866eF249b015bB99E95a3169B9eC4497, 10490511753749771); // 104,905,118 IBIT\r\n        setLegacyHolder(0xb2C91Cf2Fd763F2cC4558ed3cEDE401Fc1d1B675, 4000000000000000); // 40,000,000 IBIT\r\n        setLegacyHolder(0x2E64b76130819f30bE2df0A0740D990d706B9926, 9317247665468201); // 93,172,477 IBIT\r\n        setLegacyHolder(0x1E69003E5267E945962ae38578a76222CA408584, 5000000000000000); // 50,000,000 IBIT\r\n        setLegacyHolder(0x16F39f8ff59caead81bC680e6cd663069Eb978BE, 10100000000000000); // 101,000,000 IBIT\r\n        setLegacyHolder(0x6d102206CB3F043E22A62B4b7ecC83b877f85d9A, 5001685678902763); // 50,016,857 IBIT\r\n        setLegacyHolder(0xEC61A284Df18c4937B50880F70EB181d38fe86Bb, 1660752476400742); // 16,607,525 IBIT\r\n        setLegacyHolder(0x4C999827Bc4b51fbd6911f066d8b82baaC286a9b, 3500000000000000); // 35,000,000 IBIT\r\n        setLegacyHolder(0x5415672D7334F8d2798022242675829B16bf94db, 1441870099079523); // 14,418,701 IBIT\r\n        setLegacyHolder(0xdF10d9688528b5b60957D1727a70A30450cE9604, 5000000000000000); // 50,000,000 IBIT\r\n        setLegacyHolder(0x831114051c0edDe239ae672EdcC4c63371deC82b, 3869772286660397); // 38,697,723 IBIT\r\n        setLegacyHolder(0x1d9c8Ae02d75db48dF0d13424cF7fb188dfa4B6E, 2112190583266945); // 21,121,906 IBIT\r\n        setLegacyHolder(0x6e7182cFe90cC9AaD11f7082cC4c462dbFD2D73C, 1083000000000000); // 10,830,000 IBIT\r\n        setLegacyHolder(0x287044c98a99F08764d681eD898aECb68A5543BC, 2320032256026266); // 23,200,323 IBIT\r\n        setLegacyHolder(0x5159cD8087B040E3E5F95e1489ce1018E186795C, 2250000000000000); // 22,500,000 IBIT\r\n        setLegacyHolder(0x5eD277Af83D32fa421091244Fa802e90FE8e896d, 5464909136753054); // 54,649,091 IBIT\r\n        setLegacyHolder(0x7aBc57C6f67853D16a4400685d18eE53980A3F4F, 7697889041792168); // 76,978,890 IBIT\r\n        setLegacyHolder(0x09b3a9Ea542713dcC182728F9DebBdfCB1a0112F, 5000000000000000); // 50,000,000 IBIT\r\n        setLegacyHolder(0xF3598aD305Bbd8b40A480947e00a5dc3E29dC5a5, 4875000000000000); // 48,750,000 IBIT\r\n        setLegacyHolder(0x2Aeda0568E111Da6A465bb735D912899A15015c2, 10782747817992883); // 107,827,478 IBIT\r\n        setLegacyHolder(0xb578B5157Bcc9Fd2e73AcACf7E853FD9F861F55d, 2000000000000000); // 20,000,000 IBIT\r\n        setLegacyHolder(0x16C73eaFAA9c6f915d9026D3C2d1b6E9407d2F73, 5159396904718724); // 51,593,969 IBIT\r\n        setLegacyHolder(0x3140dD4B65C557Fda703B081C475CE4945EaaCa3, 5000000000000000); // 50,000,000 IBIT\r\n        setLegacyHolder(0xe632450E74165110459fEf989bc11E90Ee9029D1, 9350739929318052); // 93,507,399 IBIT\r\n        setLegacyHolder(0xF6E82162D8938D91b44EFd4C307DBa91EcBD6950, 2907543953360030); // 29,075,440 IBIT\r\n        setLegacyHolder(0x33AF2064Be09C34302C4cA8B8529A0E659243016, 660000000000000); // 6,600,000 IBIT\r\n        setLegacyHolder(0xAA9d9D742b5c915D65649C636fb2D485911ece4D, 1318142836424375); // 13,181,428 IBIT\r\n        setLegacyHolder(0x5507F5a1076742e3299cE8199fEEd98079ECeE34, 2500000000000000); // 25,000,000 IBIT\r\n        setLegacyHolder(0x5e75d35893200849889DD98a50fce78E3D5641F3, 3263084246964091); // 32,630,842 IBIT\r\n        setLegacyHolder(0x0665d03bDDFd7bA36b1bDC7aDdB26C48273111c8, 500000000000000); // 5,000,000 IBIT\r\n        setLegacyHolder(0x8A541f614A14B00366d92dCe6e927bF550f1c897, 5000000000000000); // 50,000,000 IBIT\r\n        setLegacyHolder(0xC8aFB078896B5780bD7b7174429AF2DAff61199b, 6139352996536699); // 61,393,530 IBIT\r\n        setLegacyHolder(0xffa25D69EF4909454825904904A2D876eA43E437, 2968750000000000); // 29,687,500 IBIT\r\n        setLegacyHolder(0xCd0951939b77e22e497895820Ea7BD3AeF480E1C, 121526011734471); // 1,215,260 IBIT\r\n        setLegacyHolder(0x1ca92Baf56A806527952Ebe610d06A66B54Bf5f1, 800000000000000); // 8,000,000 IBIT\r\n        setLegacyHolder(0xa51670db54Edf9Dd5D5E3570f619FF46535E3679, 9500000000000); // 95,000 IBIT\r\n        setLegacyHolder(0xdd30235DC68011F4de01A5c4059fC20145D5c874, 2509039665732949); // 25,090,397 IBIT\r\n        setLegacyHolder(0x9161c6B026e65Ba6B583fE8F552FA26b6D39eA89, 1425000000000000); // 14,250,000 IBIT\r\n        setLegacyHolder(0xDa85C4A66eBea97aa48a6e1741EC0E639fFe1783, 3138834219770145); // 31,388,342 IBIT\r\n        setLegacyHolder(0xCEe85e997E80B724c69a1474a9489dBFA4cF5d2C, 484424921158839); // 4,844,249 IBIT\r\n        setLegacyHolder(0x79D6F80D880f1bc1671b6fe3f88977D09eAe4DAA, 1814845856095380); // 18,148,459 IBIT\r\n        setLegacyHolder(0x6D9e1352e1F8f66F96669CC28FDCfE8e7FCF5524, 3200000000000000); // 32,000,000 IBIT\r\n        setLegacyHolder(0xA6e18D5F6b20dFA84d7d245bb656561f1f9aff69, 11246699192462885); // 112,466,992 IBIT\r\n        setLegacyHolder(0x9d0D8E5e651Ab7d54Af5B0F655b3978504E67E0C, 11031132794975236); // 110,311,328 IBIT\r\n        setLegacyHolder(0x141278EF1F894a60cBC8637871E4d19c3f2a7336, 5000000000000000); // 50,000,000 IBIT\r\n        setLegacyHolder(0x8AefCE4e323DbB2eCD5818869acF90e5415559C5, 5000000000000000); // 50,000,000 IBIT\r\n        setLegacyHolder(0x5ea0c07ADa402b67F1a9467d008EC11eD9Ca1127, 5000000000000000); // 50,000,000 IBIT\r\n        setLegacyHolder(0x2B09aCED766f8290de1F5E4E0d3B3B8915C49189, 5000000000000000); // 50,000,000 IBIT\r\n        setLegacyHolder(0xFb1BAD0Dc29a9a485F08F4FE6bFBFEdeba10ad8d, 12125000000000000); // 121,250,000 IBIT\r\n        setLegacyHolder(0x56be74F547b1c3b01E97f87461E2f3C75902374A, 1124603943161942); // 11,246,039 IBIT\r\n        setLegacyHolder(0x4A9381E176D676A07DD17A83d8BFd1287b342c77, 4810000000000000); // 48,100,000 IBIT\r\n        setLegacyHolder(0xFCe082295b4db70097c4135Ca254B13B070800E7, 10000000000000000); // 100,000,000 IBIT\r\n        setLegacyHolder(0x7ea69F87f9836FFc6797B6B2D045c11e0881b740, 5000000000000000); // 50,000,000 IBIT\r\n        setLegacyHolder(0x1cC4A2522c3847687aF45AcdA2b5d6EbB64490A9, 402527671912807); // 4,025,277 IBIT\r\n        setLegacyHolder(0x89E364598BDa1f96B6618EBE5D9879F070066358, 4750000000000000); // 47,500,000 IBIT\r\n\r\n        // These wallets did not migrate. 50% penalty as decided by the community.\r\n        setLegacyHolder(0x7FF0373F706E07eE326d538f6a6B2Cf8F7397e77, uint256(uint256(1250924993795650) / 2));\r\n        setLegacyHolder(0x5F7425396747897F91b68149915826aFc2C14c16, uint256(uint256(1097767093335720) / 2));\r\n        setLegacyHolder(0xa9b809Cfe8d95EdbDD61603Ba40081Ba6da4F24b, uint256(uint256(711944117144372) / 2));\r\n        setLegacyHolder(0x817271eA29E0297D26e87c0fCae5d7086c06ae94, uint256(uint256(263389054436059) / 2));\r\n        setLegacyHolder(0x15Cd32F5e9C286FaD0c6E6F40D1fc07c2c1a8584, uint256(uint256(130033069564332) / 2));\r\n        setLegacyHolder(0x90a71A274Cf69c0AD430481241206cd8fec7a1ED, uint256(uint256(117107416670239) / 2));\r\n        setLegacyHolder(0xC5DcAdf158Dc6DE2D6Bc1dDBB40Fb03572000D32, uint256(uint256(45488054291697) / 2));\r\n    }\r\n}","ABI":"[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"token_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eth_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens_collected\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens_swapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eth_collected\",\"type\":\"uint256\"}],\"name\":\"AutoLiquidityFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"token_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eth_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens_collected\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokens_swapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eth_collected\",\"type\":\"uint256\"}],\"name\":\"AutoLiquiditySuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AutoswapFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dev_tax_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"marketing_tax_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lp_tax_amount\",\"type\":\"uint256\"}],\"name\":\"DeductTaxes\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount_eth\",\"type\":\"uint256\"}],\"name\":\"TaxesAutoswap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DetectMaxWalletEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GetUniswapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_w\",\"type\":\"address\"}],\"name\":\"SetMaxWalletAllowList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_w\",\"type\":\"address\"}],\"name\":\"SetTaxlessAllowList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_w\",\"type\":\"address\"}],\"name\":\"SetUniswapV2Pair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"ToggleMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_w\",\"type\":\"address\"}],\"name\":\"UnsetMaxWalletAllowList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_w\",\"type\":\"address\"}],\"name\":\"UnsetTaxlessAllowList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_autoSwapTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"_calcTaxes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tax_to_collect\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_sellFromTaxWallets\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapLimit\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapLimitMax\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapThreshold\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_swapThresholdMax\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_transfersEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_uniswapV2Factory\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Factory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"autoSwapConditionCheck\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"autoswapTotalTokensAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sell_amount\",\"type\":\"uint256\"}],\"name\":\"calcAutoswapAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableTransfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAutoswapLimit\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"autoswap_limit_percent\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAutoswapThreshold\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"autoswap_threshold_percent\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDevTax\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLiquidityIBIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLpTax\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMarketingTax\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxAutoswap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"max_autoswap_limit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialAirdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_w\",\"type\":\"address\"}],\"name\":\"isMaxWalletExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"isTaxExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"deadline_seconds\",\"type\":\"uint8\"}],\"name\":\"setAutoswapDeadline\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"swapLimit\",\"type\":\"uint8\"}],\"name\":\"setAutoswapLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"swapThreshold\",\"type\":\"uint8\"}],\"name\":\"setAutoswapThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tax\",\"type\":\"uint8\"}],\"name\":\"setDevTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"devWallet\",\"type\":\"address\"}],\"name\":\"setDevWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tax\",\"type\":\"uint8\"}],\"name\":\"setLpTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tax\",\"type\":\"uint8\"}],\"name\":\"setMarketingTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketingWallet\",\"type\":\"address\"}],\"name\":\"setMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"max_amount\",\"type\":\"uint256\"}],\"name\":\"takeTokensFromTaxWallets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_taken\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"toggleAutoSwapTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enable\",\"type\":\"bool\"}],\"name\":\"toggleSellFromTaxWallets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTax\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"InfinityBitTokenV2","CompilerVersion":"v0.8.18+commit.87f61d96","OptimizationUsed":0,"Runs":200,"ConstructorArguments":"0x","EVMVersion":"Default","Library":"","LicenseType":"GNU AGPLv3","Proxy":0,"SwarmSource":"ipfs://dacac630edb96b2f23823c50b32e8a3e618537b3ca279da728d1666d693bfd9c"}]}