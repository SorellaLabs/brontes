{"expiry":1699510022,"data":[{"SourceCode":{"language":"Solidity","sources":{"@mimic-fi/v2-price-oracle/contracts/feeds/IPriceFeedProvider.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\n/**\n * @title IPriceFeedProvider\n * @dev Contract providing price feed references for (base, quote) token pairs\n */\ninterface IPriceFeedProvider {\n    /**\n     * @dev Emitted every time a price feed is set for (base, quote) pair\n     */\n    event PriceFeedSet(address indexed base, address indexed quote, address feed);\n\n    /**\n     * @dev Tells the price feed address for (base, quote) pair. It returns the zero address if there is no one set.\n     * @param base Token to be rated\n     * @param quote Token used for the price rate\n     */\n    function getPriceFeed(address base, address quote) external view returns (address);\n\n    /**\n     * @dev Sets a of price feed\n     * @param base Token base to be set\n     * @param quote Token quote to be set\n     * @param feed Price feed to be set\n     */\n    function setPriceFeed(address base, address quote, address feed) external;\n\n    /**\n     * @dev Sets a list of price feeds\n     * @param bases List of token bases to be set\n     * @param quotes List of token quotes to be set\n     * @param feeds List of price feeds to be set\n     */\n    function setPriceFeeds(address[] memory bases, address[] memory quotes, address[] memory feeds) external;\n}\n"},"contracts/test/samples/BridgeMock.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\ncontract BridgeMock {\n    function bridge(address token, uint256 amount, uint256, address, bytes memory) external {\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n    }\n}\n"},"@mimic-fi/v2-helpers/contracts/utils/Denominations.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\n/**\n * @title Denominations\n * @dev Provides a list of ground denominations for those tokens that cannot be represented by an ERC20.\n * For now, the only needed is the native token that could be ETH, MATIC, or other depending on the layer being operated.\n */\nlibrary Denominations {\n    address internal constant NATIVE_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    function isNativeToken(address token) internal pure returns (bool) {\n        return token == NATIVE_TOKEN;\n    }\n}\n"},"@mimic-fi/v2-helpers/contracts/utils/IWrappedNativeToken.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\n/**\n * @title IWrappedNativeToken\n */\ninterface IWrappedNativeToken is IERC20 {\n    /**\n     * @dev Wraps msg.value into the wrapped-native token\n     */\n    function deposit() external payable;\n\n    /**\n     * @dev Unwraps requested amount to the native token\n     */\n    function withdraw(uint256 amount) external;\n}\n"},"@mimic-fi/v2-registry/contracts/registry/IRegistry.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\nimport '@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol';\n\n/**\n * @title IRegistry\n * @dev Registry interface, it must follow the IAuthorizer interface.\n */\ninterface IRegistry is IAuthorizer {\n    /**\n     * @dev Emitted every time a new implementation is registered\n     */\n    event Registered(bytes32 indexed namespace, address indexed implementation, bool stateless);\n\n    /**\n     * @dev Emitted every time an implementation is deprecated\n     */\n    event Deprecated(bytes32 indexed namespace, address indexed implementation);\n\n    /**\n     * @dev Tells the data of an implementation:\n     * @param implementation Address of the implementation to request it's data\n     */\n    function implementationData(address implementation)\n        external\n        view\n        returns (bool stateless, bool deprecated, bytes32 namespace);\n\n    /**\n     * @dev Tells if a specific implementation is registered under a certain namespace and it's not deprecated\n     * @param namespace Namespace asking for\n     * @param implementation Address of the implementation to be checked\n     */\n    function isActive(bytes32 namespace, address implementation) external view returns (bool);\n\n    /**\n     * @dev Registers a new implementation for a given namespace\n     * @param namespace Namespace to be used for the implementation\n     * @param implementation Address of the implementation to be registered\n     * @param stateless Whether the implementation is stateless or not\n     */\n    function register(bytes32 namespace, address implementation, bool stateless) external;\n\n    /**\n     * @dev Deprecates a registered implementation\n     * @param implementation Address of the implementation to be deprecated\n     */\n    function deprecate(address implementation) external;\n}\n"},"@openzeppelin/contracts/utils/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"@mimic-fi/v2-price-oracle/contracts/oracle/IPriceOracle.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\n\n/**\n * @title IPriceOracle\n * @dev Oracle that interfaces with external feeds to provide quotes for tokens based on any other token.\n * It must support also `IImplementation`.\n */\ninterface IPriceOracle is IImplementation {\n    /**\n     * @dev Tells the price of a token (base) in a given quote. The response is expressed using the corresponding\n     * number of decimals so that when performing a fixed point product of it by a `base` amount it results in\n     * a value expressed in `quote` decimals. For example, if `base` is ETH and `quote` is USDC, then the returned\n     * value is expected to be expressed using 6 decimals:\n     *\n     * FixedPoint.mul(X[ETH], price[USDC/ETH]) = FixedPoint.mul(X[18], price[6]) = X * price [6]\n     *\n     * @param provider Contract providing the price feeds to use by the oracle\n     * @param base Token to rate\n     * @param quote Token used for the price rate\n     */\n    function getPrice(address provider, address base, address quote) external view returns (uint256);\n}\n"},"@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\n// solhint-disable func-name-mixedcase\n\n/**\n * @title IImplementation\n * @dev Implementation interface that must be followed for implementations to be registered in the Mimic Registry\n */\ninterface IImplementation {\n    /**\n     * @dev Tells the namespace under which the implementation is registered in the Mimic Registry\n     */\n    function NAMESPACE() external view returns (bytes32);\n\n    /**\n     * @dev Tells the address of the Mimic Registry\n     */\n    function registry() external view returns (address);\n}\n"},"@mimic-fi/v2-registry/contracts/implementations/InitializableAuthorizedImplementation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@mimic-fi/v2-helpers/contracts/auth/Authorizer.sol';\n\nimport './InitializableImplementation.sol';\n\n/**\n * @title InitializableAuthorizedImplementation\n * @dev InitializableImplementation using the Authorizer mixin. Initializable implementations that want to use the\n * Authorizer permissions mechanism should inherit from this contract instead.\n */\nabstract contract InitializableAuthorizedImplementation is InitializableImplementation, Authorizer {\n    /**\n     * @dev Creates a new InitializableAuthorizedImplementation\n     * @param registry Address of the Mimic Registry\n     */\n    constructor(address registry) InitializableImplementation(registry) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Initialization function that authorizes an admin account to authorize and unauthorize accounts.\n     * Note this function can only be called from a function marked with the `initializer` modifier.\n     * @param admin Address to be granted authorize and unauthorize permissions\n     */\n    function _initialize(address admin) internal onlyInitializing {\n        _initialize();\n        _authorize(admin, Authorizer.authorize.selector);\n        _authorize(admin, Authorizer.unauthorize.selector);\n    }\n}\n"},"contracts/helpers/SwapConnectorLib.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/utils/Address.sol';\n\nimport '@mimic-fi/v2-swap-connector/contracts/ISwapConnector.sol';\n\n/**\n * @title SwapConnectorLib\n * @dev Library used to delegate-call swaps and decode return data correctly\n */\nlibrary SwapConnectorLib {\n    /**\n     * @dev Delegate-calls a swap to the swap connector and decodes de expected data\n     * IMPORTANT! This helper method does not check any of the given params, these should be checked beforehand.\n     */\n    function swap(\n        address connector,\n        uint8 source,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        bytes memory data\n    ) internal returns (uint256 amountOut) {\n        bytes memory swapData = abi.encodeWithSelector(\n            ISwapConnector.swap.selector,\n            source,\n            tokenIn,\n            tokenOut,\n            amountIn,\n            minAmountOut,\n            data\n        );\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = connector.delegatecall(swapData);\n        Address.verifyCallResult(success, returndata, 'SWAP_CALL_REVERTED');\n        return abi.decode(returndata, (uint256));\n    }\n}\n"},"contracts/test/core/StrategyMock.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\nimport '@mimic-fi/v2-strategies/contracts/IStrategy.sol';\nimport '@mimic-fi/v2-registry/contracts/implementations/BaseImplementation.sol';\n\nimport '../samples/TokenMock.sol';\n\ncontract StrategyMock is IStrategy, BaseImplementation {\n    using FixedPoint for uint256;\n\n    bytes32 public constant override NAMESPACE = keccak256('STRATEGY');\n\n    address public immutable lpt;\n    address public immutable token;\n    address public immutable rewardToken;\n\n    event Claimed(bytes data);\n    event Joined(address[] tokensIn, uint256[] amountsIn, uint256 slippage, bytes data);\n    event Exited(address[] tokensIn, uint256[] amountsIn, uint256 slippage, bytes data);\n\n    constructor(address registry) BaseImplementation(registry) {\n        lpt = address(new TokenMock('LPT'));\n        token = address(new TokenMock('TKN'));\n        rewardToken = address(new TokenMock('REW'));\n    }\n\n    function mockGains(address account, uint256 multiplier) external {\n        uint256 balance = IERC20(lpt).balanceOf(account);\n        TokenMock(lpt).mint(account, balance * (multiplier - 1));\n    }\n\n    function mockLosses(address account, uint256 divisor) external {\n        uint256 balance = IERC20(lpt).balanceOf(account);\n        TokenMock(lpt).burn(account, balance / divisor);\n    }\n\n    function joinTokens() public view override returns (address[] memory tokens) {\n        tokens = new address[](1);\n        tokens[0] = token;\n    }\n\n    function exitTokens() public view override returns (address[] memory tokens) {\n        tokens = new address[](1);\n        tokens[0] = lpt;\n    }\n\n    function valueRate() public pure override returns (uint256) {\n        return FixedPoint.ONE;\n    }\n\n    function lastValue(address account) public view override returns (uint256) {\n        return IERC20(lpt).balanceOf(account);\n    }\n\n    function claim(bytes memory data) external override returns (address[] memory tokens, uint256[] memory amounts) {\n        uint256 amount = abi.decode(data, (uint256));\n        TokenMock(rewardToken).mint(address(this), amount);\n        tokens = new address[](1);\n        tokens[0] = rewardToken;\n        amounts = new uint256[](1);\n        amounts[0] = amount;\n        emit Claimed(data);\n    }\n\n    function join(address[] memory tokensIn, uint256[] memory amountsIn, uint256 slippage, bytes memory data)\n        external\n        override\n        returns (address[] memory tokensOut, uint256[] memory amountsOut, uint256 value)\n    {\n        require(tokensIn.length == 1, 'STRATEGY_INVALID_TOKENS_IN_LEN');\n        require(amountsIn.length == 1, 'STRATEGY_INVALID_AMOUNTS_IN_LEN');\n        require(tokensIn[0] == token, 'STRATEGY_INVALID_JOIN_TOKEN');\n\n        tokensOut = exitTokens();\n        amountsOut = new uint256[](1);\n        amountsOut[0] = amountsIn[0];\n\n        TokenMock(token).burn(address(this), amountsIn[0]);\n        TokenMock(lpt).mint(address(this), amountsOut[0]);\n        value = amountsOut[0].mulDown(valueRate());\n        emit Joined(tokensIn, amountsIn, slippage, data);\n    }\n\n    function exit(address[] memory tokensIn, uint256[] memory amountsIn, uint256 slippage, bytes memory data)\n        external\n        override\n        returns (address[] memory tokensOut, uint256[] memory amountsOut, uint256 value)\n    {\n        require(tokensIn.length == 1, 'STRATEGY_INVALID_TOKENS_IN_LEN');\n        require(amountsIn.length == 1, 'STRATEGY_INVALID_AMOUNTS_IN_LEN');\n        require(tokensIn[0] == lpt, 'STRATEGY_INVALID_EXIT_TOKEN');\n\n        tokensOut = joinTokens();\n        amountsOut = new uint256[](1);\n        amountsOut[0] = amountsIn[0];\n\n        TokenMock(lpt).burn(address(this), amountsIn[0]);\n        TokenMock(token).mint(address(this), amountsOut[0]);\n        value = amountsIn[0].divUp(valueRate());\n        emit Exited(tokensIn, amountsIn, slippage, data);\n    }\n}\n"},"contracts/test/samples/DexMock.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\n\ncontract DexMock {\n    using FixedPoint for uint256;\n\n    uint256 public mockedRate;\n\n    constructor() {\n        mockedRate = FixedPoint.ONE;\n    }\n\n    function mockRate(uint256 newRate) external {\n        mockedRate = newRate;\n    }\n\n    function swap(address tokenIn, address tokenOut, uint256 amountIn, uint256, bytes memory)\n        external\n        returns (uint256 amountOut)\n    {\n        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);\n        amountOut = amountIn.mulDown(mockedRate);\n        IERC20(tokenOut).transfer(msg.sender, amountOut);\n    }\n}\n"},"@openzeppelin/contracts/proxy/utils/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"},"contracts/ISmartVaultsFactory.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\n\n/**\n * @title ISmartVaultsFactory\n * @dev Smart Vaults Factory interface, it must follow the IImplementation interface.\n */\ninterface ISmartVaultsFactory is IImplementation {\n    /**\n     * @dev Emitted every time a new Smart Vault instance is created\n     */\n    event Created(address indexed implementation, address indexed instance, bytes initializeResult);\n\n    /**\n     * @dev Tells the implementation associated to a contract instance\n     * @param instance Address of the instance to request it's implementation\n     */\n    function implementationOf(address instance) external view returns (address);\n\n    /**\n     * @dev Creates a new Smart Vault pointing to a registered implementation\n     * @param salt Salt bytes to derivate the address of the new instance\n     * @param implementation Address of the implementation to be instanced\n     * @param initializeData Arbitrary data to be sent after deployment\n     * @return instance Address of the new instance created\n     */\n    function create(bytes32 salt, address implementation, bytes memory initializeData) external returns (address);\n}\n"},"@mimic-fi/v2-registry/contracts/implementations/BaseImplementation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/proxy/utils/Initializable.sol';\n\nimport './IImplementation.sol';\nimport '../registry/IRegistry.sol';\n\n/**\n * @title BaseImplementation\n * @dev This implementation contract comes with an immutable reference to an implementations registry where it should\n * be registered as well (checked during initialization). It allows requesting new instances of other registered\n * implementations to as another safety check to make sure valid instances are referenced in case it's needed.\n */\nabstract contract BaseImplementation is IImplementation {\n    // Immutable implementations registry reference\n    address public immutable override registry;\n\n    /**\n     * @dev Creates a new BaseImplementation\n     * @param _registry Address of the Mimic Registry where dependencies will be validated against\n     */\n    constructor(address _registry) {\n        registry = _registry;\n    }\n\n    /**\n     * @dev Internal function to validate a new dependency that must be registered as stateless.\n     * It checks the new dependency is registered, not deprecated, and stateless.\n     * @param dependency New stateless dependency to be set\n     */\n    function _validateStatelessDependency(address dependency) internal view {\n        require(_validateDependency(dependency), 'DEPENDENCY_NOT_STATELESS');\n    }\n\n    /**\n     * @dev Internal function to validate a new dependency that cannot be registered as stateless.\n     * It checks the new dependency is registered, not deprecated, and not stateful.\n     * @param dependency New stateful dependency to be set\n     */\n    function _validateStatefulDependency(address dependency) internal view {\n        require(!_validateDependency(dependency), 'DEPENDENCY_NOT_STATEFUL');\n    }\n\n    /**\n     * @dev Internal function to validate a new dependency. It checks the dependency is registered and not deprecated.\n     * @param dependency New dependency to be set\n     * @return Whether the dependency is stateless or not\n     */\n    function _validateDependency(address dependency) private view returns (bool) {\n        (bool stateless, bool deprecated, bytes32 namespace) = IRegistry(registry).implementationData(dependency);\n        require(namespace != bytes32(0), 'DEPENDENCY_NOT_REGISTERED');\n        require(!deprecated, 'DEPENDENCY_DEPRECATED');\n        return stateless;\n    }\n}\n"},"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"@openzeppelin/contracts/token/ERC20/ERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"},"contracts/SmartVault.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\nimport '@openzeppelin/contracts/utils/math/Math.sol';\n\nimport '@mimic-fi/v2-bridge-connector/contracts/IBridgeConnector.sol';\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\nimport '@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol';\nimport '@mimic-fi/v2-helpers/contracts/utils/Denominations.sol';\nimport '@mimic-fi/v2-helpers/contracts/utils/IWrappedNativeToken.sol';\nimport '@mimic-fi/v2-price-oracle/contracts/oracle/IPriceOracle.sol';\nimport '@mimic-fi/v2-price-oracle/contracts/feeds/PriceFeedProvider.sol';\nimport '@mimic-fi/v2-strategies/contracts/IStrategy.sol';\nimport '@mimic-fi/v2-swap-connector/contracts/ISwapConnector.sol';\nimport '@mimic-fi/v2-registry/contracts/implementations/InitializableAuthorizedImplementation.sol';\n\nimport './ISmartVault.sol';\nimport './helpers/StrategyLib.sol';\nimport './helpers/SwapConnectorLib.sol';\nimport './helpers/BridgeConnectorLib.sol';\n\n/**\n * @title Smart Vault\n * @dev Smart Vault contract where funds are being held offering a bunch of primitives to allow users model any\n * type of action to manage them, these are: collector, withdraw, swap, bridge, join, exit, bridge, wrap, and unwrap.\n *\n * It inherits from InitializableAuthorizedImplementation which means it's implementation can be cloned\n * from the Mimic Registry and should be initialized depending on each case.\n */\ncontract SmartVault is ISmartVault, PriceFeedProvider, InitializableAuthorizedImplementation {\n    using SafeERC20 for IERC20;\n    using FixedPoint for uint256;\n    using UncheckedMath for uint256;\n    using StrategyLib for address;\n    using SwapConnectorLib for address;\n    using BridgeConnectorLib for address;\n\n    // Namespace under which the Smart Vault is registered in the Mimic Registry\n    bytes32 public constant override NAMESPACE = keccak256('SMART_VAULT');\n\n    /**\n     * @dev Fee configuration parameters\n     * @param pct Percentage expressed using 16 decimals (1e18 = 100%)\n     * @param cap Maximum amount of fees to be charged per period\n     * @param token Address of the token to express the cap amount\n     * @param period Period length in seconds\n     * @param totalCharged Total amount of fees charged in the current period\n     * @param nextResetTime Current cap period end date\n     */\n    struct Fee {\n        uint256 pct;\n        uint256 cap;\n        address token;\n        uint256 period;\n        uint256 totalCharged;\n        uint256 nextResetTime;\n    }\n\n    // Price oracle reference\n    address public override priceOracle;\n\n    // Swap connector reference\n    address public override swapConnector;\n\n    // Bridge connector reference\n    address public override bridgeConnector;\n\n    // List of allowed strategies indexed by strategy address\n    mapping (address => bool) public override isStrategyAllowed;\n\n    // List of invested values indexed by strategy address\n    mapping (address => uint256) public override investedValue;\n\n    // Fee collector address where fees will be deposited\n    address public override feeCollector;\n\n    // Withdraw fee configuration\n    Fee public override withdrawFee;\n\n    // Performance fee configuration\n    Fee public override performanceFee;\n\n    // Swap fee configuration\n    Fee public override swapFee;\n\n    // Bridge fee configuration\n    Fee public override bridgeFee;\n\n    // Wrapped native token reference\n    address public immutable override wrappedNativeToken;\n\n    /**\n     * @dev Creates a new Smart Vault implementation with references that should be shared among all implementations\n     * @param _wrappedNativeToken Address of the wrapped native token to be used\n     * @param _registry Address of the Mimic Registry to be referenced\n     */\n    constructor(address _wrappedNativeToken, address _registry) InitializableAuthorizedImplementation(_registry) {\n        wrappedNativeToken = _wrappedNativeToken;\n    }\n\n    /**\n     * @dev Initializes the Smart Vault instance\n     * @param admin Address that will be granted with admin rights\n     */\n    function initialize(address admin) external initializer {\n        _initialize(admin);\n    }\n\n    /**\n     * @dev It allows receiving native token transfers\n     */\n    receive() external payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Sets a new strategy as allowed or not for a Smart Vault. Sender must be authorized.\n     * @param strategy Address of the strategy to be set\n     * @param allowed Whether the strategy is allowed or not\n     */\n    function setStrategy(address strategy, bool allowed) external override auth {\n        _setStrategy(strategy, allowed);\n    }\n\n    /**\n     * @dev Sets a new price oracle to a Smart Vault. Sender must be authorized.\n     * @param newPriceOracle Address of the new price oracle to be set\n     */\n    function setPriceOracle(address newPriceOracle) external override auth {\n        _setPriceOracle(newPriceOracle);\n    }\n\n    /**\n     * @dev Sets a new swap connector to a Smart Vault. Sender must be authorized.\n     * @param newSwapConnector Address of the new swap connector to be set\n     */\n    function setSwapConnector(address newSwapConnector) external override auth {\n        _setSwapConnector(newSwapConnector);\n    }\n\n    /**\n     * @dev Sets a new bridge connector to a Smart Vault. Sender must be authorized.\n     * @param newBridgeConnector Address of the new bridge connector to be set\n     */\n    function setBridgeConnector(address newBridgeConnector) external override auth {\n        _setBridgeConnector(newBridgeConnector);\n    }\n\n    /**\n     * @dev Sets a new fee collector. Sender must be authorized.\n     * @param newFeeCollector Address of the new fee collector to be set\n     */\n    function setFeeCollector(address newFeeCollector) external override auth {\n        _setFeeCollector(newFeeCollector);\n    }\n\n    /**\n     * @dev Sets a new withdraw fee. Sender must be authorized.\n     * @param pct Withdraw fee percentage to be set\n     * @param cap New maximum amount of withdraw fees to be charged per period\n     * @param token Address of the token cap to be set\n     * @param period New cap period length in seconds for the withdraw fee\n     */\n    function setWithdrawFee(uint256 pct, uint256 cap, address token, uint256 period) external override auth {\n        _setFeeConfiguration(withdrawFee, pct, cap, token, period);\n        emit WithdrawFeeSet(pct, cap, token, period);\n    }\n\n    /**\n     * @dev Sets a new performance fee. Sender must be authorized.\n     * @param pct Performance fee percentage to be set\n     * @param cap New maximum amount of performance fees to be charged per period\n     * @param token Address of the token cap to be set\n     * @param period New cap period length in seconds for the performance fee\n     */\n    function setPerformanceFee(uint256 pct, uint256 cap, address token, uint256 period) external override auth {\n        _setFeeConfiguration(performanceFee, pct, cap, token, period);\n        emit PerformanceFeeSet(pct, cap, token, period);\n    }\n\n    /**\n     * @dev Sets a new swap fee. Sender must be authorized.\n     * @param pct New swap fee percentage to be set\n     * @param cap New maximum amount of swap fees to be charged per period\n     * @param token Address of the token cap to be set\n     * @param period New cap period length in seconds for the swap fee\n     */\n    function setSwapFee(uint256 pct, uint256 cap, address token, uint256 period) external override auth {\n        _setFeeConfiguration(swapFee, pct, cap, token, period);\n        emit SwapFeeSet(pct, cap, token, period);\n    }\n\n    /**\n     * @dev Sets a new bridge fee. Sender must be authorized.\n     * @param pct New bridge fee percentage to be set\n     * @param cap New maximum amount of bridge fees to be charged per period\n     * @param token Address of the token cap to be set\n     * @param period New cap period length in seconds for the bridge fee\n     */\n    function setBridgeFee(uint256 pct, uint256 cap, address token, uint256 period) external override auth {\n        _setFeeConfiguration(bridgeFee, pct, cap, token, period);\n        emit BridgeFeeSet(pct, cap, token, period);\n    }\n\n    /**\n     * @dev Sets a of price feed\n     * @param base Token base to be set\n     * @param quote Token quote to be set\n     * @param feed Price feed to be set\n     */\n    function setPriceFeed(address base, address quote, address feed)\n        public\n        override(IPriceFeedProvider, PriceFeedProvider)\n        auth\n    {\n        super.setPriceFeed(base, quote, feed);\n    }\n\n    /**\n     * @dev Tells the price of a token (base) in a given quote\n     * @param base Token to rate\n     * @param quote Token used for the price rate\n     */\n    function getPrice(address base, address quote) public view override returns (uint256) {\n        return IPriceOracle(priceOracle).getPrice(address(this), base, quote);\n    }\n\n    /**\n     * @dev Tells the last value accrued for a strategy. Note this value can be outdated.\n     * @param strategy Address of the strategy querying the last value of\n     */\n    function lastValue(address strategy) public view override returns (uint256) {\n        return IStrategy(strategy).lastValue(address(this));\n    }\n\n    /**\n     * @dev Execute an arbitrary call from a Smart Vault. Sender must be authorized.\n     * @param target Address where the call will be sent\n     * @param data Calldata to be used for the call\n     * @param value Value in wei that will be attached to the call\n     * @return result Call response if it was successful, otherwise it reverts\n     */\n    function call(address target, bytes memory callData, uint256 value, bytes memory data)\n        external\n        override\n        auth\n        returns (bytes memory result)\n    {\n        result = Address.functionCallWithValue(target, callData, value, 'SMART_VAULT_ARBITRARY_CALL_FAIL');\n        emit Call(target, callData, value, result, data);\n    }\n\n    /**\n     * @dev Collect tokens from an external account to a Smart Vault. Sender must be authorized.\n     * @param token Address of the token to be collected\n     * @param from Address where the tokens will be transfer from\n     * @param amount Amount of tokens to be transferred\n     * @param data Extra data only logged\n     * @return collected Amount of tokens collected\n     */\n    function collect(address token, address from, uint256 amount, bytes memory data)\n        external\n        override\n        auth\n        returns (uint256 collected)\n    {\n        require(amount > 0, 'COLLECT_AMOUNT_ZERO');\n\n        uint256 previousBalance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(from, address(this), amount);\n        uint256 currentBalance = IERC20(token).balanceOf(address(this));\n\n        collected = currentBalance - previousBalance;\n        emit Collect(token, from, collected, data);\n    }\n\n    /**\n     * @dev Withdraw tokens to an external account. Sender must be authorized.\n     * @param token Address of the token to be withdrawn\n     * @param amount Amount of tokens to withdraw\n     * @param recipient Address where the tokens will be transferred to\n     * @param data Extra data only logged\n     * @return withdrawn Amount of tokens transferred to the recipient address\n     */\n    function withdraw(address token, uint256 amount, address recipient, bytes memory data)\n        external\n        override\n        auth\n        returns (uint256 withdrawn)\n    {\n        require(amount > 0, 'WITHDRAW_AMOUNT_ZERO');\n        require(recipient != address(0), 'RECIPIENT_ZERO');\n\n        uint256 withdrawFeeAmount = recipient == feeCollector ? 0 : _payFee(token, amount, withdrawFee);\n        withdrawn = amount - withdrawFeeAmount;\n        _safeTransfer(token, recipient, withdrawn);\n        emit Withdraw(token, recipient, withdrawn, withdrawFeeAmount, data);\n    }\n\n    /**\n     * @dev Wrap an amount of native tokens to the wrapped ERC20 version of it. Sender must be authorized.\n     * @param amount Amount of native tokens to be wrapped\n     * @param data Extra data only logged\n     * @return wrapped Amount of tokens wrapped\n     */\n    function wrap(uint256 amount, bytes memory data) external override auth returns (uint256 wrapped) {\n        require(amount > 0, 'WRAP_AMOUNT_ZERO');\n        require(address(this).balance >= amount, 'WRAP_INSUFFICIENT_AMOUNT');\n\n        IWrappedNativeToken wrappedToken = IWrappedNativeToken(wrappedNativeToken);\n        uint256 previousBalance = wrappedToken.balanceOf(address(this));\n        wrappedToken.deposit{ value: amount }();\n        uint256 currentBalance = wrappedToken.balanceOf(address(this));\n\n        wrapped = currentBalance - previousBalance;\n        emit Wrap(amount, wrapped, data);\n    }\n\n    /**\n     * @dev Unwrap an amount of wrapped native tokens. Sender must be authorized.\n     * @param amount Amount of wrapped native tokens to unwrapped\n     * @param data Extra data only logged\n     * @return unwrapped Amount of tokens unwrapped\n     */\n    function unwrap(uint256 amount, bytes memory data) external override auth returns (uint256 unwrapped) {\n        require(amount > 0, 'UNWRAP_AMOUNT_ZERO');\n\n        uint256 previousBalance = address(this).balance;\n        IWrappedNativeToken(wrappedNativeToken).withdraw(amount);\n        uint256 currentBalance = address(this).balance;\n\n        unwrapped = currentBalance - previousBalance;\n        emit Unwrap(amount, unwrapped, data);\n    }\n\n    /**\n     * @dev Claim strategy rewards. Sender must be authorized.\n     * @param strategy Address of the strategy to claim rewards\n     * @param data Extra data passed to the strategy and logged\n     * @return tokens Addresses of the tokens received as rewards\n     * @return amounts Amounts of the tokens received as rewards\n     */\n    function claim(address strategy, bytes memory data)\n        external\n        override\n        auth\n        returns (address[] memory tokens, uint256[] memory amounts)\n    {\n        require(isStrategyAllowed[strategy], 'STRATEGY_NOT_ALLOWED');\n        (tokens, amounts) = strategy.claim(data);\n        emit Claim(strategy, tokens, amounts, data);\n    }\n\n    /**\n     * @dev Join a strategy with an amount of tokens. Sender must be authorized.\n     * @param strategy Address of the strategy to join\n     * @param tokensIn List of token addresses to join with\n     * @param amountsIn List of token amounts to join with\n     * @param slippage Slippage that will be used to compute the join\n     * @param data Extra data passed to the strategy and logged\n     * @return tokensOut List of token addresses received after the join\n     * @return amountsOut List of token amounts received after the join\n     */\n    function join(\n        address strategy,\n        address[] memory tokensIn,\n        uint256[] memory amountsIn,\n        uint256 slippage,\n        bytes memory data\n    ) external override auth returns (address[] memory tokensOut, uint256[] memory amountsOut) {\n        require(isStrategyAllowed[strategy], 'STRATEGY_NOT_ALLOWED');\n        require(slippage <= FixedPoint.ONE, 'JOIN_SLIPPAGE_ABOVE_ONE');\n        require(tokensIn.length == amountsIn.length, 'JOIN_INPUT_INVALID_LENGTH');\n\n        uint256 value;\n        (tokensOut, amountsOut, value) = strategy.join(tokensIn, amountsIn, slippage, data);\n        require(tokensOut.length == amountsOut.length, 'JOIN_OUTPUT_INVALID_LENGTH');\n\n        investedValue[strategy] = investedValue[strategy] + value;\n        emit Join(strategy, tokensIn, amountsIn, tokensOut, amountsOut, value, slippage, data);\n    }\n\n    /**\n     * @dev Exit a strategy. Sender must be authorized.\n     * @param strategy Address of the strategy to exit\n     * @param tokensIn List of token addresses to exit with\n     * @param amountsIn List of token amounts to exit with\n     * @param slippage Slippage that will be used to compute the exit\n     * @param data Extra data passed to the strategy and logged\n     * @return tokensOut List of token addresses received after the exit\n     * @return amountsOut List of token amounts received after the exit\n     */\n    function exit(\n        address strategy,\n        address[] memory tokensIn,\n        uint256[] memory amountsIn,\n        uint256 slippage,\n        bytes memory data\n    ) external override auth returns (address[] memory tokensOut, uint256[] memory amountsOut) {\n        require(isStrategyAllowed[strategy], 'STRATEGY_NOT_ALLOWED');\n        require(investedValue[strategy] > 0, 'EXIT_NO_INVESTED_VALUE');\n        require(slippage <= FixedPoint.ONE, 'EXIT_SLIPPAGE_ABOVE_ONE');\n        require(tokensIn.length == amountsIn.length, 'EXIT_INPUT_INVALID_LENGTH');\n\n        uint256 value;\n        (tokensOut, amountsOut, value) = strategy.exit(tokensIn, amountsIn, slippage, data);\n        require(tokensOut.length == amountsOut.length, 'EXIT_OUTPUT_INVALID_LENGTH');\n        uint256[] memory performanceFeeAmounts = new uint256[](amountsOut.length);\n\n        // It can rely on the last updated value since we have just exited, no need to compute current value\n        uint256 valueBeforeExit = lastValue(strategy) + value;\n        if (valueBeforeExit <= investedValue[strategy]) {\n            // There were losses, invested value is simply reduced using the exited ratio compared to the value\n            // before exit. Invested value is round up to avoid interpreting losses due to rounding errors\n            investedValue[strategy] -= investedValue[strategy].mulUp(value).divUp(valueBeforeExit);\n        } else {\n            // If value gains are greater than the exit value, it means only gains are being withdrawn. In that case\n            // the taxable amount is the entire exited amount, otherwise it should be the equivalent gains ratio of it.\n            uint256 valueGains = valueBeforeExit.uncheckedSub(investedValue[strategy]);\n            bool onlyGains = valueGains >= value;\n\n            // If the exit value is greater than the value gains, the invested value should be reduced by the portion\n            // of the invested value being exited. Otherwise, it's still the same, only gains are being withdrawn.\n            // No need for checked math as we are checking it manually beforehand\n            uint256 decrement = onlyGains ? 0 : value.uncheckedSub(valueGains);\n            investedValue[strategy] = investedValue[strategy] - decrement;\n\n            // Compute performance fees per token out\n            for (uint256 i = 0; i < tokensOut.length; i = i.uncheckedAdd(1)) {\n                address token = tokensOut[i];\n                uint256 amount = amountsOut[i];\n                uint256 taxableAmount = onlyGains ? amount : ((amount * valueGains) / value);\n                uint256 feeAmount = _payFee(token, taxableAmount, performanceFee);\n                amountsOut[i] = amount - feeAmount;\n                performanceFeeAmounts[i] = feeAmount;\n            }\n        }\n\n        emit Exit(strategy, tokensIn, amountsIn, tokensOut, amountsOut, value, performanceFeeAmounts, slippage, data);\n    }\n\n    /**\n     * @dev Swaps two tokens. Sender must be authorized.\n     * @param source Source to request the swap: Uniswap V2, Uniswap V3, Balancer V2, or Paraswap V5.\n     * @param tokenIn Token being sent\n     * @param tokenOut Token being received\n     * @param amountIn Amount of tokenIn being swapped\n     * @param limitType Swap limit to be applied: slippage or min amount out\n     * @param limitAmount Amount of the swap limit to be applied depending on limitType\n     * @param data Encoded data to specify different swap parameters depending on the source picked\n     * @return amountOut Received amount of tokens out\n     */\n    function swap(\n        uint8 source,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        SwapLimit limitType,\n        uint256 limitAmount,\n        bytes memory data\n    ) external override auth returns (uint256 amountOut) {\n        require(tokenIn != tokenOut, 'SWAP_SAME_TOKEN');\n        require(swapConnector != address(0), 'SWAP_CONNECTOR_NOT_SET');\n\n        uint256 minAmountOut;\n        if (limitType == SwapLimit.MinAmountOut) {\n            minAmountOut = limitAmount;\n        } else if (limitType == SwapLimit.Slippage) {\n            require(limitAmount <= FixedPoint.ONE, 'SWAP_SLIPPAGE_ABOVE_ONE');\n            uint256 price = getPrice(tokenIn, tokenOut);\n            // No need for checked math as we are checking it manually beforehand\n            // Always round up the expected min amount out. Limit amount is slippage.\n            minAmountOut = amountIn.mulUp(price).mulUp(FixedPoint.ONE.uncheckedSub(limitAmount));\n        } else {\n            revert('SWAP_INVALID_LIMIT_TYPE');\n        }\n\n        uint256 preBalanceIn = IERC20(tokenIn).balanceOf(address(this));\n        uint256 preBalanceOut = IERC20(tokenOut).balanceOf(address(this));\n        swapConnector.swap(source, tokenIn, tokenOut, amountIn, minAmountOut, data);\n\n        uint256 postBalanceIn = IERC20(tokenIn).balanceOf(address(this));\n        require(postBalanceIn >= preBalanceIn - amountIn, 'SWAP_BAD_TOKEN_IN_BALANCE');\n\n        uint256 amountOutBeforeFees = IERC20(tokenOut).balanceOf(address(this)) - preBalanceOut;\n        require(amountOutBeforeFees >= minAmountOut, 'SWAP_MIN_AMOUNT');\n\n        uint256 swapFeeAmount = _payFee(tokenOut, amountOutBeforeFees, swapFee);\n        amountOut = amountOutBeforeFees - swapFeeAmount;\n        emit Swap(source, tokenIn, tokenOut, amountIn, amountOut, minAmountOut, swapFeeAmount, data);\n    }\n\n    /**\n     * @dev Bridge assets to another chain\n     * @param source Source to request the bridge. It depends on the Bridge Connector attached to a Smart Vault.\n     * @param chainId ID of the destination chain\n     * @param token Address of the token to be bridged\n     * @param amount Amount of tokens to be bridged\n     * @param limitType Bridge limit to be applied: slippage or min amount out\n     * @param limitAmount Amount of the swap limit to be applied depending on limitType\n     * @param recipient Address that will receive the tokens on the destination chain\n     * @param data Encoded data to specify different bridge parameters depending on the source picked\n     * @return bridged Amount requested to be bridged after fees\n     */\n    function bridge(\n        uint8 source,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        BridgeLimit limitType,\n        uint256 limitAmount,\n        address recipient,\n        bytes memory data\n    ) external override auth returns (uint256 bridged) {\n        require(block.chainid != chainId, 'BRIDGE_SAME_CHAIN');\n        require(recipient != address(0), 'BRIDGE_RECIPIENT_ZERO');\n        require(bridgeConnector != address(0), 'BRIDGE_CONNECTOR_NOT_SET');\n\n        uint256 bridgeFeeAmount = _payFee(token, amount, bridgeFee);\n        bridged = amount - bridgeFeeAmount;\n\n        uint256 minAmountOut;\n        if (limitType == BridgeLimit.MinAmountOut) {\n            minAmountOut = limitAmount;\n        } else if (limitType == BridgeLimit.Slippage) {\n            require(limitAmount <= FixedPoint.ONE, 'BRIDGE_SLIPPAGE_ABOVE_ONE');\n            // No need for checked math as we are checking it manually beforehand\n            // Always round up the expected min amount out. Limit amount is slippage.\n            minAmountOut = bridged.mulUp(FixedPoint.ONE.uncheckedSub(limitAmount));\n        } else {\n            revert('BRIDGE_INVALID_LIMIT_TYPE');\n        }\n\n        uint256 preBalanceIn = IERC20(token).balanceOf(address(this));\n        bridgeConnector.bridge(source, chainId, token, bridged, minAmountOut, recipient, data);\n        uint256 postBalanceIn = IERC20(token).balanceOf(address(this));\n        require(postBalanceIn >= preBalanceIn - bridged, 'BRIDGE_BAD_TOKEN_IN_BALANCE');\n\n        emit Bridge(source, chainId, token, bridged, minAmountOut, bridgeFeeAmount, recipient, data);\n    }\n\n    /**\n     * @dev Internal function to pay the amount of fees to be charged based on a fee configuration to the fee collector\n     * @param token Token being charged\n     * @param amount Token amount to be taxed with fees\n     * @param fee Fee configuration to be applied\n     * @return paidAmount Amount of fees paid to the fee collector\n     */\n    function _payFee(address token, uint256 amount, Fee storage fee) internal returns (uint256 paidAmount) {\n        // Fee amounts are always rounded down\n        uint256 feeAmount = amount.mulDown(fee.pct);\n\n        // If cap amount or cap period are not set, charge the entire amount\n        if (fee.token == address(0) || fee.cap == 0 || fee.period == 0) {\n            _safeTransfer(token, feeCollector, feeAmount);\n            return feeAmount;\n        }\n\n        // Reset cap totalizator if necessary\n        if (block.timestamp >= fee.nextResetTime) {\n            fee.totalCharged = 0;\n            fee.nextResetTime = block.timestamp + fee.period;\n        }\n\n        // Calc fee amount in the fee token used for the cap\n        uint256 feeTokenPrice = getPrice(token, fee.token);\n        uint256 feeAmountInFeeToken = feeAmount.mulDown(feeTokenPrice);\n\n        // Compute fee amount picking the minimum between the chargeable amount and the remaining part for the cap\n        if (fee.totalCharged + feeAmountInFeeToken <= fee.cap) {\n            paidAmount = feeAmount;\n            fee.totalCharged += feeAmountInFeeToken;\n        } else if (fee.totalCharged < fee.cap) {\n            paidAmount = (fee.cap.uncheckedSub(fee.totalCharged) * feeAmount) / feeAmountInFeeToken;\n            fee.totalCharged = fee.cap;\n        } else {\n            // This case is when the total charged amount is already greater than the cap amount. It could happen if\n            // the cap amounts is decreased or if the cap token is changed. In this case the total charged amount is\n            // not updated, and the amount to paid is zero.\n            paidAmount = 0;\n        }\n\n        // Pay fee amount to the fee collector\n        _safeTransfer(token, feeCollector, paidAmount);\n    }\n\n    /**\n     * @dev Internal method to transfer ERC20 or native tokens from a Smart Vault\n     * @param token Address of the ERC20 token to transfer\n     * @param to Address transferring the tokens to\n     * @param amount Amount of tokens to transfer\n     */\n    function _safeTransfer(address token, address to, uint256 amount) internal {\n        if (amount == 0) return;\n        if (Denominations.isNativeToken(token)) Address.sendValue(payable(to), amount);\n        else IERC20(token).safeTransfer(to, amount);\n    }\n\n    /**\n     * @dev Sets a new strategy as allowed or not\n     * @param strategy Address of the strategy to be set\n     * @param allowed Whether the strategy is allowed or not\n     */\n    function _setStrategy(address strategy, bool allowed) internal {\n        if (allowed) _validateStatelessDependency(strategy);\n        isStrategyAllowed[strategy] = allowed;\n        emit StrategySet(strategy, allowed);\n    }\n\n    /**\n     * @dev Sets a new price oracle\n     * @param newPriceOracle New price oracle to be set\n     */\n    function _setPriceOracle(address newPriceOracle) internal {\n        _validateStatelessDependency(newPriceOracle);\n        priceOracle = newPriceOracle;\n        emit PriceOracleSet(newPriceOracle);\n    }\n\n    /**\n     * @dev Sets a new swap connector\n     * @param newSwapConnector New swap connector to be set\n     */\n    function _setSwapConnector(address newSwapConnector) internal {\n        _validateStatelessDependency(newSwapConnector);\n        swapConnector = newSwapConnector;\n        emit SwapConnectorSet(newSwapConnector);\n    }\n\n    /**\n     * @dev Sets a new bridge connector\n     * @param newBridgeConnector New bridge connector to be set\n     */\n    function _setBridgeConnector(address newBridgeConnector) internal {\n        _validateStatelessDependency(newBridgeConnector);\n        bridgeConnector = newBridgeConnector;\n        emit BridgeConnectorSet(newBridgeConnector);\n    }\n\n    /**\n     * @dev Internal method to set the fee collector\n     * @param newFeeCollector New fee collector to be set\n     */\n    function _setFeeCollector(address newFeeCollector) internal {\n        require(newFeeCollector != address(0), 'FEE_COLLECTOR_ZERO');\n        feeCollector = newFeeCollector;\n        emit FeeCollectorSet(newFeeCollector);\n    }\n\n    /**\n     * @dev Internal method to set a new fee cap configuration\n     * @param fee Fee configuration to be updated\n     * @param pct Fee percentage to be set\n     * @param cap New maximum amount of fees to be charged per period\n     * @param token Address of the token cap to be set\n     * @param period New cap period length in seconds\n     */\n    function _setFeeConfiguration(Fee storage fee, uint256 pct, uint256 cap, address token, uint256 period) internal {\n        require(pct <= FixedPoint.ONE, 'FEE_PCT_ABOVE_ONE');\n\n        // If there is no fee percentage, there must not be a fee cap\n        bool isZeroCap = token == address(0) && cap == 0 && period == 0;\n        require(pct != 0 || isZeroCap, 'INVALID_CAP_WITH_FEE_ZERO');\n\n        // If there is a cap, all values must be non-zero\n        bool isNonZeroCap = token != address(0) && cap != 0 && period != 0;\n        require(isZeroCap || isNonZeroCap, 'INCONSISTENT_CAP_VALUES');\n\n        // Changing the fee percentage does not affect the totalizator at all, it only affects future fee charges\n        fee.pct = pct;\n\n        // Changing the fee cap amount does not affect the totalizator, it only applies when changing the for the total\n        // charged amount. Note that it can happen that the cap amount is lower than the total charged amount if the\n        // cap amount is lowered. However, there shouldn't be any accounting issues with that.\n        fee.cap = cap;\n\n        // Changing the cap period only affects the end time of the next period, but not the end date of the current one\n        fee.period = period;\n\n        // Therefore, only clean the totalizators if the cap is being removed\n        if (isZeroCap) {\n            fee.totalCharged = 0;\n            fee.nextResetTime = 0;\n        } else {\n            // If cap values are not zero, set the next reset time if it wasn't set already\n            // Otherwise, if the cap token is being changed the total charged amount must be updated accordingly\n            if (fee.nextResetTime == 0) {\n                fee.nextResetTime = block.timestamp + period;\n            } else if (fee.token != token) {\n                uint256 newTokenPrice = getPrice(fee.token, token);\n                fee.totalCharged = fee.totalCharged.mulDown(newTokenPrice);\n            }\n        }\n\n        // Finally simply set the new requested token\n        fee.token = token;\n    }\n}\n"},"contracts/SmartVaultsFactory.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/proxy/Clones.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\n\nimport '@mimic-fi/v2-helpers/contracts/auth/Authorizer.sol';\nimport '@mimic-fi/v2-registry/contracts/registry/IRegistry.sol';\nimport '@mimic-fi/v2-registry/contracts/implementations/BaseImplementation.sol';\n\nimport './ISmartVaultsFactory.sol';\n\n/**\n * @title SmartVaultsFactory\n * @dev\n */\ncontract SmartVaultsFactory is ISmartVaultsFactory, BaseImplementation {\n    using Address for address;\n\n    // Smart Vaults Factory namespace\n    bytes32 public constant override NAMESPACE = keccak256('SMART_VAULTS_FACTORY');\n\n    // Namespace to use by this deployer to fetch ISmartVault implementations from the Mimic Registry\n    bytes32 private constant SMART_VAULT_NAMESPACE = keccak256('SMART_VAULT');\n\n    // List of instances' implementations indexed by instance address\n    mapping (address => address) public override implementationOf;\n\n    /**\n     * @dev Creates a new Smart Vaults Factory implementation\n     * @param registry Address of the Mimic Registry to be referenced\n     */\n    constructor(address registry) BaseImplementation(registry) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    /**\n     * @dev Creates a new Smart Vault pointing to a registered implementation using CREATE2\n     * @param salt Salt bytes to derivate the address of the new instance\n     * @param implementation Address of the implementation to be instanced. It must be registered and not deprecated.\n     * @param initializeData Arbitrary data to be sent after deployment. It can be used to initialize the new instance.\n     * @return instance Address of the new instance created\n     */\n    function create(bytes32 salt, address implementation, bytes memory initializeData)\n        external\n        override\n        returns (address instance)\n    {\n        require(implementation != address(0), 'IMPLEMENTATION_ADDRESS_ZERO');\n        require(IImplementation(implementation).NAMESPACE() == SMART_VAULT_NAMESPACE, 'BAD_IMPLEMENTATION_NAMESPACE');\n        require(IRegistry(registry).isActive(SMART_VAULT_NAMESPACE, implementation), 'BAD_SMART_VAULT_IMPLEMENTATION');\n\n        bytes32 senderSalt = keccak256(abi.encodePacked(msg.sender, salt));\n        instance = Clones.cloneDeterministic(address(implementation), senderSalt);\n\n        implementationOf[instance] = implementation;\n        bytes memory result = initializeData.length == 0\n            ? new bytes(0)\n            : instance.functionCall(initializeData, 'SMART_VAULT_INIT_FAILED');\n\n        emit Created(implementation, instance, result);\n    }\n}\n"},"@mimic-fi/v2-registry/contracts/implementations/InitializableImplementation.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/proxy/utils/Initializable.sol';\n\nimport './BaseImplementation.sol';\n\n/**\n * @title InitializableImplementation\n * @dev Implementation contract to be used through proxies. Inheriting contracts are meant to be initialized through\n * initialization functions instead of constructor functions. It allows re-using the same logic contract while making\n * deployments cheaper.\n */\nabstract contract InitializableImplementation is BaseImplementation, Initializable {\n    /**\n     * @dev Creates a new BaseImplementation. Note that initializers are disabled at creation time.\n     */\n    constructor(address registry) BaseImplementation(registry) {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initialization function.\n     * Note this function can only be called from a function marked with the `initializer` modifier.\n     */\n    function _initialize() internal view onlyInitializing {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n}\n"},"@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"},"@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\n/**\n * @title IAuthorizer\n */\ninterface IAuthorizer {\n    /**\n     * @dev Emitted when an account is authorized to call a function\n     */\n    event Authorized(address indexed who, bytes4 what);\n\n    /**\n     * @dev Emitted when an account is unauthorized to call a function\n     */\n    event Unauthorized(address indexed who, bytes4 what);\n\n    /**\n     * @dev Authorizes someone to call a function. Sender must be authorize to do so.\n     * @param who Address to be authorized\n     * @param what Function selector to be granted\n     */\n    function authorize(address who, bytes4 what) external;\n\n    /**\n     * @dev Unauthorizes someone to call a function. Sender must be authorize to do so.\n     * @param who Address to be unauthorized\n     * @param what Function selector to be revoked\n     */\n    function unauthorize(address who, bytes4 what) external;\n\n    /**\n     * @dev Tells whether someone is allowed to call a function or not. It returns true if it's allowed to anyone.\n     * @param who Address asking permission for\n     * @param what Function selector asking permission for\n     */\n    function isAuthorized(address who, bytes4 what) external view returns (bool);\n}\n"},"contracts/test/samples/TokenMock.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\n\ncontract TokenMock is ERC20 {\n    constructor(string memory symbol) ERC20(symbol, symbol) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function mint(address account, uint256 amount) external {\n        _mint(account, amount);\n    }\n\n    function burn(address account, uint256 amount) external {\n        _burn(account, amount);\n    }\n}\n"},"@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"contracts/helpers/StrategyLib.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/utils/Address.sol';\n\nimport '@mimic-fi/v2-strategies/contracts/IStrategy.sol';\n\n/**\n * @title StrategyLib\n * @dev Library used to delegate-call to strategy and decode return data correctly\n */\nlibrary StrategyLib {\n    /**\n     * @dev Delegate-calls a claim to a strategy and decodes de expected data\n     * IMPORTANT! This helper method does not check any of the given params, these should be checked beforehand.\n     */\n    function claim(address strategy, bytes memory data) internal returns (address[] memory, uint256[] memory) {\n        bytes memory claimData = abi.encodeWithSelector(IStrategy.claim.selector, data);\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = strategy.delegatecall(claimData);\n        Address.verifyCallResult(success, returndata, 'CLAIM_CALL_REVERTED');\n        return abi.decode(returndata, (address[], uint256[]));\n    }\n\n    /**\n     * @dev Delegate-calls a join to a strategy and decodes de expected data\n     * IMPORTANT! This helper method does not check any of the given params, these should be checked beforehand.\n     */\n    function join(\n        address strategy,\n        address[] memory tokensIn,\n        uint256[] memory amountsIn,\n        uint256 slippage,\n        bytes memory data\n    ) internal returns (address[] memory tokensOut, uint256[] memory amountsOut, uint256 value) {\n        bytes memory joinData = abi.encodeWithSelector(IStrategy.join.selector, tokensIn, amountsIn, slippage, data);\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = strategy.delegatecall(joinData);\n        Address.verifyCallResult(success, returndata, 'JOIN_CALL_REVERTED');\n        return abi.decode(returndata, (address[], uint256[], uint256));\n    }\n\n    /**\n     * @dev Delegate-calls a exit to a strategy and decodes de expected data\n     * IMPORTANT! This helper method does not check any of the given params, these should be checked beforehand.\n     */\n    function exit(\n        address strategy,\n        address[] memory tokensIn,\n        uint256[] memory amountsIn,\n        uint256 slippage,\n        bytes memory data\n    ) internal returns (address[] memory tokensOut, uint256[] memory amountsOut, uint256 value) {\n        bytes memory exitData = abi.encodeWithSelector(IStrategy.exit.selector, tokensIn, amountsIn, slippage, data);\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = strategy.delegatecall(exitData);\n        Address.verifyCallResult(success, returndata, 'EXIT_CALL_REVERTED');\n        return abi.decode(returndata, (address[], uint256[], uint256));\n    }\n}\n"},"@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\n/**\n * @title FixedPoint\n * @dev Math library to operate with fixed point values with 18 decimals\n */\nlibrary FixedPoint {\n    // 1 in fixed point value: 18 decimal places\n    uint256 internal constant ONE = 1e18;\n\n    /**\n     * @dev Multiplies two fixed point numbers rounding down\n     */\n    function mulDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            uint256 product = a * b;\n            require(a == 0 || product / a == b, 'MUL_OVERFLOW');\n            return product / ONE;\n        }\n    }\n\n    /**\n     * @dev Multiplies two fixed point numbers rounding up\n     */\n    function mulUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            uint256 product = a * b;\n            require(a == 0 || product / a == b, 'MUL_OVERFLOW');\n            return product == 0 ? 0 : (((product - 1) / ONE) + 1);\n        }\n    }\n\n    /**\n     * @dev Divides two fixed point numbers rounding down\n     */\n    function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            require(b != 0, 'ZERO_DIVISION');\n            if (a == 0) return 0;\n            uint256 aInflated = a * ONE;\n            require(aInflated / a == ONE, 'DIV_INTERNAL');\n            return aInflated / b;\n        }\n    }\n\n    /**\n     * @dev Divides two fixed point numbers rounding up\n     */\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            require(b != 0, 'ZERO_DIVISION');\n            if (a == 0) return 0;\n            uint256 aInflated = a * ONE;\n            require(aInflated / a == ONE, 'DIV_INTERNAL');\n            return ((aInflated - 1) / b) + 1;\n        }\n    }\n}\n"},"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"},"@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\n/**\n * @title UncheckedMath\n * @dev Math library to perform unchecked operations\n */\nlibrary UncheckedMath {\n    /**\n     * @dev Unsafely adds two unsigned integers\n     */\n    function uncheckedAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return a + b;\n        }\n    }\n\n    /**\n     * @dev Unsafely subtracts two unsigned integers\n     */\n    function uncheckedSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Unsafely multiplies two unsigned integers\n     */\n    function uncheckedMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return a * b;\n        }\n    }\n\n    /**\n     * @dev Unsafely multiplies two signed integers\n     */\n    function uncheckedMul(int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            return a * b;\n        }\n    }\n\n    /**\n     * @dev Unsafely divides two unsigned integers\n     */\n    function uncheckedDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            return a / b;\n        }\n    }\n}\n"},"contracts/test/core/PriceOracleMock.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '@mimic-fi/v2-helpers/contracts/math/FixedPoint.sol';\nimport '@mimic-fi/v2-price-oracle/contracts/oracle/IPriceOracle.sol';\nimport '@mimic-fi/v2-registry/contracts/implementations/BaseImplementation.sol';\n\ncontract PriceOracleMock is IPriceOracle, BaseImplementation {\n    bytes32 public constant override NAMESPACE = keccak256('PRICE_ORACLE');\n\n    struct Feed {\n        bool set;\n        uint256 rate;\n    }\n\n    mapping (address => mapping (address => Feed)) public mockedFeeds;\n\n    constructor(address registry) BaseImplementation(registry) {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    function mockRate(address base, address quote, uint256 newMockedRate) external {\n        Feed storage feed = mockedFeeds[base][quote];\n        feed.set = true;\n        feed.rate = newMockedRate;\n    }\n\n    function getPrice(address, address base, address quote) external view override returns (uint256) {\n        if (base == quote) return FixedPoint.ONE;\n        Feed storage feed = mockedFeeds[base][quote];\n        require(feed.set, 'PRICE_ORACLE_FEED_NOT_SET');\n        return feed.rate;\n    }\n}\n"},"contracts/test/core/SwapConnectorMock.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '@mimic-fi/v2-swap-connector/contracts/ISwapConnector.sol';\nimport '@mimic-fi/v2-registry/contracts/implementations/BaseImplementation.sol';\n\nimport '../samples/DexMock.sol';\n\ncontract SwapConnectorMock is ISwapConnector, BaseImplementation {\n    bytes32 public constant override NAMESPACE = keccak256('SWAP_CONNECTOR');\n\n    DexMock public immutable dex;\n\n    constructor(address registry) BaseImplementation(registry) {\n        dex = new DexMock();\n    }\n\n    function mockRate(uint256 newRate) external {\n        dex.mockRate(newRate);\n    }\n\n    function swap(\n        uint8, /* source */\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        bytes memory data\n    ) external override returns (uint256 amountOut) {\n        IERC20(tokenIn).approve(address(dex), amountIn);\n        return dex.swap(tokenIn, tokenOut, amountIn, minAmountOut, data);\n    }\n}\n"},"contracts/test/samples/WrappedNativeTokenMock.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '@mimic-fi/v2-helpers/contracts/utils/IWrappedNativeToken.sol';\n\ncontract WrappedNativeTokenMock is IWrappedNativeToken {\n    uint8 public decimals = 18;\n    string public name = 'Wrapped Native Token';\n    string public symbol = 'WNT';\n\n    event Deposit(address indexed to, uint256 amount);\n    event Withdrawal(address indexed from, uint256 amount);\n\n    mapping (address => uint256) public override balanceOf;\n    mapping (address => mapping (address => uint256)) public override allowance;\n\n    receive() external payable {\n        deposit();\n    }\n\n    function deposit() public payable override {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) public override {\n        require(balanceOf[msg.sender] >= amount, 'WNT_NOT_ENOUGH_BALANCE');\n        balanceOf[msg.sender] -= amount;\n        payable(msg.sender).transfer(amount);\n        emit Withdrawal(msg.sender, amount);\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public override returns (bool) {\n        return transferFrom(msg.sender, to, amount);\n    }\n\n    function transferFrom(address from, address to, uint256 amount) public override returns (bool) {\n        require(balanceOf[from] >= amount, 'NOT_ENOUGH_BALANCE');\n\n        if (from != msg.sender && allowance[from][msg.sender] != type(uint256).max) {\n            require(allowance[from][msg.sender] >= amount, 'NOT_ENOUGH_ALLOWANCE');\n            allowance[from][msg.sender] -= amount;\n        }\n\n        balanceOf[from] -= amount;\n        balanceOf[to] += amount;\n        emit Transfer(from, to, amount);\n        return true;\n    }\n}\n"},"@openzeppelin/contracts/proxy/Clones.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"},"@mimic-fi/v2-helpers/contracts/auth/Authorizer.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport './IAuthorizer.sol';\n\n/**\n * @title Authorizer\n * @dev Authorization module to be used by contracts that need to implement permissions for their methods.\n * It provides a permissions model to list who is allowed to call what function in a contract. And only accounts\n * authorized to manage those permissions are the ones that are allowed to authorize or unauthorize accounts.\n */\ncontract Authorizer is IAuthorizer {\n    // Constant used to denote that a permission is open to anyone\n    address public constant ANY_ADDRESS = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\n\n    // Internal mapping to tell who is allowed to do what indexed by (account, function selector)\n    mapping (address => mapping (bytes4 => bool)) private authorized;\n\n    /**\n     * @dev Modifier that should be used to tag protected functions\n     */\n    modifier auth() {\n        _authenticate(msg.sender, msg.sig);\n        _;\n    }\n\n    /**\n     * @dev Tells whether someone is allowed to call a function or not. It returns true if it's allowed to anyone.\n     * @param who Address asking permission for\n     * @param what Function selector asking permission for\n     */\n    function isAuthorized(address who, bytes4 what) public view override returns (bool) {\n        return authorized[ANY_ADDRESS][what] || authorized[who][what];\n    }\n\n    /**\n     * @dev Authorizes someone to call a function. Sender must be authorize to do so.\n     * @param who Address to be authorized\n     * @param what Function selector to be granted\n     */\n    function authorize(address who, bytes4 what) external override auth {\n        _authorize(who, what);\n    }\n\n    /**\n     * @dev Unauthorizes someone to call a function. Sender must be authorize to do so.\n     * @param who Address to be unauthorized\n     * @param what Function selector to be revoked\n     */\n    function unauthorize(address who, bytes4 what) external override auth {\n        _unauthorize(who, what);\n    }\n\n    /**\n     * @dev Internal function to authenticate someone over a function.\n     * It reverts if the given account is not authorized to call the requested function.\n     * @param who Address to be authenticated\n     * @param what Function selector to be authenticated\n     */\n    function _authenticate(address who, bytes4 what) internal view {\n        require(isAuthorized(who, what), 'AUTH_SENDER_NOT_ALLOWED');\n    }\n\n    /**\n     * @dev Internal function to authorize someone to call a function\n     * @param who Address to be authorized\n     * @param what Function selector to be granted\n     */\n    function _authorize(address who, bytes4 what) internal {\n        authorized[who][what] = true;\n        emit Authorized(who, what);\n    }\n\n    /**\n     * @dev Internal function to unauthorize someone to call a function\n     * @param who Address to be unauthorized\n     * @param what Function selector to be revoked\n     */\n    function _unauthorize(address who, bytes4 what) internal {\n        authorized[who][what] = false;\n        emit Unauthorized(who, what);\n    }\n}\n"},"@mimic-fi/v2-strategies/contracts/IStrategy.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\n\n/**\n * @title IStrategy\n * @dev Strategy interface required by Mimic Smart Vaults. It must follow the IImplementation interface.\n */\ninterface IStrategy is IImplementation {\n    /**\n     * @dev Tokens accepted to join the strategy\n     */\n    function joinTokens() external view returns (address[] memory);\n\n    /**\n     * @dev Tokens accepted to exit the strategy\n     */\n    function exitTokens() external view returns (address[] memory);\n\n    /**\n     * @dev Tells how much a value unit means expressed in the asset token.\n     * For example, if a strategy has a value of 100 in T0, and then it has a value of 120 in T1,\n     * and the value rate is 1.5, it means the strategy has earned 30 strategy tokens between T0 and T1.\n     */\n    function valueRate() external view returns (uint256);\n\n    /**\n     * @dev Tells the last value an account has over time. Note this value can be outdated: there could be rewards to\n     * be claimed that will affect the accrued value. For example, if an account has a value of 100 in T0, and then it\n     * has a value of 120 in T1, it means it gained a 20% between T0 and T1.\n     * @param account Address of the account querying the last value of\n     */\n    function lastValue(address account) external view returns (uint256);\n\n    /**\n     * @dev Claim any existing rewards\n     * @param data Arbitrary extra data\n     * @return tokens Addresses of the tokens received as rewards\n     * @return amounts Amounts of the tokens received as rewards\n     */\n    function claim(bytes memory data) external returns (address[] memory tokens, uint256[] memory amounts);\n\n    /**\n     * @dev Join the interfaced DeFi protocol\n     * @param tokensIn List of token addresses to join with\n     * @param amountsIn List of token amounts to join with\n     * @param slippage Slippage value to join with\n     * @param data Arbitrary extra data\n     * @return tokensOut List of token addresses received after the join\n     * @return amountsOut List of token amounts received after the join\n     * @return value Value represented by the joined amount\n     */\n    function join(address[] memory tokensIn, uint256[] memory amountsIn, uint256 slippage, bytes memory data)\n        external\n        returns (address[] memory tokensOut, uint256[] memory amountsOut, uint256 value);\n\n    /**\n     * @dev Exit the interfaced DeFi protocol\n     * @param tokensIn List of token addresses to exit with\n     * @param amountsIn List of token amounts to exit with\n     * @param slippage Slippage value to exit with\n     * @param data Arbitrary extra data\n     * @return tokensOut List of token addresses received after the exit\n     * @return amountsOut List of token amounts received after the exit\n     * @return value Value represented by the exited amount\n     */\n    function exit(address[] memory tokensIn, uint256[] memory amountsIn, uint256 slippage, bytes memory data)\n        external\n        returns (address[] memory tokensOut, uint256[] memory amountsOut, uint256 value);\n}\n"},"@mimic-fi/v2-swap-connector/contracts/ISwapConnector.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\n\n/**\n * @title ISwapConnector\n * @dev Swap Connector interface to perform token swaps. It must follow the IImplementation interface.\n */\ninterface ISwapConnector is IImplementation {\n    /**\n     * @dev Enum identifying the sources proposed: Uniswap V2, Uniswap V3, Balancer V2, Paraswap V5, 1inch V5, and Hop.\n     */\n    enum Source {\n        UniswapV2,\n        UniswapV3,\n        BalancerV2,\n        ParaswapV5,\n        OneInchV5,\n        Hop\n    }\n\n    /**\n     * @dev Swaps two tokens\n     * @param source Source to execute the requested swap\n     * @param tokenIn Token being sent\n     * @param tokenOut Token being received\n     * @param amountIn Amount of tokenIn being swapped\n     * @param minAmountOut Minimum amount of tokenOut willing to receive\n     * @param data Encoded data to specify different swap parameters depending on the source picked\n     */\n    function swap(\n        uint8 source,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        bytes memory data\n    ) external returns (uint256 amountOut);\n}\n"},"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"},"@openzeppelin/contracts/utils/math/Math.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)`  `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"},"contracts/ISmartVault.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@mimic-fi/v2-helpers/contracts/auth/IAuthorizer.sol';\nimport '@mimic-fi/v2-price-oracle/contracts/feeds/IPriceFeedProvider.sol';\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\n\n/**\n * @title ISmartVault\n * @dev Mimic Smart Vault interface to manage assets. It must support also `IImplementation` and `IAuthorizer`\n */\ninterface ISmartVault is IPriceFeedProvider, IImplementation, IAuthorizer {\n    enum SwapLimit {\n        Slippage,\n        MinAmountOut\n    }\n\n    enum BridgeLimit {\n        Slippage,\n        MinAmountOut\n    }\n\n    /**\n     * @dev Emitted every time a new strategy is set for the Smart Vault\n     */\n    event StrategySet(address indexed strategy, bool allowed);\n\n    /**\n     * @dev Emitted every time a new price oracle is set for the Smart Vault\n     */\n    event PriceOracleSet(address indexed priceOracle);\n\n    /**\n     * @dev Emitted every time a new swap connector is set for the Smart Vault\n     */\n    event SwapConnectorSet(address indexed swapConnector);\n\n    /**\n     * @dev Emitted every time a new bridge connector is set for the Smart Vault\n     */\n    event BridgeConnectorSet(address indexed bridgeConnector);\n\n    /**\n     * @dev Emitted every time a new fee collector is set\n     */\n    event FeeCollectorSet(address indexed feeCollector);\n\n    /**\n     * @dev Emitted every time the withdraw fee percentage is set\n     */\n    event WithdrawFeeSet(uint256 pct, uint256 cap, address token, uint256 period);\n\n    /**\n     * @dev Emitted every time the performance fee percentage is set\n     */\n    event PerformanceFeeSet(uint256 pct, uint256 cap, address token, uint256 period);\n\n    /**\n     * @dev Emitted every time the swap fee percentage is set\n     */\n    event SwapFeeSet(uint256 pct, uint256 cap, address token, uint256 period);\n\n    /**\n     * @dev Emitted every time the bridge fee percentage is set\n     */\n    event BridgeFeeSet(uint256 pct, uint256 cap, address token, uint256 period);\n\n    /**\n     * @dev Emitted every time `call` is called\n     */\n    event Call(address indexed target, bytes callData, uint256 value, bytes result, bytes data);\n\n    /**\n     * @dev Emitted every time `collect` is called\n     */\n    event Collect(address indexed token, address indexed from, uint256 collected, bytes data);\n\n    /**\n     * @dev Emitted every time `withdraw` is called\n     */\n    event Withdraw(address indexed token, address indexed recipient, uint256 withdrawn, uint256 fee, bytes data);\n\n    /**\n     * @dev Emitted every time `wrap` is called\n     */\n    event Wrap(uint256 amount, uint256 wrapped, bytes data);\n\n    /**\n     * @dev Emitted every time `unwrap` is called\n     */\n    event Unwrap(uint256 amount, uint256 unwrapped, bytes data);\n\n    /**\n     * @dev Emitted every time `claim` is called\n     */\n    event Claim(address indexed strategy, address[] tokens, uint256[] amounts, bytes data);\n\n    /**\n     * @dev Emitted every time `join` is called\n     */\n    event Join(\n        address indexed strategy,\n        address[] tokensIn,\n        uint256[] amountsIn,\n        address[] tokensOut,\n        uint256[] amountsOut,\n        uint256 value,\n        uint256 slippage,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted every time `exit` is called\n     */\n    event Exit(\n        address indexed strategy,\n        address[] tokensIn,\n        uint256[] amountsIn,\n        address[] tokensOut,\n        uint256[] amountsOut,\n        uint256 value,\n        uint256[] fees,\n        uint256 slippage,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted every time `swap` is called\n     */\n    event Swap(\n        uint8 indexed source,\n        address indexed tokenIn,\n        address indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 minAmountOut,\n        uint256 fee,\n        bytes data\n    );\n\n    /**\n     * @dev Emitted every time `bridge` is called\n     */\n    event Bridge(\n        uint8 indexed source,\n        uint256 indexed chainId,\n        address indexed token,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        uint256 fee,\n        address recipient,\n        bytes data\n    );\n\n    /**\n     * @dev Tells a strategy is allowed or not\n     * @param strategy Address of the strategy being queried\n     */\n    function isStrategyAllowed(address strategy) external view returns (bool);\n\n    /**\n     * @dev Tells the invested value for a strategy\n     * @param strategy Address of the strategy querying the invested value of\n     */\n    function investedValue(address strategy) external view returns (uint256);\n\n    /**\n     * @dev Tells the last value accrued for a strategy. Note this value can be outdated.\n     * @param strategy Address of the strategy querying the last value of\n     */\n    function lastValue(address strategy) external view returns (uint256);\n\n    /**\n     * @dev Tells the price oracle associated to a Smart Vault\n     */\n    function priceOracle() external view returns (address);\n\n    /**\n     * @dev Tells the swap connector associated to a Smart Vault\n     */\n    function swapConnector() external view returns (address);\n\n    /**\n     * @dev Tells the bridge connector associated to a Smart Vault\n     */\n    function bridgeConnector() external view returns (address);\n\n    /**\n     * @dev Tells the address where fees will be deposited\n     */\n    function feeCollector() external view returns (address);\n\n    /**\n     * @dev Tells the withdraw fee configuration\n     */\n    function withdrawFee()\n        external\n        view\n        returns (uint256 pct, uint256 cap, address token, uint256 period, uint256 totalCharged, uint256 nextResetTime);\n\n    /**\n     * @dev Tells the performance fee configuration\n     */\n    function performanceFee()\n        external\n        view\n        returns (uint256 pct, uint256 cap, address token, uint256 period, uint256 totalCharged, uint256 nextResetTime);\n\n    /**\n     * @dev Tells the swap fee configuration\n     */\n    function swapFee()\n        external\n        view\n        returns (uint256 pct, uint256 cap, address token, uint256 period, uint256 totalCharged, uint256 nextResetTime);\n\n    /**\n     * @dev Tells the bridge fee configuration\n     */\n    function bridgeFee()\n        external\n        view\n        returns (uint256 pct, uint256 cap, address token, uint256 period, uint256 totalCharged, uint256 nextResetTime);\n\n    /**\n     * @dev Tells the address of the wrapped native token\n     */\n    function wrappedNativeToken() external view returns (address);\n\n    /**\n     * @dev Sets a new strategy as allowed or not for a Smart Vault\n     * @param strategy Address of the strategy to be set\n     * @param allowed Whether the strategy is allowed or not\n     */\n    function setStrategy(address strategy, bool allowed) external;\n\n    /**\n     * @dev Sets a new price oracle to a Smart Vault\n     * @param newPriceOracle Address of the new price oracle to be set\n     */\n    function setPriceOracle(address newPriceOracle) external;\n\n    /**\n     * @dev Sets a new swap connector to a Smart Vault\n     * @param newSwapConnector Address of the new swap connector to be set\n     */\n    function setSwapConnector(address newSwapConnector) external;\n\n    /**\n     * @dev Sets a new bridge connector to a Smart Vault\n     * @param newBridgeConnector Address of the new bridge connector to be set\n     */\n    function setBridgeConnector(address newBridgeConnector) external;\n\n    /**\n     * @dev Sets a new fee collector\n     * @param newFeeCollector Address of the new fee collector to be set\n     */\n    function setFeeCollector(address newFeeCollector) external;\n\n    /**\n     * @dev Sets a new withdraw fee configuration\n     * @param pct Withdraw fee percentage to be set\n     * @param cap New maximum amount of withdraw fees to be charged per period\n     * @param token Address of the token cap to be set\n     * @param period New cap period length in seconds for the withdraw fee\n     */\n    function setWithdrawFee(uint256 pct, uint256 cap, address token, uint256 period) external;\n\n    /**\n     * @dev Sets a new performance fee configuration\n     * @param pct Performance fee percentage to be set\n     * @param cap New maximum amount of performance fees to be charged per period\n     * @param token Address of the token cap to be set\n     * @param period New cap period length in seconds for the performance fee\n     */\n    function setPerformanceFee(uint256 pct, uint256 cap, address token, uint256 period) external;\n\n    /**\n     * @dev Sets a new swap fee configuration\n     * @param pct Swap fee percentage to be set\n     * @param cap New maximum amount of swap fees to be charged per period\n     * @param token Address of the token cap to be set\n     * @param period New cap period length in seconds for the swap fee\n     */\n    function setSwapFee(uint256 pct, uint256 cap, address token, uint256 period) external;\n\n    /**\n     * @dev Sets a new bridge fee configuration\n     * @param pct Bridge fee percentage to be set\n     * @param cap New maximum amount of bridge fees to be charged per period\n     * @param token Address of the token cap to be set\n     * @param period New cap period length in seconds for the bridge fee\n     */\n    function setBridgeFee(uint256 pct, uint256 cap, address token, uint256 period) external;\n\n    /**\n     * @dev Tells the price of a token (base) in a given quote\n     * @param base Token to rate\n     * @param quote Token used for the price rate\n     */\n    function getPrice(address base, address quote) external view returns (uint256);\n\n    /**\n     * @dev Execute an arbitrary call from a Smart Vault\n     * @param target Address where the call will be sent\n     * @param callData Calldata to be used for the call\n     * @param value Value in wei that will be attached to the call\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return result Call response if it was successful, otherwise it reverts\n     */\n    function call(address target, bytes memory callData, uint256 value, bytes memory data)\n        external\n        returns (bytes memory result);\n\n    /**\n     * @dev Collect tokens from a sender to a Smart Vault\n     * @param token Address of the token to be collected\n     * @param from Address where the tokens will be transfer from\n     * @param amount Amount of tokens to be transferred\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return collected Amount of tokens assigned to the Smart Vault\n     */\n    function collect(address token, address from, uint256 amount, bytes memory data)\n        external\n        returns (uint256 collected);\n\n    /**\n     * @dev Withdraw tokens to an external account\n     * @param token Address of the token to be withdrawn\n     * @param amount Amount of tokens to withdraw\n     * @param recipient Address where the tokens will be transferred to\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return withdrawn Amount of tokens transferred to the recipient address\n     */\n    function withdraw(address token, uint256 amount, address recipient, bytes memory data)\n        external\n        returns (uint256 withdrawn);\n\n    /**\n     * @dev Wrap an amount of native tokens to the wrapped ERC20 version of it\n     * @param amount Amount of native tokens to be wrapped\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return wrapped Amount of tokens wrapped\n     */\n    function wrap(uint256 amount, bytes memory data) external returns (uint256 wrapped);\n\n    /**\n     * @dev Unwrap an amount of wrapped native tokens\n     * @param amount Amount of wrapped native tokens to unwrapped\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return unwrapped Amount of tokens unwrapped\n     */\n    function unwrap(uint256 amount, bytes memory data) external returns (uint256 unwrapped);\n\n    /**\n     * @dev Claim strategy rewards\n     * @param strategy Address of the strategy to claim rewards\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return tokens Addresses of the tokens received as rewards\n     * @return amounts Amounts of the tokens received as rewards\n     */\n    function claim(address strategy, bytes memory data)\n        external\n        returns (address[] memory tokens, uint256[] memory amounts);\n\n    /**\n     * @dev Join a strategy with an amount of tokens\n     * @param strategy Address of the strategy to join\n     * @param tokensIn List of token addresses to join with\n     * @param amountsIn List of token amounts to join with\n     * @param slippage Slippage that will be used to compute the join\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return tokensOut List of token addresses received after the join\n     * @return amountsOut List of token amounts received after the join\n     */\n    function join(\n        address strategy,\n        address[] memory tokensIn,\n        uint256[] memory amountsIn,\n        uint256 slippage,\n        bytes memory data\n    ) external returns (address[] memory tokensOut, uint256[] memory amountsOut);\n\n    /**\n     * @dev Exit a strategy\n     * @param strategy Address of the strategy to exit\n     * @param tokensIn List of token addresses to exit with\n     * @param amountsIn List of token amounts to exit with\n     * @param slippage Slippage that will be used to compute the exit\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return tokensOut List of token addresses received after the exit\n     * @return amountsOut List of token amounts received after the exit\n     */\n    function exit(\n        address strategy,\n        address[] memory tokensIn,\n        uint256[] memory amountsIn,\n        uint256 slippage,\n        bytes memory data\n    ) external returns (address[] memory tokensOut, uint256[] memory amountsOut);\n\n    /**\n     * @dev Swaps two tokens\n     * @param source Source to request the swap. It depends on the Swap Connector attached to a Smart Vault.\n     * @param tokenIn Token being sent\n     * @param tokenOut Token being received\n     * @param amountIn Amount of tokenIn being swapped\n     * @param limitType Swap limit to be applied: slippage or min amount out\n     * @param limitAmount Amount of the swap limit to be applied depending on limitType\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return amountOut Received amount of tokens out\n     */\n    function swap(\n        uint8 source,\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        SwapLimit limitType,\n        uint256 limitAmount,\n        bytes memory data\n    ) external returns (uint256 amountOut);\n\n    /**\n     * @dev Bridge assets to another chain\n     * @param source Source to request the bridge. It depends on the Bridge Connector attached to a Smart Vault.\n     * @param chainId ID of the destination chain\n     * @param token Address of the token to be bridged\n     * @param amount Amount of tokens to be bridged\n     * @param limitType Swap limit to be applied: slippage or min amount out\n     * @param limitAmount Amount of the swap limit to be applied depending on limitType\n     * @param recipient Address that will receive the tokens on the destination chain\n     * @param data Extra data that may enable or not different behaviors depending on the implementation\n     * @return bridged Amount requested to be bridged after fees\n     */\n    function bridge(\n        uint8 source,\n        uint256 chainId,\n        address token,\n        uint256 amount,\n        BridgeLimit limitType,\n        uint256 limitAmount,\n        address recipient,\n        bytes memory data\n    ) external returns (uint256 bridged);\n}\n"},"contracts/test/core/BridgeConnectorMock.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport '@mimic-fi/v2-bridge-connector/contracts/IBridgeConnector.sol';\nimport '@mimic-fi/v2-registry/contracts/implementations/BaseImplementation.sol';\n\nimport '../samples/BridgeMock.sol';\n\ncontract BridgeConnectorMock is IBridgeConnector, BaseImplementation {\n    bytes32 public constant override NAMESPACE = keccak256('BRIDGE_CONNECTOR');\n\n    BridgeMock public immutable bridgeMock;\n\n    constructor(address registry) BaseImplementation(registry) {\n        bridgeMock = new BridgeMock();\n    }\n\n    function bridge(\n        uint8, /* source */\n        uint256, /* chainId */\n        address token,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address recipient,\n        bytes memory data\n    ) external override {\n        IERC20(token).approve(address(bridgeMock), amountIn);\n        return bridgeMock.bridge(token, amountIn, minAmountOut, recipient, data);\n    }\n}\n"},"@mimic-fi/v2-bridge-connector/contracts/IBridgeConnector.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.0;\n\nimport '@mimic-fi/v2-registry/contracts/implementations/IImplementation.sol';\n\n/**\n * @title IBridgeConnector\n * @dev Bridge Connector interface to bridge tokens between different chains. It must follow IImplementation interface.\n */\ninterface IBridgeConnector is IImplementation {\n    /**\n     * @dev Enum identifying the sources proposed: Hop only for now.\n     */\n    enum Source {\n        Hop\n    }\n\n    /**\n     * @dev Bridge assets to a different chain\n     * @param source Source to execute the requested bridge op\n     * @param chainId ID of the destination chain\n     * @param token Address of the token to be bridged\n     * @param amountIn Amount of tokens to be bridged\n     * @param minAmountOut Minimum amount of tokens willing to receive on the destination chain\n     * @param recipient Address that will receive the tokens on the destination chain\n     * @param data ABI encoded data that will depend on the requested source\n     */\n    function bridge(\n        uint8 source,\n        uint256 chainId,\n        address token,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address recipient,\n        bytes memory data\n    ) external;\n}\n"},"@mimic-fi/v2-price-oracle/contracts/feeds/PriceFeedProvider.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@mimic-fi/v2-helpers/contracts/math/UncheckedMath.sol';\n\nimport './IPriceFeedProvider.sol';\n\n/**\n * @title IPriceFeedProvider\n * @dev Contract providing price feed references for (base, quote) token pairs\n */\ncontract PriceFeedProvider is IPriceFeedProvider {\n    using UncheckedMath for uint256;\n\n    // Mapping of price feeds from \"token A\" to \"token B\"\n    mapping (address => mapping (address => address)) private _priceFeeds;\n\n    /**\n     * @dev Tells the price feed address for (base, quote) pair. It returns the zero address if there is no one set.\n     * @param base Token to be rated\n     * @param quote Token used for the price rate\n     */\n    function getPriceFeed(address base, address quote) external view override returns (address) {\n        return _priceFeeds[base][quote];\n    }\n\n    /**\n     * @dev Sets a of price feed\n     * @param base Token base to be set\n     * @param quote Token quote to be set\n     * @param feed Price feed to be set\n     */\n    function setPriceFeed(address base, address quote, address feed) public virtual override {\n        _priceFeeds[base][quote] = feed;\n        emit PriceFeedSet(base, quote, feed);\n    }\n\n    /**\n     * @dev Sets a list of price feeds. Sender must be authorized.\n     * @param bases List of token bases to be set\n     * @param quotes List of token quotes to be set\n     * @param feeds List of price feeds to be set\n     */\n    function setPriceFeeds(address[] memory bases, address[] memory quotes, address[] memory feeds)\n        public\n        virtual\n        override\n    {\n        require(bases.length == quotes.length, 'SET_FEEDS_INVALID_QUOTES_LENGTH');\n        require(bases.length == feeds.length, 'SET_FEEDS_INVALID_FEEDS_LENGTH');\n        for (uint256 i = 0; i < bases.length; i = i.uncheckedAdd(1)) setPriceFeed(bases[i], quotes[i], feeds[i]);\n    }\n}\n"},"contracts/helpers/BridgeConnectorLib.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.8.0;\n\nimport '@openzeppelin/contracts/utils/Address.sol';\n\nimport '@mimic-fi/v2-bridge-connector/contracts/IBridgeConnector.sol';\n\n/**\n * @title BridgeConnectorLib\n * @dev Library used to delegate-call bridge ops and decode return data correctly\n */\nlibrary BridgeConnectorLib {\n    /**\n     * @dev Delegate-calls a bridge to the bridge connector and decodes de expected data\n     * IMPORTANT! This helper method does not check any of the given params, these should be checked beforehand.\n     */\n    function bridge(\n        address connector,\n        uint8 source,\n        uint256 chainId,\n        address token,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address recipient,\n        bytes memory data\n    ) internal {\n        bytes memory bridgeData = abi.encodeWithSelector(\n            IBridgeConnector.bridge.selector,\n            source,\n            chainId,\n            token,\n            amountIn,\n            minAmountOut,\n            recipient,\n            data\n        );\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = connector.delegatecall(bridgeData);\n        Address.verifyCallResult(success, returndata, 'BRIDGE_CALL_REVERTED');\n    }\n}\n"}},"settings":{"libraries":{},"optimizer":{"enabled":true,"runs":10000},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}}},"ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wrappedNativeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"what\",\"type\":\"bytes4\"}],\"name\":\"Authorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"source\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Bridge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bridgeConnector\",\"type\":\"address\"}],\"name\":\"BridgeConnectorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pct\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"BridgeFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Call\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collected\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Collect\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokensIn\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amountsIn\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokensOut\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amountsOut\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"fees\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Exit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeCollector\",\"type\":\"address\"}],\"name\":\"FeeCollectorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokensIn\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amountsIn\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokensOut\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amountsOut\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Join\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pct\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"PerformanceFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"quote\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feed\",\"type\":\"address\"}],\"name\":\"PriceFeedSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"priceOracle\",\"type\":\"address\"}],\"name\":\"PriceOracleSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"StrategySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"source\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"swapConnector\",\"type\":\"address\"}],\"name\":\"SwapConnectorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pct\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"SwapFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"what\",\"type\":\"bytes4\"}],\"name\":\"Unauthorized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unwrapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Unwrap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pct\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"WithdrawFeeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wrapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Wrap\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ANY_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAMESPACE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"what\",\"type\":\"bytes4\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"source\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum ISmartVault.BridgeLimit\",\"name\":\"limitType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"limitAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bridged\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridgeConnector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridgeFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCharged\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextResetTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"call\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"collect\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collected\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokensIn\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsIn\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"exit\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokensOut\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsOut\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quote\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quote\",\"type\":\"address\"}],\"name\":\"getPriceFeed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"investedValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"what\",\"type\":\"bytes4\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isStrategyAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"tokensIn\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsIn\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"join\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokensOut\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amountsOut\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"lastValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"performanceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCharged\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextResetTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newBridgeConnector\",\"type\":\"address\"}],\"name\":\"setBridgeConnector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"setBridgeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeCollector\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"setPerformanceFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"base\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"quote\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feed\",\"type\":\"address\"}],\"name\":\"setPriceFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"bases\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"quotes\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"feeds\",\"type\":\"address[]\"}],\"name\":\"setPriceFeeds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPriceOracle\",\"type\":\"address\"}],\"name\":\"setPriceOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSwapConnector\",\"type\":\"address\"}],\"name\":\"setSwapConnector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"setWithdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"source\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"enum ISmartVault.SwapLimit\",\"name\":\"limitType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"limitAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapConnector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCharged\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextResetTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"what\",\"type\":\"bytes4\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"unwrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unwrapped\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pct\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cap\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCharged\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextResetTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"wrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"wrapped\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wrappedNativeToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"SmartVault","CompilerVersion":"v0.8.3+commit.8d00100c","OptimizationUsed":1,"Runs":10000,"ConstructorArguments":"0x000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000de6d4872c0c8167fb4f405c7854fd2fed7edca21","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}