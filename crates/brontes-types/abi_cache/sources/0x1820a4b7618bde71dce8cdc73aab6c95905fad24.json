{"expiry":1699509698,"data":[{"SourceCode":"/* ERC1820 Pseudo-introspection Registry Contract\r\n * This standard defines a universal registry smart contract where any address (contract or regular account) can\r\n * register which interface it supports and which smart contract is responsible for its implementation.\r\n *\r\n * Written in 2019 by Jordi Baylina and Jacques Dafflon\r\n *\r\n * To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to\r\n * this software to the public domain worldwide. This software is distributed without any warranty.\r\n *\r\n * You should have received a copy of the CC0 Public Domain Dedication along with this software. If not, see\r\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\r\n *\r\n *    ███████╗██████╗  ██████╗ ██╗ █████╗ ██████╗  ██████╗\r\n *    ██╔════╝██╔══██╗██╔════╝███║██╔══██╗╚════██╗██╔═████╗\r\n *    █████╗  ██████╔╝██║     ╚██║╚█████╔╝ █████╔╝██║██╔██║\r\n *    ██╔══╝  ██╔══██╗██║      ██║██╔══██╗██╔═══╝ ████╔╝██║\r\n *    ███████╗██║  ██║╚██████╗ ██║╚█████╔╝███████╗╚██████╔╝\r\n *    ╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═╝ ╚════╝ ╚══════╝ ╚═════╝\r\n *\r\n *    ██████╗ ███████╗ ██████╗ ██╗███████╗████████╗██████╗ ██╗   ██╗\r\n *    ██╔══██╗██╔════╝██╔════╝ ██║██╔════╝╚══██╔══╝██╔══██╗╚██╗ ██╔╝\r\n *    ██████╔╝█████╗  ██║  ███╗██║███████╗   ██║   ██████╔╝ ╚████╔╝\r\n *    ██╔══██╗██╔══╝  ██║   ██║██║╚════██║   ██║   ██╔══██╗  ╚██╔╝\r\n *    ██║  ██║███████╗╚██████╔╝██║███████║   ██║   ██║  ██║   ██║\r\n *    ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝   ╚═╝\r\n *\r\n */\r\npragma solidity 0.5.3;\r\n// IV is value needed to have a vanity address starting with '0x1820'.\r\n// IV: 53759\r\n\r\n/// @dev The interface a contract MUST implement if it is the implementer of\r\n/// some (other) interface for any address other than itself.\r\ninterface ERC1820ImplementerInterface {\r\n    /// @notice Indicates whether the contract implements the interface 'interfaceHash' for the address 'addr' or not.\r\n    /// @param interfaceHash keccak256 hash of the name of the interface\r\n    /// @param addr Address for which the contract will implement the interface\r\n    /// @return ERC1820_ACCEPT_MAGIC only if the contract implements 'interfaceHash' for the address 'addr'.\r\n    function canImplementInterfaceForAddress(bytes32 interfaceHash, address addr) external view returns(bytes32);\r\n}\r\n\r\n\r\n/// @title ERC1820 Pseudo-introspection Registry Contract\r\n/// @author Jordi Baylina and Jacques Dafflon\r\n/// @notice This contract is the official implementation of the ERC1820 Registry.\r\n/// @notice For more details, see https://eips.ethereum.org/EIPS/eip-1820\r\ncontract ERC1820Registry {\r\n    /// @notice ERC165 Invalid ID.\r\n    bytes4 constant internal INVALID_ID = 0xffffffff;\r\n    /// @notice Method ID for the ERC165 supportsInterface method (= `bytes4(keccak256('supportsInterface(bytes4)'))`).\r\n    bytes4 constant internal ERC165ID = 0x01ffc9a7;\r\n    /// @notice Magic value which is returned if a contract implements an interface on behalf of some other address.\r\n    bytes32 constant internal ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));\r\n\r\n    /// @notice mapping from addresses and interface hashes to their implementers.\r\n    mapping(address => mapping(bytes32 => address)) internal interfaces;\r\n    /// @notice mapping from addresses to their manager.\r\n    mapping(address => address) internal managers;\r\n    /// @notice flag for each address and erc165 interface to indicate if it is cached.\r\n    mapping(address => mapping(bytes4 => bool)) internal erc165Cached;\r\n\r\n    /// @notice Indicates a contract is the 'implementer' of 'interfaceHash' for 'addr'.\r\n    event InterfaceImplementerSet(address indexed addr, bytes32 indexed interfaceHash, address indexed implementer);\r\n    /// @notice Indicates 'newManager' is the address of the new manager for 'addr'.\r\n    event ManagerChanged(address indexed addr, address indexed newManager);\r\n\r\n    /// @notice Query if an address implements an interface and through which contract.\r\n    /// @param _addr Address being queried for the implementer of an interface.\r\n    /// (If '_addr' is the zero address then 'msg.sender' is assumed.)\r\n    /// @param _interfaceHash Keccak256 hash of the name of the interface as a string.\r\n    /// E.g., 'web3.utils.keccak256(\"ERC777TokensRecipient\")' for the 'ERC777TokensRecipient' interface.\r\n    /// @return The address of the contract which implements the interface '_interfaceHash' for '_addr'\r\n    /// or '0' if '_addr' did not register an implementer for this interface.\r\n    function getInterfaceImplementer(address _addr, bytes32 _interfaceHash) external view returns (address) {\r\n        address addr = _addr == address(0) ? msg.sender : _addr;\r\n        if (isERC165Interface(_interfaceHash)) {\r\n            bytes4 erc165InterfaceHash = bytes4(_interfaceHash);\r\n            return implementsERC165Interface(addr, erc165InterfaceHash) ? addr : address(0);\r\n        }\r\n        return interfaces[addr][_interfaceHash];\r\n    }\r\n\r\n    /// @notice Sets the contract which implements a specific interface for an address.\r\n    /// Only the manager defined for that address can set it.\r\n    /// (Each address is the manager for itself until it sets a new manager.)\r\n    /// @param _addr Address for which to set the interface.\r\n    /// (If '_addr' is the zero address then 'msg.sender' is assumed.)\r\n    /// @param _interfaceHash Keccak256 hash of the name of the interface as a string.\r\n    /// E.g., 'web3.utils.keccak256(\"ERC777TokensRecipient\")' for the 'ERC777TokensRecipient' interface.\r\n    /// @param _implementer Contract address implementing '_interfaceHash' for '_addr'.\r\n    function setInterfaceImplementer(address _addr, bytes32 _interfaceHash, address _implementer) external {\r\n        address addr = _addr == address(0) ? msg.sender : _addr;\r\n        require(getManager(addr) == msg.sender, \"Not the manager\");\r\n\r\n        require(!isERC165Interface(_interfaceHash), \"Must not be an ERC165 hash\");\r\n        if (_implementer != address(0) && _implementer != msg.sender) {\r\n            require(\r\n                ERC1820ImplementerInterface(_implementer)\r\n                    .canImplementInterfaceForAddress(_interfaceHash, addr) == ERC1820_ACCEPT_MAGIC,\r\n                \"Does not implement the interface\"\r\n            );\r\n        }\r\n        interfaces[addr][_interfaceHash] = _implementer;\r\n        emit InterfaceImplementerSet(addr, _interfaceHash, _implementer);\r\n    }\r\n\r\n    /// @notice Sets '_newManager' as manager for '_addr'.\r\n    /// The new manager will be able to call 'setInterfaceImplementer' for '_addr'.\r\n    /// @param _addr Address for which to set the new manager.\r\n    /// @param _newManager Address of the new manager for 'addr'. (Pass '0x0' to reset the manager to '_addr'.)\r\n    function setManager(address _addr, address _newManager) external {\r\n        require(getManager(_addr) == msg.sender, \"Not the manager\");\r\n        managers[_addr] = _newManager == _addr ? address(0) : _newManager;\r\n        emit ManagerChanged(_addr, _newManager);\r\n    }\r\n\r\n    /// @notice Get the manager of an address.\r\n    /// @param _addr Address for which to return the manager.\r\n    /// @return Address of the manager for a given address.\r\n    function getManager(address _addr) public view returns(address) {\r\n        // By default the manager of an address is the same address\r\n        if (managers[_addr] == address(0)) {\r\n            return _addr;\r\n        } else {\r\n            return managers[_addr];\r\n        }\r\n    }\r\n\r\n    /// @notice Compute the keccak256 hash of an interface given its name.\r\n    /// @param _interfaceName Name of the interface.\r\n    /// @return The keccak256 hash of an interface name.\r\n    function interfaceHash(string calldata _interfaceName) external pure returns(bytes32) {\r\n        return keccak256(abi.encodePacked(_interfaceName));\r\n    }\r\n\r\n    /* --- ERC165 Related Functions --- */\r\n    /* --- Developed in collaboration with William Entriken. --- */\r\n\r\n    /// @notice Updates the cache with whether the contract implements an ERC165 interface or not.\r\n    /// @param _contract Address of the contract for which to update the cache.\r\n    /// @param _interfaceId ERC165 interface for which to update the cache.\r\n    function updateERC165Cache(address _contract, bytes4 _interfaceId) external {\r\n        interfaces[_contract][_interfaceId] = implementsERC165InterfaceNoCache(\r\n            _contract, _interfaceId) ? _contract : address(0);\r\n        erc165Cached[_contract][_interfaceId] = true;\r\n    }\r\n\r\n    /// @notice Checks whether a contract implements an ERC165 interface or not.\r\n    //  If the result is not cached a direct lookup on the contract address is performed.\r\n    //  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\r\n    //  'updateERC165Cache' with the contract address.\r\n    /// @param _contract Address of the contract to check.\r\n    /// @param _interfaceId ERC165 interface to check.\r\n    /// @return True if '_contract' implements '_interfaceId', false otherwise.\r\n    function implementsERC165Interface(address _contract, bytes4 _interfaceId) public view returns (bool) {\r\n        if (!erc165Cached[_contract][_interfaceId]) {\r\n            return implementsERC165InterfaceNoCache(_contract, _interfaceId);\r\n        }\r\n        return interfaces[_contract][_interfaceId] == _contract;\r\n    }\r\n\r\n    /// @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\r\n    /// @param _contract Address of the contract to check.\r\n    /// @param _interfaceId ERC165 interface to check.\r\n    /// @return True if '_contract' implements '_interfaceId', false otherwise.\r\n    function implementsERC165InterfaceNoCache(address _contract, bytes4 _interfaceId) public view returns (bool) {\r\n        uint256 success;\r\n        uint256 result;\r\n\r\n        (success, result) = noThrowCall(_contract, ERC165ID);\r\n        if (success == 0 || result == 0) {\r\n            return false;\r\n        }\r\n\r\n        (success, result) = noThrowCall(_contract, INVALID_ID);\r\n        if (success == 0 || result != 0) {\r\n            return false;\r\n        }\r\n\r\n        (success, result) = noThrowCall(_contract, _interfaceId);\r\n        if (success == 1 && result == 1) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @notice Checks whether the hash is a ERC165 interface (ending with 28 zeroes) or not.\r\n    /// @param _interfaceHash The hash to check.\r\n    /// @return True if '_interfaceHash' is an ERC165 interface (ending with 28 zeroes), false otherwise.\r\n    function isERC165Interface(bytes32 _interfaceHash) internal pure returns (bool) {\r\n        return _interfaceHash & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0;\r\n    }\r\n\r\n    /// @dev Make a call on a contract without throwing if the function does not exist.\r\n    function noThrowCall(address _contract, bytes4 _interfaceId)\r\n        internal view returns (uint256 success, uint256 result)\r\n    {\r\n        bytes4 erc165ID = ERC165ID;\r\n\r\n        assembly {\r\n            let x := mload(0x40)               // Find empty storage location using \"free memory pointer\"\r\n            mstore(x, erc165ID)                // Place signature at beginning of empty storage\r\n            mstore(add(x, 0x04), _interfaceId) // Place first argument directly next to signature\r\n\r\n            success := staticcall(\r\n                30000,                         // 30k gas\r\n                _contract,                     // To addr\r\n                x,                             // Inputs are stored at location x\r\n                0x24,                          // Inputs are 36 (4 + 32) bytes long\r\n                x,                             // Store output over input (saves space)\r\n                0x20                           // Outputs are 32 bytes long\r\n            )\r\n\r\n            result := mload(x)                 // Load the result\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_interfaceHash\",\"type\":\"bytes32\"},{\"name\":\"_implementer\",\"type\":\"address\"}],\"name\":\"setInterfaceImplementer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_newManager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceName\",\"type\":\"string\"}],\"name\":\"interfaceHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"updateERC165Cache\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_interfaceHash\",\"type\":\"bytes32\"}],\"name\":\"getInterfaceImplementer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"implementsERC165InterfaceNoCache\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"implementsERC165Interface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"interfaceHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"implementer\",\"type\":\"address\"}],\"name\":\"InterfaceImplementerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagerChanged\",\"type\":\"event\"}]","ContractName":"ERC1820Registry","CompilerVersion":"v0.5.3+commit.10d17f24","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":"bzzr://377f4a2d4301ede9949f163f319021a6e9c687c292a5e2b2c4734c126b524e6c"}]}