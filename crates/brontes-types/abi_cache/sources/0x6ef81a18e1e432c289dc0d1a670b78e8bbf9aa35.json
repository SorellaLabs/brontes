{"expiry":1699509696,"data":[{"SourceCode":{"language":"Solidity","sources":{"src/Libraries/LibDiamond.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IDiamondCut } from \"../Interfaces/IDiamondCut.sol\";\nimport { LibUtil } from \"../Libraries/LibUtil.sol\";\nimport { OnlyContractOwner } from \"../Errors/GenericErrors.sol\";\n\n/// Implementation of EIP-2535 Diamond Standard\n/// https://eips.ethereum.org/EIPS/eip-2535\nlibrary LibDiamond {\n    bytes32 internal constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"diamond.standard.diamond.storage\");\n\n    // Diamond specific errors\n    error IncorrectFacetCutAction();\n    error NoSelectorsInFace();\n    error FunctionAlreadyExists();\n    error FacetAddressIsZero();\n    error FacetAddressIsNotZero();\n    error FacetContainsNoCode();\n    error FunctionDoesNotExist();\n    error FunctionIsImmutable();\n    error InitZeroButCalldataNotEmpty();\n    error CalldataEmptyButInitNotZero();\n    error InitReverted();\n    // ----------------\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        if (msg.sender != diamondStorage().contractOwner)\n            revert OnlyContractOwner();\n    }\n\n    event DiamondCut(\n        IDiamondCut.FacetCut[] _diamondCut,\n        address _init,\n        bytes _calldata\n    );\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n            } else {\n                revert IncorrectFacetCutAction();\n            }\n            unchecked {\n                ++facetIndex;\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        if (_functionSelectors.length == 0) {\n            revert NoSelectorsInFace();\n        }\n        DiamondStorage storage ds = diamondStorage();\n        if (LibUtil.isZeroAddress(_facetAddress)) {\n            revert FacetAddressIsZero();\n        }\n        uint96 selectorPosition = uint96(\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\n        );\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            if (!LibUtil.isZeroAddress(oldFacetAddress)) {\n                revert FunctionAlreadyExists();\n            }\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            unchecked {\n                ++selectorPosition;\n                ++selectorIndex;\n            }\n        }\n    }\n\n    function replaceFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        if (_functionSelectors.length == 0) {\n            revert NoSelectorsInFace();\n        }\n        DiamondStorage storage ds = diamondStorage();\n        if (LibUtil.isZeroAddress(_facetAddress)) {\n            revert FacetAddressIsZero();\n        }\n        uint96 selectorPosition = uint96(\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\n        );\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            if (oldFacetAddress == _facetAddress) {\n                revert FunctionAlreadyExists();\n            }\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            unchecked {\n                ++selectorPosition;\n                ++selectorIndex;\n            }\n        }\n    }\n\n    function removeFunctions(\n        address _facetAddress,\n        bytes4[] memory _functionSelectors\n    ) internal {\n        if (_functionSelectors.length == 0) {\n            revert NoSelectorsInFace();\n        }\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        if (!LibUtil.isZeroAddress(_facetAddress)) {\n            revert FacetAddressIsNotZero();\n        }\n        for (\n            uint256 selectorIndex;\n            selectorIndex < _functionSelectors.length;\n\n        ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds\n                .selectorToFacetAndPosition[selector]\n                .facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n            unchecked {\n                ++selectorIndex;\n            }\n        }\n    }\n\n    function addFacet(\n        DiamondStorage storage ds,\n        address _facetAddress\n    ) internal {\n        enforceHasContractCode(_facetAddress);\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds\n            .facetAddresses\n            .length;\n        ds.facetAddresses.push(_facetAddress);\n    }\n\n    function addFunction(\n        DiamondStorage storage ds,\n        bytes4 _selector,\n        uint96 _selectorPosition,\n        address _facetAddress\n    ) internal {\n        ds\n            .selectorToFacetAndPosition[_selector]\n            .functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(\n            _selector\n        );\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(\n        DiamondStorage storage ds,\n        address _facetAddress,\n        bytes4 _selector\n    ) internal {\n        if (LibUtil.isZeroAddress(_facetAddress)) {\n            revert FunctionDoesNotExist();\n        }\n        // an immutable function is a function defined directly in a diamond\n        if (_facetAddress == address(this)) {\n            revert FunctionIsImmutable();\n        }\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds\n            .selectorToFacetAndPosition[_selector]\n            .functionSelectorPosition;\n        uint256 lastSelectorPosition = ds\n            .facetFunctionSelectors[_facetAddress]\n            .functionSelectors\n            .length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds\n                .facetFunctionSelectors[_facetAddress]\n                .functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[\n                selectorPosition\n            ] = lastSelector;\n            ds\n                .selectorToFacetAndPosition[lastSelector]\n                .functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds\n                .facetFunctionSelectors[_facetAddress]\n                .facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[\n                    lastFacetAddressPosition\n                ];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds\n                    .facetFunctionSelectors[lastFacetAddress]\n                    .facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds\n                .facetFunctionSelectors[_facetAddress]\n                .facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        if (LibUtil.isZeroAddress(_init)) {\n            if (_calldata.length != 0) {\n                revert InitZeroButCalldataNotEmpty();\n            }\n        } else {\n            if (_calldata.length == 0) {\n                revert CalldataEmptyButInitNotZero();\n            }\n            if (_init != address(this)) {\n                enforceHasContractCode(_init);\n            }\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert InitReverted();\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract) internal view {\n        uint256 contractSize;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        if (contractSize == 0) {\n            revert FacetContainsNoCode();\n        }\n    }\n}\n"},"src/Interfaces/IHopBridge.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IHopBridge {\n    function sendToL2(\n        uint256 chainId,\n        address recipient,\n        uint256 amount,\n        uint256 amountOutMin,\n        uint256 deadline,\n        address relayer,\n        uint256 relayerFee\n    ) external payable;\n\n    function swapAndSend(\n        uint256 chainId,\n        address recipient,\n        uint256 amount,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 deadline,\n        uint256 destinationAmountOutMin,\n        uint256 destinationDeadline\n    ) external payable;\n\n    function send(\n        uint256 chainId,\n        address recipient,\n        uint256 amount,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 deadline\n    ) external;\n}\n\ninterface IL2AmmWrapper {\n    function bridge() external view returns (address);\n\n    function l2CanonicalToken() external view returns (address);\n\n    function hToken() external view returns (address);\n\n    function exchangeAddress() external view returns (address);\n}\n\ninterface ISwap {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256);\n}\n"},"src/Libraries/LibBytes.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nlibrary LibBytes {\n    // solhint-disable no-inline-assembly\n\n    // LibBytes specific errors\n    error SliceOverflow();\n    error SliceOutOfBounds();\n    error AddressOutOfBounds();\n\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n\n    // -------------------------\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        if (_length + 31 < _length) revert SliceOverflow();\n        if (_bytes.length < _start + _length) revert SliceOutOfBounds();\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(\n                    add(tempBytes, lengthmod),\n                    mul(0x20, iszero(lengthmod))\n                )\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(\n                        add(\n                            add(_bytes, lengthmod),\n                            mul(0x20, iszero(lengthmod))\n                        ),\n                        _start\n                    )\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(\n        bytes memory _bytes,\n        uint256 _start\n    ) internal pure returns (address) {\n        if (_bytes.length < _start + 20) {\n            revert AddressOutOfBounds();\n        }\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(\n                mload(add(add(_bytes, 0x20), _start)),\n                0x1000000000000000000000000\n            )\n        }\n\n        return tempAddress;\n    }\n\n    /// Copied from OpenZeppelin's `Strings.sol` utility library.\n    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8335676b0e99944eef6a742e16dcd9ff6e68e609/contracts/utils/Strings.sol\n    function toHexString(\n        uint256 value,\n        uint256 length\n    ) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"},"src/Interfaces/IERC173.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"},"src/Facets/HopFacetOptimized.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { IHopBridge } from \"../Interfaces/IHopBridge.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { SwapperV2, LibSwap } from \"../Helpers/SwapperV2.sol\";\nimport { LibDiamond } from \"../Libraries/LibDiamond.sol\";\n\n/// @title Hop Facet (Optimized)\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Hop\n/// @custom:version 2.0.0\ncontract HopFacetOptimized is ILiFi, SwapperV2 {\n    /// Types ///\n\n    struct HopData {\n        uint256 bonderFee;\n        uint256 amountOutMin;\n        uint256 deadline;\n        uint256 destinationAmountOutMin;\n        uint256 destinationDeadline;\n        IHopBridge hopBridge;\n        address relayer;\n        uint256 relayerFee;\n        uint256 nativeFee;\n    }\n\n    /// External Methods ///\n\n    /// @notice Sets approval for the Hop Bridge to spend the specified token\n    /// @param bridges The Hop Bridges to approve\n    /// @param tokensToApprove The tokens to approve to approve to the Hop Bridges\n    function setApprovalForBridges(\n        address[] calldata bridges,\n        address[] calldata tokensToApprove\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n        for (uint256 i; i < bridges.length; i++) {\n            // Give Hop approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(tokensToApprove[i]),\n                address(bridges[i]),\n                type(uint256).max\n            );\n        }\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L1\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function startBridgeTokensViaHopL1ERC20(\n        ILiFi.BridgeData calldata _bridgeData,\n        HopData calldata _hopData\n    ) external payable {\n        // Deposit assets\n        LibAsset.transferFromERC20(\n            _bridgeData.sendingAssetId,\n            msg.sender,\n            address(this),\n            _bridgeData.minAmount\n        );\n        // Bridge assets\n        _hopData.hopBridge.sendToL2{ value: _hopData.nativeFee }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline,\n            _hopData.relayer,\n            _hopData.relayerFee\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L1\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function startBridgeTokensViaHopL1Native(\n        ILiFi.BridgeData calldata _bridgeData,\n        HopData calldata _hopData\n    ) external payable {\n        // Bridge assets\n        _hopData.hopBridge.sendToL2{\n            value: _bridgeData.minAmount + _hopData.nativeFee\n        }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline,\n            _hopData.relayer,\n            _hopData.relayerFee\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging ERC20 tokens via Hop Protocol from L1\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _hopData data specific to Hop Protocol\n    function swapAndStartBridgeTokensViaHopL1ERC20(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData calldata _hopData\n    ) external payable {\n        // Deposit and swap assets\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _hopData.nativeFee\n        );\n\n        // Bridge assets\n        _hopData.hopBridge.sendToL2{ value: _hopData.nativeFee }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline,\n            _hopData.relayer,\n            _hopData.relayerFee\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging Native tokens via Hop Protocol from L1\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _hopData data specific to Hop Protocol\n    function swapAndStartBridgeTokensViaHopL1Native(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData calldata _hopData\n    ) external payable {\n        // Deposit and swap assets\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender),\n            _hopData.nativeFee\n        );\n\n        // Bridge assets\n        _hopData.hopBridge.sendToL2{\n            value: _bridgeData.minAmount + _hopData.nativeFee\n        }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline,\n            _hopData.relayer,\n            _hopData.relayerFee\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L2\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function startBridgeTokensViaHopL2ERC20(\n        ILiFi.BridgeData calldata _bridgeData,\n        HopData calldata _hopData\n    ) external {\n        // Deposit assets\n        LibAsset.transferFromERC20(\n            _bridgeData.sendingAssetId,\n            msg.sender,\n            address(this),\n            _bridgeData.minAmount\n        );\n        // Bridge assets\n        _hopData.hopBridge.swapAndSend(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.bonderFee,\n            _hopData.amountOutMin,\n            _hopData.deadline,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L2\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _hopData data specific to Hop Protocol\n    function startBridgeTokensViaHopL2Native(\n        ILiFi.BridgeData calldata _bridgeData,\n        HopData calldata _hopData\n    ) external payable {\n        // Bridge assets\n        _hopData.hopBridge.swapAndSend{ value: _bridgeData.minAmount }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.bonderFee,\n            _hopData.amountOutMin,\n            _hopData.deadline,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging ERC20 tokens via Hop Protocol from L2\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _hopData data specific to Hop Protocol\n    function swapAndStartBridgeTokensViaHopL2ERC20(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData calldata _hopData\n    ) external payable {\n        // Deposit and swap assets\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        // Bridge assets\n        _hopData.hopBridge.swapAndSend(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.bonderFee,\n            _hopData.amountOutMin,\n            _hopData.deadline,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n\n    /// @notice Performs a swap before bridging Native tokens via Hop Protocol from L2\n    /// @param _bridgeData the core information needed for bridging\n    /// @param _swapData an array of swap related data for performing swaps before bridging\n    /// @param _hopData data specific to Hop Protocol\n    function swapAndStartBridgeTokensViaHopL2Native(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        HopData calldata _hopData\n    ) external payable {\n        // Deposit and swap assets\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n        // Bridge assets\n        _hopData.hopBridge.swapAndSend{ value: _bridgeData.minAmount }(\n            _bridgeData.destinationChainId,\n            _bridgeData.receiver,\n            _bridgeData.minAmount,\n            _hopData.bonderFee,\n            _hopData.amountOutMin,\n            _hopData.deadline,\n            _hopData.destinationAmountOutMin,\n            _hopData.destinationDeadline\n        );\n        emit LiFiTransferStarted(_bridgeData);\n    }\n}\n"},"src/Errors/GenericErrors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nerror AlreadyInitialized();\nerror CannotAuthoriseSelf();\nerror CannotBridgeToSameNetwork();\nerror ContractCallNotAllowed();\nerror CumulativeSlippageTooHigh(uint256 minAmount, uint256 receivedAmount);\nerror ExternalCallFailed();\nerror InformationMismatch();\nerror InsufficientBalance(uint256 required, uint256 balance);\nerror InvalidAmount();\nerror InvalidCallData();\nerror InvalidConfig();\nerror InvalidContract();\nerror InvalidDestinationChain();\nerror InvalidFallbackAddress();\nerror InvalidReceiver();\nerror InvalidSendingToken();\nerror NativeAssetNotSupported();\nerror NativeAssetTransferFailed();\nerror NoSwapDataProvided();\nerror NoSwapFromZeroBalance();\nerror NotAContract();\nerror NotInitialized();\nerror NoTransferToNullAddress();\nerror NullAddrIsNotAnERC20Token();\nerror NullAddrIsNotAValidSpender();\nerror OnlyContractOwner();\nerror RecoveryAddressCannotBeZero();\nerror ReentrancyError();\nerror TokenNotSupported();\nerror UnAuthorized();\nerror UnsupportedChainId(uint256 chainId);\nerror WithdrawFailed();\nerror ZeroAmount();\n"},"src/Helpers/SwapperV2.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { LibSwap } from \"../Libraries/LibSwap.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\nimport { LibAllowList } from \"../Libraries/LibAllowList.sol\";\nimport { ContractCallNotAllowed, NoSwapDataProvided, CumulativeSlippageTooHigh } from \"../Errors/GenericErrors.sol\";\n\n/// @title Swapper\n/// @author LI.FI (https://li.fi)\n/// @notice Abstract contract to provide swap functionality\ncontract SwapperV2 is ILiFi {\n    /// Types ///\n\n    /// @dev only used to get around \"Stack Too Deep\" errors\n    struct ReserveData {\n        bytes32 transactionId;\n        address payable leftoverReceiver;\n        uint256 nativeReserve;\n    }\n\n    /// Modifiers ///\n\n    /// @dev Sends any leftover balances back to the user\n    /// @notice Sends any leftover balances to the user\n    /// @param _swaps Swap data array\n    /// @param _leftoverReceiver Address to send leftover tokens to\n    /// @param _initialBalances Array of initial token balances\n    modifier noLeftovers(\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver,\n        uint256[] memory _initialBalances\n    ) {\n        uint256 numSwaps = _swaps.length;\n        if (numSwaps != 1) {\n            address finalAsset = _swaps[numSwaps - 1].receivingAssetId;\n            uint256 curBalance;\n\n            _;\n\n            for (uint256 i = 0; i < numSwaps - 1; ) {\n                address curAsset = _swaps[i].receivingAssetId;\n                // Handle multi-to-one swaps\n                if (curAsset != finalAsset) {\n                    curBalance =\n                        LibAsset.getOwnBalance(curAsset) -\n                        _initialBalances[i];\n                    if (curBalance > 0) {\n                        LibAsset.transferAsset(\n                            curAsset,\n                            _leftoverReceiver,\n                            curBalance\n                        );\n                    }\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n        } else {\n            _;\n        }\n    }\n\n    /// @dev Sends any leftover balances back to the user reserving native tokens\n    /// @notice Sends any leftover balances to the user\n    /// @param _swaps Swap data array\n    /// @param _leftoverReceiver Address to send leftover tokens to\n    /// @param _initialBalances Array of initial token balances\n    modifier noLeftoversReserve(\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver,\n        uint256[] memory _initialBalances,\n        uint256 _nativeReserve\n    ) {\n        uint256 numSwaps = _swaps.length;\n        if (numSwaps != 1) {\n            address finalAsset = _swaps[numSwaps - 1].receivingAssetId;\n            uint256 curBalance;\n\n            _;\n\n            for (uint256 i = 0; i < numSwaps - 1; ) {\n                address curAsset = _swaps[i].receivingAssetId;\n                // Handle multi-to-one swaps\n                if (curAsset != finalAsset) {\n                    curBalance =\n                        LibAsset.getOwnBalance(curAsset) -\n                        _initialBalances[i];\n                    uint256 reserve = LibAsset.isNativeAsset(curAsset)\n                        ? _nativeReserve\n                        : 0;\n                    if (curBalance > 0) {\n                        LibAsset.transferAsset(\n                            curAsset,\n                            _leftoverReceiver,\n                            curBalance - reserve\n                        );\n                    }\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n        } else {\n            _;\n        }\n    }\n\n    /// @dev Refunds any excess native asset sent to the contract after the main function\n    /// @notice Refunds any excess native asset sent to the contract after the main function\n    /// @param _refundReceiver Address to send refunds to\n    modifier refundExcessNative(address payable _refundReceiver) {\n        uint256 initialBalance = address(this).balance - msg.value;\n        _;\n        uint256 finalBalance = address(this).balance;\n\n        if (finalBalance > initialBalance) {\n            LibAsset.transferAsset(\n                LibAsset.NATIVE_ASSETID,\n                _refundReceiver,\n                finalBalance - initialBalance\n            );\n        }\n    }\n\n    /// Internal Methods ///\n\n    /// @dev Deposits value, executes swaps, and performs minimum amount check\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _minAmount the minimum amount of the final asset to receive\n    /// @param _swaps Array of data used to execute swaps\n    /// @param _leftoverReceiver The address to send leftover funds to\n    /// @return uint256 result of the swap\n    function _depositAndSwap(\n        bytes32 _transactionId,\n        uint256 _minAmount,\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver\n    ) internal returns (uint256) {\n        uint256 numSwaps = _swaps.length;\n\n        if (numSwaps == 0) {\n            revert NoSwapDataProvided();\n        }\n\n        address finalTokenId = _swaps[numSwaps - 1].receivingAssetId;\n        uint256 initialBalance = LibAsset.getOwnBalance(finalTokenId);\n\n        if (LibAsset.isNativeAsset(finalTokenId)) {\n            initialBalance -= msg.value;\n        }\n\n        uint256[] memory initialBalances = _fetchBalances(_swaps);\n\n        LibAsset.depositAssets(_swaps);\n        _executeSwaps(\n            _transactionId,\n            _swaps,\n            _leftoverReceiver,\n            initialBalances\n        );\n\n        uint256 newBalance = LibAsset.getOwnBalance(finalTokenId) -\n            initialBalance;\n\n        if (newBalance < _minAmount) {\n            revert CumulativeSlippageTooHigh(_minAmount, newBalance);\n        }\n\n        return newBalance;\n    }\n\n    /// @dev Deposits value, executes swaps, and performs minimum amount check and reserves native token for fees\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _minAmount the minimum amount of the final asset to receive\n    /// @param _swaps Array of data used to execute swaps\n    /// @param _leftoverReceiver The address to send leftover funds to\n    /// @param _nativeReserve Amount of native token to prevent from being swept back to the caller\n    function _depositAndSwap(\n        bytes32 _transactionId,\n        uint256 _minAmount,\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver,\n        uint256 _nativeReserve\n    ) internal returns (uint256) {\n        uint256 numSwaps = _swaps.length;\n\n        if (numSwaps == 0) {\n            revert NoSwapDataProvided();\n        }\n\n        address finalTokenId = _swaps[numSwaps - 1].receivingAssetId;\n        uint256 initialBalance = LibAsset.getOwnBalance(finalTokenId);\n\n        if (LibAsset.isNativeAsset(finalTokenId)) {\n            initialBalance -= msg.value;\n        }\n\n        uint256[] memory initialBalances = _fetchBalances(_swaps);\n\n        LibAsset.depositAssets(_swaps);\n        ReserveData memory rd = ReserveData(\n            _transactionId,\n            _leftoverReceiver,\n            _nativeReserve\n        );\n        _executeSwaps(rd, _swaps, initialBalances);\n\n        uint256 newBalance = LibAsset.getOwnBalance(finalTokenId) -\n            initialBalance;\n\n        if (LibAsset.isNativeAsset(finalTokenId)) {\n            newBalance -= _nativeReserve;\n        }\n\n        if (newBalance < _minAmount) {\n            revert CumulativeSlippageTooHigh(_minAmount, newBalance);\n        }\n\n        return newBalance;\n    }\n\n    /// Private Methods ///\n\n    /// @dev Executes swaps and checks that DEXs used are in the allowList\n    /// @param _transactionId the transaction id associated with the operation\n    /// @param _swaps Array of data used to execute swaps\n    /// @param _leftoverReceiver Address to send leftover tokens to\n    /// @param _initialBalances Array of initial balances\n    function _executeSwaps(\n        bytes32 _transactionId,\n        LibSwap.SwapData[] calldata _swaps,\n        address payable _leftoverReceiver,\n        uint256[] memory _initialBalances\n    ) internal noLeftovers(_swaps, _leftoverReceiver, _initialBalances) {\n        uint256 numSwaps = _swaps.length;\n        for (uint256 i = 0; i < numSwaps; ) {\n            LibSwap.SwapData calldata currentSwap = _swaps[i];\n\n            if (\n                !((LibAsset.isNativeAsset(currentSwap.sendingAssetId) ||\n                    LibAllowList.contractIsAllowed(currentSwap.approveTo)) &&\n                    LibAllowList.contractIsAllowed(currentSwap.callTo) &&\n                    LibAllowList.selectorIsAllowed(\n                        bytes4(currentSwap.callData[:4])\n                    ))\n            ) revert ContractCallNotAllowed();\n\n            LibSwap.swap(_transactionId, currentSwap);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Executes swaps and checks that DEXs used are in the allowList\n    /// @param _reserveData Data passed used to reserve native tokens\n    /// @param _swaps Array of data used to execute swaps\n    function _executeSwaps(\n        ReserveData memory _reserveData,\n        LibSwap.SwapData[] calldata _swaps,\n        uint256[] memory _initialBalances\n    )\n        internal\n        noLeftoversReserve(\n            _swaps,\n            _reserveData.leftoverReceiver,\n            _initialBalances,\n            _reserveData.nativeReserve\n        )\n    {\n        uint256 numSwaps = _swaps.length;\n        for (uint256 i = 0; i < numSwaps; ) {\n            LibSwap.SwapData calldata currentSwap = _swaps[i];\n\n            if (\n                !((LibAsset.isNativeAsset(currentSwap.sendingAssetId) ||\n                    LibAllowList.contractIsAllowed(currentSwap.approveTo)) &&\n                    LibAllowList.contractIsAllowed(currentSwap.callTo) &&\n                    LibAllowList.selectorIsAllowed(\n                        bytes4(currentSwap.callData[:4])\n                    ))\n            ) revert ContractCallNotAllowed();\n\n            LibSwap.swap(_reserveData.transactionId, currentSwap);\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Fetches balances of tokens to be swapped before swapping.\n    /// @param _swaps Array of data used to execute swaps\n    /// @return uint256[] Array of token balances.\n    function _fetchBalances(\n        LibSwap.SwapData[] calldata _swaps\n    ) private view returns (uint256[] memory) {\n        uint256 numSwaps = _swaps.length;\n        uint256[] memory balances = new uint256[](numSwaps);\n        address asset;\n        for (uint256 i = 0; i < numSwaps; ) {\n            asset = _swaps[i].receivingAssetId;\n            balances[i] = LibAsset.getOwnBalance(asset);\n\n            if (LibAsset.isNativeAsset(asset)) {\n                balances[i] -= msg.value;\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        return balances;\n    }\n}\n"},"src/Interfaces/IDiamondCut.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"},"src/Helpers/TransferrableOwnership.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IERC173 } from \"../Interfaces/IERC173.sol\";\nimport { LibAsset } from \"../Libraries/LibAsset.sol\";\n\ncontract TransferrableOwnership is IERC173 {\n    address public owner;\n    address public pendingOwner;\n\n    /// Errors ///\n    error UnAuthorized();\n    error NoNullOwner();\n    error NewOwnerMustNotBeSelf();\n    error NoPendingOwnershipTransfer();\n    error NotPendingOwner();\n\n    /// Events ///\n    event OwnershipTransferRequested(\n        address indexed _from,\n        address indexed _to\n    );\n\n    constructor(address initialOwner) {\n        owner = initialOwner;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert UnAuthorized();\n        _;\n    }\n\n    /// @notice Initiates transfer of ownership to a new address\n    /// @param _newOwner the address to transfer ownership to\n    function transferOwnership(address _newOwner) external onlyOwner {\n        if (_newOwner == LibAsset.NULL_ADDRESS) revert NoNullOwner();\n        if (_newOwner == msg.sender) revert NewOwnerMustNotBeSelf();\n        pendingOwner = _newOwner;\n        emit OwnershipTransferRequested(msg.sender, pendingOwner);\n    }\n\n    /// @notice Cancel transfer of ownership\n    function cancelOwnershipTransfer() external onlyOwner {\n        if (pendingOwner == LibAsset.NULL_ADDRESS)\n            revert NoPendingOwnershipTransfer();\n        pendingOwner = LibAsset.NULL_ADDRESS;\n    }\n\n    /// @notice Confirms transfer of ownership to the calling address (msg.sender)\n    function confirmOwnershipTransfer() external {\n        address _pendingOwner = pendingOwner;\n        if (msg.sender != _pendingOwner) revert NotPendingOwner();\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = LibAsset.NULL_ADDRESS;\n    }\n}\n"},"src/Libraries/LibAllowList.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { InvalidContract } from \"../Errors/GenericErrors.sol\";\n\n/// @title Lib Allow List\n/// @author LI.FI (https://li.fi)\n/// @notice Library for managing and accessing the conract address allow list\nlibrary LibAllowList {\n    /// Storage ///\n    bytes32 internal constant NAMESPACE =\n        keccak256(\"com.lifi.library.allow.list\");\n\n    struct AllowListStorage {\n        mapping(address => bool) allowlist;\n        mapping(bytes4 => bool) selectorAllowList;\n        address[] contracts;\n    }\n\n    /// @dev Adds a contract address to the allow list\n    /// @param _contract the contract address to add\n    function addAllowedContract(address _contract) internal {\n        _checkAddress(_contract);\n\n        AllowListStorage storage als = _getStorage();\n\n        if (als.allowlist[_contract]) return;\n\n        als.allowlist[_contract] = true;\n        als.contracts.push(_contract);\n    }\n\n    /// @dev Checks whether a contract address has been added to the allow list\n    /// @param _contract the contract address to check\n    function contractIsAllowed(\n        address _contract\n    ) internal view returns (bool) {\n        return _getStorage().allowlist[_contract];\n    }\n\n    /// @dev Remove a contract address from the allow list\n    /// @param _contract the contract address to remove\n    function removeAllowedContract(address _contract) internal {\n        AllowListStorage storage als = _getStorage();\n\n        if (!als.allowlist[_contract]) {\n            return;\n        }\n\n        als.allowlist[_contract] = false;\n\n        uint256 length = als.contracts.length;\n        // Find the contract in the list\n        for (uint256 i = 0; i < length; i++) {\n            if (als.contracts[i] == _contract) {\n                // Move the last element into the place to delete\n                als.contracts[i] = als.contracts[length - 1];\n                // Remove the last element\n                als.contracts.pop();\n                break;\n            }\n        }\n    }\n\n    /// @dev Fetch contract addresses from the allow list\n    function getAllowedContracts() internal view returns (address[] memory) {\n        return _getStorage().contracts;\n    }\n\n    /// @dev Add a selector to the allow list\n    /// @param _selector the selector to add\n    function addAllowedSelector(bytes4 _selector) internal {\n        _getStorage().selectorAllowList[_selector] = true;\n    }\n\n    /// @dev Removes a selector from the allow list\n    /// @param _selector the selector to remove\n    function removeAllowedSelector(bytes4 _selector) internal {\n        _getStorage().selectorAllowList[_selector] = false;\n    }\n\n    /// @dev Returns if selector has been added to the allow list\n    /// @param _selector the selector to check\n    function selectorIsAllowed(bytes4 _selector) internal view returns (bool) {\n        return _getStorage().selectorAllowList[_selector];\n    }\n\n    /// @dev Fetch local storage struct\n    function _getStorage()\n        internal\n        pure\n        returns (AllowListStorage storage als)\n    {\n        bytes32 position = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            als.slot := position\n        }\n    }\n\n    /// @dev Contains business logic for validating a contract address.\n    /// @param _contract address of the dex to check\n    function _checkAddress(address _contract) private view {\n        if (_contract == address(0)) revert InvalidContract();\n\n        if (_contract.code.length == 0) revert InvalidContract();\n    }\n}\n"},"src/Facets/HopFacetPacked.sol":{"content":"// // SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { IHopBridge, IL2AmmWrapper, ISwap } from \"../Interfaces/IHopBridge.sol\";\nimport { ILiFi } from \"../Interfaces/ILiFi.sol\";\nimport { ERC20, SafeTransferLib } from \"solmate/utils/SafeTransferLib.sol\";\nimport { LibAsset, IERC20 } from \"../Libraries/LibAsset.sol\";\nimport { TransferrableOwnership } from \"../Helpers/TransferrableOwnership.sol\";\nimport { HopFacetOptimized } from \"lifi/Facets/HopFacetOptimized.sol\";\nimport { WETH } from \"solmate/tokens/WETH.sol\";\n\n/// @title Hop Facet (Optimized for Rollups)\n/// @author LI.FI (https://li.fi)\n/// @notice Provides functionality for bridging through Hop\n/// @custom:version 1.0.6\ncontract HopFacetPacked is ILiFi, TransferrableOwnership {\n    using SafeTransferLib for ERC20;\n\n    /// Storage ///\n\n    address public immutable nativeBridge;\n    address public immutable nativeL2CanonicalToken;\n    address public immutable nativeHToken;\n    address public immutable nativeExchangeAddress;\n\n    /// Errors ///\n\n    error Invalid();\n\n    /// Events ///\n\n    event LiFiHopTransfer(bytes8 _transactionId);\n\n    /// Constructor ///\n\n    /// @notice Initialize the contract.\n    /// @param _owner The contract owner to approve tokens.\n    /// @param _wrapper The address of Hop L2_AmmWrapper for native asset.\n    constructor(\n        address _owner,\n        address _wrapper\n    ) TransferrableOwnership(_owner) {\n        bool wrapperIsSet = _wrapper != address(0);\n\n        if (block.chainid == 1 && wrapperIsSet) {\n            revert Invalid();\n        }\n\n        nativeL2CanonicalToken = wrapperIsSet\n            ? IL2AmmWrapper(_wrapper).l2CanonicalToken()\n            : address(0);\n        nativeHToken = wrapperIsSet\n            ? IL2AmmWrapper(_wrapper).hToken()\n            : address(0);\n        nativeExchangeAddress = wrapperIsSet\n            ? IL2AmmWrapper(_wrapper).exchangeAddress()\n            : address(0);\n        nativeBridge = wrapperIsSet\n            ? IL2AmmWrapper(_wrapper).bridge()\n            : address(0);\n    }\n\n    /// External Methods ///\n\n    /// @dev Only meant to be called outside of the context of the diamond\n    /// @notice Sets approval for the Hop Bridge to spend the specified token\n    /// @param bridges The Hop Bridges to approve\n    /// @param tokensToApprove The tokens to approve to approve to the Hop Bridges\n    function setApprovalForHopBridges(\n        address[] calldata bridges,\n        address[] calldata tokensToApprove\n    ) external onlyOwner {\n        uint256 numBridges = bridges.length;\n\n        for (uint256 i; i < numBridges; i++) {\n            // Give Hop approval to bridge tokens\n            LibAsset.maxApproveERC20(\n                IERC20(tokensToApprove[i]),\n                address(bridges[i]),\n                type(uint256).max\n            );\n        }\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L2\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaHopL2NativePacked() external payable {\n        // first 4 bytes are function signature\n        // transactionId: bytes8(msg.data[4:12]),\n        // receiver: address(bytes20(msg.data[12:32])),\n        // destinationChainId: uint256(uint32(bytes4(msg.data[32:36]))),\n        // bonderFee: uint256(uint128(bytes16(msg.data[36:52]))),\n        // amountOutMin: uint256(uint128(bytes16(msg.data[52:68])))\n        // => total calldata length required: 68\n\n        uint256 destinationChainId = uint256(uint32(bytes4(msg.data[32:36])));\n        uint256 amountOutMin = uint256(uint128(bytes16(msg.data[52:68])));\n        bool toL1 = destinationChainId == 1;\n\n        // Wrap ETH\n        WETH(payable(nativeL2CanonicalToken)).deposit{ value: msg.value }();\n\n        // Exchange WETH for hToken\n        uint256 swapAmount = ISwap(nativeExchangeAddress).swap(\n            0,\n            1,\n            msg.value,\n            amountOutMin,\n            block.timestamp\n        );\n\n        // Bridge assets\n        // solhint-disable-next-line check-send-result\n        IHopBridge(nativeBridge).send(\n            destinationChainId,\n            address(bytes20(msg.data[12:32])), // receiver\n            swapAmount,\n            uint256(uint128(bytes16(msg.data[36:52]))), // bonderFee\n            toL1 ? 0 : amountOutMin,\n            toL1 ? 0 : block.timestamp + 7 * 24 * 60 * 60\n        );\n\n        emit LiFiHopTransfer(\n            bytes8(msg.data[4:12]) // transactionId\n        );\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L2\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param bonderFee Fees payed to hop bonder\n    /// @param amountOutMin Source swap minimal accepted amount\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param destinationDeadline Destination swap maximal time\n    /// @param hopBridge Address of the Hop L2_AmmWrapper\n    function startBridgeTokensViaHopL2NativeMin(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 destinationAmountOutMin,\n        uint256 destinationDeadline,\n        address hopBridge\n    ) external payable {\n        // Bridge assets\n        IHopBridge(hopBridge).swapAndSend{ value: msg.value }(\n            destinationChainId,\n            receiver,\n            msg.value,\n            bonderFee,\n            amountOutMin,\n            block.timestamp,\n            destinationAmountOutMin,\n            destinationDeadline\n        );\n\n        emit LiFiHopTransfer(transactionId);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L2\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param bonderFee Fees payed to hop bonder\n    /// @param amountOutMin Source swap minimal accepted amount\n    function encode_startBridgeTokensViaHopL2NativePacked(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        uint256 bonderFee,\n        uint256 amountOutMin\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            bonderFee <= type(uint128).max,\n            \"bonderFee value passed too big to fit in uint128\"\n        );\n        require(\n            amountOutMin <= type(uint128).max,\n            \"amountOutMin value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                HopFacetPacked.startBridgeTokensViaHopL2NativePacked.selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes16(uint128(bonderFee)),\n                bytes16(uint128(amountOutMin))\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaHopL2NativePacked\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaHopL2NativePacked(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, HopFacetOptimized.HopData memory)\n    {\n        require(\n            _data.length >= 68,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        HopFacetOptimized.HopData memory hopData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint256(uint32(bytes4(_data[32:36])));\n        hopData.bonderFee = uint256(uint128(bytes16(_data[36:52])));\n        hopData.amountOutMin = uint256(uint128(bytes16(_data[52:68])));\n\n        return (bridgeData, hopData);\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L2\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaHopL2ERC20Packed() external {\n        // first 4 bytes are function signature\n        // transactionId: bytes8(msg.data[4:12]),\n        // receiver: address(bytes20(msg.data[12:32])),\n        // destinationChainId: uint256(uint32(bytes4(msg.data[32:36]))),\n        // sendingAssetId: address(bytes20(msg.data[36:56])),\n        // amount: uint256(uint128(bytes16(msg.data[56:72]))),\n        // bonderFee: uint256(uint128(bytes16(msg.data[72:88]))),\n        // amountOutMin: uint256(uint128(bytes16(msg.data[88:104]))),\n        // destinationAmountOutMin: uint256(uint128(bytes16(msg.data[104:120]))),\n        // destinationDeadline: uint256(uint32(bytes4(msg.data[120:124]))),\n        // wrapper: address(bytes20(msg.data[124:144]))\n        // => total calldata length required: 144\n\n        uint256 destinationChainId = uint256(uint32(bytes4(msg.data[32:36])));\n        uint256 amount = uint256(uint128(bytes16(msg.data[56:72])));\n        uint256 amountOutMin = uint256(uint128(bytes16(msg.data[88:104])));\n        bool toL1 = destinationChainId == 1;\n\n        IL2AmmWrapper wrapper = IL2AmmWrapper(\n            address(bytes20(msg.data[124:144]))\n        );\n\n        // Deposit assets\n        ERC20(address(bytes20(msg.data[36:56]))).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Exchange sending asset to hToken\n        uint256 swapAmount = ISwap(wrapper.exchangeAddress()).swap(\n            0,\n            1,\n            amount,\n            amountOutMin,\n            block.timestamp\n        );\n\n        // Bridge assets\n        // solhint-disable-next-line check-send-result\n        IHopBridge(wrapper.bridge()).send(\n            destinationChainId,\n            address(bytes20(msg.data[12:32])),\n            swapAmount,\n            uint256(uint128(bytes16(msg.data[72:88]))),\n            toL1 ? 0 : uint256(uint128(bytes16(msg.data[104:120]))),\n            toL1 ? 0 : uint256(uint32(bytes4(msg.data[120:124])))\n        );\n\n        emit LiFiHopTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L2\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param bonderFee Fees payed to hop bonder\n    /// @param amountOutMin Source swap minimal accepted amount\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param destinationDeadline Destination swap maximal time\n    /// @param hopBridge Address of the Hop L2_AmmWrapper\n    function startBridgeTokensViaHopL2ERC20Min(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 destinationAmountOutMin,\n        uint256 destinationDeadline,\n        address hopBridge\n    ) external {\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // Bridge assets\n        IHopBridge(hopBridge).swapAndSend(\n            destinationChainId,\n            receiver,\n            minAmount,\n            bonderFee,\n            amountOutMin,\n            block.timestamp,\n            destinationAmountOutMin,\n            destinationDeadline\n        );\n\n        emit LiFiHopTransfer(transactionId);\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L2\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param bonderFee Fees payed to hop bonder\n    /// @param amountOutMin Source swap minimal accepted amount\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param destinationDeadline Destination swap maximal time\n    /// @param wrapper Address of the Hop L2_AmmWrapper\n    function encode_startBridgeTokensViaHopL2ERC20Packed(\n        bytes32 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint256 bonderFee,\n        uint256 amountOutMin,\n        uint256 destinationAmountOutMin,\n        uint256 destinationDeadline,\n        address wrapper\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            minAmount <= type(uint128).max,\n            \"amount value passed too big to fit in uint128\"\n        );\n        require(\n            bonderFee <= type(uint128).max,\n            \"bonderFee value passed too big to fit in uint128\"\n        );\n        require(\n            amountOutMin <= type(uint128).max,\n            \"amountOutMin value passed too big to fit in uint128\"\n        );\n        require(\n            destinationAmountOutMin <= type(uint128).max,\n            \"destinationAmountOutMin value passed too big to fit in uint128\"\n        );\n        require(\n            destinationDeadline <= type(uint32).max,\n            \"destinationDeadline value passed too big to fit in uint32\"\n        );\n\n        return\n            bytes.concat(\n                HopFacetPacked.startBridgeTokensViaHopL2ERC20Packed.selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes16(uint128(bonderFee)),\n                bytes16(uint128(amountOutMin)),\n                bytes16(uint128(destinationAmountOutMin)),\n                bytes4(uint32(destinationDeadline)),\n                bytes20(wrapper)\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaHopL2ERC20Packed\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaHopL2ERC20Packed(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, HopFacetOptimized.HopData memory)\n    {\n        require(\n            _data.length >= 144,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        HopFacetOptimized.HopData memory hopData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint256(uint32(bytes4(_data[32:36])));\n        bridgeData.sendingAssetId = address(bytes20(_data[36:56]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[56:72])));\n        hopData.bonderFee = uint256(uint128(bytes16(_data[72:88])));\n        hopData.amountOutMin = uint256(uint128(bytes16(_data[88:104])));\n        hopData.destinationAmountOutMin = uint256(\n            uint128(bytes16(_data[104:120]))\n        );\n        hopData.destinationDeadline = uint256(uint32(bytes4(_data[120:124])));\n        hopData.hopBridge = IHopBridge(address(bytes20(_data[124:144])));\n\n        return (bridgeData, hopData);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L1\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaHopL1NativePacked() external payable {\n        // first 4 bytes are function signature\n        // transactionId: bytes8(msg.data[4:12]),\n        // receiver: address(bytes20(msg.data[12:32])),\n        // destinationChainId: uint256(uint32(bytes4(msg.data[32:36]))),\n        // destinationAmountOutMin: uint256(uint128(bytes16(msg.data[36:52]))),\n        // relayer: address(bytes20(msg.data[52:72])),\n        // relayerFee: uint256(uint128(bytes16(msg.data[72:88]))),\n        // hopBridge: address(bytes20(msg.data[88:108]))\n        // => total calldata length required: 108\n\n        // Bridge assets\n        IHopBridge(address(bytes20(msg.data[88:108]))).sendToL2{\n            value: msg.value\n        }(\n            uint256(uint32(bytes4(msg.data[32:36]))),\n            address(bytes20(msg.data[12:32])),\n            msg.value,\n            uint256(uint128(bytes16(msg.data[36:52]))),\n            block.timestamp + 7 * 24 * 60 * 60,\n            address(bytes20(msg.data[52:72])),\n            uint256(uint128(bytes16(msg.data[72:88])))\n        );\n\n        emit LiFiHopTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L1\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param relayer needed for gas spikes\n    /// @param relayerFee needed for gas spikes\n    /// @param hopBridge Address of the Hop Bridge\n    function startBridgeTokensViaHopL1NativeMin(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        uint256 destinationAmountOutMin,\n        address relayer,\n        uint256 relayerFee,\n        address hopBridge\n    ) external payable {\n        // Bridge assets\n        IHopBridge(hopBridge).sendToL2{ value: msg.value }(\n            destinationChainId,\n            receiver,\n            msg.value,\n            destinationAmountOutMin,\n            block.timestamp + 7 * 24 * 60 * 60,\n            relayer,\n            relayerFee\n        );\n\n        emit LiFiHopTransfer(transactionId);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L1\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param relayer needed for gas spikes\n    /// @param relayerFee needed for gas spikes\n    /// @param hopBridge Address of the Hop Bridge\n    function encode_startBridgeTokensViaHopL1NativePacked(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        uint256 destinationAmountOutMin,\n        address relayer,\n        uint256 relayerFee,\n        address hopBridge\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            destinationAmountOutMin <= type(uint128).max,\n            \"destinationAmountOutMin value passed too big to fit in uint128\"\n        );\n        require(\n            relayerFee <= type(uint128).max,\n            \"relayerFee value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                HopFacetPacked.startBridgeTokensViaHopL1NativePacked.selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes16(uint128(destinationAmountOutMin)),\n                bytes20(relayer),\n                bytes16(uint128(relayerFee)),\n                bytes20(hopBridge)\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaHopL1NativePacked\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaHopL1NativePacked(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, HopFacetOptimized.HopData memory)\n    {\n        require(\n            _data.length >= 108,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        HopFacetOptimized.HopData memory hopData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint256(uint32(bytes4(_data[32:36])));\n        hopData.destinationAmountOutMin = uint256(\n            uint128(bytes16(_data[36:52]))\n        );\n        // relayer = address(bytes20(_data[52:72]));\n        // relayerFee = uint256(uint128(bytes16(_data[72:88])));\n        hopData.hopBridge = IHopBridge(address(bytes20(_data[88:108])));\n\n        return (bridgeData, hopData);\n    }\n\n    /// @notice Bridges Native tokens via Hop Protocol from L1\n    /// No params, all data will be extracted from manually encoded callData\n    function startBridgeTokensViaHopL1ERC20Packed() external payable {\n        // first 4 bytes are function signature\n        // transactionId: bytes8(msg.data[4:12]),\n        // receiver: address(bytes20(msg.data[12:32])),\n        // destinationChainId: uint256(uint32(bytes4(msg.data[32:36]))),\n        // sendingAssetId: address(bytes20(msg.data[36:56])),\n        // amount: uint256(uint128(bytes16(msg.data[56:72]))),\n        // destinationAmountOutMin: uint256(uint128(bytes16(msg.data[72:88]))),\n        // relayer: address(bytes20(msg.data[88:108])),\n        // relayerFee: uint256(uint128(bytes16(msg.data[108:124]))),\n        // hopBridge: address(bytes20(msg.data[124:144]))\n        // => total calldata length required: 144\n\n        uint256 amount = uint256(uint128(bytes16(msg.data[56:72])));\n\n        // Deposit assets\n        ERC20(address(bytes20(msg.data[36:56]))).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n\n        // Bridge assets\n        IHopBridge(address(bytes20(msg.data[124:144]))).sendToL2(\n            uint256(uint32(bytes4(msg.data[32:36]))),\n            address(bytes20(msg.data[12:32])),\n            amount,\n            uint256(uint128(bytes16(msg.data[72:88]))),\n            block.timestamp + 7 * 24 * 60 * 60,\n            address(bytes20(msg.data[88:108])),\n            uint256(uint128(bytes16(msg.data[108:124])))\n        );\n\n        emit LiFiHopTransfer(bytes8(msg.data[4:12]));\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L1\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param relayer needed for gas spikes\n    /// @param relayerFee needed for gas spikes\n    /// @param hopBridge Address of the Hop Bridge\n    function startBridgeTokensViaHopL1ERC20Min(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint256 destinationAmountOutMin,\n        address relayer,\n        uint256 relayerFee,\n        address hopBridge\n    ) external {\n        // Deposit assets\n        ERC20(sendingAssetId).safeTransferFrom(\n            msg.sender,\n            address(this),\n            minAmount\n        );\n\n        // Bridge assets\n        IHopBridge(hopBridge).sendToL2(\n            destinationChainId,\n            receiver,\n            minAmount,\n            destinationAmountOutMin,\n            block.timestamp + 7 * 24 * 60 * 60,\n            relayer,\n            relayerFee\n        );\n\n        emit LiFiHopTransfer(transactionId);\n    }\n\n    /// @notice Bridges ERC20 tokens via Hop Protocol from L1\n    /// @param transactionId Custom transaction ID for tracking\n    /// @param receiver Receiving wallet address\n    /// @param destinationChainId Receiving chain\n    /// @param sendingAssetId Address of the source asset to bridge\n    /// @param minAmount Amount of the source asset to bridge\n    /// @param destinationAmountOutMin Destination swap minimal accepted amount\n    /// @param relayer needed for gas spikes\n    /// @param relayerFee needed for gas spikes\n    /// @param hopBridge Address of the Hop Bridge\n    function encode_startBridgeTokensViaHopL1ERC20Packed(\n        bytes8 transactionId,\n        address receiver,\n        uint256 destinationChainId,\n        address sendingAssetId,\n        uint256 minAmount,\n        uint256 destinationAmountOutMin,\n        address relayer,\n        uint256 relayerFee,\n        address hopBridge\n    ) external pure returns (bytes memory) {\n        require(\n            destinationChainId <= type(uint32).max,\n            \"destinationChainId value passed too big to fit in uint32\"\n        );\n        require(\n            minAmount <= type(uint128).max,\n            \"amount value passed too big to fit in uint128\"\n        );\n        require(\n            destinationAmountOutMin <= type(uint128).max,\n            \"destinationAmountOutMin value passed too big to fit in uint128\"\n        );\n        require(\n            relayerFee <= type(uint128).max,\n            \"relayerFee value passed too big to fit in uint128\"\n        );\n\n        return\n            bytes.concat(\n                HopFacetPacked.startBridgeTokensViaHopL1ERC20Packed.selector,\n                bytes8(transactionId),\n                bytes20(receiver),\n                bytes4(uint32(destinationChainId)),\n                bytes20(sendingAssetId),\n                bytes16(uint128(minAmount)),\n                bytes16(uint128(destinationAmountOutMin)),\n                bytes20(relayer),\n                bytes16(uint128(relayerFee)),\n                bytes20(hopBridge)\n            );\n    }\n\n    /// @notice Decodes calldata for startBridgeTokensViaHopL1ERC20Packed\n    /// @param _data the calldata to decode\n    function decode_startBridgeTokensViaHopL1ERC20Packed(\n        bytes calldata _data\n    )\n        external\n        pure\n        returns (BridgeData memory, HopFacetOptimized.HopData memory)\n    {\n        require(\n            _data.length >= 144,\n            \"data passed in is not the correct length\"\n        );\n\n        BridgeData memory bridgeData;\n        HopFacetOptimized.HopData memory hopData;\n\n        bridgeData.transactionId = bytes32(bytes8(_data[4:12]));\n        bridgeData.receiver = address(bytes20(_data[12:32]));\n        bridgeData.destinationChainId = uint256(uint32(bytes4(_data[32:36])));\n        bridgeData.sendingAssetId = address(bytes20(_data[36:56]));\n        bridgeData.minAmount = uint256(uint128(bytes16(_data[56:72])));\n        hopData.destinationAmountOutMin = uint256(\n            uint128(bytes16(_data[72:88]))\n        );\n        // relayer = address(bytes20(_data[88:108]));\n        // relayerFee = uint256(uint128(bytes16(_data[108:124])));\n        hopData.hopBridge = IHopBridge(address(bytes20(_data[124:144])));\n\n        return (bridgeData, hopData);\n    }\n}\n"},"lib/solmate/src/utils/SafeTransferLib.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"../tokens/ERC20.sol\";\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\nlibrary SafeTransferLib {\n    /*//////////////////////////////////////////////////////////////\n                             ETH OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferETH(address to, uint256 amount) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer the ETH and store if it succeeded or not.\n            success := call(gas(), to, amount, 0, 0, 0, 0)\n        }\n\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            ERC20 OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function safeTransferFrom(\n        ERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FROM_FAILED\");\n    }\n\n    function safeTransfer(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"TRANSFER_FAILED\");\n    }\n\n    function safeApprove(\n        ERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        bool success;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Get a pointer to some free memory.\n            let freeMemoryPointer := mload(0x40)\n\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\n\n            success := and(\n                // Set success to whether the call reverted, if not we check it either\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\n                // Counterintuitively, this call must be positioned second to the or() call in the\n                // surrounding and() call or else returndatasize() will be zero during the computation.\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\n            )\n        }\n\n        require(success, \"APPROVE_FAILED\");\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\n     * 0 before setting it to a non-zero value.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"},"src/Libraries/LibAsset.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\nimport { InsufficientBalance, NullAddrIsNotAnERC20Token, NullAddrIsNotAValidSpender, NoTransferToNullAddress, InvalidAmount, NativeAssetTransferFailed } from \"../Errors/GenericErrors.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { LibSwap } from \"./LibSwap.sol\";\n\n/// @title LibAsset\n/// @notice This library contains helpers for dealing with onchain transfers\n///         of assets, including accounting for the native asset `assetId`\n///         conventions and any noncompliant ERC20 transfers\nlibrary LibAsset {\n    uint256 private constant MAX_UINT = type(uint256).max;\n\n    address internal constant NULL_ADDRESS = address(0);\n\n    /// @dev All native assets use the empty address for their asset id\n    ///      by convention\n\n    address internal constant NATIVE_ASSETID = NULL_ADDRESS; //address(0)\n\n    /// @notice Gets the balance of the inheriting contract for the given asset\n    /// @param assetId The asset identifier to get the balance of\n    /// @return Balance held by contracts using this library\n    function getOwnBalance(address assetId) internal view returns (uint256) {\n        return\n            isNativeAsset(assetId)\n                ? address(this).balance\n                : IERC20(assetId).balanceOf(address(this));\n    }\n\n    /// @notice Transfers ether from the inheriting contract to a given\n    ///         recipient\n    /// @param recipient Address to send ether to\n    /// @param amount Amount to send to given recipient\n    function transferNativeAsset(\n        address payable recipient,\n        uint256 amount\n    ) private {\n        if (recipient == NULL_ADDRESS) revert NoTransferToNullAddress();\n        if (amount > address(this).balance)\n            revert InsufficientBalance(amount, address(this).balance);\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        if (!success) revert NativeAssetTransferFailed();\n    }\n\n    /// @notice If the current allowance is insufficient, the allowance for a given spender\n    /// is set to MAX_UINT.\n    /// @param assetId Token address to transfer\n    /// @param spender Address to give spend approval to\n    /// @param amount Amount to approve for spending\n    function maxApproveERC20(\n        IERC20 assetId,\n        address spender,\n        uint256 amount\n    ) internal {\n        if (isNativeAsset(address(assetId))) {\n            return;\n        }\n        if (spender == NULL_ADDRESS) {\n            revert NullAddrIsNotAValidSpender();\n        }\n\n        if (assetId.allowance(address(this), spender) < amount) {\n            SafeERC20.safeApprove(IERC20(assetId), spender, 0);\n            SafeERC20.safeApprove(IERC20(assetId), spender, MAX_UINT);\n        }\n    }\n\n    /// @notice Transfers tokens from the inheriting contract to a given\n    ///         recipient\n    /// @param assetId Token address to transfer\n    /// @param recipient Address to send token to\n    /// @param amount Amount to send to given recipient\n    function transferERC20(\n        address assetId,\n        address recipient,\n        uint256 amount\n    ) private {\n        if (isNativeAsset(assetId)) {\n            revert NullAddrIsNotAnERC20Token();\n        }\n        if (recipient == NULL_ADDRESS) {\n            revert NoTransferToNullAddress();\n        }\n\n        uint256 assetBalance = IERC20(assetId).balanceOf(address(this));\n        if (amount > assetBalance) {\n            revert InsufficientBalance(amount, assetBalance);\n        }\n        SafeERC20.safeTransfer(IERC20(assetId), recipient, amount);\n    }\n\n    /// @notice Transfers tokens from a sender to a given recipient\n    /// @param assetId Token address to transfer\n    /// @param from Address of sender/owner\n    /// @param to Address of recipient/spender\n    /// @param amount Amount to transfer from owner to spender\n    function transferFromERC20(\n        address assetId,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (isNativeAsset(assetId)) {\n            revert NullAddrIsNotAnERC20Token();\n        }\n        if (to == NULL_ADDRESS) {\n            revert NoTransferToNullAddress();\n        }\n\n        IERC20 asset = IERC20(assetId);\n        uint256 prevBalance = asset.balanceOf(to);\n        SafeERC20.safeTransferFrom(asset, from, to, amount);\n        if (asset.balanceOf(to) - prevBalance != amount) {\n            revert InvalidAmount();\n        }\n    }\n\n    function depositAsset(address assetId, uint256 amount) internal {\n        if (amount == 0) revert InvalidAmount();\n        if (isNativeAsset(assetId)) {\n            if (msg.value < amount) revert InvalidAmount();\n        } else {\n            uint256 balance = IERC20(assetId).balanceOf(msg.sender);\n            if (balance < amount) revert InsufficientBalance(amount, balance);\n            transferFromERC20(assetId, msg.sender, address(this), amount);\n        }\n    }\n\n    function depositAssets(LibSwap.SwapData[] calldata swaps) internal {\n        for (uint256 i = 0; i < swaps.length; ) {\n            LibSwap.SwapData calldata swap = swaps[i];\n            if (swap.requiresDeposit) {\n                depositAsset(swap.sendingAssetId, swap.fromAmount);\n            }\n            unchecked {\n                i++;\n            }\n        }\n    }\n\n    /// @notice Determines whether the given assetId is the native asset\n    /// @param assetId The asset identifier to evaluate\n    /// @return Boolean indicating if the asset is the native asset\n    function isNativeAsset(address assetId) internal pure returns (bool) {\n        return assetId == NATIVE_ASSETID;\n    }\n\n    /// @notice Wrapper function to transfer a given asset (native or erc20) to\n    ///         some recipient. Should handle all non-compliant return value\n    ///         tokens as well by using the SafeERC20 contract by open zeppelin.\n    /// @param assetId Asset id for transfer (address(0) for native asset,\n    ///                token address for erc20s)\n    /// @param recipient Address to send asset to\n    /// @param amount Amount to send to given recipient\n    function transferAsset(\n        address assetId,\n        address payable recipient,\n        uint256 amount\n    ) internal {\n        isNativeAsset(assetId)\n            ? transferNativeAsset(recipient, amount)\n            : transferERC20(assetId, recipient, amount);\n    }\n\n    /// @dev Checks whether the given address is a contract and contains code\n    function isContract(address _contractAddr) internal view returns (bool) {\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(_contractAddr)\n        }\n        return size > 0;\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"},"src/Libraries/LibSwap.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport { LibAsset } from \"./LibAsset.sol\";\nimport { LibUtil } from \"./LibUtil.sol\";\nimport { InvalidContract, NoSwapFromZeroBalance, InsufficientBalance } from \"../Errors/GenericErrors.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary LibSwap {\n    struct SwapData {\n        address callTo;\n        address approveTo;\n        address sendingAssetId;\n        address receivingAssetId;\n        uint256 fromAmount;\n        bytes callData;\n        bool requiresDeposit;\n    }\n\n    event AssetSwapped(\n        bytes32 transactionId,\n        address dex,\n        address fromAssetId,\n        address toAssetId,\n        uint256 fromAmount,\n        uint256 toAmount,\n        uint256 timestamp\n    );\n\n    function swap(bytes32 transactionId, SwapData calldata _swap) internal {\n        if (!LibAsset.isContract(_swap.callTo)) revert InvalidContract();\n        uint256 fromAmount = _swap.fromAmount;\n        if (fromAmount == 0) revert NoSwapFromZeroBalance();\n        uint256 nativeValue = LibAsset.isNativeAsset(_swap.sendingAssetId)\n            ? _swap.fromAmount\n            : 0;\n        uint256 initialSendingAssetBalance = LibAsset.getOwnBalance(\n            _swap.sendingAssetId\n        );\n        uint256 initialReceivingAssetBalance = LibAsset.getOwnBalance(\n            _swap.receivingAssetId\n        );\n\n        if (nativeValue == 0) {\n            LibAsset.maxApproveERC20(\n                IERC20(_swap.sendingAssetId),\n                _swap.approveTo,\n                _swap.fromAmount\n            );\n        }\n\n        if (initialSendingAssetBalance < _swap.fromAmount) {\n            revert InsufficientBalance(\n                _swap.fromAmount,\n                initialSendingAssetBalance\n            );\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = _swap.callTo.call{\n            value: nativeValue\n        }(_swap.callData);\n        if (!success) {\n            string memory reason = LibUtil.getRevertMsg(res);\n            revert(reason);\n        }\n\n        uint256 newBalance = LibAsset.getOwnBalance(_swap.receivingAssetId);\n\n        emit AssetSwapped(\n            transactionId,\n            _swap.callTo,\n            _swap.sendingAssetId,\n            _swap.receivingAssetId,\n            _swap.fromAmount,\n            newBalance > initialReceivingAssetBalance\n                ? newBalance - initialReceivingAssetBalance\n                : newBalance,\n            block.timestamp\n        );\n    }\n}\n"},"lib/openzeppelin-contracts/contracts/utils/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"},"src/Libraries/LibUtil.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./LibBytes.sol\";\n\nlibrary LibUtil {\n    using LibBytes for bytes;\n\n    function getRevertMsg(\n        bytes memory _res\n    ) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_res.length < 68) return \"Transaction reverted silently\";\n        bytes memory revertData = _res.slice(4, _res.length - 4); // Remove the selector which is the first 4 bytes\n        return abi.decode(revertData, (string)); // All that remains is the revert string\n    }\n\n    /// @notice Determines whether the given address is the zero address\n    /// @param addr The address to verify\n    /// @return Boolean indicating if the address is the zero address\n    function isZeroAddress(address addr) internal pure returns (bool) {\n        return addr == address(0);\n    }\n}\n"},"src/Interfaces/ILiFi.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ILiFi {\n    /// Structs ///\n\n    struct BridgeData {\n        bytes32 transactionId;\n        string bridge;\n        string integrator;\n        address referrer;\n        address sendingAssetId;\n        address receiver;\n        uint256 minAmount;\n        uint256 destinationChainId;\n        bool hasSourceSwaps;\n        bool hasDestinationCall;\n    }\n\n    /// Events ///\n\n    event LiFiTransferStarted(ILiFi.BridgeData bridgeData);\n\n    event LiFiTransferCompleted(\n        bytes32 indexed transactionId,\n        address receivingAssetId,\n        address receiver,\n        uint256 amount,\n        uint256 timestamp\n    );\n\n    event LiFiTransferRecovered(\n        bytes32 indexed transactionId,\n        address receivingAssetId,\n        address receiver,\n        uint256 amount,\n        uint256 timestamp\n    );\n\n    event LiFiGenericSwapCompleted(\n        bytes32 indexed transactionId,\n        string integrator,\n        string referrer,\n        address receiver,\n        address fromAssetId,\n        address toAssetId,\n        uint256 fromAmount,\n        uint256 toAmount\n    );\n\n    // Deprecated but kept here to include in ABI to parse historic events\n    event LiFiSwappedGeneric(\n        bytes32 indexed transactionId,\n        string integrator,\n        string referrer,\n        address fromAssetId,\n        address toAssetId,\n        uint256 fromAmount,\n        uint256 toAmount\n    );\n}\n"},"lib/solmate/src/tokens/WETH.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\nimport {ERC20} from \"./ERC20.sol\";\n\nimport {SafeTransferLib} from \"../utils/SafeTransferLib.sol\";\n\n/// @notice Minimalist and modern Wrapped Ether implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/WETH.sol)\n/// @author Inspired by WETH9 (https://github.com/dapphub/ds-weth/blob/master/src/weth9.sol)\ncontract WETH is ERC20(\"Wrapped Ether\", \"WETH\", 18) {\n    using SafeTransferLib for address;\n\n    event Deposit(address indexed from, uint256 amount);\n\n    event Withdrawal(address indexed to, uint256 amount);\n\n    function deposit() public payable virtual {\n        _mint(msg.sender, msg.value);\n\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) public virtual {\n        _burn(msg.sender, amount);\n\n        emit Withdrawal(msg.sender, amount);\n\n        msg.sender.safeTransferETH(amount);\n    }\n\n    receive() external payable virtual {\n        deposit();\n    }\n}\n"},"lib/solmate/src/tokens/ERC20.sol":{"content":"// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\nabstract contract ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /*//////////////////////////////////////////////////////////////\n                            METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    uint8 public immutable decimals;\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC20 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    uint256 internal immutable INITIAL_CHAIN_ID;\n\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\n\n    mapping(address => uint256) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        INITIAL_CHAIN_ID = block.chainid;\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               ERC20 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowance[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        balanceOf[msg.sender] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\n\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\n\n        balanceOf[from] -= amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        // Unchecked because the only math done is incrementing\n        // the owner's nonce which cannot realistically overflow.\n        unchecked {\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                keccak256(\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n                                ),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n\n            allowance[recoveredAddress][spender] = value;\n        }\n\n        emit Approval(owner, spender, value);\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\n    }\n\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name)),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 amount) internal virtual {\n        totalSupply += amount;\n\n        // Cannot overflow because the sum of all user\n        // balances can't exceed the max uint256 value.\n        unchecked {\n            balanceOf[to] += amount;\n        }\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal virtual {\n        balanceOf[from] -= amount;\n\n        // Cannot underflow because a user's balance\n        // will never be larger than the total supply.\n        unchecked {\n            totalSupply -= amount;\n        }\n\n        emit Transfer(from, address(0), amount);\n    }\n}\n"}},"settings":{"evmVersion":"london","libraries":{},"metadata":{"bytecodeHash":"ipfs"},"optimizer":{"enabled":true,"runs":1000000},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}},"remappings":["@eth-optimism/=node_modules/@hop-protocol/sdk/node_modules/@eth-optimism/","@openzeppelin/=lib/openzeppelin-contracts/","@uniswap/=node_modules/@uniswap/","celer-network/=lib/sgn-v2-contracts/","create3-factory/=lib/create3-factory/src/","ds-test/=lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","eth-gas-reporter/=node_modules/eth-gas-reporter/","forge-std/=lib/forge-std/src/","hardhat-deploy/=node_modules/hardhat-deploy/","hardhat/=node_modules/hardhat/","lifi/=src/","openzeppelin-contracts/=lib/openzeppelin-contracts/","openzeppelin/=lib/openzeppelin-contracts/contracts/","sgn-v2-contracts/=lib/sgn-v2-contracts/contracts/","solmate/=lib/solmate/src/","test/=test/"]}},"ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wrapper\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Invalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerMustNotBeSelf\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoNullOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoPendingOwnershipTransfer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPendingOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NullAddrIsNotAValidSpender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnAuthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"integrator\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"referrer\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromAssetId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAssetId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toAmount\",\"type\":\"uint256\"}],\"name\":\"LiFiGenericSwapCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes8\",\"name\":\"_transactionId\",\"type\":\"bytes8\"}],\"name\":\"LiFiHopTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"integrator\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"referrer\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromAssetId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAssetId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toAmount\",\"type\":\"uint256\"}],\"name\":\"LiFiSwappedGeneric\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receivingAssetId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"LiFiTransferCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receivingAssetId\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"LiFiTransferRecovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"bridge\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"integrator\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sendingAssetId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasSourceSwaps\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasDestinationCall\",\"type\":\"bool\"}],\"indexed\":false,\"internalType\":\"struct ILiFi.BridgeData\",\"name\":\"bridgeData\",\"type\":\"tuple\"}],\"name\":\"LiFiTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confirmOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"decode_startBridgeTokensViaHopL1ERC20Packed\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"bridge\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"integrator\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sendingAssetId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasSourceSwaps\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasDestinationCall\",\"type\":\"bool\"}],\"internalType\":\"struct ILiFi.BridgeData\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"bonderFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationAmountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationDeadline\",\"type\":\"uint256\"},{\"internalType\":\"contract IHopBridge\",\"name\":\"hopBridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"relayerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"}],\"internalType\":\"struct HopFacetOptimized.HopData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"decode_startBridgeTokensViaHopL1NativePacked\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"bridge\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"integrator\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sendingAssetId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasSourceSwaps\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasDestinationCall\",\"type\":\"bool\"}],\"internalType\":\"struct ILiFi.BridgeData\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"bonderFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationAmountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationDeadline\",\"type\":\"uint256\"},{\"internalType\":\"contract IHopBridge\",\"name\":\"hopBridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"relayerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"}],\"internalType\":\"struct HopFacetOptimized.HopData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"decode_startBridgeTokensViaHopL2ERC20Packed\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"bridge\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"integrator\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sendingAssetId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasSourceSwaps\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasDestinationCall\",\"type\":\"bool\"}],\"internalType\":\"struct ILiFi.BridgeData\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"bonderFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationAmountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationDeadline\",\"type\":\"uint256\"},{\"internalType\":\"contract IHopBridge\",\"name\":\"hopBridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"relayerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"}],\"internalType\":\"struct HopFacetOptimized.HopData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"decode_startBridgeTokensViaHopL2NativePacked\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"bridge\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"integrator\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sendingAssetId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"hasSourceSwaps\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"hasDestinationCall\",\"type\":\"bool\"}],\"internalType\":\"struct ILiFi.BridgeData\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"bonderFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationAmountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationDeadline\",\"type\":\"uint256\"},{\"internalType\":\"contract IHopBridge\",\"name\":\"hopBridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"relayerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nativeFee\",\"type\":\"uint256\"}],\"internalType\":\"struct HopFacetOptimized.HopData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes8\",\"name\":\"transactionId\",\"type\":\"bytes8\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sendingAssetId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationAmountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"relayerFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"hopBridge\",\"type\":\"address\"}],\"name\":\"encode_startBridgeTokensViaHopL1ERC20Packed\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes8\",\"name\":\"transactionId\",\"type\":\"bytes8\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationAmountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"relayerFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"hopBridge\",\"type\":\"address\"}],\"name\":\"encode_startBridgeTokensViaHopL1NativePacked\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sendingAssetId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonderFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationAmountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationDeadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wrapper\",\"type\":\"address\"}],\"name\":\"encode_startBridgeTokensViaHopL2ERC20Packed\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes8\",\"name\":\"transactionId\",\"type\":\"bytes8\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonderFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"}],\"name\":\"encode_startBridgeTokensViaHopL2NativePacked\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeBridge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeExchangeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeHToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeL2CanonicalToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"bridges\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokensToApprove\",\"type\":\"address[]\"}],\"name\":\"setApprovalForHopBridges\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes8\",\"name\":\"transactionId\",\"type\":\"bytes8\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sendingAssetId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationAmountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"relayerFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"hopBridge\",\"type\":\"address\"}],\"name\":\"startBridgeTokensViaHopL1ERC20Min\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBridgeTokensViaHopL1ERC20Packed\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes8\",\"name\":\"transactionId\",\"type\":\"bytes8\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationAmountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"relayerFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"hopBridge\",\"type\":\"address\"}],\"name\":\"startBridgeTokensViaHopL1NativeMin\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBridgeTokensViaHopL1NativePacked\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes8\",\"name\":\"transactionId\",\"type\":\"bytes8\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sendingAssetId\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonderFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationAmountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationDeadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"hopBridge\",\"type\":\"address\"}],\"name\":\"startBridgeTokensViaHopL2ERC20Min\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBridgeTokensViaHopL2ERC20Packed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes8\",\"name\":\"transactionId\",\"type\":\"bytes8\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bonderFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationAmountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationDeadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"hopBridge\",\"type\":\"address\"}],\"name\":\"startBridgeTokensViaHopL2NativeMin\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBridgeTokensViaHopL2NativePacked\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"HopFacetPacked","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":1,"Runs":1000000,"ConstructorArguments":"0x00000000000000000000000011f11121df7256c40339393b0fb045321022ce440000000000000000000000000000000000000000000000000000000000000000","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}