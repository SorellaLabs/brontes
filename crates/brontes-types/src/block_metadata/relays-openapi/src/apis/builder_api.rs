/*
 * Relay API
 *
 * API specification for MEV-Boost PBS relays.
 *
 * The version of the OpenAPI document: dev
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::apis::ResponseContent;

/// struct for typed errors of method [`get_validators`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetValidatorsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`submit_block`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubmitBlockError {
    Status400(crate::models::SubmitBlock400Response),
    Status500(crate::models::SubmitBlock400ResponseAllOf),
    UnknownValue(serde_json::Value),
}

/// * Used by builders to know when to submit bids for an upcoming proposal.  *
///   Returns an array of validator registrations for the current and next
///   epoch.  * Each entry includes a slot and the validator with assigned duty.
///   * Slots without a registered validator are omitted.
pub async fn get_validators(
    configuration: &configuration::Configuration,
) -> Result<Vec<crate::models::GetValidators200ResponseInner>, Error<GetValidatorsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str =
        format!("{}/relay/v1/builder/validators", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetValidatorsError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status:  local_var_status,
            content: local_var_content,
            entity:  local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}

/// * Blocks can be submitted as JSON or SSZ, and optionally GZIP encoded. To be
///   clear, there are four options: JSON, JSON+GZIP, SSZ, SSZ+GZIP. If JSON,
///   the   content type should be `application/json`. If SSZ, the content type
///   should   be `application/octet-stream`.  * The relay will simulate the
///   block to verify properties and proposer   payment in the payment
///   transaction from builder to proposer   `fee_recipient` at the end of
///   block.  * For accountability, builder signature is over the SSZ encoded
///   `message`.  * The `message`, which does not include the transactions, will
///   be made   public via the data API, allowing anyone to verify the builder
///   signature.  * Any new submission by a builder will overwrite a previous
///   one by the same   `builder_pubkey`, even if it is less profitable.
pub async fn submit_block(
    configuration: &configuration::Configuration,
    submit_block_request: crate::models::SubmitBlockRequest,
    cancellations: Option<&str>,
) -> Result<crate::models::SubmitBlock200Response, Error<SubmitBlockError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str =
        format!("{}/relay/v1/builder/blocks", local_var_configuration.base_path);
    let mut local_var_req_builder =
        local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = cancellations {
        local_var_req_builder =
            local_var_req_builder.query(&[("cancellations", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder =
            local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&submit_block_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<SubmitBlockError> =
            serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent {
            status:  local_var_status,
            content: local_var_content,
            entity:  local_var_entity,
        };
        Err(Error::ResponseError(local_var_error))
    }
}
