# Block Tree

The `BlockTree` decodes, classifies and normalizes a block's transaction traces into a collection of `TransactionTrees`, each representing a transaction's call hierarchy.

A `TransactionTree` organizes all EVM traces as a collection of `Action`, which form the nodes of the tree. Each `Action` normalizes core DeFi operations—such as swaps, flash loans, and mints—into a standardized format. This approach harmonizes idiosyncrasies between different DeFi protocol implementations, generalizing the representation of core primitives to establish a consistent analytical framework applicable across all protocols.

## Block Tree Building

At a high level, generating the Block Tree involves three primary steps:

<div style="text-align: center;">
 <img src="diagrams/tree-flow.png" alt="brontes-flow" style="border-radius: 20px; width: auto ; height: 600px;">
</div>

1. **Fetching Raw EVM Data**: Brontes retrieves the transaction traces and the `BlockHeader` for a block, first querying the database. If the data is not available, it is generated using a custom `revm-inspector` and stored to accelerate reruns.

2. **Tree Building**: Traced transactions are individually passed to the TxTree builder which descends through the call hierarchy, classifying each trace into a normalized action. Decoding and normalization occur via the `dispatch` macro which routes call data to it's protocol classifier. See the [Action Classification](#action-classification) section for more.

3. **Processing**: The newly built BlockTree undergoes sanitization to account for tax tokens and duplicate transfers. It also classifies multi-call frame actions, which span multiple traces. More on this in the [Complex Classification](#complex-classification) section.

## Action Classification

Each transaction trace is classified into an `Action` and an optional `DexPriceMsg` if it should be priced. The diagram below illustrates the classification process:

<div style="text-align: center;">
 <img src="diagrams/trace-classifier.png" alt="brontes-flow" style="border-radius: 10px; width: auto ; height: 600px;">
</div>

### Protocol Classifiers

The `ProtocolClassifier`, generated by the `action_dispatch` proc macro, orchestrates the call trace classification. When invoked, this macro expects a list of action classifiers, each handling a specific function and protocol. These classifiers then become potential destinations within the `dispatch` function’s routing logic.

The following code snippet shows how to use the `action_dispatch` macro to define the set of available classifiers:

```rust
action_dispatch!(
    ProtocolClassifier,
    UniswapV2SwapCall,
    UniswapV2MintCall,
    SushiSwapV2SwapCall,
    PancakeSwapV2BurnCall,
    UniswapV3SwapCall,
    ...
);
```

#### Action Dispatch

The `dispatch` function will:

1. **Retrieve Protocol Information**: Queries the database with `get_protocol` to retrieve the protocol related to the call trace target address.

2. **Create a Match Key**: Extracts the selector from the trace call data and appends the protocol byte to the function signature to form a match key.

3. **Identify the action classifier**: Compares the match key against the set of classifiers. If a match is found, it invokes `decode_trace_data` on the corresponding classifier, which takes the `CallInfo`, database connection (`db_tx`), `block`, and transaction index (`tx_idx`) as inputs.

#### Classifying the Action

//TODO: Simplify to make it clear that the point is: you define the inputs you want & the logic & then everything is generated for you
The `decode_trace_data` method of the action classifier,generated by the `action_impl` proc macro, decodes & classifies the trace. It creates the decoding logic and implements a user-defined closure that transforms the decoded data into a structured `Action`.

##### Understanding the `action_impl` Macro

The `action_impl` macro will generates the decoding logic based on the macro flags which specify which data must be decoded. call data, logs, and return data.

Here's a breakdown of the macro's structure:

```rust
action_impl!(
    ProtocolPath,            // Path to the protocol module
    PathToCall,              // Path to the specific function within the module
    CallType,                // The type of call, e.g., Swap, Mint
    [LogType],               // Array of log types, in the order they are emitted
    logs: bool,              // Flag to specify if logs should be decoded
    call_data: bool,         // Flag to specify if call data should be decoded
    return_data: bool        // Flag to specify if return data should be decoded
    call_function: ExprClosure, // Closure defining the logic to construct the action
);
```

The action classifier's name combines the last identifiers from `ProtocolPath` and `PathToCall` to ensuring uniqueness, this is what's used in the action dispatch macro above.

Let's consider this macro invocation to classify swap actions for the `MakerPSM`:

```rust
action_impl!(
    Protocol::MakerPSM,               // Specifies the protocol
    crate::MakerPSM::buyGemCall,      // Specifies the function
    Swap,                             // Action type
    [BuyGem],                         // Log type emitted by the function
    call_data: true,                  // Decode call data
    logs: true,                       // Decode log data
    |info: CallInfo,
     call_data: buyGemCall,
     log_data: MakerPSMBuyGemCallLogs,
     db_tx: &DB| {
        // Custom logic to process the data and classify the action into a swap action

        // For the PSM, the token0 should always be set to DAI and token1
        // is the gem (USDC or USDP)
        let details = db_tx.get_protocol_details(info.target_address)?;
        let [token_0, token_1] = [details.token0, details.token1];
        let t0_info = db_tx.try_fetch_token_info(token_0)?;
        let t1_info = db_tx.try_fetch_token_info(token_1)?;

        // The amount of gem token being bought
        let amount_out = call_data.gemAmt.to_scaled_rational(t1_info.decimals);

        // The fee in DAI decimals
        let fee = log_data.buy_gem_field?.fee;
        let fee_amount = fee.to_scaled_rational(t0_info.decimals);

        // The amount of DAI being spent, amount out + fee
        let amount_in = &amount_out + &amount_out * fee_amount;

        // Returns the normalized swap action
        Ok(NormalizedSwap {
            protocol: Protocol::MakerPSM,
            trace_index: info.trace_idx,
            from: info.from_address,
            recipient: call_data.usr,
            pool: info.target_address,
            token_in: t0_info,
            token_out: t1_info,
            amount_in,
            amount_out,
            msg_value: info.msg_value,
        })
    }
);
```

In this example, the macro:

- Defines inputs based on the included flags (`call_data` and `logs`).
- Executes a closure that uses the decoded call data & logs & normalizes the call into a `NormalizedSwap` action.

### Discovery Classifiers

TODO

### Implementing a New Classifier

TODO

### Complex Classification

TODO

Complex classification handles scenarios where actions are spread across multiple call frames, requiring contextual analysis beyond simple signature matching. This include:

- **Multi-Call Frame Classification**: Classifying actions that span multiple traces and can contain nested actions such as flashloans and solver batch settlements.
