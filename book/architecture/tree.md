# Block Tree

The `BlockTree` decodes, and classifies a block's transaction traces into a collection of `TransactionTrees`, each representing a transaction's call hierarchy.

A `TransactionTree` structures EVM traces as a series of `Action`, which serve as the nodes of the tree. Each `Action` normalizes core DeFi operations, such as swaps, flash loans, and mints. This approach harmonizes idiosyncratic protocol implementations, generalizing their representation to establish a consistent analytical framework.

## Block Tree Building

At a high level, generating the Block Tree involves three primary steps:

<div style="text-align: center;">
 <img src="diagrams/tree-flow.png" alt="brontes-flow" style="border-radius: 20px; width: auto ; height: 600px;">
</div>

1. **Fetching Raw EVM Data**: Brontes retrieves the transaction traces and the `BlockHeader` for a block, first querying the database. If the data is not available, it is generated using a custom `revm-inspector` and cached in the database for future use.

2. **Tree Building**: Traced transactions are individually passed to the TxTree builder which descends through the call hierarchy, classifying each trace into an `Action`. Decoding and normalization occur via the `dispatch` macro which routes call data to it's `ProtocolClassifier`. See the [Action Classification](#action-classification) section for more.

3. **Processing**: The newly built BlockTree undergoes sanitization to account for tax tokens and duplicate transfers. It also classifies multi-call frame actions, which span multiple traces. More on this in the [Complex Classification](#complex-classification) section.

## Action Classification

Each transaction trace is classified into an `Action` and an optional `DexPriceMsg` if it should be priced. The diagram below illustrates the classification process:

<div style="text-align: center;">
 <img src="diagrams/trace-classifier.png" alt="brontes-flow" style="border-radius: 10px; width: auto ; height: 600px;">
</div>

### Protocol Classifiers

The `ProtocolClassifier`, generated by the `action_dispatch` proc macro, orchestrates the call trace classification. This macro creates the `dispatch` function which routes each trace to its action classifier. These classifiers decode and normalize trace data into a standardized `Action`. To incorporate new classifiers, developers simply add them in the macro invocation.

Here is an example of how you'd declare available classifiers using the `action_dispatch` macro:

```rust,ignore
action_dispatch!(
    ProtocolClassifier,
    UniswapV2SwapCall,
    PancakeSwapV2BurnCall,
    UniswapV3SwapCall,
    ...
);
```

#### Action Dispatch

The `dispatch` function routes each call trace to its classifiers through these steps:

1. **Retrieve Protocol Information**: Fetches the protocol associated with the trace's target address by querying the `AddressToProtocolInfo` table, consistently updated by the [`DiscoveryClassifier`](#discovery-classifiers).

2. **Create a Match Key**: Append the protocol to the function signature to form a match key.

3. **Identify the action classifier**: Compares the match key against the set of classifiers. If a match is found, `decode_call_trace` is called on the corresponding classifier, passing `CallInfo`, database connection (`db_tx`), `block`, and transaction index (`tx_idx`) as inputs.

#### Classifying the Action

The `decode_call_trace` method of the action classifier, generated by the `action_impl` proc macro, decodes & classifies the trace. Developers specify the expected data inputs and the transformation logic, and the macro handles all aspects of data decoding.

#### Understanding the `action_impl` Macro

The `action_impl` macro generates all necessary decoding logic based on specified flags — namely call data, logs, and return data — allowing developers to focus solely on how the data is transformed into a normalized Action.

Here’s a breakdown of the macro's usage:

```rust,ignore
action_impl!(
    ProtocolPath,            // Path to the protocol module
    PathToCall,              // Path to the alloy binding for that function
    CallType,                // The type of action, e.g., Swap, Mint
    [LogType],               // Array of log types, in the order they are emitted
    logs: bool,              // Flag to specify if logs should be decoded
    call_data: bool,         // Flag to specify if call data should be decoded
    return_data: bool        // Flag to specify if return data should be decoded
    call_function: ExprClosure, // Closure defining the logic to construct the action
);
```

#### Example: Classifying a Maker PSM Swap Action

Let's consider this macro invocation to classify swap actions for the Maker PSM module.

```rust,ignore
action_impl!(
    Protocol::MakerPSM,               // Path to the protocol module
    crate::MakerPSM::buyGemCall,      // Specifies the function
    Swap,                             // Action type
    [BuyGem],                         // Log type emitted by the function
    call_data: true,                  // Decode call data
    logs: true,                       // Decode log data
    |info: CallInfo,
     call_data: buyGemCall,
     log_data: MakerPSMBuyGemCallLogs,
     db_tx: &DB| {
        // Custom logic to process the data and classify the action into a swap action

        // Fetches the details of this contract
        let details = db_tx.get_protocol_details(info.target_address)?;

        // For the PSM, the token0 should always be set to DAI and token1
        // is the gem (USDC or USDP)
        let [token_0, token_1] = [details.token0, details.token1];

        // Retrieves the token symbol and decimals
        let t0_info = db_tx.try_fetch_token_info(token_0)?;
        let t1_info = db_tx.try_fetch_token_info(token_1)?;

        // Extracts the amount of tokens being bought from the decoded call data
        let amount_out = call_data.gemAmt.to_scaled_rational(t1_info.decimals);

        // Extracts the fee in DAI decimals from the decoded log
        let fee = log_data.buy_gem_field?.fee;
        let fee_amount = fee.to_scaled_rational(t0_info.decimals);

        // The amount of DAI being spent, amount out + fee
        let amount_in = &amount_out + &amount_out * fee_amount;

        // Returns the normalized swap action
        Ok(NormalizedSwap {
            protocol: Protocol::MakerPSM,
            trace_index: info.trace_idx,
            from: info.from_address,
            recipient: call_data.usr,
            pool: info.target_address,
            token_in: t0_info,
            token_out: t1_info,
            amount_in,
            amount_out,
            msg_value: info.msg_value,
        })
    }
);
```

In this implementation:

- The required inputs are specified via the flags (`call_data` and `logs`).
- The closure uses the decoded call data & logs to normalize the call into a `NormalizedSwap` action.

### Discovery Classifiers

The `DiscoveryClassifier`, generated by the `discovery_dispatch` proc macro, manages the indexing of new protocol contracts. This macro creates the `dispatch` function which routes each create trace to its factory contract classifier. These classifiers the create trace a corresponding factory contract initialization function into a `NormalizedNewPool` action variant. To incorporate discovery for a protocol, developers simply add them in the macro invocation.

Here is an example of how you'd declare available discovery classifiers using the `discovery_dispatch` macro:

```rust,ignore
discovery_dispatch!(
    DiscoveryClassifier,
    UniswapV2Discovery,
    UniswapV3Discovery,
    PancakeSwapV3Discovery,
    CurveV1MetaDiscovery,
    CurveV2PlainDiscovery0,
    ...
);
```

#### Discovery Dispatch

The `dispatch` function routes each call trace to its classifiers through these steps:

1. **Create a Match Key**: Gets the immediate parent call of the create trace to retrieve the factory contract address and the factory contract initialization function signature. Appends the factory address and the function signature to form a match key.

2. **Identify the discovery classifier**: Compares the match key against the set of discovery classifiers. If a match is found, `decode_create_trace` is called on the corresponding classifier, passing `CallInfo`, database connection (`db_tx`), `block`, and transaction index (`tx_idx`) as inputs.

#### Classifying the Contract

The `decode_call_trace` method of the action classifier, generated by the `action_impl` proc macro, decodes & classifies the trace. Developers specify the expected data inputs and the transformation logic, and the macro handles all aspects of data decoding.

#### Understanding the `discovery_impl` Macro

The `action_impl` macro generates all necessary decoding logic based on specified flags — namely call data, logs, and return data — allowing developers to focus solely on how the data is transformed into a normalized Action.

Here’s a breakdown of the macro's usage:

```rust,ignore
discovery_impl!(
    UniswapV2Discovery,
    crate::UniswapV2Factory::createPairCall,
    0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f,
    |deployed_address: Address, trace_index: u64, call_data: createPairCall, _| async move {
        let token_a = call_data.tokenA;
        let token_b = call_data.tokenB;
        vec![NormalizedNewPool {
            pool_address: deployed_address,
            trace_index,
            protocol: Protocol::UniswapV2,
            tokens: vec![token_a, token_b],
        }]
    }
);
```

### Implementing a New Classifier

# TODO write uniswap v3 example

TODO

### Implementing a New Classifier

### Complex Classification

TODO

Complex classification handles scenarios where actions are spread across multiple call frames, requiring contextual analysis beyond simple signature matching. This include:

- **Multi-Call Frame Classification**: Classifying actions that span multiple traces and can contain nested actions such as flashloans and solver batch settlements.
