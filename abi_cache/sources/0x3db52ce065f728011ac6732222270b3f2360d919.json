{"expiry":1689528919,"data":[{"SourceCode":{"language":"Solidity","sources":{"@openzeppelin/contracts/access/Ownable2Step.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Ownable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() external {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n}\n"},"@openzeppelin/contracts/utils/Context.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"},"cache/solpp-generated-contracts/zksync/ValidatorTimelock.sol":{"content":"pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n\n\nimport \"@openzeppelin/contracts/access/Ownable2Step.sol\";\nimport \"./interfaces/IExecutor.sol\";\n\n/// @author Matter Labs\n/// @notice Intermediate smart contract between the validator EOA account and the zkSync smart contract.\n/// @dev The primary purpose of this contract is to provide a trustless means of delaying block execution without\n/// modifying the main zkSync contract. As such, even if this contract is compromised, it will not impact the main contract.\n/// @dev zkSync actively monitors the chain activity and reacts to any suspicious activity by freezing the chain.\n/// This allows time for investigation and mitigation before resuming normal operations.\n/// @dev The contract overloads all of the 4 methods, that are used in state transition. When the block is committed, the\n/// timestamp is stored for it. Later, when the owner calls the block execution, the contract checks that block\n/// was committed not earlier than X time ago.\ncontract ValidatorTimelock is IExecutor, Ownable2Step {\n    /// @notice The delay between committing and executing blocks is changed.\n    event NewExecutionDelay(uint256 _newExecutionDelay);\n\n    /// @notice The validator address is changed.\n    event NewValidator(address _oldValidator, address _newValidator);\n\n    /// @dev The main zkSync smart contract.\n    address public immutable zkSyncContract;\n\n    /// @dev The mapping of L2 block number => timestamp when it was commited.\n    mapping(uint256 => uint256) public committedBlockTimestamp;\n\n    /// @dev The address that can commit/revert/validate/execute blocks.\n    address public validator;\n\n    /// @dev The delay between committing and executing blocks.\n    uint256 public executionDelay;\n\n    constructor(\n        address _initialOwner,\n        address _zkSyncContract,\n        uint256 _executionDelay,\n        address _validator\n    ) {\n        _transferOwnership(_initialOwner);\n        zkSyncContract = _zkSyncContract;\n        executionDelay = _executionDelay;\n        validator = _validator;\n    }\n\n    /// @dev Set new validator address.\n    function setValidator(address _newValidator) external onlyOwner {\n        address oldValidator = validator;\n        validator = _newValidator;\n        emit NewValidator(oldValidator, _newValidator);\n    }\n\n    /// @dev Set the delay between committing and executing blocks.\n    function setExecutionDelay(uint256 _executionDelay) external onlyOwner {\n        executionDelay = _executionDelay;\n        emit NewExecutionDelay(_executionDelay);\n    }\n\n    /// @notice Checks if the caller is a validator.\n    modifier onlyValidator() {\n        require(msg.sender == validator, \"8h\");\n        _;\n    }\n\n    /// @dev Records the timestamp for all provided committed blocks and make\n    /// a call to the zkSync contract with the same calldata.\n    function commitBlocks(StoredBlockInfo calldata, CommitBlockInfo[] calldata _newBlocksData) external onlyValidator {\n        for (uint256 i = 0; i < _newBlocksData.length; ++i) {\n            committedBlockTimestamp[_newBlocksData[i].blockNumber] = block.timestamp;\n        }\n\n        _propagateToZkSync();\n    }\n\n    /// @dev Make a call to the zkSync contract with the same calldata.\n    /// Note: If the block is reverted, it needs to be committed first before the execution.\n    /// So it's safe to not override the committed blocks.\n    function revertBlocks(uint256) external onlyValidator {\n        _propagateToZkSync();\n    }\n\n    /// @dev Make a call to the zkSync contract with the same calldata.\n    /// Note: We don't track the time when blocks are proven, since all information about\n    /// the block is known on the commit stage and the proved is not finalized (may be reverted).\n    function proveBlocks(\n        StoredBlockInfo calldata,\n        StoredBlockInfo[] calldata,\n        ProofInput calldata\n    ) external onlyValidator {\n        _propagateToZkSync();\n    }\n\n    /// @dev Check that blocks were committed at least X time ago and\n    /// make a call to the zkSync contract with the same calldata.\n    function executeBlocks(StoredBlockInfo[] calldata _newBlocksData) external onlyValidator {\n        for (uint256 i = 0; i < _newBlocksData.length; ++i) {\n            uint256 commitBlockTimestamp = committedBlockTimestamp[_newBlocksData[i].blockNumber];\n\n            // Note: if the `commitBlockTimestamp` is zero, that means either:\n            // * The block was committed, but not though this contract.\n            // * The block wasn't committed at all, so execution will fail in the zkSync contract.\n            // We allow executing such blocks.\n\n            require(block.timestamp > commitBlockTimestamp + executionDelay, \"5c\"); // The delay is not passed\n        }\n\n        _propagateToZkSync();\n    }\n\n    /// @dev Call the zkSync contract with the same calldata as this contract was called.\n    /// Note: it is called the zkSync contract, not delegatecalled!\n    function _propagateToZkSync() internal {\n        address contractAddress = zkSyncContract;\n        assembly {\n            // Copy function signature and arguments from calldata at zero position into memory at pointer position\n            calldatacopy(0, 0, calldatasize())\n            // Call method of the zkSync contract returns 0 on error\n            let result := call(gas(), contractAddress, 0, 0, calldatasize(), 0, 0)\n            // Get the size of the last return data\n            let size := returndatasize()\n            // Copy the size length of bytes from return data at zero position to pointer position\n            returndatacopy(0, 0, size)\n            // Depending on the result value\n            switch result\n            case 0 {\n                // End execution and revert state changes\n                revert(0, size)\n            }\n            default {\n                // Return data with length of size at pointers position\n                return(0, size)\n            }\n        }\n    }\n}\n"},"@openzeppelin/contracts/access/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"},"cache/solpp-generated-contracts/zksync/interfaces/IExecutor.sol":{"content":"pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n\n\ninterface IExecutor {\n    /// @notice Rollup block stored data\n    /// @param blockNumber Rollup block number\n    /// @param blockHash Hash of L2 block\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\n    /// @param priorityOperationsHash Hash of all priority operations from this block\n    /// @param l2LogsTreeRoot Root hash of tree that contains L2 -> L1 messages from this block\n    /// @param timestamp Rollup block timestamp, have the same format as Ethereum block constant\n    /// @param commitment Verified input for the zkSync circuit\n    struct StoredBlockInfo {\n        uint64 blockNumber;\n        bytes32 blockHash;\n        uint64 indexRepeatedStorageChanges;\n        uint256 numberOfLayer1Txs;\n        bytes32 priorityOperationsHash;\n        bytes32 l2LogsTreeRoot;\n        uint256 timestamp;\n        bytes32 commitment;\n    }\n\n    /// @notice Data needed to commit new block\n    /// @param blockNumber Number of the committed block\n    /// @param timestamp Unix timestamp denoting the start of the block execution\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\n    /// @param newStateRoot The state root of the full state tree\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\n    /// @param l2LogsTreeRoot The root hash of the tree that contains all L2 -> L1 logs in the block\n    /// @param priorityOperationsHash Hash of all priority operations from this block\n    /// @param initialStorageChanges Storage write access as a concatenation key-value\n    /// @param repeatedStorageChanges Storage write access as a concatenation index-value\n    /// @param l2Logs concatenation of all L2 -> L1 logs in the block\n    /// @param l2ArbitraryLengthMessages array of hash preimages that were sent as value of L2 logs by special system L2 contract\n    /// @param factoryDeps array of l2 bytecodes that were marked as known on L2\n    struct CommitBlockInfo {\n        uint64 blockNumber;\n        uint64 timestamp;\n        uint64 indexRepeatedStorageChanges;\n        bytes32 newStateRoot;\n        uint256 numberOfLayer1Txs;\n        bytes32 l2LogsTreeRoot;\n        bytes32 priorityOperationsHash;\n        bytes initialStorageChanges;\n        bytes repeatedStorageChanges;\n        bytes l2Logs;\n        bytes[] l2ArbitraryLengthMessages;\n        bytes[] factoryDeps;\n    }\n\n    /// @notice Recursive proof input data (individual commitments are constructed onchain)\n    struct ProofInput {\n        uint256[] recursiveAggregationInput;\n        uint256[] serializedProof;\n    }\n\n    function commitBlocks(StoredBlockInfo calldata _lastCommittedBlockData, CommitBlockInfo[] calldata _newBlocksData)\n        external;\n\n    function proveBlocks(\n        StoredBlockInfo calldata _prevBlock,\n        StoredBlockInfo[] calldata _committedBlocks,\n        ProofInput calldata _proof\n    ) external;\n\n    function executeBlocks(StoredBlockInfo[] calldata _blocksData) external;\n\n    function revertBlocks(uint256 _newLastBlock) external;\n\n    /// @notice Event emitted when a block is committed\n    event BlockCommit(uint256 indexed blockNumber, bytes32 indexed blockHash, bytes32 indexed commitment);\n\n    /// @notice Event emitted when blocks are verified\n    event BlocksVerification(uint256 indexed previousLastVerifiedBlock, uint256 indexed currentLastVerifiedBlock);\n\n    /// @notice Event emitted when a block is executed\n    event BlockExecution(uint256 indexed blockNumber, bytes32 indexed blockHash, bytes32 indexed commitment);\n\n    /// @notice Event emitted when blocks are reverted\n    event BlocksRevert(uint256 totalBlocksCommitted, uint256 totalBlocksVerified, uint256 totalBlocksExecuted);\n}\n"}},"settings":{"libraries":{},"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}}},"ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initialOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_zkSyncContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_executionDelay\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"name\":\"BlockCommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"name\":\"BlockExecution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBlocksCommitted\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBlocksVerified\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBlocksExecuted\",\"type\":\"uint256\"}],\"name\":\"BlocksRevert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"previousLastVerifiedBlock\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"currentLastVerifiedBlock\",\"type\":\"uint256\"}],\"name\":\"BlocksVerification\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newExecutionDelay\",\"type\":\"uint256\"}],\"name\":\"NewExecutionDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_oldValidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newValidator\",\"type\":\"address\"}],\"name\":\"NewValidator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"indexRepeatedStorageChanges\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"numberOfLayer1Txs\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"priorityOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"l2LogsTreeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct IExecutor.StoredBlockInfo\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"indexRepeatedStorageChanges\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"newStateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"numberOfLayer1Txs\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"l2LogsTreeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"priorityOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"initialStorageChanges\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"repeatedStorageChanges\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"l2Logs\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"l2ArbitraryLengthMessages\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"factoryDeps\",\"type\":\"bytes[]\"}],\"internalType\":\"struct IExecutor.CommitBlockInfo[]\",\"name\":\"_newBlocksData\",\"type\":\"tuple[]\"}],\"name\":\"commitBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"committedBlockTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"indexRepeatedStorageChanges\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"numberOfLayer1Txs\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"priorityOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"l2LogsTreeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct IExecutor.StoredBlockInfo[]\",\"name\":\"_newBlocksData\",\"type\":\"tuple[]\"}],\"name\":\"executeBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executionDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"indexRepeatedStorageChanges\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"numberOfLayer1Txs\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"priorityOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"l2LogsTreeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct IExecutor.StoredBlockInfo\",\"name\":\"\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"indexRepeatedStorageChanges\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"numberOfLayer1Txs\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"priorityOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"l2LogsTreeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct IExecutor.StoredBlockInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"recursiveAggregationInput\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"serializedProof\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IExecutor.ProofInput\",\"name\":\"\",\"type\":\"tuple\"}],\"name\":\"proveBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"revertBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_executionDelay\",\"type\":\"uint256\"}],\"name\":\"setExecutionDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newValidator\",\"type\":\"address\"}],\"name\":\"setValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zkSyncContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"ValidatorTimelock","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x000000000000000000000000c301f8b2a2c08958e6e7a286ab49a986c1f7ef6a00000000000000000000000032400084c286cf3e17e7b677ea9583e60a0003240000000000000000000000000000000000000000000000000000000000015180000000000000000000000000112200eaa6d57120c86b8b51a8b6049d56b82211","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}