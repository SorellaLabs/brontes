{"expiry":1689528948,"data":[{"SourceCode":{"language":"Solidity","sources":{"contracts/interfaces/IAvoVersionsRegistry.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\ninterface IAvoVersionsRegistry {\n    /// @notice                   checks if an address is listed as allowed AvoWallet version and reverts if it is not\n    /// @param avoWalletVersion_  address of the Avo wallet logic contract to check\n    function requireValidAvoWalletVersion(address avoWalletVersion_) external view;\n\n    /// @notice                      checks if an address is listed as allowed AvoForwarder version\n    ///                              and reverts if it is not\n    /// @param avoForwarderVersion_  address of the AvoForwarder logic contract to check\n    function requireValidAvoForwarderVersion(address avoForwarderVersion_) external view;\n}\n"},"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"},"contracts/AvoSafe.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\n/// @title   IAvoSafe\n/// @notice  interface to access _avoWalletImpl on-chain\ninterface IAvoSafe {\n    function _avoWalletImpl() external view returns (address);\n}\n\n/// @title      AvoSafe\n/// @notice     Proxy for AvoWallets as deployed by the AvoFactory.\n///             Basic Proxy with fallback to delegate and address for implementation contract at storage 0x0\n/// @dev        If this contract changes then the deployment addresses for new AvoSafes through factory change too!!\n///             Relayers might want to pass in version as new param then to forward to the correct factory\ncontract AvoSafe {\n    /// @notice address of the Avo wallet logic / implementation contract. IMPORTANT: SAME STORAGE SLOT AS FOR PROXY\n    /// @dev    _avoWalletImpl MUST ALWAYS be the first declared variable here in the proxy and in the logic contract\n    ///         when upgrading, the storage at memory address 0x0 is upgraded (first slot).\n    ///         To reduce deployment costs this variable is internal but can still be retrieved with\n    ///         _avoWalletImpl(), see code and comments in fallback below\n    address internal _avoWalletImpl;\n\n    /// @notice   sets _avoWalletImpl address, fetching it from msg.sender via avoWalletImpl()\n    /// @dev      avoWalletImpl_ is not an input param to not influence the deterministic Create2 address!\n    constructor() {\n        // \"\\x8e\\x7d\\xaf\\x69\" is hardcoded bytes of function selector for avoWalletImpl()\n        (bool success_, bytes memory data_) = msg.sender.call(bytes(\"\\x8e\\x7d\\xaf\\x69\"));\n\n        address avoWalletImpl_;\n        assembly {\n            // cast last 20 bytes of hash to address\n            avoWalletImpl_ := mload(add(data_, 32))\n        }\n\n        if (!success_ || avoWalletImpl_.code.length == 0) {\n            revert();\n        }\n\n        _avoWalletImpl = avoWalletImpl_;\n    }\n\n    /// @notice Delegates the current call to `_avoWalletImpl` unless _avoWalletImpl() is called\n    ///         if _avoWalletImpl() is called then the address for _avoWalletImpl is returned\n    /// @dev    Mostly based on OpenZeppelin Proxy.sol\n    fallback() external payable {\n        assembly {\n            // load address avoWalletImpl_ from storage\n            let avoWalletImpl_ := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n\n            // first 4 bytes of calldata specify which function to call.\n            // if those first 4 bytes == 87e9052a (function selector for _avoWalletImpl()) then we return the _avoWalletImpl address\n            // The value is right padded to 32-bytes with 0s\n            if eq(calldataload(0), 0x87e9052a00000000000000000000000000000000000000000000000000000000) {\n                mstore(0, avoWalletImpl_) // store address avoWalletImpl_ at memory address 0x0\n                return(0, 0x20) // send first 20 bytes of address at memory address 0x0\n            }\n\n            // @dev code below is taken from OpenZeppelin Proxy.sol _delegate function\n\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), avoWalletImpl_, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"},"contracts/interfaces/IAvoWalletV1.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\ninterface IAvoWalletV1 {\n    /// @notice an executable action via low-level call, including target, data and value\n    struct Action {\n        address target; // the targets to execute the actions on\n        bytes data; // the data to be passed to the .call for each target\n        uint256 value; // the msg.value to be passed to the .call for each target. set to 0 if none\n    }\n\n    /// @notice             AvoSafe Owner\n    function owner() external view returns (address);\n\n    /// @notice             Domain separator name for signatures\n    function DOMAIN_SEPARATOR_NAME() external view returns (string memory);\n\n    /// @notice             Domain separator version for signatures\n    function DOMAIN_SEPARATOR_VERSION() external view returns (string memory);\n\n    /// @notice             incrementing nonce for each valid tx executed (to ensure unique)\n    function avoSafeNonce() external view returns (uint96);\n\n    /// @notice             initializer called by AvoFactory after deployment\n    /// @param owner_       the owner (immutable) of this smart wallet\n    function initialize(address owner_) external;\n\n    /// @notice             returns the domainSeparator for EIP712 signature\n    /// @return             the bytes32 domainSeparator for EIP712 signature\n    function domainSeparatorV4() external view returns (bytes32);\n\n    /// @notice             Verify the transaction is valid and can be executed.\n    ///                     Does not revert and returns successfully if the input is valid.\n    ///                     Reverts if any validation has failed. For instance, if params or either signature or avoSafeNonce are incorrect.\n    /// @param actions_     the actions to execute (target, data, value)\n    /// @param validUntil_  As EIP-2770: the highest block number the request can be forwarded in, or 0 if request validity is not time-limited\n    ///                     Protects against relayers executing a certain transaction at a later moment not intended by the user, where it might\n    ///                     have a completely different effect. (Given that the transaction is not executed right away for some reason)\n    /// @param gas_         As EIP-2770: an amount of gas limit to set for the execution\n    ///                     Protects gainst potential gas griefing attacks / the relayer getting a reward without properly executing the tx completely\n    ///                     See https://ronan.eth.limo/blog/ethereum-gas-dangers/\n    /// @param source_      Source like e.g. referral for this tx\n    /// @param metadata_    Optional metadata for future flexibility\n    /// @param signature_   the EIP712 signature, see verifySig method\n    /// @return             returns true if everything is valid, otherwise reverts\n    function verify(\n        Action[] calldata actions_,\n        uint256 validUntil_,\n        uint256 gas_,\n        address source_,\n        bytes calldata metadata_,\n        bytes calldata signature_\n    ) external view returns (bool);\n\n    /// @notice               executes arbitrary actions according to datas on targets\n    ///                       if one action fails, the transaction doesn't revert. Instead the CastFailed event is emitted\n    ///                       and all previous actions are reverted. On success, emits CastExecuted event.\n    /// @dev                  validates EIP712 signature then executes a .call for every action.\n    /// @param actions_       the actions to execute (target, data, value)\n    /// @param validUntil_    As EIP-2770: the highest block number the request can be forwarded in, or 0 if request validity is not time-limited\n    ///                       Protects against relayers executing a certain transaction at a later moment not intended by the user, where it might\n    ///                       have a completely different effect. (Given that the transaction is not executed right away for some reason)\n    /// @param gas_           As EIP-2770: an amount of gas limit to set for the execution\n    ///                       Protects gainst potential gas griefing attacks / the relayer getting a reward without properly executing the tx completely\n    ///                       See https://ronan.eth.limo/blog/ethereum-gas-dangers/\n    /// @param source_        Source like e.g. referral for this tx\n    /// @param metadata_      Optional metadata for future flexibility\n    /// @param signature_     the EIP712 signature, see verifySig method\n    /// @return success       true if all actions were executed succesfully, false otherwise.\n    /// @return revertReason  revert reason if one of the actions fail\n    function cast(\n        Action[] calldata actions_,\n        uint256 validUntil_,\n        uint256 gas_,\n        address source_,\n        bytes calldata metadata_,\n        bytes calldata signature_\n    ) external payable returns (bool success, string memory revertReason);\n}\n"},"contracts/interfaces/IAvoFactory.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\nimport { IAvoVersionsRegistry } from \"./IAvoVersionsRegistry.sol\";\n\ninterface IAvoFactory {\n    /// @notice AvoVersionsRegistry (proxy) address\n    /// @return contract address\n    function avoVersionsRegistry() external view returns (IAvoVersionsRegistry);\n\n    /// @notice Avo wallet logic contract address that new AvoSafe deployments point to\n    /// @return contract address\n    function avoWalletImpl() external view returns (address);\n\n    /// @notice           Checks if a certain address is an AvoSafe instance. only works for already deployed AvoSafes\n    /// @param avoSafe_   address to check\n    /// @return           true if address is an avoSafe\n    function isAvoSafe(address avoSafe_) external view returns (bool);\n\n    /// @notice         Computes the deterministic address for owner based on Create2\n    /// @param owner_   AvoSafe Owner\n    /// @return         computed address for the contract (AvoSafe)\n    function computeAddress(address owner_) external view returns (address);\n\n    /// @notice         Deploys an AvoSafe for a certain owner deterministcally using Create2.\n    ///                 Does not check if contract at address already exists. AvoForwarder already does that.\n    /// @param owner_   AvoSafe owner\n    /// @return         deployed address for the contract (AvoSafe)\n    function deploy(address owner_) external returns (address);\n\n    /// @notice                    Deploys an AvoSafe with non-default version for an owner deterministcally using Create2.\n    ///                            ATTENTION: Only supports AvoWallet version > 2.0.0\n    ///                            Does not check if contract at address already exists. AvoForwarder already does that.\n    /// @param owner_              AvoSafe owner\n    /// @param avoWalletVersion_   Version of AvoWallet logic contract to deploy\n    /// @return                    deployed address for the contract (AvoSafe)\n    function deployWithVersion(address owner_, address avoWalletVersion_) external returns (address);\n\n    /// @notice                   registry can update the current AvoWallet implementation contract\n    ///                           set as default for new AvoSafe (proxy) deployments logic contract\n    /// @param avoWalletImpl_     the new avoWalletImpl address\n    function setAvoWalletImpl(address avoWalletImpl_) external;\n\n    /// @notice      reads the byteCode for the AvoSafe contract used for Create2 address computation\n    /// @return      the bytes32 byteCode for the contract\n    function avoSafeBytecode() external view returns (bytes32);\n}\n"},"contracts/interfaces/IAvoWalletV2.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\ninterface IAvoWalletV2 {\n    /// @notice an executable action via low-level call, including operation (call or delegateCall), target, data and value\n    struct Action {\n        address target; // the targets to execute the actions on\n        bytes data; // the data to be passed to the call for each target\n        uint256 value; // the msg.value to be passed to the call for each target. set to 0 if none\n        uint256 operation; // 0 -> .call; 1 -> .delegateCall, 2 -> flashloan (via .call), id must be 0 or 2\n    }\n\n    struct CastParams {\n        /// @param validUntil     As EIP-2770: the highest block number the request can be forwarded in, or 0 if request validity is not time-limited\n        ///                       Protects against relayers executing a certain transaction at a later moment not intended by the user, where it might\n        ///                       have a completely different effect. (Given that the transaction is not executed right away for some reason)\n        uint256 validUntil;\n        /// @param gas            As EIP-2770: an amount of gas limit to set for the execution\n        ///                       Protects gainst potential gas griefing attacks / the relayer getting a reward without properly executing the tx completely\n        ///                       See https://ronan.eth.limo/blog/ethereum-gas-dangers/\n        uint256 gas;\n        /// @param source         Source like e.g. referral for this tx\n        address source;\n        /// @param id             id for actions, e.g. 0 = CALL, 1 = MIXED (call and delegatecall), 20 = FLASHLOAN_CALL, 21 = FLASHLOAN_MIXED\n        uint256 id;\n        /// @param metadata       Optional metadata for future flexibility\n        bytes metadata;\n    }\n\n    /// @notice struct containing variables in storage for a snapshot\n    struct StorageSnapshot {\n        address avoWalletImpl;\n        uint88 avoSafeNonce;\n        address owner;\n    }\n\n    /// @notice             AvoSafe Owner\n    function owner() external view returns (address);\n\n    /// @notice             Domain separator name for signatures\n    function DOMAIN_SEPARATOR_NAME() external view returns (string memory);\n\n    /// @notice             Domain separator version for signatures\n    function DOMAIN_SEPARATOR_VERSION() external view returns (string memory);\n\n    /// @notice             incrementing nonce for each valid tx executed (to ensure unique)\n    function avoSafeNonce() external view returns (uint88);\n\n    /// @notice             initializer called by AvoFactory after deployment\n    /// @param owner_       the owner (immutable) of this smart wallet\n    function initialize(address owner_) external;\n\n    /// @notice                     initialize contract and set new AvoWallet version\n    /// @param owner_               the owner (immutable) of this smart wallet\n    /// @param avoWalletVersion_    version of AvoWallet logic contract to deploy\n    function initializeWithVersion(address owner_, address avoWalletVersion_) external;\n\n    /// @notice             returns the domainSeparator for EIP712 signature\n    /// @return             the bytes32 domainSeparator for EIP712 signature\n    function domainSeparatorV4() external view returns (bytes32);\n\n    /// @notice               Verify the transaction is valid and can be executed.\n    ///                       Does not revert and returns successfully if the input is valid.\n    ///                       Reverts if any validation has failed. For instance, if params or either signature or avoSafeNonce are incorrect.\n    /// @param actions_       the actions to execute (target, data, value)\n    /// @param params_        Cast params: validUntil, gas, source, id and metadata\n    /// @param signature_     the EIP712 signature, see verifySig method\n    /// @return               returns true if everything is valid, otherwise reverts\n    function verify(\n        Action[] calldata actions_,\n        CastParams calldata params_,\n        bytes calldata signature_\n    ) external view returns (bool);\n\n    /// @notice               executes arbitrary actions according to datas on targets\n    ///                       if one action fails, the transaction doesn't revert. Instead the CastFailed event is emitted\n    ///                       and all previous actions are reverted. On success, emits CastExecuted event.\n    /// @dev                  validates EIP712 signature then executes a .call or .delegateCall for every action.\n    /// @param actions_       the actions to execute (target, data, value)\n    /// @param params_        Cast params: validUntil, gas, source, id and metadata\n    /// @param signature_     the EIP712 signature, see verifySig method\n    /// @return success       true if all actions were executed succesfully, false otherwise.\n    /// @return revertReason  revert reason if one of the actions fail\n    function cast(\n        Action[] calldata actions_,\n        CastParams calldata params_,\n        bytes calldata signature_\n    ) external payable returns (bool success, string memory revertReason);\n}\n"},"@openzeppelin/contracts/utils/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"},"contracts/AvoForwarder.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\nimport { Address } from \"@openzeppelin/contracts/utils/Address.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { IAvoFactory } from \"./interfaces/IAvoFactory.sol\";\nimport { IAvoWalletV1 } from \"./interfaces/IAvoWalletV1.sol\";\nimport { IAvoWalletV2 } from \"./interfaces/IAvoWalletV2.sol\";\nimport { IAvoSafe } from \"./AvoSafe.sol\";\n\n/// @title    AvoForwarder\n/// @notice   Only compatible with forwarding `cast` calls to AvoWallet contracts. This is not a generic forwarder.\n///           This is NOT a \"TrustedForwarder\" as proposed in EIP-2770. See notice in AvoWallet.\n/// @dev      Does not validate the EIP712 signature (instead this is done in the AvoWallet)\n///           contract is Upgradeable through AvoForwarderProxy\ncontract AvoForwarder is Initializable {\n    using Address for address;\n\n    /***********************************|\n    |                ERRORS             |\n    |__________________________________*/\n\n    error AvoForwarder__VersionMismatch();\n    error AvoForwarder__InvalidParams();\n    error AvoForwarder__Unauthorized();\n    error AvoForwarder__LegacyVersionNotDeployed();\n\n    /***********************************|\n    |           STATE VARIABLES         |\n    |__________________________________*/\n\n    /// @notice  AvoFactory that this contract uses to find or create AvoSafe deployments\n    /// @dev     Note that if this changes then the deployment addresses for AvoWallet change too\n    ///          Relayers might want to pass in version as new param then to forward to the correct factory\n    IAvoFactory public immutable avoFactory;\n\n    /// @dev cached AvoSafe Bytecode to optimize gas usage.\n    /// If this changes because of a AvoFactory (and AvoSafe change) upgrade,\n    /// then this variable must be updated through an upgrade deploying a new AvoForwarder!\n    bytes32 public immutable avoSafeBytecode;\n\n    /***********************************|\n    |               EVENTS              |\n    |__________________________________*/\n\n    /// @notice emitted when all actions for AvoWallet.cast() are executed successfully\n    event Executed(\n        address indexed avoSafeOwner,\n        address indexed avoSafeAddress,\n        address indexed source,\n        bytes metadata\n    );\n\n    /// @notice emitted if one of the actions in AvoWallet.cast() fails\n    event ExecuteFailed(\n        address indexed avoSafeOwner,\n        address indexed avoSafeAddress,\n        address indexed source,\n        bytes metadata,\n        string reason\n    );\n\n    /***********************************|\n    |    CONSTRUCTOR / INITIALIZERS     |\n    |__________________________________*/\n\n    /// @notice constructor sets the immutable avoFactory address\n    /// @param avoFactory_      address of AvoFactory\n    constructor(IAvoFactory avoFactory_) {\n        if (address(avoFactory_) == address(0)) {\n            revert AvoForwarder__InvalidParams();\n        }\n        avoFactory = avoFactory_;\n\n        // get avo safe bytecode from factory.\n        // @dev Note if a new AvoFactory is deployed (upgraded), a new AvoForwarder must be deployed\n        // to update the avoSafeBytecode. See Readme for more info.\n        avoSafeBytecode = avoFactory.avoSafeBytecode();\n\n        // Ensure logic contract initializer is not abused by disabling initializing\n        // see https://forum.openzeppelin.com/t/security-advisory-initialize-uups-implementation-contracts/15301\n        // and https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializing_the_implementation_contract\n        _disableInitializers();\n    }\n\n    /// @notice initializes the contract\n    function initialize() public initializer {}\n\n    /***********************************|\n    |            PUBLIC API             |\n    |__________________________________*/\n\n    /// @notice         Retrieves the current avoSafeNonce of AvoWallet for owner address, needed for signatures\n    /// @param owner_   AvoSafe Owner to retrieve the nonce for. Address signing a tx\n    /// @return         returns the avoSafeNonce for the owner necessary to sign a meta transaction\n    function avoSafeNonce(address owner_) external view returns (uint88) {\n        address avoAddress_ = _computeAvoSafeAddress(owner_);\n        if (avoAddress_.isContract()) {\n            return IAvoWalletV2(avoAddress_).avoSafeNonce();\n        }\n\n        return 0;\n    }\n\n    /// @notice         Retrieves the current AvoWallet implementation name for owner address, needed for signatures\n    /// @param owner_   AvoSafe Owner to retrieve the name for. Address signing a tx\n    /// @return         returns the domain separator name for the owner necessary to sign a meta transaction\n    function avoWalletVersionName(address owner_) external view returns (string memory) {\n        address avoAddress_ = _computeAvoSafeAddress(owner_);\n        if (avoAddress_.isContract()) {\n            // if AvoWallet is deployed, return value from deployed Avo\n            return IAvoWalletV2(avoAddress_).DOMAIN_SEPARATOR_NAME();\n        }\n\n        // otherwise return default value for current implementation that will be deployed\n        return IAvoWalletV2(avoFactory.avoWalletImpl()).DOMAIN_SEPARATOR_NAME();\n    }\n\n    /// @notice         Retrieves the current AvoWallet implementation version for owner address, needed for signatures\n    /// @param owner_   AvoSafe Owner to retrieve the version for. Address signing a tx\n    /// @return         returns the domain separator version for the owner necessary to sign a meta transaction\n    function avoWalletVersion(address owner_) external view returns (string memory) {\n        address avoAddress_ = _computeAvoSafeAddress(owner_);\n        if (avoAddress_.isContract()) {\n            // if AvoWallet is deployed, return value from deployed Avo\n            return IAvoWalletV2(avoAddress_).DOMAIN_SEPARATOR_VERSION();\n        }\n\n        // otherwise return default value for current implementation that will be deployed\n        return IAvoWalletV2(avoFactory.avoWalletImpl()).DOMAIN_SEPARATOR_VERSION();\n    }\n\n    /// @notice         Computes the deterministic address for owner based on Create2\n    /// @param owner_   AvoSafe Owner\n    /// @return         computed address for the contract\n    function computeAddress(address owner_) external view returns (address) {\n        if (Address.isContract(owner_)) {\n            // owner of a AvoSafe must be an EOA, if it's a contract return zero address\n            return address(0);\n        }\n        return _computeAvoSafeAddress(owner_);\n    }\n\n    /***********************************|\n    |         Version V2: 2.0.x         |\n    |__________________________________*/\n\n    /// @notice               Deploys AvoSafe for owner if necessary and calls `cast` on it. For AvoWallet version ~2\n    ///                       This method should be called by relayers.\n    /// @param from_          AvoSafe Owner who signed the transaction (the signature creator)\n    /// @param params_        Cast params: validUntil, gas, source, id and metadata\n    /// @param signature_     the EIP712 signature, see verifySig method\n    function executeV2(\n        address from_,\n        IAvoWalletV2.Action[] calldata actions_,\n        IAvoWalletV2.CastParams calldata params_,\n        bytes calldata signature_\n    ) external payable {\n        // msg.sender must be EOA\n        if (Address.isContract(msg.sender)) {\n            revert AvoForwarder__Unauthorized();\n        }\n\n        // _getDeployedAvoWallet automatically checks if AvoSafe has to be deployed\n        // or if it already exists and simply returns the address in that case\n        IAvoWalletV2 avoWallet_ = IAvoWalletV2(_getDeployedAvoWallet(from_));\n\n        (bool success_, string memory revertReason_) = avoWallet_.cast{ value: msg.value }(\n            actions_,\n            params_,\n            signature_\n        );\n\n        if (success_ == true) {\n            emit Executed(from_, address(avoWallet_), params_.source, params_.metadata);\n        } else {\n            (address(avoWallet_)).call(abi.encodeWithSelector(bytes4(0xb92e87fa), new IAvoWalletV2.Action[](0), 0));\n\n            emit ExecuteFailed(from_, address(avoWallet_), params_.source, params_.metadata, revertReason_);\n        }\n    }\n\n    /// @notice               Verify the transaction is valid and can be executed. For AvoWallet version ~2\n    ///                       IMPORTANT: Expected to be called via callStatic\n    ///                       Does not revert and returns successfully if the input is valid.\n    ///                       Reverts if any validation has failed. For instance, if params or either signature or avoSafeNonce are incorrect.\n    /// @param from_          AvoSafe Owner who signed the transaction (the signature creator)\n    /// @param params_        Cast params: validUntil, gas, source, id and metadata\n    /// @param signature_     the EIP712 signature, see verifySig method\n    /// @return               returns true if everything is valid, otherwise reverts\n    /// @dev                  not marked as view because it does potentially state by deploying the AvoWallet for \"from\" if it does not exist yet.\n    ///                       Expected to be called via callStatic\n    function verifyV2(\n        address from_,\n        IAvoWalletV2.Action[] calldata actions_,\n        IAvoWalletV2.CastParams calldata params_,\n        bytes calldata signature_\n    ) external returns (bool) {\n        // _getDeployedAvoWallet automatically checks if AvoSafe has to be deployed\n        // or if it already exists and simply returns the address\n        IAvoWalletV2 avoWallet_ = IAvoWalletV2(_getDeployedAvoWallet(from_));\n\n        return avoWallet_.verify(actions_, params_, signature_);\n    }\n\n    /***********************************|\n    |         Version V1: 1.0.0         |\n    |__________________________________*/\n\n    /// @notice               Calls `cast` on an already deployed AvoWallet. For AvoWallet version 1.0.0\n    /// @param from_          AvoSafe Owner who signed the transaction (the signature creator)\n    /// @param actions_       the actions to execute (target, data, value)\n    /// @param validUntil_    As EIP-2770: the highest block number the request can be forwarded in, or 0 if request validity is not time-limited\n    ///                       Protects against relayers executing a certain transaction at a later moment not intended by the user, where it might\n    ///                       have a completely different effect. (Given that the transaction is not executed right away for some reason)\n    /// @param gas_           As EIP-2770: an amount of gas limit to set for the execution\n    ///                       Protects gainst potential gas griefing attacks / the relayer getting a reward without properly executing the tx completely\n    ///                       See https://ronan.eth.limo/blog/ethereum-gas-dangers/\n    /// @param source_        Source like e.g. referral for this tx\n    /// @param metadata_      Optional metadata for future flexibility\n    /// @param signature_     the EIP712 signature, see verifySig method\n    function executeV1(\n        address from_,\n        IAvoWalletV1.Action[] calldata actions_,\n        uint256 validUntil_,\n        uint256 gas_,\n        address source_,\n        bytes calldata metadata_,\n        bytes calldata signature_\n    ) public payable {\n        // msg.sender must be EOA\n        if (Address.isContract(msg.sender)) {\n            revert AvoForwarder__Unauthorized();\n        }\n\n        // For legacy versions, AvoWallet must already be deployed\n        address computedAvoSafeAddress_ = _computeAvoSafeAddress(from_);\n        if (!Address.isContract(computedAvoSafeAddress_)) {\n            revert AvoForwarder__LegacyVersionNotDeployed();\n        }\n        IAvoWalletV1 avoWallet_ = IAvoWalletV1(computedAvoSafeAddress_);\n\n        (bool success_, string memory revertReason_) = avoWallet_.cast{ value: msg.value }(\n            actions_,\n            validUntil_,\n            gas_,\n            source_,\n            metadata_,\n            signature_\n        );\n\n        if (success_ == true) {\n            emit Executed(from_, address(avoWallet_), source_, metadata_);\n        } else {\n            emit ExecuteFailed(from_, address(avoWallet_), source_, metadata_, revertReason_);\n        }\n    }\n\n    /// @notice               Verify the transaction is valid and can be executed. For AvoWallet version 1.0.0\n    ///                       IMPORTANT: Expected to be called via callStatic\n    ///                       Does not revert and returns successfully if the input is valid.\n    ///                       Reverts if any validation has failed. For instance, if params or either signature or avoSafeNonce are incorrect.\n    /// @param from_          AvoSafe Owner who signed the transaction (the signature creator)\n    /// @param actions_       the actions to execute (target, data, value)\n    /// @param validUntil_    As EIP-2770: the highest block number the request can be forwarded in, or 0 if request validity is not time-limited\n    ///                       Protects against relayers executing a certain transaction at a later moment not intended by the user, where it might\n    ///                       have a completely different effect. (Given that the transaction is not executed right away for some reason)\n    /// @param gas_           As EIP-2770: an amount of gas limit to set for the execution\n    ///                       Protects gainst potential gas griefing attacks / the relayer getting a reward without properly executing the tx completely\n    ///                       See https://ronan.eth.limo/blog/ethereum-gas-dangers/\n    /// @param source_        Source like e.g. referral for this tx\n    /// @param metadata_      Optional metadata for future flexibility\n    /// @param signature_     the EIP712 signature, see verifySig method\n    /// @return               returns true if everything is valid, otherwise reverts\n    /// @dev                  not marked as view to make as similar as possible to legacy version. Expected to be called via callStatic\n    function verifyV1(\n        address from_,\n        IAvoWalletV1.Action[] calldata actions_,\n        uint256 validUntil_,\n        uint256 gas_,\n        address source_,\n        bytes calldata metadata_,\n        bytes calldata signature_\n    ) public returns (bool) {\n        // For legacy versions, AvoWallet must already be deployed\n        address computedAvoSafeAddress_ = _computeAvoSafeAddress(from_);\n        if (!Address.isContract(computedAvoSafeAddress_)) {\n            revert AvoForwarder__LegacyVersionNotDeployed();\n        }\n        IAvoWalletV1 avoWallet_ = IAvoWalletV1(computedAvoSafeAddress_);\n\n        return avoWallet_.verify(actions_, validUntil_, gas_, source_, metadata_, signature_);\n    }\n\n    /***********************************|\n    |      LEGACY DEPRECATED FOR V1     |\n    |__________________________________*/\n\n    /// @custom:deprecated    DEPRECATED: Use executeV1() instead. Will be removed in the next version\n    /// @notice               see executeV1() for details\n    function execute(\n        address from_,\n        IAvoWalletV1.Action[] calldata actions_,\n        uint256 validUntil_,\n        uint256 gas_,\n        address source_,\n        bytes calldata metadata_,\n        bytes calldata signature_\n    ) external payable {\n        return executeV1(from_, actions_, validUntil_, gas_, source_, metadata_, signature_);\n    }\n\n    /// @custom:deprecated    DEPRECATED: Use executeV1() instead. Will be removed in the next version\n    /// @notice               see verifyV1() for details\n    function verify(\n        address from_,\n        IAvoWalletV1.Action[] calldata actions_,\n        uint256 validUntil_,\n        uint256 gas_,\n        address source_,\n        bytes calldata metadata_,\n        bytes calldata signature_\n    ) external returns (bool) {\n        return verifyV1(from_, actions_, validUntil_, gas_, source_, metadata_, signature_);\n    }\n\n    /***********************************|\n    |              INTERNAL             |\n    |__________________________________*/\n\n    /// @dev             gets or if necessary deploys an AvoSafe\n    /// @param from_     AvoSafe Owner\n    /// @return          the AvoSafe for the owner\n    function _getDeployedAvoWallet(address from_) internal returns (address) {\n        address computedAvoSafeAddress_ = _computeAvoSafeAddress(from_);\n        if (Address.isContract(computedAvoSafeAddress_)) {\n            return computedAvoSafeAddress_;\n        } else {\n            return avoFactory.deploy(from_);\n        }\n    }\n\n    /// @dev            computes the deterministic contract address for a AvoSafe deployment for owner_\n    /// @param  owner_  AvoSafe owner\n    /// @return         the computed contract address\n    function _computeAvoSafeAddress(address owner_) internal view returns (address) {\n        bytes32 hash = keccak256(\n            abi.encodePacked(bytes1(0xff), address(avoFactory), _getSalt(owner_), avoSafeBytecode)\n        );\n\n        // cast last 20 bytes of hash to address\n        return address(uint160(uint256(hash)));\n    }\n\n    /// @dev            gets the salt used for deterministic deployment for owner_\n    /// @param owner_   AvoSafe owner\n    /// @return         the bytes32 (keccak256) salt\n    function _getSalt(address owner_) internal pure returns (bytes32) {\n        // only owner is used as salt\n        // no extra salt is needed because even if another version of AvoFactory would be deployed,\n        // deterministic deployments take into account the deployers address (i.e. the factory address)\n        return keccak256(abi.encode(owner_));\n    }\n}\n"},"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"}},"settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":false,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}}},"ABI":"[{\"inputs\":[{\"internalType\":\"contract IAvoFactory\",\"name\":\"avoFactory_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AvoForwarder__InvalidParams\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AvoForwarder__LegacyVersionNotDeployed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AvoForwarder__Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AvoForwarder__VersionMismatch\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"avoSafeOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"avoSafeAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"ExecuteFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"avoSafeOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"avoSafeAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"avoFactory\",\"outputs\":[{\"internalType\":\"contract IAvoFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avoSafeBytecode\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"avoSafeNonce\",\"outputs\":[{\"internalType\":\"uint88\",\"name\":\"\",\"type\":\"uint88\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"avoWalletVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"avoWalletVersionName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"computeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct IAvoWalletV1.Action[]\",\"name\":\"actions_\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"validUntil_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"source_\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadata_\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature_\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct IAvoWalletV1.Action[]\",\"name\":\"actions_\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"validUntil_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"source_\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadata_\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature_\",\"type\":\"bytes\"}],\"name\":\"executeV1\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operation\",\"type\":\"uint256\"}],\"internalType\":\"struct IAvoWalletV2.Action[]\",\"name\":\"actions_\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"validUntil\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"internalType\":\"struct IAvoWalletV2.CastParams\",\"name\":\"params_\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature_\",\"type\":\"bytes\"}],\"name\":\"executeV2\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct IAvoWalletV1.Action[]\",\"name\":\"actions_\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"validUntil_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"source_\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadata_\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature_\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct IAvoWalletV1.Action[]\",\"name\":\"actions_\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"validUntil_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"source_\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"metadata_\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature_\",\"type\":\"bytes\"}],\"name\":\"verifyV1\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operation\",\"type\":\"uint256\"}],\"internalType\":\"struct IAvoWalletV2.Action[]\",\"name\":\"actions_\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"validUntil\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"metadata\",\"type\":\"bytes\"}],\"internalType\":\"struct IAvoWalletV2.CastParams\",\"name\":\"params_\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature_\",\"type\":\"bytes\"}],\"name\":\"verifyV2\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"AvoForwarder","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":0,"Runs":200,"ConstructorArguments":"0x0000000000000000000000003adae9699029ab2953f607ae1f62372681d35978","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}