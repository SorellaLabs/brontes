{"expiry":1689528949,"data":[{"SourceCode":{"language":"Solidity","sources":{"contracts/infiniteProxy/proxy.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport { Events } from \"./events.sol\";\n\ncontract CoreInternals is Events {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct SigsSlot {\n        bytes4[] value;\n    }\n\n    /// @dev Storage slot with the admin of the contract.\n    /// This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n    /// validated in the constructor.\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /// @dev Storage slot with the address of the current dummy-implementation.\n    /// This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n    /// validated in the constructor.\n    bytes32 internal constant _DUMMY_IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /// @dev Returns the storage slot which stores the sigs array set for the implementation.\n    function getSlotImplSigsSlotInternal(address implementation_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\"eip1967.proxy.implementation\", implementation_));\n    }\n\n    /// @dev Returns the storage slot which stores the implementation address for the function sig.\n    function getSlotSigsImplSlotInternal(bytes4 sig_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\"eip1967.proxy.implementation\", sig_));\n    }\n\n    /// @dev Returns an `AddressSlot` with member `value` located at `slot`.\n    function getAddressSlotInternal(bytes32 slot_) internal pure returns (AddressSlot storage _r) {\n        assembly {\n            _r.slot := slot_\n        }\n    }\n\n    /// @dev Returns an `SigsSlot` with member `value` located at `slot`.\n    function getSigsSlotInternal(bytes32 slot_) internal pure returns (SigsSlot storage _r) {\n        assembly {\n            _r.slot := slot_\n        }\n    }\n\n    /// @dev Sets new implementation and adds mapping from implementation to sigs and sig to implementation.\n    function setImplementationSigsInternal(address implementation_, bytes4[] memory sigs_) internal {\n        require(sigs_.length != 0, \"no-sigs\");\n        bytes32 slot_ = getSlotImplSigsSlotInternal(implementation_);\n        bytes4[] memory sigsCheck_ = getSigsSlotInternal(slot_).value;\n        require(sigsCheck_.length == 0, \"implementation-already-exist\");\n\n        for (uint256 i; i < sigs_.length; i++) {\n            bytes32 sigSlot_ = getSlotSigsImplSlotInternal(sigs_[i]);\n            require(getAddressSlotInternal(sigSlot_).value == address(0), \"sig-already-exist\");\n            getAddressSlotInternal(sigSlot_).value = implementation_;\n        }\n\n        getSigsSlotInternal(slot_).value = sigs_;\n        emit LogSetImplementation(implementation_, sigs_);\n    }\n\n    /// @dev Removes implementation and the mappings corresponding to it.\n    function removeImplementationSigsInternal(address implementation_) internal {\n        bytes32 slot_ = getSlotImplSigsSlotInternal(implementation_);\n        bytes4[] memory sigs_ = getSigsSlotInternal(slot_).value;\n        require(sigs_.length != 0, \"implementation-not-exist\");\n\n        for (uint256 i; i < sigs_.length; i++) {\n            bytes32 sigSlot_ = getSlotSigsImplSlotInternal(sigs_[i]);\n            delete getAddressSlotInternal(sigSlot_).value;\n        }\n\n        delete getSigsSlotInternal(slot_).value;\n        emit LogRemoveImplementation(implementation_);\n    }\n\n    /// @dev Returns bytes4[] sigs from implementation address. If implemenatation is not registered then returns empty array.\n    function getImplementationSigsInternal(address implementation_) internal view returns (bytes4[] memory) {\n        bytes32 slot_ = getSlotImplSigsSlotInternal(implementation_);\n        return getSigsSlotInternal(slot_).value;\n    }\n\n    /// @dev Returns implementation address from bytes4 sig. If sig is not registered then returns address(0).\n    function getSigImplementationInternal(bytes4 sig_) internal view returns (address implementation_) {\n        bytes32 slot_ = getSlotSigsImplSlotInternal(sig_);\n        return getAddressSlotInternal(slot_).value;\n    }\n\n    /// @dev Returns the current admin.\n    function getAdminInternal() internal view returns (address) {\n        return getAddressSlotInternal(_ADMIN_SLOT).value;\n    }\n\n    /// @dev Returns the current dummy-implementation.\n    function getDummyImplementationInternal() internal view returns (address) {\n        return getAddressSlotInternal(_DUMMY_IMPLEMENTATION_SLOT).value;\n    }\n\n    /// @dev Stores a new address in the EIP1967 admin slot.\n    function setAdminInternal(address newAdmin_) internal {\n        address oldAdmin_ = getAdminInternal();\n        require(newAdmin_ != address(0), \"ERC1967: new admin is the zero address\");\n        getAddressSlotInternal(_ADMIN_SLOT).value = newAdmin_;\n        emit LogSetAdmin(oldAdmin_, newAdmin_);\n    }\n\n    /// @dev Stores a new address in the EIP1967 implementation slot.\n    function setDummyImplementationInternal(address newDummyImplementation_) internal {\n        address oldDummyImplementation_ = getDummyImplementationInternal();\n        getAddressSlotInternal(_DUMMY_IMPLEMENTATION_SLOT).value = newDummyImplementation_;\n        emit LogSetDummyImplementation(oldDummyImplementation_, newDummyImplementation_);\n    }\n\n    /// @dev Delegates the current call to `implementation`.\n    /// This function does not return to its internall call site, it will return directly to the external caller.\n    function delegateInternal(address implementation_) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation_, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /// @dev Delegates the current call to the address returned by Implementations registry.\n    /// This function does not return to its internall call site, it will return directly to the external caller.\n    function fallbackInternal(bytes4 sig_) internal {\n        address implementation_ = getSigImplementationInternal(sig_);\n        require(implementation_ != address(0), \"Liquidity: Not able to find implementation_\");\n        delegateInternal(implementation_);\n    }\n}\n\ncontract AdminInternals is CoreInternals {\n    /// @dev Only admin guard\n    modifier onlyAdmin() {\n        require(msg.sender == getAdminInternal(), \"only-admin\");\n        _;\n    }\n\n    constructor(address admin_, address dummyImplementation_) {\n        setAdminInternal(admin_);\n        setDummyImplementationInternal(dummyImplementation_);\n    }\n\n    /// @dev Sets new admin.\n    function setAdmin(address newAdmin_) external onlyAdmin {\n        setAdminInternal(newAdmin_);\n    }\n\n    /// @dev Sets new dummy-implementation.\n    function setDummyImplementation(address newDummyImplementation_) external onlyAdmin {\n        setDummyImplementationInternal(newDummyImplementation_);\n    }\n\n    /// @dev Adds new implementation address.\n    function addImplementation(address implementation_, bytes4[] calldata sigs_) external onlyAdmin {\n        setImplementationSigsInternal(implementation_, sigs_);\n    }\n\n    /// @dev Removes an existing implementation address.\n    function removeImplementation(address implementation_) external onlyAdmin {\n        removeImplementationSigsInternal(implementation_);\n    }\n}\n\n/// @title Proxy\n/// @notice This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\nabstract contract Proxy is AdminInternals {\n    constructor(address admin_, address dummyImplementation_) AdminInternals(admin_, dummyImplementation_) {}\n\n    /// @dev Returns admin's address.\n    function getAdmin() external view returns (address) {\n        return getAdminInternal();\n    }\n\n    /// @dev Returns dummy-implementations's address.\n    function getDummyImplementation() external view returns (address) {\n        return getDummyImplementationInternal();\n    }\n\n    /// @dev Returns bytes4[] sigs from implementation address If not registered then returns empty array.\n    function getImplementationSigs(address impl_) external view returns (bytes4[] memory) {\n        return getImplementationSigsInternal(impl_);\n    }\n\n    /// @dev Returns implementation address from bytes4 sig. If sig is not registered then returns address(0).\n    function getSigsImplementation(bytes4 sig_) external view returns (address) {\n        return getSigImplementationInternal(sig_);\n    }\n\n    /// @dev Fallback function that delegates calls to the address returned by Implementations registry.\n    fallback() external payable {\n        fallbackInternal(msg.sig);\n    }\n\n    /// @dev Fallback function that delegates calls to the address returned by Implementations registry.\n    receive() external payable {\n        if (msg.sig != 0x00000000) {\n            fallbackInternal(msg.sig);\n        }\n    }\n}\n"},"contracts/vault/proxy/infiniteProxy.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../../infiniteProxy/proxy.sol\";\n\ncontract Vault is Proxy {\n    constructor(address admin_, address dummyImplementation_)\n        Proxy(admin_, dummyImplementation_)\n    {}\n}\n"},"contracts/infiniteProxy/events.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\ncontract Events {\n    event LogSetAdmin(address oldAdmin_, address newAdmin_);\n\n    event LogSetDummyImplementation(\n        address oldDummyImplementation_,\n        address newDummyImplementation_\n    );\n\n    event LogSetImplementation(address implementation_, bytes4[] sigs_);\n\n    event LogRemoveImplementation(address implementation_);\n}\n"}},"settings":{"libraries":{},"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}}},"ABI":"[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dummyImplementation_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"name\":\"LogRemoveImplementation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin_\",\"type\":\"address\"}],\"name\":\"LogSetAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldDummyImplementation_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDummyImplementation_\",\"type\":\"address\"}],\"name\":\"LogSetDummyImplementation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4[]\",\"name\":\"sigs_\",\"type\":\"bytes4[]\"}],\"name\":\"LogSetImplementation\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"sigs_\",\"type\":\"bytes4[]\"}],\"name\":\"addImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDummyImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"impl_\",\"type\":\"address\"}],\"name\":\"getImplementationSigs\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"sig_\",\"type\":\"bytes4\"}],\"name\":\"getSigsImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"implementation_\",\"type\":\"address\"}],\"name\":\"removeImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin_\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDummyImplementation_\",\"type\":\"address\"}],\"name\":\"setDummyImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]","ContractName":"Vault","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x000000000000000000000000910e413dbf3f6276fe8213ff656726bdc142e08e000000000000000000000000172455d14d1eb242e6f7f3b451529ab289095bb6","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":1,"Implementation":"0x172455d14d1eb242e6f7f3b451529ab289095bb6","SwarmSource":""}]}