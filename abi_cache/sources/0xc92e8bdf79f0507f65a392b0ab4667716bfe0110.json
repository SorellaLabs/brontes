{"expiry":1689528939,"data":[{"SourceCode":{"language":"Solidity","sources":{"src/contracts/test/GPv2TransferTestInterface.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/GPv2Transfer.sol\";\n\ncontract GPv2TransferTestInterface {\n    function fastTransferFromAccountTest(\n        IVault vault,\n        GPv2Transfer.Data calldata transfer,\n        address recipient\n    ) external {\n        GPv2Transfer.fastTransferFromAccount(vault, transfer, recipient);\n    }\n\n    function transferFromAccountsTest(\n        IVault vault,\n        GPv2Transfer.Data[] calldata transfers,\n        address recipient\n    ) external {\n        GPv2Transfer.transferFromAccounts(vault, transfers, recipient);\n    }\n\n    function transferToAccountsTest(\n        IVault vault,\n        GPv2Transfer.Data[] memory transfers\n    ) external {\n        GPv2Transfer.transferToAccounts(vault, transfers);\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n}\n"},"src/contracts/libraries/GPv2Trade.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../mixins/GPv2Signing.sol\";\nimport \"./GPv2Order.sol\";\n\n/// @title Gnosis Protocol v2 Trade Library.\n/// @author Gnosis Developers\nlibrary GPv2Trade {\n    using GPv2Order for GPv2Order.Data;\n    using GPv2Order for bytes;\n\n    /// @dev A struct representing a trade to be executed as part a batch\n    /// settlement.\n    struct Data {\n        uint256 sellTokenIndex;\n        uint256 buyTokenIndex;\n        address receiver;\n        uint256 sellAmount;\n        uint256 buyAmount;\n        uint32 validTo;\n        bytes32 appData;\n        uint256 feeAmount;\n        uint256 flags;\n        uint256 executedAmount;\n        bytes signature;\n    }\n\n    /// @dev Extracts the order data and signing scheme for the specified trade.\n    ///\n    /// @param trade The trade.\n    /// @param tokens The list of tokens included in the settlement. The token\n    /// indices in the trade parameters map to tokens in this array.\n    /// @param order The memory location to extract the order data to.\n    function extractOrder(\n        Data calldata trade,\n        IERC20[] calldata tokens,\n        GPv2Order.Data memory order\n    ) internal pure returns (GPv2Signing.Scheme signingScheme) {\n        order.sellToken = tokens[trade.sellTokenIndex];\n        order.buyToken = tokens[trade.buyTokenIndex];\n        order.receiver = trade.receiver;\n        order.sellAmount = trade.sellAmount;\n        order.buyAmount = trade.buyAmount;\n        order.validTo = trade.validTo;\n        order.appData = trade.appData;\n        order.feeAmount = trade.feeAmount;\n        (\n            order.kind,\n            order.partiallyFillable,\n            order.sellTokenBalance,\n            order.buyTokenBalance,\n            signingScheme\n        ) = extractFlags(trade.flags);\n    }\n\n    /// @dev Decodes trade flags.\n    ///\n    /// Trade flags are used to tightly encode information on how to decode\n    /// an order. Examples that directly affect the structure of an order are\n    /// the kind of order (either a sell or a buy order) as well as whether the\n    /// order is partially fillable or if it is a \"fill-or-kill\" order. It also\n    /// encodes the signature scheme used to validate the order. As the most\n    /// likely values are fill-or-kill sell orders by an externally owned\n    /// account, the flags are chosen such that `0x00` represents this kind of\n    /// order. The flags byte uses the following format:\n    ///\n    /// ```\n    /// bit | 31 ...   | 6 | 5 | 4 | 3 | 2 | 1 | 0 |\n    /// ----+----------+---+---+-------+---+---+\n    ///     | reserved | *   * | * | *   * | * | * |\n    ///                  |   |   |   |   |   |   |\n    ///                  |   |   |   |   |   |   +---- order kind bit, 0 for a sell order\n    ///                  |   |   |   |   |   |         and 1 for a buy order\n    ///                  |   |   |   |   |   |\n    ///                  |   |   |   |   |   +-------- order fill bit, 0 for fill-or-kill\n    ///                  |   |   |   |   |             and 1 for a partially fillable order\n    ///                  |   |   |   |   |\n    ///                  |   |   |   +---+------------ use internal sell token balance bit:\n    ///                  |   |   |                     0x: ERC20 token balance\n    ///                  |   |   |                     10: external Balancer Vault balance\n    ///                  |   |   |                     11: internal Balancer Vault balance\n    ///                  |   |   |\n    ///                  |   |   +-------------------- use buy token balance bit\n    ///                  |   |                         0: ERC20 token balance\n    ///                  |   |                         1: internal Balancer Vault balance\n    ///                  |   |\n    ///                  +---+------------------------ signature scheme bits:\n    ///                                                00: EIP-712\n    ///                                                01: eth_sign\n    ///                                                10: EIP-1271\n    ///                                                11: pre_sign\n    /// ```\n    function extractFlags(uint256 flags)\n        internal\n        pure\n        returns (\n            bytes32 kind,\n            bool partiallyFillable,\n            bytes32 sellTokenBalance,\n            bytes32 buyTokenBalance,\n            GPv2Signing.Scheme signingScheme\n        )\n    {\n        if (flags & 0x01 == 0) {\n            kind = GPv2Order.KIND_SELL;\n        } else {\n            kind = GPv2Order.KIND_BUY;\n        }\n        partiallyFillable = flags & 0x02 != 0;\n        if (flags & 0x08 == 0) {\n            sellTokenBalance = GPv2Order.BALANCE_ERC20;\n        } else if (flags & 0x04 == 0) {\n            sellTokenBalance = GPv2Order.BALANCE_EXTERNAL;\n        } else {\n            sellTokenBalance = GPv2Order.BALANCE_INTERNAL;\n        }\n        if (flags & 0x10 == 0) {\n            buyTokenBalance = GPv2Order.BALANCE_ERC20;\n        } else {\n            buyTokenBalance = GPv2Order.BALANCE_INTERNAL;\n        }\n\n        // NOTE: Take advantage of the fact that Solidity will revert if the\n        // following expression does not produce a valid enum value. This means\n        // we check here that the leading reserved bits must be 0.\n        signingScheme = GPv2Signing.Scheme(flags >> 5);\n    }\n}\n"},"src/contracts/test/GPv2TradeTestInterface.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/GPv2Order.sol\";\nimport \"../libraries/GPv2Trade.sol\";\n\ncontract GPv2TradeTestInterface {\n    function extractOrderTest(\n        IERC20[] calldata tokens,\n        GPv2Trade.Data calldata trade\n    ) external pure returns (GPv2Order.Data memory order) {\n        GPv2Trade.extractOrder(trade, tokens, order);\n    }\n\n    function extractFlagsTest(uint256 flags)\n        external\n        pure\n        returns (\n            bytes32 kind,\n            bool partiallyFillable,\n            bytes32 sellTokenBalance,\n            bytes32 buyTokenBalance,\n            GPv2Signing.Scheme signingScheme\n        )\n    {\n        return GPv2Trade.extractFlags(flags);\n    }\n}\n"},"src/contracts/libraries/GPv2Order.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\nimport \"../interfaces/IERC20.sol\";\n\n/// @title Gnosis Protocol v2 Order Library\n/// @author Gnosis Developers\nlibrary GPv2Order {\n    /// @dev The complete data for a Gnosis Protocol order. This struct contains\n    /// all order parameters that are signed for submitting to GP.\n    struct Data {\n        IERC20 sellToken;\n        IERC20 buyToken;\n        address receiver;\n        uint256 sellAmount;\n        uint256 buyAmount;\n        uint32 validTo;\n        bytes32 appData;\n        uint256 feeAmount;\n        bytes32 kind;\n        bool partiallyFillable;\n        bytes32 sellTokenBalance;\n        bytes32 buyTokenBalance;\n    }\n\n    /// @dev The order EIP-712 type hash for the [`GPv2Order.Data`] struct.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\n    ///     \"Order(\" +\n    ///         \"address sellToken,\" +\n    ///         \"address buyToken,\" +\n    ///         \"address receiver,\" +\n    ///         \"uint256 sellAmount,\" +\n    ///         \"uint256 buyAmount,\" +\n    ///         \"uint32 validTo,\" +\n    ///         \"bytes32 appData,\" +\n    ///         \"uint256 feeAmount,\" +\n    ///         \"string kind,\" +\n    ///         \"bool partiallyFillable\" +\n    ///         \"string sellTokenBalance\" +\n    ///         \"string buyTokenBalance\" +\n    ///     \")\"\n    /// )\n    /// ```\n    bytes32 internal constant TYPE_HASH =\n        hex\"d5a25ba2e97094ad7d83dc28a6572da797d6b3e7fc6663bd93efb789fc17e489\";\n\n    /// @dev The marker value for a sell order for computing the order struct\n    /// hash. This allows the EIP-712 compatible wallets to display a\n    /// descriptive string for the order kind (instead of 0 or 1).\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"sell\")\n    /// ```\n    bytes32 internal constant KIND_SELL =\n        hex\"f3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775\";\n\n    /// @dev The OrderKind marker value for a buy order for computing the order\n    /// struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"buy\")\n    /// ```\n    bytes32 internal constant KIND_BUY =\n        hex\"6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc\";\n\n    /// @dev The TokenBalance marker value for using direct ERC20 balances for\n    /// computing the order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"erc20\")\n    /// ```\n    bytes32 internal constant BALANCE_ERC20 =\n        hex\"5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc9\";\n\n    /// @dev The TokenBalance marker value for using Balancer Vault external\n    /// balances (in order to re-use Vault ERC20 approvals) for computing the\n    /// order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"external\")\n    /// ```\n    bytes32 internal constant BALANCE_EXTERNAL =\n        hex\"abee3b73373acd583a130924aad6dc38cfdc44ba0555ba94ce2ff63980ea0632\";\n\n    /// @dev The TokenBalance marker value for using Balancer Vault internal\n    /// balances for computing the order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"internal\")\n    /// ```\n    bytes32 internal constant BALANCE_INTERNAL =\n        hex\"4ac99ace14ee0a5ef932dc609df0943ab7ac16b7583634612f8dc35a4289a6ce\";\n\n    /// @dev Marker address used to indicate that the receiver of the trade\n    /// proceeds should the owner of the order.\n    ///\n    /// This is chosen to be `address(0)` for gas efficiency as it is expected\n    /// to be the most common case.\n    address internal constant RECEIVER_SAME_AS_OWNER = address(0);\n\n    /// @dev The byte length of an order unique identifier.\n    uint256 internal constant UID_LENGTH = 56;\n\n    /// @dev Returns the actual receiver for an order. This function checks\n    /// whether or not the [`receiver`] field uses the marker value to indicate\n    /// it is the same as the order owner.\n    ///\n    /// @return receiver The actual receiver of trade proceeds.\n    function actualReceiver(Data memory order, address owner)\n        internal\n        pure\n        returns (address receiver)\n    {\n        if (order.receiver == RECEIVER_SAME_AS_OWNER) {\n            receiver = owner;\n        } else {\n            receiver = order.receiver;\n        }\n    }\n\n    /// @dev Return the EIP-712 signing hash for the specified order.\n    ///\n    /// @param order The order to compute the EIP-712 signing hash for.\n    /// @param domainSeparator The EIP-712 domain separator to use.\n    /// @return orderDigest The 32 byte EIP-712 struct hash.\n    function hash(Data memory order, bytes32 domainSeparator)\n        internal\n        pure\n        returns (bytes32 orderDigest)\n    {\n        bytes32 structHash;\n\n        // NOTE: Compute the EIP-712 order struct hash in place. As suggested\n        // in the EIP proposal, noting that the order struct has 10 fields, and\n        // including the type hash `(12 + 1) * 32 = 416` bytes to hash.\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#rationale-for-encodedata>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let dataStart := sub(order, 32)\n            let temp := mload(dataStart)\n            mstore(dataStart, TYPE_HASH)\n            structHash := keccak256(dataStart, 416)\n            mstore(dataStart, temp)\n        }\n\n        // NOTE: Now that we have the struct hash, compute the EIP-712 signing\n        // hash using scratch memory past the free memory pointer. The signing\n        // hash is computed from `\"\\x19\\x01\" || domainSeparator || structHash`.\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory>\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#specification>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, \"\\x19\\x01\")\n            mstore(add(freeMemoryPointer, 2), domainSeparator)\n            mstore(add(freeMemoryPointer, 34), structHash)\n            orderDigest := keccak256(freeMemoryPointer, 66)\n        }\n    }\n\n    /// @dev Packs order UID parameters into the specified memory location. The\n    /// result is equivalent to `abi.encodePacked(...)` with the difference that\n    /// it allows re-using the memory for packing the order UID.\n    ///\n    /// This function reverts if the order UID buffer is not the correct size.\n    ///\n    /// @param orderUid The buffer pack the order UID parameters into.\n    /// @param orderDigest The EIP-712 struct digest derived from the order\n    /// parameters.\n    /// @param owner The address of the user who owns this order.\n    /// @param validTo The epoch time at which the order will stop being valid.\n    function packOrderUidParams(\n        bytes memory orderUid,\n        bytes32 orderDigest,\n        address owner,\n        uint32 validTo\n    ) internal pure {\n        require(orderUid.length == UID_LENGTH, \"GPv2: uid buffer overflow\");\n\n        // NOTE: Write the order UID to the allocated memory buffer. The order\n        // parameters are written to memory in **reverse order** as memory\n        // operations write 32-bytes at a time and we want to use a packed\n        // encoding. This means, for example, that after writing the value of\n        // `owner` to bytes `20:52`, writing the `orderDigest` to bytes `0:32`\n        // will **overwrite** bytes `20:32`. This is desirable as addresses are\n        // only 20 bytes and `20:32` should be `0`s:\n        //\n        //        |           1111111111222222222233333333334444444444555555\n        //   byte | 01234567890123456789012345678901234567890123456789012345\n        // -------+---------------------------------------------------------\n        //  field | [.........orderDigest..........][......owner.......][vT]\n        // -------+---------------------------------------------------------\n        // mstore |                         [000000000000000000000000000.vT]\n        //        |                     [00000000000.......owner.......]\n        //        | [.........orderDigest..........]\n        //\n        // Additionally, since Solidity `bytes memory` are length prefixed,\n        // 32 needs to be added to all the offsets.\n        //\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(add(orderUid, 56), validTo)\n            mstore(add(orderUid, 52), owner)\n            mstore(add(orderUid, 32), orderDigest)\n        }\n    }\n\n    /// @dev Extracts specific order information from the standardized unique\n    /// order id of the protocol.\n    ///\n    /// @param orderUid The unique identifier used to represent an order in\n    /// the protocol. This uid is the packed concatenation of the order digest,\n    /// the validTo order parameter and the address of the user who created the\n    /// order. It is used by the user to interface with the contract directly,\n    /// and not by calls that are triggered by the solvers.\n    /// @return orderDigest The EIP-712 signing digest derived from the order\n    /// parameters.\n    /// @return owner The address of the user who owns this order.\n    /// @return validTo The epoch time at which the order will stop being valid.\n    function extractOrderUidParams(bytes calldata orderUid)\n        internal\n        pure\n        returns (\n            bytes32 orderDigest,\n            address owner,\n            uint32 validTo\n        )\n    {\n        require(orderUid.length == UID_LENGTH, \"GPv2: invalid uid\");\n\n        // Use assembly to efficiently decode packed calldata.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            orderDigest := calldataload(orderUid.offset)\n            owner := shr(96, calldataload(add(orderUid.offset, 32)))\n            validTo := shr(224, calldataload(add(orderUid.offset, 52)))\n        }\n    }\n}\n"},"src/contracts/test/GPv2SigningTestInterface.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/GPv2Order.sol\";\nimport \"../libraries/GPv2Trade.sol\";\nimport \"../mixins/GPv2Signing.sol\";\n\ncontract GPv2SigningTestInterface is GPv2Signing {\n    function recoverOrderFromTradeTest(\n        IERC20[] calldata tokens,\n        GPv2Trade.Data calldata trade\n    ) external view returns (RecoveredOrder memory recoveredOrder) {\n        recoveredOrder = allocateRecoveredOrder();\n        recoverOrderFromTrade(recoveredOrder, tokens, trade);\n    }\n\n    function recoverOrderSignerTest(\n        GPv2Order.Data memory order,\n        GPv2Signing.Scheme signingScheme,\n        bytes calldata signature\n    ) external view returns (address owner) {\n        (, owner) = recoverOrderSigner(order, signingScheme, signature);\n    }\n}\n"},"src/contracts/mixins/StorageAccessible.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\n\n// Vendored from Gnosis utility contracts with minor modifications:\n// - Modified Solidity version\n// - Formatted code\n// - Added linter directives to ignore low level call and assembly warnings\n// <https://github.com/gnosis/util-contracts/blob/v3.1.0-solc-7/contracts/StorageAccessible.sol>\n\npragma solidity ^0.7.6;\n\n/// @title ViewStorageAccessible - Interface on top of StorageAccessible base class to allow simulations from view functions\ninterface ViewStorageAccessible {\n    /**\n     * @dev Same as `simulateDelegatecall` on StorageAccessible. Marked as view so that it can be called from external contracts\n     * that want to run simulations from within view functions. Will revert if the invoked simulation attempts to change state.\n     */\n    function simulateDelegatecall(\n        address targetContract,\n        bytes memory calldataPayload\n    ) external view returns (bytes memory);\n\n    /**\n     * @dev Same as `getStorageAt` on StorageAccessible. This method allows reading aribtrary ranges of storage.\n     */\n    function getStorageAt(uint256 offset, uint256 length)\n        external\n        view\n        returns (bytes memory);\n}\n\n/// @title StorageAccessible - generic base contract that allows callers to access all internal storage.\ncontract StorageAccessible {\n    /**\n     * @dev Reads `length` bytes of storage in the currents contract\n     * @param offset - the offset in the current contract's storage in words to start reading from\n     * @param length - the number of words (32 bytes) of data to read\n     * @return the bytes that were read.\n     */\n    function getStorageAt(uint256 offset, uint256 length)\n        external\n        view\n        returns (bytes memory)\n    {\n        bytes memory result = new bytes(length * 32);\n        for (uint256 index = 0; index < length; index++) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let word := sload(add(offset, index))\n                mstore(add(add(result, 0x20), mul(index, 0x20)), word)\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Performs a delegetecall on a targetContract in the context of self.\n     * Internally reverts execution to avoid side effects (making it static). Catches revert and returns encoded result as bytes.\n     * @param targetContract Address of the contract containing the code to execute.\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\n     */\n    function simulateDelegatecall(\n        address targetContract,\n        bytes memory calldataPayload\n    ) public returns (bytes memory response) {\n        bytes memory innerCall =\n            abi.encodeWithSelector(\n                this.simulateDelegatecallInternal.selector,\n                targetContract,\n                calldataPayload\n            );\n        // solhint-disable-next-line avoid-low-level-calls\n        (, response) = address(this).call(innerCall);\n        bool innerSuccess = response[response.length - 1] == 0x01;\n        setLength(response, response.length - 1);\n        if (innerSuccess) {\n            return response;\n        } else {\n            revertWith(response);\n        }\n    }\n\n    /**\n     * @dev Performs a delegetecall on a targetContract in the context of self.\n     * Internally reverts execution to avoid side effects (making it static). Returns encoded result as revert message\n     * concatenated with the success flag of the inner call as a last byte.\n     * @param targetContract Address of the contract containing the code to execute.\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\n     */\n    function simulateDelegatecallInternal(\n        address targetContract,\n        bytes memory calldataPayload\n    ) external returns (bytes memory response) {\n        bool success;\n        // solhint-disable-next-line avoid-low-level-calls\n        (success, response) = targetContract.delegatecall(calldataPayload);\n        revertWith(abi.encodePacked(response, success));\n    }\n\n    function revertWith(bytes memory response) internal pure {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            revert(add(response, 0x20), mload(response))\n        }\n    }\n\n    function setLength(bytes memory buffer, uint256 length) internal pure {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(buffer, length)\n        }\n    }\n}\n"},"src/contracts/GPv2Settlement.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"./GPv2VaultRelayer.sol\";\nimport \"./interfaces/GPv2Authentication.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./libraries/GPv2Interaction.sol\";\nimport \"./libraries/GPv2Order.sol\";\nimport \"./libraries/GPv2Trade.sol\";\nimport \"./libraries/GPv2Transfer.sol\";\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./mixins/GPv2Signing.sol\";\nimport \"./mixins/ReentrancyGuard.sol\";\nimport \"./mixins/StorageAccessible.sol\";\n\n/// @title Gnosis Protocol v2 Settlement Contract\n/// @author Gnosis Developers\ncontract GPv2Settlement is GPv2Signing, ReentrancyGuard, StorageAccessible {\n    using GPv2Order for bytes;\n    using GPv2Transfer for IVault;\n    using SafeCast for int256;\n    using SafeCast for uint256;\n    using SafeMath for uint256;\n\n    /// @dev The authenticator is used to determine who can call the settle function.\n    /// That is, only authorised solvers have the ability to invoke settlements.\n    /// Any valid authenticator implements an isSolver method called by the onlySolver\n    /// modifier below.\n    GPv2Authentication public immutable authenticator;\n\n    /// @dev The Balancer Vault the protocol uses for managing user funds.\n    IVault public immutable vault;\n\n    /// @dev The Balancer Vault relayer which can interact on behalf of users.\n    /// This contract is created during deployment\n    GPv2VaultRelayer public immutable vaultRelayer;\n\n    /// @dev Map each user order by UID to the amount that has been filled so\n    /// far. If this amount is larger than or equal to the amount traded in the\n    /// order (amount sold for sell orders, amount bought for buy orders) then\n    /// the order cannot be traded anymore. If the order is fill or kill, then\n    /// this value is only used to determine whether the order has already been\n    /// executed.\n    mapping(bytes => uint256) public filledAmount;\n\n    /// @dev Event emitted for each executed trade.\n    event Trade(\n        address indexed owner,\n        IERC20 sellToken,\n        IERC20 buyToken,\n        uint256 sellAmount,\n        uint256 buyAmount,\n        uint256 feeAmount,\n        bytes orderUid\n    );\n\n    /// @dev Event emitted for each executed interaction.\n    ///\n    /// For gas effeciency, only the interaction calldata selector (first 4\n    /// bytes) is included in the event. For interactions without calldata or\n    /// whose calldata is shorter than 4 bytes, the selector will be `0`.\n    event Interaction(address indexed target, uint256 value, bytes4 selector);\n\n    /// @dev Event emitted when a settlement complets\n    event Settlement(address indexed solver);\n\n    /// @dev Event emitted when an order is invalidated.\n    event OrderInvalidated(address indexed owner, bytes orderUid);\n\n    constructor(GPv2Authentication authenticator_, IVault vault_) {\n        authenticator = authenticator_;\n        vault = vault_;\n        vaultRelayer = new GPv2VaultRelayer(vault_);\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {\n        // NOTE: Include an empty receive function so that the settlement\n        // contract can receive Ether from contract interactions.\n    }\n\n    /// @dev This modifier is called by settle function to block any non-listed\n    /// senders from settling batches.\n    modifier onlySolver {\n        require(authenticator.isSolver(msg.sender), \"GPv2: not a solver\");\n        _;\n    }\n\n    /// @dev Modifier to ensure that an external function is only callable as a\n    /// settlement interaction.\n    modifier onlyInteraction {\n        require(address(this) == msg.sender, \"GPv2: not an interaction\");\n        _;\n    }\n\n    /// @dev Settle the specified orders at a clearing price. Note that it is\n    /// the responsibility of the caller to ensure that all GPv2 invariants are\n    /// upheld for the input settlement, otherwise this call will revert.\n    /// Namely:\n    /// - All orders are valid and signed\n    /// - Accounts have sufficient balance and approval.\n    /// - Settlement contract has sufficient balance to execute trades. Note\n    ///   this implies that the accumulated fees held in the contract can also\n    ///   be used for settlement. This is OK since:\n    ///   - Solvers need to be authorized\n    ///   - Misbehaving solvers will be slashed for abusing accumulated fees for\n    ///     settlement\n    ///   - Critically, user orders are entirely protected\n    ///\n    /// @param tokens An array of ERC20 tokens to be traded in the settlement.\n    /// Trades encode tokens as indices into this array.\n    /// @param clearingPrices An array of clearing prices where the `i`-th price\n    /// is for the `i`-th token in the [`tokens`] array.\n    /// @param trades Trades for signed orders.\n    /// @param interactions Smart contract interactions split into three\n    /// separate lists to be run before the settlement, during the settlement\n    /// and after the settlement respectively.\n    function settle(\n        IERC20[] calldata tokens,\n        uint256[] calldata clearingPrices,\n        GPv2Trade.Data[] calldata trades,\n        GPv2Interaction.Data[][3] calldata interactions\n    ) external nonReentrant onlySolver {\n        executeInteractions(interactions[0]);\n\n        (\n            GPv2Transfer.Data[] memory inTransfers,\n            GPv2Transfer.Data[] memory outTransfers\n        ) = computeTradeExecutions(tokens, clearingPrices, trades);\n\n        vaultRelayer.transferFromAccounts(inTransfers);\n\n        executeInteractions(interactions[1]);\n\n        vault.transferToAccounts(outTransfers);\n\n        executeInteractions(interactions[2]);\n\n        emit Settlement(msg.sender);\n    }\n\n    /// @dev Settle an order directly against Balancer V2 pools.\n    ///\n    /// @param swaps The Balancer V2 swap steps to use for trading.\n    /// @param tokens An array of ERC20 tokens to be traded in the settlement.\n    /// Swaps and the trade encode tokens as indices into this array.\n    /// @param trade The trade to match directly against Balancer liquidity. The\n    /// order will always be fully executed, so the trade's `executedAmount`\n    /// field is used to represent a swap limit amount.\n    function swap(\n        IVault.BatchSwapStep[] calldata swaps,\n        IERC20[] calldata tokens,\n        GPv2Trade.Data calldata trade\n    ) external nonReentrant onlySolver {\n        RecoveredOrder memory recoveredOrder = allocateRecoveredOrder();\n        GPv2Order.Data memory order = recoveredOrder.data;\n        recoverOrderFromTrade(recoveredOrder, tokens, trade);\n\n        IVault.SwapKind kind =\n            order.kind == GPv2Order.KIND_SELL\n                ? IVault.SwapKind.GIVEN_IN\n                : IVault.SwapKind.GIVEN_OUT;\n\n        IVault.FundManagement memory funds;\n        funds.sender = recoveredOrder.owner;\n        funds.fromInternalBalance =\n            order.sellTokenBalance == GPv2Order.BALANCE_INTERNAL;\n        funds.recipient = payable(recoveredOrder.receiver);\n        funds.toInternalBalance =\n            order.buyTokenBalance == GPv2Order.BALANCE_INTERNAL;\n\n        int256[] memory limits = new int256[](tokens.length);\n        uint256 limitAmount = trade.executedAmount;\n        // NOTE: Array allocation initializes elements to 0, so we only need to\n        // set the limits we care about. This ensures that the swap will respect\n        // the order's limit price.\n        if (order.kind == GPv2Order.KIND_SELL) {\n            require(limitAmount >= order.buyAmount, \"GPv2: limit too low\");\n            limits[trade.sellTokenIndex] = order.sellAmount.toInt256();\n            limits[trade.buyTokenIndex] = -limitAmount.toInt256();\n        } else {\n            require(limitAmount <= order.sellAmount, \"GPv2: limit too high\");\n            limits[trade.sellTokenIndex] = limitAmount.toInt256();\n            limits[trade.buyTokenIndex] = -order.buyAmount.toInt256();\n        }\n\n        GPv2Transfer.Data memory feeTransfer;\n        feeTransfer.account = recoveredOrder.owner;\n        feeTransfer.token = order.sellToken;\n        feeTransfer.amount = order.feeAmount;\n        feeTransfer.balance = order.sellTokenBalance;\n\n        int256[] memory tokenDeltas =\n            vaultRelayer.batchSwapWithFee(\n                kind,\n                swaps,\n                tokens,\n                funds,\n                limits,\n                // NOTE: Specify a deadline to ensure that an expire order\n                // cannot be used to trade.\n                order.validTo,\n                feeTransfer\n            );\n\n        bytes memory orderUid = recoveredOrder.uid;\n        uint256 executedSellAmount =\n            tokenDeltas[trade.sellTokenIndex].toUint256();\n        uint256 executedBuyAmount =\n            (-tokenDeltas[trade.buyTokenIndex]).toUint256();\n\n        // NOTE: Check that the orders were completely filled and update their\n        // filled amounts to avoid replaying them. The limit price and order\n        // validity have already been verified when executing the swap through\n        // the `limit` and `deadline` parameters.\n        require(filledAmount[orderUid] == 0, \"GPv2: order filled\");\n        if (order.kind == GPv2Order.KIND_SELL) {\n            require(\n                executedSellAmount == order.sellAmount,\n                \"GPv2: sell amount not respected\"\n            );\n            filledAmount[orderUid] = order.sellAmount;\n        } else {\n            require(\n                executedBuyAmount == order.buyAmount,\n                \"GPv2: buy amount not respected\"\n            );\n            filledAmount[orderUid] = order.buyAmount;\n        }\n\n        emit Trade(\n            recoveredOrder.owner,\n            order.sellToken,\n            order.buyToken,\n            executedSellAmount,\n            executedBuyAmount,\n            order.feeAmount,\n            orderUid\n        );\n        emit Settlement(msg.sender);\n    }\n\n    /// @dev Invalidate onchain an order that has been signed offline.\n    ///\n    /// @param orderUid The unique identifier of the order that is to be made\n    /// invalid after calling this function. The user that created the order\n    /// must be the the sender of this message. See [`extractOrderUidParams`]\n    /// for details on orderUid.\n    function invalidateOrder(bytes calldata orderUid) external {\n        (, address owner, ) = orderUid.extractOrderUidParams();\n        require(owner == msg.sender, \"GPv2: caller does not own order\");\n        filledAmount[orderUid] = uint256(-1);\n        emit OrderInvalidated(owner, orderUid);\n    }\n\n    /// @dev Free storage from the filled amounts of **expired** orders to claim\n    /// a gas refund. This method can only be called as an interaction.\n    ///\n    /// @param orderUids The unique identifiers of the expired order to free\n    /// storage for.\n    function freeFilledAmountStorage(bytes[] calldata orderUids)\n        external\n        onlyInteraction\n    {\n        freeOrderStorage(filledAmount, orderUids);\n    }\n\n    /// @dev Free storage from the pre signatures of **expired** orders to claim\n    /// a gas refund. This method can only be called as an interaction.\n    ///\n    /// @param orderUids The unique identifiers of the expired order to free\n    /// storage for.\n    function freePreSignatureStorage(bytes[] calldata orderUids)\n        external\n        onlyInteraction\n    {\n        freeOrderStorage(preSignature, orderUids);\n    }\n\n    /// @dev Process all trades one at a time returning the computed net in and\n    /// out transfers for the trades.\n    ///\n    /// This method reverts if processing of any single trade fails. See\n    /// [`computeTradeExecution`] for more details.\n    ///\n    /// @param tokens An array of ERC20 tokens to be traded in the settlement.\n    /// @param clearingPrices An array of token clearing prices.\n    /// @param trades Trades for signed orders.\n    /// @return inTransfers Array of in transfers of executed sell amounts.\n    /// @return outTransfers Array of out transfers of executed buy amounts.\n    function computeTradeExecutions(\n        IERC20[] calldata tokens,\n        uint256[] calldata clearingPrices,\n        GPv2Trade.Data[] calldata trades\n    )\n        internal\n        returns (\n            GPv2Transfer.Data[] memory inTransfers,\n            GPv2Transfer.Data[] memory outTransfers\n        )\n    {\n        RecoveredOrder memory recoveredOrder = allocateRecoveredOrder();\n\n        inTransfers = new GPv2Transfer.Data[](trades.length);\n        outTransfers = new GPv2Transfer.Data[](trades.length);\n\n        for (uint256 i = 0; i < trades.length; i++) {\n            GPv2Trade.Data calldata trade = trades[i];\n\n            recoverOrderFromTrade(recoveredOrder, tokens, trade);\n            computeTradeExecution(\n                recoveredOrder,\n                clearingPrices[trade.sellTokenIndex],\n                clearingPrices[trade.buyTokenIndex],\n                trade.executedAmount,\n                inTransfers[i],\n                outTransfers[i]\n            );\n        }\n    }\n\n    /// @dev Compute the in and out transfer amounts for a single trade.\n    /// This function reverts if:\n    /// - The order has expired\n    /// - The order's limit price is not respected\n    /// - The order gets over-filled\n    /// - The fee discount is larger than the executed fee\n    ///\n    /// @param recoveredOrder The recovered order to process.\n    /// @param sellPrice The price of the order's sell token.\n    /// @param buyPrice The price of the order's buy token.\n    /// @param executedAmount The portion of the order to execute. This will be\n    /// ignored for fill-or-kill orders.\n    /// @param inTransfer Memory location for computed executed sell amount\n    /// transfer.\n    /// @param outTransfer Memory location for computed executed buy amount\n    /// transfer.\n    function computeTradeExecution(\n        RecoveredOrder memory recoveredOrder,\n        uint256 sellPrice,\n        uint256 buyPrice,\n        uint256 executedAmount,\n        GPv2Transfer.Data memory inTransfer,\n        GPv2Transfer.Data memory outTransfer\n    ) internal {\n        GPv2Order.Data memory order = recoveredOrder.data;\n        bytes memory orderUid = recoveredOrder.uid;\n\n        // solhint-disable-next-line not-rely-on-time\n        require(order.validTo >= block.timestamp, \"GPv2: order expired\");\n\n        // NOTE: The following computation is derived from the equation:\n        // ```\n        // amount_x * price_x = amount_y * price_y\n        // ```\n        // Intuitively, if a chocolate bar is 0,50€ and a beer is 4€, 1 beer\n        // is roughly worth 8 chocolate bars (`1 * 4 = 8 * 0.5`). From this\n        // equation, we can derive:\n        // - The limit price for selling `x` and buying `y` is respected iff\n        // ```\n        // limit_x * price_x >= limit_y * price_y\n        // ```\n        // - The executed amount of token `y` given some amount of `x` and\n        //   clearing prices is:\n        // ```\n        // amount_y = amount_x * price_x / price_y\n        // ```\n\n        require(\n            order.sellAmount.mul(sellPrice) >= order.buyAmount.mul(buyPrice),\n            \"GPv2: limit price not respected\"\n        );\n\n        uint256 executedSellAmount;\n        uint256 executedBuyAmount;\n        uint256 executedFeeAmount;\n        uint256 currentFilledAmount;\n\n        if (order.kind == GPv2Order.KIND_SELL) {\n            if (order.partiallyFillable) {\n                executedSellAmount = executedAmount;\n                executedFeeAmount = order.feeAmount.mul(executedSellAmount).div(\n                    order.sellAmount\n                );\n            } else {\n                executedSellAmount = order.sellAmount;\n                executedFeeAmount = order.feeAmount;\n            }\n\n            executedBuyAmount = executedSellAmount.mul(sellPrice).ceilDiv(\n                buyPrice\n            );\n\n            currentFilledAmount = filledAmount[orderUid].add(\n                executedSellAmount\n            );\n            require(\n                currentFilledAmount <= order.sellAmount,\n                \"GPv2: order filled\"\n            );\n        } else {\n            if (order.partiallyFillable) {\n                executedBuyAmount = executedAmount;\n                executedFeeAmount = order.feeAmount.mul(executedBuyAmount).div(\n                    order.buyAmount\n                );\n            } else {\n                executedBuyAmount = order.buyAmount;\n                executedFeeAmount = order.feeAmount;\n            }\n\n            executedSellAmount = executedBuyAmount.mul(buyPrice).div(sellPrice);\n\n            currentFilledAmount = filledAmount[orderUid].add(executedBuyAmount);\n            require(\n                currentFilledAmount <= order.buyAmount,\n                \"GPv2: order filled\"\n            );\n        }\n\n        executedSellAmount = executedSellAmount.add(executedFeeAmount);\n        filledAmount[orderUid] = currentFilledAmount;\n\n        emit Trade(\n            recoveredOrder.owner,\n            order.sellToken,\n            order.buyToken,\n            executedSellAmount,\n            executedBuyAmount,\n            executedFeeAmount,\n            orderUid\n        );\n\n        inTransfer.account = recoveredOrder.owner;\n        inTransfer.token = order.sellToken;\n        inTransfer.amount = executedSellAmount;\n        inTransfer.balance = order.sellTokenBalance;\n\n        outTransfer.account = recoveredOrder.receiver;\n        outTransfer.token = order.buyToken;\n        outTransfer.amount = executedBuyAmount;\n        outTransfer.balance = order.buyTokenBalance;\n    }\n\n    /// @dev Execute a list of arbitrary contract calls from this contract.\n    /// @param interactions The list of interactions to execute.\n    function executeInteractions(GPv2Interaction.Data[] calldata interactions)\n        internal\n    {\n        for (uint256 i; i < interactions.length; i++) {\n            GPv2Interaction.Data calldata interaction = interactions[i];\n\n            // To prevent possible attack on user funds, we explicitly disable\n            // any interactions with the vault relayer contract.\n            require(\n                interaction.target != address(vaultRelayer),\n                \"GPv2: forbidden interaction\"\n            );\n            GPv2Interaction.execute(interaction);\n\n            emit Interaction(\n                interaction.target,\n                interaction.value,\n                GPv2Interaction.selector(interaction)\n            );\n        }\n    }\n\n    /// @dev Claims refund for the specified storage and order UIDs.\n    ///\n    /// This method reverts if any of the orders are still valid.\n    ///\n    /// @param orderUids Order refund data for freeing storage.\n    /// @param orderStorage Order storage mapped on a UID.\n    function freeOrderStorage(\n        mapping(bytes => uint256) storage orderStorage,\n        bytes[] calldata orderUids\n    ) internal {\n        for (uint256 i = 0; i < orderUids.length; i++) {\n            bytes calldata orderUid = orderUids[i];\n\n            (, , uint32 validTo) = orderUid.extractOrderUidParams();\n            // solhint-disable-next-line not-rely-on-time\n            require(validTo < block.timestamp, \"GPv2: order still valid\");\n\n            orderStorage[orderUid] = 0;\n        }\n    }\n}\n"},"src/contracts/test/GPv2AllowListAuthenticationV2.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\nimport \"../GPv2AllowListAuthentication.sol\";\n\ncontract GPv2AllowListAuthenticationV2 is GPv2AllowListAuthentication {\n    function newMethod() external pure returns (uint256) {\n        return 1337;\n    }\n}\n"},"src/contracts/test/StateChangingERC1271.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\nimport \"../interfaces/GPv2EIP1271.sol\";\n\n/// @dev This contract implements the standard described in EIP-1271 with the\n/// minor change that the verification function changes the state. This is\n/// forbidden by the standard specifications.\ncontract StateChangingEIP1271 {\n    uint256 public state = 0;\n\n    // solhint-disable-next-line no-unused-vars\n    function isValidSignature(bytes32 _hash, bytes memory _signature)\n        public\n        returns (bytes4 magicValue)\n    {\n        state += 1;\n        magicValue = GPv2EIP1271.MAGICVALUE;\n\n        // The following lines are here to suppress no-unused-var compiler-time\n        // warnings when compiling the contracts. The warning is forwarded by\n        // Hardhat from Solc. It is currently not possible to selectively\n        // ignore Solc warinings:\n        // <https://github.com/ethereum/solidity/issues/269>\n        _hash;\n        _signature;\n    }\n}\n"},"src/contracts/mixins/GPv2Signing.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\nimport \"../interfaces/GPv2EIP1271.sol\";\nimport \"../libraries/GPv2Order.sol\";\nimport \"../libraries/GPv2Trade.sol\";\n\n/// @title Gnosis Protocol v2 Signing Library.\n/// @author Gnosis Developers\nabstract contract GPv2Signing {\n    using GPv2Order for GPv2Order.Data;\n    using GPv2Order for bytes;\n\n    /// @dev Recovered trade data containing the extracted order and the\n    /// recovered owner address.\n    struct RecoveredOrder {\n        GPv2Order.Data data;\n        bytes uid;\n        address owner;\n        address receiver;\n    }\n\n    /// @dev Signing scheme used for recovery.\n    enum Scheme {Eip712, EthSign, Eip1271, PreSign}\n\n    /// @dev The EIP-712 domain type hash used for computing the domain\n    /// separator.\n    bytes32 private constant DOMAIN_TYPE_HASH =\n        keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n\n    /// @dev The EIP-712 domain name used for computing the domain separator.\n    bytes32 private constant DOMAIN_NAME = keccak256(\"Gnosis Protocol\");\n\n    /// @dev The EIP-712 domain version used for computing the domain separator.\n    bytes32 private constant DOMAIN_VERSION = keccak256(\"v2\");\n\n    /// @dev Marker value indicating an order is pre-signed.\n    uint256 private constant PRE_SIGNED =\n        uint256(keccak256(\"GPv2Signing.Scheme.PreSign\"));\n\n    /// @dev The domain separator used for signing orders that gets mixed in\n    /// making signatures for different domains incompatible. This domain\n    /// separator is computed following the EIP-712 standard and has replay\n    /// protection mixed in so that signed orders are only valid for specific\n    /// GPv2 contracts.\n    bytes32 public immutable domainSeparator;\n\n    /// @dev Storage indicating whether or not an order has been signed by a\n    /// particular address.\n    mapping(bytes => uint256) public preSignature;\n\n    /// @dev Event that is emitted when an account either pre-signs an order or\n    /// revokes an existing pre-signature.\n    event PreSignature(address indexed owner, bytes orderUid, bool signed);\n\n    constructor() {\n        // NOTE: Currently, the only way to get the chain ID in solidity is\n        // using assembly.\n        uint256 chainId;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            chainId := chainid()\n        }\n\n        domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPE_HASH,\n                DOMAIN_NAME,\n                DOMAIN_VERSION,\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    /// @dev Sets a presignature for the specified order UID.\n    ///\n    /// @param orderUid The unique identifier of the order to pre-sign.\n    function setPreSignature(bytes calldata orderUid, bool signed) external {\n        (, address owner, ) = orderUid.extractOrderUidParams();\n        require(owner == msg.sender, \"GPv2: cannot presign order\");\n        if (signed) {\n            preSignature[orderUid] = PRE_SIGNED;\n        } else {\n            preSignature[orderUid] = 0;\n        }\n        emit PreSignature(owner, orderUid, signed);\n    }\n\n    /// @dev Returns an empty recovered order with a pre-allocated buffer for\n    /// packing the unique identifier.\n    ///\n    /// @return recoveredOrder The empty recovered order data.\n    function allocateRecoveredOrder()\n        internal\n        pure\n        returns (RecoveredOrder memory recoveredOrder)\n    {\n        recoveredOrder.uid = new bytes(GPv2Order.UID_LENGTH);\n    }\n\n    /// @dev Extracts order data and recovers the signer from the specified\n    /// trade.\n    ///\n    /// @param recoveredOrder Memory location used for writing the recovered order data.\n    /// @param tokens The list of tokens included in the settlement. The token\n    /// indices in the trade parameters map to tokens in this array.\n    /// @param trade The trade data to recover the order data from.\n    function recoverOrderFromTrade(\n        RecoveredOrder memory recoveredOrder,\n        IERC20[] calldata tokens,\n        GPv2Trade.Data calldata trade\n    ) internal view {\n        GPv2Order.Data memory order = recoveredOrder.data;\n\n        Scheme signingScheme = GPv2Trade.extractOrder(trade, tokens, order);\n        (bytes32 orderDigest, address owner) =\n            recoverOrderSigner(order, signingScheme, trade.signature);\n\n        recoveredOrder.uid.packOrderUidParams(\n            orderDigest,\n            owner,\n            order.validTo\n        );\n        recoveredOrder.owner = owner;\n        recoveredOrder.receiver = order.actualReceiver(owner);\n    }\n\n    /// @dev The length of any signature from an externally owned account.\n    uint256 private constant ECDSA_SIGNATURE_LENGTH = 65;\n\n    /// @dev Recovers an order's signer from the specified order and signature.\n    ///\n    /// @param order The order to recover a signature for.\n    /// @param signingScheme The signing scheme.\n    /// @param signature The signature bytes.\n    /// @return orderDigest The computed order hash.\n    /// @return owner The recovered address from the specified signature.\n    function recoverOrderSigner(\n        GPv2Order.Data memory order,\n        Scheme signingScheme,\n        bytes calldata signature\n    ) internal view returns (bytes32 orderDigest, address owner) {\n        orderDigest = order.hash(domainSeparator);\n        if (signingScheme == Scheme.Eip712) {\n            owner = recoverEip712Signer(orderDigest, signature);\n        } else if (signingScheme == Scheme.EthSign) {\n            owner = recoverEthsignSigner(orderDigest, signature);\n        } else if (signingScheme == Scheme.Eip1271) {\n            owner = recoverEip1271Signer(orderDigest, signature);\n        } else {\n            // signingScheme == Scheme.PreSign\n            owner = recoverPreSigner(orderDigest, signature, order.validTo);\n        }\n    }\n\n    /// @dev Perform an ECDSA recover for the specified message and calldata\n    /// signature.\n    ///\n    /// The signature is encoded by tighyly packing the following struct:\n    /// ```\n    /// struct EncodedSignature {\n    ///     bytes32 r;\n    ///     bytes32 s;\n    ///     uint8 v;\n    /// }\n    /// ```\n    ///\n    /// @param message The signed message.\n    /// @param encodedSignature The encoded signature.\n    function ecdsaRecover(bytes32 message, bytes calldata encodedSignature)\n        internal\n        pure\n        returns (address signer)\n    {\n        require(\n            encodedSignature.length == ECDSA_SIGNATURE_LENGTH,\n            \"GPv2: malformed ecdsa signature\"\n        );\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // NOTE: Use assembly to efficiently decode signature data.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // r = uint256(encodedSignature[0:32])\n            r := calldataload(encodedSignature.offset)\n            // s = uint256(encodedSignature[32:64])\n            s := calldataload(add(encodedSignature.offset, 32))\n            // v = uint8(encodedSignature[64])\n            v := shr(248, calldataload(add(encodedSignature.offset, 64)))\n        }\n\n        signer = ecrecover(message, v, r, s);\n        require(signer != address(0), \"GPv2: invalid ecdsa signature\");\n    }\n\n    /// @dev Decodes signature bytes originating from an EIP-712-encoded\n    /// signature.\n    ///\n    /// EIP-712 signs typed data. The specifications are described in the\n    /// related EIP (<https://eips.ethereum.org/EIPS/eip-712>).\n    ///\n    /// EIP-712 signatures are encoded as standard ECDSA signatures as described\n    /// in the corresponding decoding function [`ecdsaRecover`].\n    ///\n    /// @param orderDigest The EIP-712 signing digest derived from the order\n    /// parameters.\n    /// @param encodedSignature Calldata pointing to tightly packed signature\n    /// bytes.\n    /// @return owner The address of the signer.\n    function recoverEip712Signer(\n        bytes32 orderDigest,\n        bytes calldata encodedSignature\n    ) internal pure returns (address owner) {\n        owner = ecdsaRecover(orderDigest, encodedSignature);\n    }\n\n    /// @dev Decodes signature bytes originating from the output of the eth_sign\n    /// RPC call.\n    ///\n    /// The specifications are described in the Ethereum documentation\n    /// (<https://eth.wiki/json-rpc/API#eth_sign>).\n    ///\n    /// eth_sign signatures are encoded as standard ECDSA signatures as\n    /// described in the corresponding decoding function\n    /// [`ecdsaRecover`].\n    ///\n    /// @param orderDigest The EIP-712 signing digest derived from the order\n    /// parameters.\n    /// @param encodedSignature Calldata pointing to tightly packed signature\n    /// bytes.\n    /// @return owner The address of the signer.\n    function recoverEthsignSigner(\n        bytes32 orderDigest,\n        bytes calldata encodedSignature\n    ) internal pure returns (address owner) {\n        // The signed message is encoded as:\n        // `\"\\x19Ethereum Signed Message:\\n\" || length || data`, where\n        // the length is a constant (32 bytes) and the data is defined as:\n        // `orderDigest`.\n        bytes32 ethsignDigest =\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19Ethereum Signed Message:\\n32\",\n                    orderDigest\n                )\n            );\n\n        owner = ecdsaRecover(ethsignDigest, encodedSignature);\n    }\n\n    /// @dev Verifies the input calldata as an EIP-1271 contract signature and\n    /// returns the address of the signer.\n    ///\n    /// The encoded signature tightly packs the following struct:\n    ///\n    /// ```\n    /// struct EncodedEip1271Signature {\n    ///     address owner;\n    ///     bytes signature;\n    /// }\n    /// ```\n    ///\n    /// This function enforces that the encoded data stores enough bytes to\n    /// cover the full length of the decoded signature.\n    ///\n    /// @param encodedSignature The encoded EIP-1271 signature.\n    /// @param orderDigest The EIP-712 signing digest derived from the order\n    /// parameters.\n    /// @return owner The address of the signer.\n    function recoverEip1271Signer(\n        bytes32 orderDigest,\n        bytes calldata encodedSignature\n    ) internal view returns (address owner) {\n        // NOTE: Use assembly to read the verifier address from the encoded\n        // signature bytes.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // owner = address(encodedSignature[0:20])\n            owner := shr(96, calldataload(encodedSignature.offset))\n        }\n\n        // NOTE: Configure prettier to ignore the following line as it causes\n        // a panic in the Solidity plugin.\n        // prettier-ignore\n        bytes calldata signature = encodedSignature[20:];\n\n        require(\n            EIP1271Verifier(owner).isValidSignature(orderDigest, signature) ==\n                GPv2EIP1271.MAGICVALUE,\n            \"GPv2: invalid eip1271 signature\"\n        );\n    }\n\n    /// @dev Verifies the order has been pre-signed. The signature is the\n    /// address of the signer of the order.\n    ///\n    /// @param orderDigest The EIP-712 signing digest derived from the order\n    /// parameters.\n    /// @param encodedSignature The pre-sign signature reprenting the order UID.\n    /// @param validTo The order expiry timestamp.\n    /// @return owner The address of the signer.\n    function recoverPreSigner(\n        bytes32 orderDigest,\n        bytes calldata encodedSignature,\n        uint32 validTo\n    ) internal view returns (address owner) {\n        require(encodedSignature.length == 20, \"GPv2: malformed presignature\");\n        // NOTE: Use assembly to read the owner address from the encoded\n        // signature bytes.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // owner = address(encodedSignature[0:20])\n            owner := shr(96, calldataload(encodedSignature.offset))\n        }\n\n        bytes memory orderUid = new bytes(GPv2Order.UID_LENGTH);\n        orderUid.packOrderUidParams(orderDigest, owner, validTo);\n\n        require(\n            preSignature[orderUid] == PRE_SIGNED,\n            \"GPv2: order not presigned\"\n        );\n    }\n}\n"},"src/contracts/test/GPv2AllowListAuthenticationTestInterface.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\nimport \"../GPv2AllowListAuthentication.sol\";\nimport \"../libraries/GPv2EIP1967.sol\";\n\ncontract GPv2AllowListAuthenticationTestInterface is\n    GPv2AllowListAuthentication\n{\n    constructor(address owner) {\n        GPv2EIP1967.setAdmin(owner);\n    }\n}\n"},"src/contracts/GPv2VaultRelayer.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./libraries/GPv2Transfer.sol\";\n\n/// @title Gnosis Protocol v2 Vault Relayer Contract\n/// @author Gnosis Developers\ncontract GPv2VaultRelayer {\n    using GPv2Transfer for IVault;\n\n    /// @dev The creator of the contract which has special permissions. This\n    /// value is set at creation time and cannot change.\n    address private immutable creator;\n\n    /// @dev The vault this relayer is for.\n    IVault private immutable vault;\n\n    constructor(IVault vault_) {\n        creator = msg.sender;\n        vault = vault_;\n    }\n\n    /// @dev Modifier that ensures that a function can only be called by the\n    /// creator of this contract.\n    modifier onlyCreator {\n        require(msg.sender == creator, \"GPv2: not creator\");\n        _;\n    }\n\n    /// @dev Transfers all sell amounts for the executed trades from their\n    /// owners to the caller.\n    ///\n    /// This function reverts if:\n    /// - The caller is not the creator of the vault relayer\n    /// - Any ERC20 transfer fails\n    ///\n    /// @param transfers The transfers to execute.\n    function transferFromAccounts(GPv2Transfer.Data[] calldata transfers)\n        external\n        onlyCreator\n    {\n        vault.transferFromAccounts(transfers, msg.sender);\n    }\n\n    /// @dev Performs a Balancer batched swap on behalf of a user and sends a\n    /// fee to the caller.\n    ///\n    /// This function reverts if:\n    /// - The caller is not the creator of the vault relayer\n    /// - The swap fails\n    /// - The fee transfer fails\n    ///\n    /// @param kind The Balancer swap kind, this can either be `GIVEN_IN` for\n    /// sell orders or `GIVEN_OUT` for buy orders.\n    /// @param swaps The swaps to perform.\n    /// @param tokens The tokens for the swaps. Swaps encode to and from tokens\n    /// as indices into this array.\n    /// @param funds The fund management settings, specifying the user the swap\n    /// is being performed for as well as the recipient of the proceeds.\n    /// @param limits Swap limits for encoding limit prices.\n    /// @param deadline The deadline for the swap.\n    /// @param feeTransfer The transfer data for the caller fee.\n    /// @return tokenDeltas The executed swap amounts.\n    function batchSwapWithFee(\n        IVault.SwapKind kind,\n        IVault.BatchSwapStep[] calldata swaps,\n        IERC20[] memory tokens,\n        IVault.FundManagement memory funds,\n        int256[] memory limits,\n        uint256 deadline,\n        GPv2Transfer.Data calldata feeTransfer\n    ) external onlyCreator returns (int256[] memory tokenDeltas) {\n        tokenDeltas = vault.batchSwap(\n            kind,\n            swaps,\n            tokens,\n            funds,\n            limits,\n            deadline\n        );\n        vault.fastTransferFromAccount(feeTransfer, msg.sender);\n    }\n}\n"},"src/contracts/mixins/ReentrancyGuard.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// Vendored from OpenZeppelin contracts with minor modifications:\n// - Modified Solidity version\n// - Formatted code\n// <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/utils/ReentrancyGuard.sol>\n\npragma solidity ^0.7.6;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"},"src/contracts/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// Vendored from OpenZeppelin contracts with minor modifications:\n// - Modified Solidity version\n// - Formatted code\n// - Added `name`, `symbol` and `decimals` function declarations\n// <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/token/ERC20/IERC20.sol>\n\npragma solidity ^0.7.6;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the number of decimals the token uses.\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"},"src/contracts/test/GPv2InteractionTestInterface.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/GPv2Interaction.sol\";\n\ncontract GPv2InteractionTestInterface {\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    function executeTest(GPv2Interaction.Data calldata interaction) external {\n        GPv2Interaction.execute(interaction);\n    }\n\n    function selectorTest(GPv2Interaction.Data calldata interaction)\n        external\n        pure\n        returns (bytes4)\n    {\n        return GPv2Interaction.selector(interaction);\n    }\n}\n"},"src/contracts/libraries/GPv2EIP1967.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\nlibrary GPv2EIP1967 {\n    /// @dev The storage slot where the proxy administrator is stored, defined\n    /// as `keccak256('eip1967.proxy.admin') - 1`.\n    bytes32 internal constant ADMIN_SLOT =\n        hex\"b53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\";\n\n    /// @dev Returns the address stored in the EIP-1967 administrator storage\n    /// slot for the current contract. If this method is not called from an\n    /// contract behind an EIP-1967 proxy, then it will most likely return\n    /// `address(0)`, as the implementation slot is likely to be unset.\n    ///\n    /// @return admin The administrator address.\n    function getAdmin() internal view returns (address admin) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            admin := sload(ADMIN_SLOT)\n        }\n    }\n\n    /// @dev Sets the storage at the EIP-1967 administrator slot to be the\n    /// specified address.\n    ///\n    /// @param admin The administrator address to set.\n    function setAdmin(address admin) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(ADMIN_SLOT, admin)\n        }\n    }\n}\n"},"src/contracts/libraries/GPv2Transfer.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IVault.sol\";\nimport \"./GPv2Order.sol\";\nimport \"./GPv2SafeERC20.sol\";\n\n/// @title Gnosis Protocol v2 Transfers\n/// @author Gnosis Developers\nlibrary GPv2Transfer {\n    using GPv2SafeERC20 for IERC20;\n\n    /// @dev Transfer data.\n    struct Data {\n        address account;\n        IERC20 token;\n        uint256 amount;\n        bytes32 balance;\n    }\n\n    /// @dev Ether marker address used to indicate an Ether transfer.\n    address internal constant BUY_ETH_ADDRESS =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    /// @dev Execute the specified transfer from the specified account to a\n    /// recipient. The recipient will either receive internal Vault balances or\n    /// ERC20 token balances depending on whether the account is using internal\n    /// balances or not.\n    ///\n    /// This method is used for transferring fees to the settlement contract\n    /// when settling a single order directly with Balancer.\n    ///\n    /// Note that this method is subtly different from `transferFromAccounts`\n    /// with a single transfer with respect to how it deals with internal\n    /// balances. Specifically, this method will perform an **internal balance\n    /// transfer to the settlement contract instead of a withdrawal to the\n    /// external balance of the settlement contract** for trades that specify\n    /// trading with internal balances. This is done as a gas optimization in\n    /// the single order \"fast-path\".\n    ///\n    /// @param vault The Balancer vault to use.\n    /// @param transfer The transfer to perform specifying the sender account.\n    /// @param recipient The recipient for the transfer.\n    function fastTransferFromAccount(\n        IVault vault,\n        Data calldata transfer,\n        address recipient\n    ) internal {\n        require(\n            address(transfer.token) != BUY_ETH_ADDRESS,\n            \"GPv2: cannot transfer native ETH\"\n        );\n\n        if (transfer.balance == GPv2Order.BALANCE_ERC20) {\n            transfer.token.safeTransferFrom(\n                transfer.account,\n                recipient,\n                transfer.amount\n            );\n        } else {\n            IVault.UserBalanceOp[] memory balanceOps =\n                new IVault.UserBalanceOp[](1);\n\n            IVault.UserBalanceOp memory balanceOp = balanceOps[0];\n            balanceOp.kind = transfer.balance == GPv2Order.BALANCE_EXTERNAL\n                ? IVault.UserBalanceOpKind.TRANSFER_EXTERNAL\n                : IVault.UserBalanceOpKind.TRANSFER_INTERNAL;\n            balanceOp.asset = transfer.token;\n            balanceOp.amount = transfer.amount;\n            balanceOp.sender = transfer.account;\n            balanceOp.recipient = payable(recipient);\n\n            vault.manageUserBalance(balanceOps);\n        }\n    }\n\n    /// @dev Execute the specified transfers from the specified accounts to a\n    /// single recipient. The recipient will receive all transfers as ERC20\n    /// token balances, regardless of whether or not the accounts are using\n    /// internal Vault balances.\n    ///\n    /// This method is used for accumulating user balances into the settlement\n    /// contract.\n    ///\n    /// @param vault The Balancer vault to use.\n    /// @param transfers The batched transfers to perform specifying the\n    /// sender accounts.\n    /// @param recipient The single recipient for all the transfers.\n    function transferFromAccounts(\n        IVault vault,\n        Data[] calldata transfers,\n        address recipient\n    ) internal {\n        // NOTE: Allocate buffer of Vault balance operations large enough to\n        // hold all GP transfers. This is done to avoid re-allocations (which\n        // are gas inefficient) while still allowing all transfers to be batched\n        // into a single Vault call.\n        IVault.UserBalanceOp[] memory balanceOps =\n            new IVault.UserBalanceOp[](transfers.length);\n        uint256 balanceOpCount = 0;\n\n        for (uint256 i = 0; i < transfers.length; i++) {\n            Data calldata transfer = transfers[i];\n            require(\n                address(transfer.token) != BUY_ETH_ADDRESS,\n                \"GPv2: cannot transfer native ETH\"\n            );\n\n            if (transfer.balance == GPv2Order.BALANCE_ERC20) {\n                transfer.token.safeTransferFrom(\n                    transfer.account,\n                    recipient,\n                    transfer.amount\n                );\n            } else {\n                IVault.UserBalanceOp memory balanceOp =\n                    balanceOps[balanceOpCount++];\n                balanceOp.kind = transfer.balance == GPv2Order.BALANCE_EXTERNAL\n                    ? IVault.UserBalanceOpKind.TRANSFER_EXTERNAL\n                    : IVault.UserBalanceOpKind.WITHDRAW_INTERNAL;\n                balanceOp.asset = transfer.token;\n                balanceOp.amount = transfer.amount;\n                balanceOp.sender = transfer.account;\n                balanceOp.recipient = payable(recipient);\n            }\n        }\n\n        if (balanceOpCount > 0) {\n            truncateBalanceOpsArray(balanceOps, balanceOpCount);\n            vault.manageUserBalance(balanceOps);\n        }\n    }\n\n    /// @dev Execute the specified transfers to their respective accounts.\n    ///\n    /// This method is used for paying out trade proceeds from the settlement\n    /// contract.\n    ///\n    /// @param vault The Balancer vault to use.\n    /// @param transfers The batched transfers to perform.\n    function transferToAccounts(IVault vault, Data[] memory transfers)\n        internal\n    {\n        IVault.UserBalanceOp[] memory balanceOps =\n            new IVault.UserBalanceOp[](transfers.length);\n        uint256 balanceOpCount = 0;\n\n        for (uint256 i = 0; i < transfers.length; i++) {\n            Data memory transfer = transfers[i];\n\n            if (address(transfer.token) == BUY_ETH_ADDRESS) {\n                require(\n                    transfer.balance != GPv2Order.BALANCE_INTERNAL,\n                    \"GPv2: unsupported internal ETH\"\n                );\n                payable(transfer.account).transfer(transfer.amount);\n            } else if (transfer.balance == GPv2Order.BALANCE_ERC20) {\n                transfer.token.safeTransfer(transfer.account, transfer.amount);\n            } else {\n                IVault.UserBalanceOp memory balanceOp =\n                    balanceOps[balanceOpCount++];\n                balanceOp.kind = IVault.UserBalanceOpKind.DEPOSIT_INTERNAL;\n                balanceOp.asset = transfer.token;\n                balanceOp.amount = transfer.amount;\n                balanceOp.sender = address(this);\n                balanceOp.recipient = payable(transfer.account);\n            }\n        }\n\n        if (balanceOpCount > 0) {\n            truncateBalanceOpsArray(balanceOps, balanceOpCount);\n            vault.manageUserBalance(balanceOps);\n        }\n    }\n\n    /// @dev Truncate a Vault balance operation array to its actual size.\n    ///\n    /// This method **does not** check whether or not the new length is valid,\n    /// and specifying a size that is larger than the array's actual length is\n    /// undefined behaviour.\n    ///\n    /// @param balanceOps The memory array of balance operations to truncate.\n    /// @param newLength The new length to set.\n    function truncateBalanceOpsArray(\n        IVault.UserBalanceOp[] memory balanceOps,\n        uint256 newLength\n    ) private pure {\n        // NOTE: Truncate the vault transfers array to the specified length.\n        // This is done by setting the array's length which occupies the first\n        // word in memory pointed to by the `balanceOps` memory variable.\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(balanceOps, newLength)\n        }\n    }\n}\n"},"src/contracts/interfaces/GPv2Authentication.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\n/// @title Gnosis Protocol v2 Authentication Interface\n/// @author Gnosis Developers\ninterface GPv2Authentication {\n    /// @dev determines whether the provided address is an authenticated solver.\n    /// @param prospectiveSolver the address of prospective solver.\n    /// @return true when prospectiveSolver is an authenticated solver, otherwise false.\n    function isSolver(address prospectiveSolver) external view returns (bool);\n}\n"},"src/contracts/GPv2AllowListAuthentication.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\nimport \"./interfaces/GPv2Authentication.sol\";\nimport \"./libraries/GPv2EIP1967.sol\";\nimport \"./mixins/Initializable.sol\";\nimport \"./mixins/StorageAccessible.sol\";\n\n/// @title Gnosis Protocol v2 Access Control Contract\n/// @author Gnosis Developers\ncontract GPv2AllowListAuthentication is\n    GPv2Authentication,\n    Initializable,\n    StorageAccessible\n{\n    /// @dev The address of the manager that has permissions to add and remove\n    /// solvers.\n    address public manager;\n\n    /// @dev The set of allowed solvers. Allowed solvers have a value of `true`\n    /// in this mapping.\n    mapping(address => bool) private solvers;\n\n    /// @dev Event emitted when the manager changes.\n    event ManagerChanged(address newManager, address oldManager);\n\n    /// @dev Event emitted when a solver gets added.\n    event SolverAdded(address solver);\n\n    /// @dev Event emitted when a solver gets removed.\n    event SolverRemoved(address solver);\n\n    /// @dev Initialize the manager to a value.\n    ///\n    /// This method is a contract initializer that is called exactly once after\n    /// creation. An initializer is used instead of a constructor so that this\n    /// contract can be used behind a proxy.\n    ///\n    /// This initializer is idempotent.\n    ///\n    /// @param manager_ The manager to initialize the contract with.\n    function initializeManager(address manager_) external initializer {\n        manager = manager_;\n        emit ManagerChanged(manager_, address(0));\n    }\n\n    /// @dev Modifier that ensures a method can only be called by the contract\n    /// manager. Reverts if called by other addresses.\n    modifier onlyManager() {\n        require(manager == msg.sender, \"GPv2: caller not manager\");\n        _;\n    }\n\n    /// @dev Modifier that ensures method can be either called by the contract\n    /// manager or the proxy owner.\n    ///\n    /// This modifier assumes that the proxy uses an EIP-1967 compliant storage\n    /// slot for the admin.\n    modifier onlyManagerOrOwner() {\n        require(\n            manager == msg.sender || GPv2EIP1967.getAdmin() == msg.sender,\n            \"GPv2: not authorized\"\n        );\n        _;\n    }\n\n    /// @dev Set the manager for this contract.\n    ///\n    /// This method can be called by the current manager (if they want to to\n    /// reliquish the role and give it to another address) or the contract\n    /// owner (i.e. the proxy admin).\n    ///\n    /// @param manager_ The new contract manager address.\n    function setManager(address manager_) external onlyManagerOrOwner {\n        address oldManager = manager;\n        manager = manager_;\n        emit ManagerChanged(manager_, oldManager);\n    }\n\n    /// @dev Add an address to the set of allowed solvers. This method can only\n    /// be called by the contract manager.\n    ///\n    /// This function is idempotent.\n    ///\n    /// @param solver The solver address to add.\n    function addSolver(address solver) external onlyManager {\n        solvers[solver] = true;\n        emit SolverAdded(solver);\n    }\n\n    /// @dev Removes an address to the set of allowed solvers. This method can\n    /// only be called by the contract manager.\n    ///\n    /// This function is idempotent.\n    ///\n    /// @param solver The solver address to remove.\n    function removeSolver(address solver) external onlyManager {\n        solvers[solver] = false;\n        emit SolverRemoved(solver);\n    }\n\n    /// @inheritdoc GPv2Authentication\n    function isSolver(address prospectiveSolver)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return solvers[prospectiveSolver];\n    }\n}\n"},"src/contracts/libraries/GPv2Interaction.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\n/// @title Gnosis Protocol v2 Interaction Library\n/// @author Gnosis Developers\nlibrary GPv2Interaction {\n    /// @dev Interaction data for performing arbitrary contract interactions.\n    /// Submitted to [`GPv2Settlement.settle`] for code execution.\n    struct Data {\n        address target;\n        uint256 value;\n        bytes callData;\n    }\n\n    /// @dev Execute an arbitrary contract interaction.\n    ///\n    /// @param interaction Interaction data.\n    function execute(Data calldata interaction) internal {\n        address target = interaction.target;\n        uint256 value = interaction.value;\n        bytes calldata callData = interaction.callData;\n\n        // NOTE: Use assembly to call the interaction instead of a low level\n        // call for two reasons:\n        // - We don't want to copy the return data, since we discard it for\n        // interactions.\n        // - Solidity will under certain conditions generate code to copy input\n        // calldata twice to memory (the second being a \"memcopy loop\").\n        // <https://github.com/gnosis/gp-v2-contracts/pull/417#issuecomment-775091258>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            calldatacopy(freeMemoryPointer, callData.offset, callData.length)\n            if iszero(\n                call(\n                    gas(),\n                    target,\n                    value,\n                    freeMemoryPointer,\n                    callData.length,\n                    0,\n                    0\n                )\n            ) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    /// @dev Extracts the Solidity ABI selector for the specified interaction.\n    ///\n    /// @param interaction Interaction data.\n    /// @return result The 4 byte function selector of the call encoded in\n    /// this interaction.\n    function selector(Data calldata interaction)\n        internal\n        pure\n        returns (bytes4 result)\n    {\n        bytes calldata callData = interaction.callData;\n        if (callData.length >= 4) {\n            // NOTE: Read the first word of the interaction's calldata. The\n            // value does not need to be shifted since `bytesN` values are left\n            // aligned, and the value does not need to be masked since masking\n            // occurs when the value is accessed and not stored:\n            // <https://docs.soliditylang.org/en/v0.7.6/abi-spec.html#encoding-of-indexed-event-parameters>\n            // <https://docs.soliditylang.org/en/v0.7.6/assembly.html#access-to-external-variables-functions-and-libraries>\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                result := calldataload(callData.offset)\n            }\n        }\n    }\n}\n"},"src/contracts/libraries/SafeCast.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// Vendored from OpenZeppelin contracts with minor modifications:\n// - Modified Solidity version\n// - Formatted code\n// - Shortened revert messages\n// - Removed unused methods\n// - Convert to `type(*).*` notation\n// <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/utils/SafeCast.sol>\n\npragma solidity ^0.7.6;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: not positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(\n            value <= uint256(type(int256).max),\n            \"SafeCast: int256 overflow\"\n        );\n        return int256(value);\n    }\n}\n"},"src/contracts/interfaces/GPv2EIP1271.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\nlibrary GPv2EIP1271 {\n    /// @dev Value returned by a call to `isValidSignature` if the signature\n    /// was verified successfully. The value is defined in EIP-1271 as:\n    /// bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))\n    bytes4 internal constant MAGICVALUE = 0x1626ba7e;\n}\n\n/// @title EIP1271 Interface\n/// @dev Standardized interface for an implementation of smart contract\n/// signatures as described in EIP-1271. The code that follows is identical to\n/// the code in the standard with the exception of formatting and syntax\n/// changes to adapt the code to our Solidity version.\ninterface EIP1271Verifier {\n    /// @dev Should return whether the signature provided is valid for the\n    /// provided data\n    /// @param _hash      Hash of the data to be signed\n    /// @param _signature Signature byte array associated with _data\n    ///\n    /// MUST return the bytes4 magic value 0x1626ba7e when function passes.\n    /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for\n    /// solc > 0.5)\n    /// MUST allow external calls\n    ///\n    function isValidSignature(bytes32 _hash, bytes memory _signature)\n        external\n        view\n        returns (bytes4 magicValue);\n}\n"},"src/contracts/test/NonStandardERC20.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\nimport \"../libraries/SafeMath.sol\";\n\nabstract contract NonStandardERC20 {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    function mint(address to, uint256 amount) external {\n        balanceOf[to] = balanceOf[to].add(amount);\n    }\n\n    function approve(address spender, uint256 amount) external {\n        allowance[msg.sender][spender] = amount;\n    }\n\n    function transfer_(address to, uint256 amount) internal {\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount);\n        balanceOf[to] = balanceOf[to].add(amount);\n    }\n\n    function transferFrom_(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        allowance[from][msg.sender] = allowance[from][msg.sender].sub(amount);\n        balanceOf[from] = balanceOf[from].sub(amount);\n        balanceOf[to] = balanceOf[to].add(amount);\n    }\n}\n\ncontract ERC20NoReturn is NonStandardERC20 {\n    function transfer(address to, uint256 amount) external {\n        transfer_(to, amount);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external {\n        transferFrom_(from, to, amount);\n    }\n}\n\ncontract ERC20ReturningUint is NonStandardERC20 {\n    // Largest 256-bit prime :)\n    uint256 private constant OK =\n        115792089237316195423570985008687907853269984665640564039457584007913129639747;\n\n    function transfer(address to, uint256 amount) external returns (uint256) {\n        transfer_(to, amount);\n        return OK;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (uint256) {\n        transferFrom_(from, to, amount);\n        return OK;\n    }\n}\n"},"src/contracts/test/GPv2SafeERC20TestInterface.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../libraries/GPv2SafeERC20.sol\";\n\ncontract GPv2SafeERC20TestInterface {\n    using GPv2SafeERC20 for IERC20;\n\n    function transfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) public {\n        token.safeTransfer(to, value);\n    }\n\n    function transferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) public {\n        token.safeTransferFrom(from, to, value);\n    }\n}\n"},"src/contracts/test/SmartSellOrder.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"../interfaces/GPv2EIP1271.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../libraries/GPv2Order.sol\";\nimport \"../libraries/GPv2SafeERC20.sol\";\nimport \"../libraries/SafeMath.sol\";\nimport \"../GPv2Settlement.sol\";\n\n/// @title Proof of Concept Smart Order\n/// @author Gnosis Developers\ncontract SmartSellOrder is EIP1271Verifier {\n    using GPv2Order for GPv2Order.Data;\n    using GPv2SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    bytes32 public constant APPDATA = keccak256(\"SmartSellOrder\");\n\n    address public immutable owner;\n    bytes32 public immutable domainSeparator;\n    IERC20 public immutable sellToken;\n    IERC20 public immutable buyToken;\n    uint256 public immutable totalSellAmount;\n    uint256 public immutable totalFeeAmount;\n    uint32 public immutable validTo;\n\n    constructor(\n        GPv2Settlement settlement,\n        IERC20 sellToken_,\n        IERC20 buyToken_,\n        uint32 validTo_,\n        uint256 totalSellAmount_,\n        uint256 totalFeeAmount_\n    ) {\n        owner = msg.sender;\n        domainSeparator = settlement.domainSeparator();\n        sellToken = sellToken_;\n        buyToken = buyToken_;\n        validTo = validTo_;\n        totalSellAmount = totalSellAmount_;\n        totalFeeAmount = totalFeeAmount_;\n\n        sellToken_.approve(\n            address(settlement.vaultRelayer()),\n            type(uint256).max\n        );\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"not owner\");\n        _;\n    }\n\n    function withdraw(uint256 amount) external onlyOwner {\n        sellToken.safeTransfer(owner, amount);\n    }\n\n    function close() external onlyOwner {\n        uint256 balance = sellToken.balanceOf(address(this));\n        if (balance != 0) {\n            sellToken.safeTransfer(owner, balance);\n        }\n        selfdestruct(payable(owner));\n    }\n\n    function isValidSignature(bytes32 hash, bytes memory signature)\n        external\n        view\n        override\n        returns (bytes4 magicValue)\n    {\n        uint256 sellAmount = abi.decode(signature, (uint256));\n        GPv2Order.Data memory order = orderForSellAmount(sellAmount);\n\n        if (order.hash(domainSeparator) == hash) {\n            magicValue = GPv2EIP1271.MAGICVALUE;\n        }\n    }\n\n    function orderForSellAmount(uint256 sellAmount)\n        public\n        view\n        returns (GPv2Order.Data memory order)\n    {\n        order.sellToken = sellToken;\n        order.buyToken = buyToken;\n        order.receiver = owner;\n        order.sellAmount = sellAmount;\n        order.buyAmount = buyAmountForSellAmount(sellAmount);\n        order.validTo = validTo;\n        order.appData = APPDATA;\n        order.feeAmount = totalFeeAmount.mul(sellAmount).div(totalSellAmount);\n        order.kind = GPv2Order.KIND_SELL;\n        // NOTE: We counter-intuitively set `partiallyFillable` to `false`, even\n        // if the smart order as a whole acts like a partially fillable order.\n        // This is done since, once a settlement commits to a specific sell\n        // amount, then it is expected to use it completely and not partially.\n        order.partiallyFillable = false;\n        order.sellTokenBalance = GPv2Order.BALANCE_ERC20;\n        order.buyTokenBalance = GPv2Order.BALANCE_ERC20;\n    }\n\n    function buyAmountForSellAmount(uint256 sellAmount)\n        private\n        view\n        returns (uint256 buyAmount)\n    {\n        uint256 feeAdjustedBalance =\n            sellToken.balanceOf(address(this)).mul(totalSellAmount).div(\n                totalSellAmount.add(totalFeeAmount)\n            );\n        uint256 soldAmount =\n            totalSellAmount > feeAdjustedBalance\n                ? totalSellAmount - feeAdjustedBalance\n                : 0;\n\n        // NOTE: This is currently a silly price strategy where the xrate\n        // increases linearly from 1:1 to 1:2 as the smart order gets filled.\n        // This can be extended to more complex \"price curves\".\n        buyAmount = sellAmount\n            .mul(totalSellAmount.add(sellAmount).add(soldAmount))\n            .div(totalSellAmount);\n    }\n}\n"},"src/contracts/libraries/GPv2SafeERC20.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\nimport \"../interfaces/IERC20.sol\";\n\n/// @title Gnosis Protocol v2 Safe ERC20 Transfer Library\n/// @author Gnosis Developers\n/// @dev Gas-efficient version of Openzeppelin's SafeERC20 contract that notably\n/// does not revert when calling a non-contract.\nlibrary GPv2SafeERC20 {\n    /// @dev Wrapper around a call to the ERC20 function `transfer` that reverts\n    /// also when the token returns `false`.\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        bytes4 selector_ = token.transfer.selector;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, selector_)\n            mstore(\n                add(freeMemoryPointer, 4),\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\n            )\n            mstore(add(freeMemoryPointer, 36), value)\n\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        require(getLastTansferResult(token), \"GPv2: failed transfer\");\n    }\n\n    /// @dev Wrapper around a call to the ERC20 function `transferFrom` that\n    /// reverts also when the token returns `false`.\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        bytes4 selector_ = token.transferFrom.selector;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, selector_)\n            mstore(\n                add(freeMemoryPointer, 4),\n                and(from, 0xffffffffffffffffffffffffffffffffffffffff)\n            )\n            mstore(\n                add(freeMemoryPointer, 36),\n                and(to, 0xffffffffffffffffffffffffffffffffffffffff)\n            )\n            mstore(add(freeMemoryPointer, 68), value)\n\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        require(getLastTansferResult(token), \"GPv2: failed transferFrom\");\n    }\n\n    /// @dev Verifies that the last return was a successful `transfer*` call.\n    /// This is done by checking that the return data is either empty, or\n    /// is a valid ABI encoded boolean.\n    function getLastTansferResult(IERC20 token)\n        private\n        view\n        returns (bool success)\n    {\n        // NOTE: Inspecting previous return data requires assembly. Note that\n        // we write the return data to memory 0 in the case where the return\n        // data size is 32, this is OK since the first 64 bytes of memory are\n        // reserved by Solidy as a scratch space that can be used within\n        // assembly blocks.\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            /// @dev Revert with an ABI encoded Solidity error with a message\n            /// that fits into 32-bytes.\n            ///\n            /// An ABI encoded Solidity error has the following memory layout:\n            ///\n            /// ------------+----------------------------------\n            ///  byte range | value\n            /// ------------+----------------------------------\n            ///  0x00..0x04 |        selector(\"Error(string)\")\n            ///  0x04..0x24 |      string offset (always 0x20)\n            ///  0x24..0x44 |                    string length\n            ///  0x44..0x64 | string value, padded to 32-bytes\n            function revertWithMessage(length, message) {\n                mstore(0x00, \"\\x08\\xc3\\x79\\xa0\")\n                mstore(0x04, 0x20)\n                mstore(0x24, length)\n                mstore(0x44, message)\n                revert(0x00, 0x64)\n            }\n\n            switch returndatasize()\n                // Non-standard ERC20 transfer without return.\n                case 0 {\n                    // NOTE: When the return data size is 0, verify that there\n                    // is code at the address. This is done in order to maintain\n                    // compatibility with Solidity calling conventions.\n                    // <https://docs.soliditylang.org/en/v0.7.6/control-structures.html#external-function-calls>\n                    if iszero(extcodesize(token)) {\n                        revertWithMessage(20, \"GPv2: not a contract\")\n                    }\n\n                    success := 1\n                }\n                // Standard ERC20 transfer returning boolean success value.\n                case 32 {\n                    returndatacopy(0, 0, returndatasize())\n\n                    // NOTE: For ABI encoding v1, any non-zero value is accepted\n                    // as `true` for a boolean. In order to stay compatible with\n                    // OpenZeppelin's `SafeERC20` library which is known to work\n                    // with the existing ERC20 implementation we care about,\n                    // make sure we return success for any non-zero return value\n                    // from the `transfer*` call.\n                    success := iszero(iszero(mload(0)))\n                }\n                default {\n                    revertWithMessage(31, \"GPv2: malformed transfer result\")\n                }\n        }\n    }\n}\n"},"src/contracts/interfaces/IVault.sol":{"content":"// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Minimal interface for the Vault core contract only containing methods\n * used by Gnosis Protocol V2. Original source:\n * <https://github.com/balancer-labs/balancer-core-v2/blob/v1.0.0/contracts/vault/interfaces/IVault.sol>\n */\ninterface IVault {\n    // Internal Balance\n    //\n    // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\n    // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\n    // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\n    // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\n    //\n    // Internal Balance management features batching, which means a single contract call can be used to perform multiple\n    // operations of different kinds, with different senders and recipients, at once.\n\n    /**\n     * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\n     * it lets integrators reuse a user's Vault allowance.\n     *\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\n     */\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable;\n\n    /**\n     * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\n     without manual WETH wrapping or unwrapping.\n     */\n    struct UserBalanceOp {\n        UserBalanceOpKind kind;\n        IERC20 asset;\n        uint256 amount;\n        address sender;\n        address payable recipient;\n    }\n\n    // There are four possible operations in `manageUserBalance`:\n    //\n    // - DEPOSIT_INTERNAL\n    // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\n    // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\n    //\n    // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\n    // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\n    // relevant for relayers).\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - WITHDRAW_INTERNAL\n    // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\n    //\n    // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\n    // it to the recipient as ETH.\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - TRANSFER_INTERNAL\n    // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\n    //\n    // Reverts if the ETH sentinel value is passed.\n    //\n    // Emits an `InternalBalanceChanged` event.\n    //\n    //\n    // - TRANSFER_EXTERNAL\n    // Transfers tokens from `sender` to `recipient`, using the Vault's ERC20 allowance. This is typically used by\n    // relayers, as it lets them reuse a user's Vault allowance.\n    //\n    // Reverts if the ETH sentinel value is passed.\n    //\n    // Emits an `ExternalBalanceTransfer` event.\n\n    enum UserBalanceOpKind {\n        DEPOSIT_INTERNAL,\n        WITHDRAW_INTERNAL,\n        TRANSFER_INTERNAL,\n        TRANSFER_EXTERNAL\n    }\n\n    // Swaps\n    //\n    // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\n    // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\n    // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\n    //\n    // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\n    // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\n    // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\n    // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\n    // individual swaps.\n    //\n    // There are two swap kinds:\n    //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\n    // `onSwap` hook) the amount of tokens out (to send to the recipient).\n    //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\n    // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\n    //\n    // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\n    // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\n    // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\n    // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\n    // the final intended token.\n    //\n    // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\n    // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\n    // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\n    // much less gas than they would otherwise.\n    //\n    // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\n    // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\n    // updating the Pool's internal accounting).\n    //\n    // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\n    // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\n    // minimum amount of tokens to receive (by passing a negative value) is specified.\n    //\n    // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\n    // this point in time (e.g. if the transaction failed to be included in a block promptly).\n    //\n    // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\n    // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\n    // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\n    // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\n    //\n    // Finally, Internal Balance can be used when either sending or receiving tokens.\n\n    enum SwapKind {GIVEN_IN, GIVEN_OUT}\n\n    /**\n     * @dev Performs a swap with a single Pool.\n     *\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\n     * taken from the Pool, which must be greater than or equal to `limit`.\n     *\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\n     * sent to the Pool, which must be less than or equal to `limit`.\n     *\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\n     *\n     * Emits a `Swap` event.\n     */\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    /**\n     * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\n     * the `kind` value.\n     *\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        IERC20 assetIn;\n        IERC20 assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\n     *\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\n     * the same index in the `assets` array.\n     *\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\n     * `amountOut` depending on the swap kind.\n     *\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\n     *\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\n     * or unwrapped from WETH by the Vault.\n     *\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\n     *\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\n     * equivalent `swap` call.\n     *\n     * Emits `Swap` events.\n     */\n    function batchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IERC20[] memory assets,\n        FundManagement memory funds,\n        int256[] memory limits,\n        uint256 deadline\n    ) external payable returns (int256[] memory);\n\n    /**\n     * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\n     *\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\n     * from the previous swap, depending on the swap kind.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct BatchSwapStep {\n        bytes32 poolId;\n        uint256 assetInIndex;\n        uint256 assetOutIndex;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\n     * `recipient` account.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\n     * `joinPool`.\n     *\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\n     * transferred. This matches the behavior of `exitPool`.\n     *\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\n     * revert.\n     */\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n}\n"},"src/contracts/mixins/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// Vendored from OpenZeppelin contracts with minor modifications:\n// - Modified Solidity version\n// - Formatted code\n// - Shortned revert messages\n// - Inlined `Address.isContract` implementation\n// <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/proxy/Initializable.sol>\n\npragma solidity ^0.7.6;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(\n            _initializing || _isConstructor() || !_initialized,\n            \"Initializable: initialized\"\n        );\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(address())\n        }\n        return size == 0;\n    }\n}\n"},"src/contracts/libraries/SafeMath.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// Vendored from OpenZeppelin contracts with minor modifications:\n// - Modified Solidity version\n// - Formatted code\n// - Shortened some revert messages\n// - Removed unused methods\n// - Added `ceilDiv` method\n// <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/math/SafeMath.sol>\n\npragma solidity ^0.7.6;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: mul overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by 0\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the ceiling integer division of two unsigned integers,\n     * reverting on division by zero. The result is rounded towards up the\n     * nearest integer, instead of truncating the fractional part.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     * - The sum of the dividend and divisor cannot overflow.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: ceiling division by 0\");\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"},"src/contracts/test/GPv2OrderTestInterface.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"../libraries/GPv2Order.sol\";\n\ncontract GPv2OrderTestInterface {\n    using GPv2Order for GPv2Order.Data;\n    using GPv2Order for bytes;\n\n    function typeHashTest() external pure returns (bytes32) {\n        return GPv2Order.TYPE_HASH;\n    }\n\n    function hashTest(GPv2Order.Data memory order, bytes32 domainSeparator)\n        external\n        pure\n        returns (bytes32 orderDigest)\n    {\n        orderDigest = order.hash(domainSeparator);\n    }\n\n    function packOrderUidParamsTest(\n        uint256 bufferLength,\n        bytes32 orderDigest,\n        address owner,\n        uint32 validTo\n    ) external pure returns (bytes memory orderUid) {\n        orderUid = new bytes(bufferLength);\n        orderUid.packOrderUidParams(orderDigest, owner, validTo);\n    }\n\n    function extractOrderUidParamsTest(bytes calldata orderUid)\n        external\n        pure\n        returns (\n            bytes32 orderDigest,\n            address owner,\n            uint32 validTo\n        )\n    {\n        return orderUid.extractOrderUidParams();\n    }\n}\n"},"src/contracts/test/GPv2SettlementTestInterface.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\npragma abicoder v2;\n\nimport \"../GPv2Settlement.sol\";\nimport \"../libraries/GPv2Interaction.sol\";\nimport \"../libraries/GPv2Trade.sol\";\nimport \"../libraries/GPv2Transfer.sol\";\n\ncontract GPv2SettlementTestInterface is GPv2Settlement {\n    constructor(GPv2Authentication authenticator_, IVault vault)\n        GPv2Settlement(authenticator_, vault)\n    // solhint-disable-next-line no-empty-blocks\n    {\n\n    }\n\n    function setFilledAmount(bytes calldata orderUid, uint256 amount) external {\n        filledAmount[orderUid] = amount;\n    }\n\n    function computeTradeExecutionsTest(\n        IERC20[] calldata tokens,\n        uint256[] calldata clearingPrices,\n        GPv2Trade.Data[] calldata trades\n    )\n        external\n        returns (\n            GPv2Transfer.Data[] memory inTransfers,\n            GPv2Transfer.Data[] memory outTransfers\n        )\n    {\n        (inTransfers, outTransfers) = computeTradeExecutions(\n            tokens,\n            clearingPrices,\n            trades\n        );\n    }\n\n    function computeTradeExecutionMemoryTest() external returns (uint256 mem) {\n        RecoveredOrder memory recoveredOrder;\n        GPv2Transfer.Data memory inTransfer;\n        GPv2Transfer.Data memory outTransfer;\n\n        // NOTE: Solidity stores the free memory pointer at address 0x40. Read\n        // it before and after calling `processOrder` to ensure that there are\n        // no memory allocations.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mem := mload(0x40)\n        }\n\n        // solhint-disable-next-line not-rely-on-time\n        recoveredOrder.data.validTo = uint32(block.timestamp);\n        computeTradeExecution(recoveredOrder, 1, 1, 0, inTransfer, outTransfer);\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mem := sub(mload(0x40), mem)\n        }\n    }\n\n    function executeInteractionsTest(\n        GPv2Interaction.Data[] calldata interactions\n    ) external {\n        executeInteractions(interactions);\n    }\n\n    function freeFilledAmountStorageTest(bytes[] calldata orderUids) external {\n        this.freeFilledAmountStorage(orderUids);\n    }\n\n    function freePreSignatureStorageTest(bytes[] calldata orderUids) external {\n        this.freePreSignatureStorage(orderUids);\n    }\n}\n"}},"settings":{"metadata":{"useLiteralContent":true},"optimizer":{"enabled":true,"runs":1000000},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","abi"]}}}},"ABI":"[{\"inputs\":[{\"internalType\":\"contract IVault\",\"name\":\"vault_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"enum IVault.SwapKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"assetInIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"assetOutIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"internalType\":\"struct IVault.BatchSwapStep[]\",\"name\":\"swaps\",\"type\":\"tuple[]\"},{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"fromInternalBalance\",\"type\":\"bool\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"toInternalBalance\",\"type\":\"bool\"}],\"internalType\":\"struct IVault.FundManagement\",\"name\":\"funds\",\"type\":\"tuple\"},{\"internalType\":\"int256[]\",\"name\":\"limits\",\"type\":\"int256[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"balance\",\"type\":\"bytes32\"}],\"internalType\":\"struct GPv2Transfer.Data\",\"name\":\"feeTransfer\",\"type\":\"tuple\"}],\"name\":\"batchSwapWithFee\",\"outputs\":[{\"internalType\":\"int256[]\",\"name\":\"tokenDeltas\",\"type\":\"int256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"balance\",\"type\":\"bytes32\"}],\"internalType\":\"struct GPv2Transfer.Data[]\",\"name\":\"transfers\",\"type\":\"tuple[]\"}],\"name\":\"transferFromAccounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GPv2VaultRelayer","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":1,"Runs":1000000,"ConstructorArguments":"0x000000000000000000000000ba12222222228d8ba445958a75a0704d566bf2c8","EVMVersion":"Default","Library":"","LicenseType":"GNU GPLv3","Proxy":0,"SwarmSource":"ipfs://364a6941bea69620b7dc3a957d0ab4cbf3bfc459c7ad3924d220620aca9202fc"}]}