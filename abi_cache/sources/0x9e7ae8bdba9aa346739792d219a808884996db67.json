{"expiry":1689524807,"data":[{"SourceCode":{"language":"Solidity","sources":{"src/contracts/interfaces/GPv2Authentication.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\n/// @title Gnosis Protocol v2 Authentication Interface\n/// @author Gnosis Developers\ninterface GPv2Authentication {\n    /// @dev determines whether the provided address is an authenticated solver.\n    /// @param prospectiveSolver the address of prospective solver.\n    /// @return true when prospectiveSolver is an authenticated solver, otherwise false.\n    function isSolver(address prospectiveSolver) external view returns (bool);\n}\n"},"src/contracts/GPv2AllowListAuthentication.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\nimport \"./interfaces/GPv2Authentication.sol\";\nimport \"./libraries/GPv2EIP1967.sol\";\nimport \"./mixins/Initializable.sol\";\nimport \"./mixins/StorageAccessible.sol\";\n\n/// @title Gnosis Protocol v2 Access Control Contract\n/// @author Gnosis Developers\ncontract GPv2AllowListAuthentication is\n    GPv2Authentication,\n    Initializable,\n    StorageAccessible\n{\n    /// @dev The address of the manager that has permissions to add and remove\n    /// solvers.\n    address public manager;\n\n    /// @dev The set of allowed solvers. Allowed solvers have a value of `true`\n    /// in this mapping.\n    mapping(address => bool) private solvers;\n\n    /// @dev Event emitted when the manager changes.\n    event ManagerChanged(address newManager, address oldManager);\n\n    /// @dev Event emitted when a solver gets added.\n    event SolverAdded(address solver);\n\n    /// @dev Event emitted when a solver gets removed.\n    event SolverRemoved(address solver);\n\n    /// @dev Initialize the manager to a value.\n    ///\n    /// This method is a contract initializer that is called exactly once after\n    /// creation. An initializer is used instead of a constructor so that this\n    /// contract can be used behind a proxy.\n    ///\n    /// This initializer is idempotent.\n    ///\n    /// @param manager_ The manager to initialize the contract with.\n    function initializeManager(address manager_) external initializer {\n        manager = manager_;\n        emit ManagerChanged(manager_, address(0));\n    }\n\n    /// @dev Modifier that ensures a method can only be called by the contract\n    /// manager. Reverts if called by other addresses.\n    modifier onlyManager() {\n        require(manager == msg.sender, \"GPv2: caller not manager\");\n        _;\n    }\n\n    /// @dev Modifier that ensures method can be either called by the contract\n    /// manager or the proxy owner.\n    ///\n    /// This modifier assumes that the proxy uses an EIP-1967 compliant storage\n    /// slot for the admin.\n    modifier onlyManagerOrOwner() {\n        require(\n            manager == msg.sender || GPv2EIP1967.getAdmin() == msg.sender,\n            \"GPv2: not authorized\"\n        );\n        _;\n    }\n\n    /// @dev Set the manager for this contract.\n    ///\n    /// This method can be called by the current manager (if they want to to\n    /// reliquish the role and give it to another address) or the contract\n    /// owner (i.e. the proxy admin).\n    ///\n    /// @param manager_ The new contract manager address.\n    function setManager(address manager_) external onlyManagerOrOwner {\n        address oldManager = manager;\n        manager = manager_;\n        emit ManagerChanged(manager_, oldManager);\n    }\n\n    /// @dev Add an address to the set of allowed solvers. This method can only\n    /// be called by the contract manager.\n    ///\n    /// This function is idempotent.\n    ///\n    /// @param solver The solver address to add.\n    function addSolver(address solver) external onlyManager {\n        solvers[solver] = true;\n        emit SolverAdded(solver);\n    }\n\n    /// @dev Removes an address to the set of allowed solvers. This method can\n    /// only be called by the contract manager.\n    ///\n    /// This function is idempotent.\n    ///\n    /// @param solver The solver address to remove.\n    function removeSolver(address solver) external onlyManager {\n        solvers[solver] = false;\n        emit SolverRemoved(solver);\n    }\n\n    /// @inheritdoc GPv2Authentication\n    function isSolver(address prospectiveSolver)\n        external\n        view\n        override\n        returns (bool)\n    {\n        return solvers[prospectiveSolver];\n    }\n}\n"},"src/contracts/mixins/StorageAccessible.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\n\n// Vendored from Gnosis utility contracts with minor modifications:\n// - Modified Solidity version\n// - Formatted code\n// - Added linter directives to ignore low level call and assembly warnings\n// <https://github.com/gnosis/util-contracts/blob/v3.1.0-solc-7/contracts/StorageAccessible.sol>\n\npragma solidity ^0.7.6;\n\n/// @title ViewStorageAccessible - Interface on top of StorageAccessible base class to allow simulations from view functions\ninterface ViewStorageAccessible {\n    /**\n     * @dev Same as `simulateDelegatecall` on StorageAccessible. Marked as view so that it can be called from external contracts\n     * that want to run simulations from within view functions. Will revert if the invoked simulation attempts to change state.\n     */\n    function simulateDelegatecall(\n        address targetContract,\n        bytes memory calldataPayload\n    ) external view returns (bytes memory);\n\n    /**\n     * @dev Same as `getStorageAt` on StorageAccessible. This method allows reading aribtrary ranges of storage.\n     */\n    function getStorageAt(uint256 offset, uint256 length)\n        external\n        view\n        returns (bytes memory);\n}\n\n/// @title StorageAccessible - generic base contract that allows callers to access all internal storage.\ncontract StorageAccessible {\n    /**\n     * @dev Reads `length` bytes of storage in the currents contract\n     * @param offset - the offset in the current contract's storage in words to start reading from\n     * @param length - the number of words (32 bytes) of data to read\n     * @return the bytes that were read.\n     */\n    function getStorageAt(uint256 offset, uint256 length)\n        external\n        view\n        returns (bytes memory)\n    {\n        bytes memory result = new bytes(length * 32);\n        for (uint256 index = 0; index < length; index++) {\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                let word := sload(add(offset, index))\n                mstore(add(add(result, 0x20), mul(index, 0x20)), word)\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Performs a delegetecall on a targetContract in the context of self.\n     * Internally reverts execution to avoid side effects (making it static). Catches revert and returns encoded result as bytes.\n     * @param targetContract Address of the contract containing the code to execute.\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\n     */\n    function simulateDelegatecall(\n        address targetContract,\n        bytes memory calldataPayload\n    ) public returns (bytes memory response) {\n        bytes memory innerCall =\n            abi.encodeWithSelector(\n                this.simulateDelegatecallInternal.selector,\n                targetContract,\n                calldataPayload\n            );\n        // solhint-disable-next-line avoid-low-level-calls\n        (, response) = address(this).call(innerCall);\n        bool innerSuccess = response[response.length - 1] == 0x01;\n        setLength(response, response.length - 1);\n        if (innerSuccess) {\n            return response;\n        } else {\n            revertWith(response);\n        }\n    }\n\n    /**\n     * @dev Performs a delegetecall on a targetContract in the context of self.\n     * Internally reverts execution to avoid side effects (making it static). Returns encoded result as revert message\n     * concatenated with the success flag of the inner call as a last byte.\n     * @param targetContract Address of the contract containing the code to execute.\n     * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\n     */\n    function simulateDelegatecallInternal(\n        address targetContract,\n        bytes memory calldataPayload\n    ) external returns (bytes memory response) {\n        bool success;\n        // solhint-disable-next-line avoid-low-level-calls\n        (success, response) = targetContract.delegatecall(calldataPayload);\n        revertWith(abi.encodePacked(response, success));\n    }\n\n    function revertWith(bytes memory response) internal pure {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            revert(add(response, 0x20), mload(response))\n        }\n    }\n\n    function setLength(bytes memory buffer, uint256 length) internal pure {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(buffer, length)\n        }\n    }\n}\n"},"src/contracts/libraries/GPv2EIP1967.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity ^0.7.6;\n\nlibrary GPv2EIP1967 {\n    /// @dev The storage slot where the proxy administrator is stored, defined\n    /// as `keccak256('eip1967.proxy.admin') - 1`.\n    bytes32 internal constant ADMIN_SLOT =\n        hex\"b53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103\";\n\n    /// @dev Returns the address stored in the EIP-1967 administrator storage\n    /// slot for the current contract. If this method is not called from an\n    /// contract behind an EIP-1967 proxy, then it will most likely return\n    /// `address(0)`, as the implementation slot is likely to be unset.\n    ///\n    /// @return admin The administrator address.\n    function getAdmin() internal view returns (address admin) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            admin := sload(ADMIN_SLOT)\n        }\n    }\n\n    /// @dev Sets the storage at the EIP-1967 administrator slot to be the\n    /// specified address.\n    ///\n    /// @param admin The administrator address to set.\n    function setAdmin(address admin) internal {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(ADMIN_SLOT, admin)\n        }\n    }\n}\n"},"src/contracts/mixins/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// Vendored from OpenZeppelin contracts with minor modifications:\n// - Modified Solidity version\n// - Formatted code\n// - Shortned revert messages\n// - Inlined `Address.isContract` implementation\n// <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/proxy/Initializable.sol>\n\npragma solidity ^0.7.6;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(\n            _initializing || _isConstructor() || !_initialized,\n            \"Initializable: initialized\"\n        );\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function _isConstructor() private view returns (bool) {\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(address())\n        }\n        return size == 0;\n    }\n}\n"}},"settings":{"evmVersion":"istanbul","libraries":{},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":true,"runs":1000000},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","abi"]}},"remappings":[]}},"ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldManager\",\"type\":\"address\"}],\"name\":\"ManagerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"}],\"name\":\"SolverAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"}],\"name\":\"SolverRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"}],\"name\":\"addSolver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"getStorageAt\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager_\",\"type\":\"address\"}],\"name\":\"initializeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"prospectiveSolver\",\"type\":\"address\"}],\"name\":\"isSolver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"solver\",\"type\":\"address\"}],\"name\":\"removeSolver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"manager_\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"calldataPayload\",\"type\":\"bytes\"}],\"name\":\"simulateDelegatecall\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetContract\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"calldataPayload\",\"type\":\"bytes\"}],\"name\":\"simulateDelegatecallInternal\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"response\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"GPv2AllowListAuthentication","CompilerVersion":"v0.7.6+commit.7338295f","OptimizationUsed":1,"Runs":1000000,"ConstructorArguments":"0x","EVMVersion":"Default","Library":"","LicenseType":"GNU LGPLv3","Proxy":0,"SwarmSource":""}]}