{"expiry":1689522355,"data":[{"SourceCode":{"language":"Solidity","sources":{"cache/solpp-generated-contracts/zksync/Verifier.sol":{"content":"pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n\n\nimport \"./Plonk4VerifierWithAccessToDNext.sol\";\nimport \"../common/libraries/UncheckedMath.sol\";\n\ncontract Verifier is Plonk4VerifierWithAccessToDNext {\n    using UncheckedMath for uint256;\n\n    function get_verification_key() public pure returns (VerificationKey memory vk) {\n        vk.num_inputs = 1;\n        vk.domain_size = 67108864;\n        vk.omega = PairingsBn254.new_fr(0x1dba8b5bdd64ef6ce29a9039aca3c0e524395c43b9227b96c75090cc6cc7ec97);\n        // coefficients\n        vk.gate_setup_commitments[0] = PairingsBn254.new_g1(\n            0x08fa9d6f0dd6ac1cbeb94ae20fe7a23df05cb1095df66fb561190e615a4037ef,\n            0x196dcc8692fe322d21375920559944c12ba7b1ba8b732344cf4ba2e3aa0fc8b4\n        );\n        vk.gate_setup_commitments[1] = PairingsBn254.new_g1(\n            0x0074aaf5d97bd57551311a8b3e4aa7840bc55896502020b2f43ad6a98d81a443,\n            0x2d275a3ad153dc9d89ebb9c9b6a0afd2dde82470554e9738d905c328fbb4c8bc\n        );\n        vk.gate_setup_commitments[2] = PairingsBn254.new_g1(\n            0x287f1975a9aeaef5d2bb0767b5ef538f76e82f7da01c0cb6db8c6f920818ec4f,\n            0x2fff6f53594129f794a7731d963d27e72f385c5c6d8e08829e6f66a9d29a12ea\n        );\n        vk.gate_setup_commitments[3] = PairingsBn254.new_g1(\n            0x038809fa3d4b7320d43e023454194f0a7878baa7e73a295d2d105260f1c34cbc,\n            0x25418b1105cf45b2a3da6c349bab1d9caaf145eaf24d1e8fb92c11654c000781\n        );\n        vk.gate_setup_commitments[4] = PairingsBn254.new_g1(\n            0x0561cafd527ac3f0bc550db77d87cd1c63938f7ec051e62ebf84a5bbe07f9840,\n            0x28f87201b4cbe19f1517a1c29ca6d6cb074502ccfed4c31c8931c6992c3eea43\n        );\n        vk.gate_setup_commitments[5] = PairingsBn254.new_g1(\n            0x27e0af572bac6e36d31c33808cb44c0ef8ceee5e2850e916fb01f3747db72491,\n            0x1da20087ba61c59366b21e31e4ac6889d357cf11bf16b94d875f94f41525c427\n        );\n        vk.gate_setup_commitments[6] = PairingsBn254.new_g1(\n            0x2c2bcafea8f93d07f96874f470985a8d272c09c8ed49373f36497ee80bd8da17,\n            0x299276cf6dca1a7e3780f6276c5d067403f6e024e83e0cc1ab4c5f7252b7f653\n        );\n        vk.gate_setup_commitments[7] = PairingsBn254.new_g1(\n            0x0ba9d4a53e050da25b8410045b634f1ca065ff74acd35bab1a72bf1f20047ef3,\n            0x1f1eefc8b0507a08f852f554bd7abcbd506e52de390ca127477a678d212abfe5\n        );\n        // gate selectors\n        vk.gate_selectors_commitments[0] = PairingsBn254.new_g1(\n            0x1c6b68d9920620012d85a4850dad9bd6d03ae8bbc7a08b827199e85dba1ef2b1,\n            0x0f6380560d1b585628ed259289cec19d3a7c70c60e66bbfebfcb70c8c312d91e\n        );\n        vk.gate_selectors_commitments[1] = PairingsBn254.new_g1(\n            0x0dfead780e5067181aae631ff734a33fca302773472997daca58ba49dbd20dcc,\n            0x00f13fa6e356f525d2fd1c533acf2858c0d2b9f0a9b3180f94e1543929c75073\n        );\n        // permutation\n        vk.permutation_commitments[0] = PairingsBn254.new_g1(\n            0x1df0747c787934650d99c5696f9273088ad07ec3e0825c9d39685a9b9978ebed,\n            0x2ace2a277becbc69af4e89518eb50960a733d9d71354845ea43d2e65c8e0e4cb\n        );\n        vk.permutation_commitments[1] = PairingsBn254.new_g1(\n            0x06598c8236a5f5045cd7444dc87f3e1f66f99bf01251e13be4dc0ab1f7f1af4b,\n            0x14ca234fe9b3bb1e5517fc60d6b90f8ad44b0899a2d4f71a64c9640b3142ce8b\n        );\n        vk.permutation_commitments[2] = PairingsBn254.new_g1(\n            0x01889e2c684caefde60471748f4259196ecf4209a735ccdf7b1816f05bafa50a,\n            0x092d287a080bfe2fd40ad392ff290e462cd0e347b8fd9d05b90af234ce77a11b\n        );\n        vk.permutation_commitments[3] = PairingsBn254.new_g1(\n            0x0dd98eeb5bc12c221da969398b67750a8774dbdd37a78da52367f9fc0e566d5c,\n            0x06750ceb40c9fb87fc424df9599340938b7552b759914a90cb0e41d3915c945b\n        );\n        // lookup table commitments\n        vk.lookup_selector_commitment = PairingsBn254.new_g1(\n            0x2f491c662ae53ceb358f57a868dc00b89befa853bd9a449127ea2d46820995bd,\n            0x231fe6538634ff8b6fa21ca248fb15e7f43d82eb0bfa705490d24ddb3e3cad77\n        );\n        vk.lookup_tables_commitments[0] = PairingsBn254.new_g1(\n            0x0ebe0de4a2f39df3b903da484c1641ffdffb77ff87ce4f9508c548659eb22d3c,\n            0x12a3209440242d5662729558f1017ed9dcc08fe49a99554dd45f5f15da5e4e0b\n        );\n        vk.lookup_tables_commitments[1] = PairingsBn254.new_g1(\n            0x1b7d54f8065ca63bed0bfbb9280a1011b886d07e0c0a26a66ecc96af68c53bf9,\n            0x2c51121fff5b8f58c302f03c74e0cb176ae5a1d1730dec4696eb9cce3fe284ca\n        );\n        vk.lookup_tables_commitments[2] = PairingsBn254.new_g1(\n            0x0138733c5faa9db6d4b8df9748081e38405999e511fb22d40f77cf3aef293c44,\n            0x269bee1c1ac28053238f7fe789f1ea2e481742d6d16ae78ed81e87c254af0765\n        );\n        vk.lookup_tables_commitments[3] = PairingsBn254.new_g1(\n            0x1b1be7279d59445065a95f01f16686adfa798ec4f1e6845ffcec9b837e88372e,\n            0x057c90cb96d8259238ed86b05f629efd55f472a721efeeb56926e979433e6c0e\n        );\n        vk.lookup_table_type_commitment = PairingsBn254.new_g1(\n            0x12cd873a6f18a4a590a846d9ebf61565197edf457efd26bc408eb61b72f37b59,\n            0x19890cbdac892682e7a5910ca6c238c082130e1c71f33d0c9c901153377770d1\n        );\n        // non residues\n        vk.non_residues[0] = PairingsBn254.new_fr(0x0000000000000000000000000000000000000000000000000000000000000005);\n        vk.non_residues[1] = PairingsBn254.new_fr(0x0000000000000000000000000000000000000000000000000000000000000007);\n        vk.non_residues[2] = PairingsBn254.new_fr(0x000000000000000000000000000000000000000000000000000000000000000a);\n\n        // g2 elements\n        vk.g2_elements[0] = PairingsBn254.new_g2(\n            [\n                0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\n                0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed\n            ],\n            [\n                0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\n                0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\n            ]\n        );\n        vk.g2_elements[1] = PairingsBn254.new_g2(\n            [\n                0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\n                0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0\n            ],\n            [\n                0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\n                0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55\n            ]\n        );\n    }\n\n    function deserialize_proof(uint256[] calldata public_inputs, uint256[] calldata serialized_proof)\n        internal\n        pure\n        returns (Proof memory proof)\n    {\n        require(serialized_proof.length == 44);\n        proof.input_values = new uint256[](public_inputs.length);\n        for (uint256 i = 0; i < public_inputs.length; i = i.uncheckedInc()) {\n            proof.input_values[i] = public_inputs[i];\n        }\n\n        uint256 j;\n        for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()) {\n            proof.state_polys_commitments[i] = PairingsBn254.new_g1_checked(\n                serialized_proof[j],\n                serialized_proof[j.uncheckedInc()]\n            );\n\n            j = j.uncheckedAdd(2);\n        }\n        proof.copy_permutation_grand_product_commitment = PairingsBn254.new_g1_checked(\n            serialized_proof[j],\n            serialized_proof[j.uncheckedInc()]\n        );\n        j = j.uncheckedAdd(2);\n\n        proof.lookup_s_poly_commitment = PairingsBn254.new_g1_checked(\n            serialized_proof[j],\n            serialized_proof[j.uncheckedInc()]\n        );\n        j = j.uncheckedAdd(2);\n\n        proof.lookup_grand_product_commitment = PairingsBn254.new_g1_checked(\n            serialized_proof[j],\n            serialized_proof[j.uncheckedInc()]\n        );\n        j = j.uncheckedAdd(2);\n        for (uint256 i = 0; i < proof.quotient_poly_parts_commitments.length; i = i.uncheckedInc()) {\n            proof.quotient_poly_parts_commitments[i] = PairingsBn254.new_g1_checked(\n                serialized_proof[j],\n                serialized_proof[j.uncheckedInc()]\n            );\n            j = j.uncheckedAdd(2);\n        }\n\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z.length; i = i.uncheckedInc()) {\n            proof.state_polys_openings_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\n\n            j = j.uncheckedInc();\n        }\n\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z_omega.length; i = i.uncheckedInc()) {\n            proof.state_polys_openings_at_z_omega[i] = PairingsBn254.new_fr(serialized_proof[j]);\n\n            j = j.uncheckedInc();\n        }\n        for (uint256 i = 0; i < proof.gate_selectors_openings_at_z.length; i = i.uncheckedInc()) {\n            proof.gate_selectors_openings_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\n\n            j = j.uncheckedInc();\n        }\n        for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z.length; i = i.uncheckedInc()) {\n            proof.copy_permutation_polys_openings_at_z[i] = PairingsBn254.new_fr(serialized_proof[j]);\n\n            j = j.uncheckedInc();\n        }\n        proof.copy_permutation_grand_product_opening_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\n\n        j = j.uncheckedInc();\n        proof.lookup_s_poly_opening_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\n        j = j.uncheckedInc();\n        proof.lookup_grand_product_opening_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\n\n        j = j.uncheckedInc();\n        proof.lookup_t_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);\n\n        j = j.uncheckedInc();\n        proof.lookup_t_poly_opening_at_z_omega = PairingsBn254.new_fr(serialized_proof[j]);\n        j = j.uncheckedInc();\n        proof.lookup_selector_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);\n        j = j.uncheckedInc();\n        proof.lookup_table_type_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);\n        j = j.uncheckedInc();\n        proof.quotient_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);\n        j = j.uncheckedInc();\n        proof.linearization_poly_opening_at_z = PairingsBn254.new_fr(serialized_proof[j]);\n        j = j.uncheckedInc();\n        proof.opening_proof_at_z = PairingsBn254.new_g1_checked(\n            serialized_proof[j],\n            serialized_proof[j.uncheckedInc()]\n        );\n        j = j.uncheckedAdd(2);\n        proof.opening_proof_at_z_omega = PairingsBn254.new_g1_checked(\n            serialized_proof[j],\n            serialized_proof[j.uncheckedInc()]\n        );\n    }\n\n    function verify_serialized_proof(uint256[] calldata public_inputs, uint256[] calldata serialized_proof)\n        public\n        view\n        returns (bool)\n    {\n        VerificationKey memory vk = get_verification_key();\n        require(vk.num_inputs == public_inputs.length);\n\n        Proof memory proof = deserialize_proof(public_inputs, serialized_proof);\n\n        return verify(proof, vk);\n    }\n}\n"},"cache/solpp-generated-contracts/common/libraries/UnsafeBytes.sol":{"content":"pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n\n\n/**\n * @author Matter Labs\n * @dev The library provides a set of functions that help read data from an \"abi.encodePacked\" byte array.\n * @dev Each of the functions accepts the `bytes memory` and the offset where data should be read and returns a value of a certain type.\n *\n * @dev WARNING!\n * 1) Functions don't check the length of the bytes array, so it can go out of bounds.\n * The user of the library must check for bytes length before using any functions from the library!\n *\n * 2) Read variables are not cleaned up - https://docs.soliditylang.org/en/v0.8.16/internals/variable_cleanup.html.\n * Using data in inline assembly can lead to unexpected behavior!\n */\nlibrary UnsafeBytes {\n    function readUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 4)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readAddress(bytes memory _bytes, uint256 _start) internal pure returns (address result, uint256 offset) {\n        assembly {\n            offset := add(_start, 20)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 32)\n            result := mload(add(_bytes, offset))\n        }\n    }\n\n    function readBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32 result, uint256 offset) {\n        assembly {\n            offset := add(_start, 32)\n            result := mload(add(_bytes, offset))\n        }\n    }\n}\n"},"cache/solpp-generated-contracts/zksync/libraries/PriorityQueue.sol":{"content":"pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n\n\n/// @notice The structure that contains meta information of the L2 transaction that was requested from L1\n/// @dev The weird size of fields was selected specifically to minimize the structure storage size\n/// @param canonicalTxHash Hashed L2 transaction data that is needed to process it\n/// @param expirationTimestamp Expiration timestamp for this request (must be satisfied before)\n/// @param layer2Tip Additional payment to the validator as an incentive to perform the operation\nstruct PriorityOperation {\n    bytes32 canonicalTxHash;\n    uint64 expirationTimestamp;\n    uint192 layer2Tip;\n}\n\n/// @author Matter Labs\n/// @dev The library provides the API to interact with the priority queue container\n/// @dev Order of processing operations from queue - FIFO (Fist in - first out)\nlibrary PriorityQueue {\n    using PriorityQueue for Queue;\n\n    /// @notice Container that stores priority operations\n    /// @param data The inner mapping that saves priority operation by its index\n    /// @param head The pointer to the first unprocessed priority operation, equal to the tail if the queue is empty\n    /// @param tail The pointer to the free slot\n    struct Queue {\n        mapping(uint256 => PriorityOperation) data;\n        uint256 tail;\n        uint256 head;\n    }\n\n    /// @notice Returns zero if and only if no operations were processed from the queue\n    /// @return Index of the oldest priority operation that wasn't processed yet\n    function getFirstUnprocessedPriorityTx(Queue storage _queue) internal view returns (uint256) {\n        return _queue.head;\n    }\n\n    /// @return The total number of priority operations that were added to the priority queue, including all processed ones\n    function getTotalPriorityTxs(Queue storage _queue) internal view returns (uint256) {\n        return _queue.tail;\n    }\n\n    /// @return The total number of unprocessed priority operations in a priority queue\n    function getSize(Queue storage _queue) internal view returns (uint256) {\n        return uint256(_queue.tail - _queue.head);\n    }\n\n    /// @return Whether the priority queue contains no operations\n    function isEmpty(Queue storage _queue) internal view returns (bool) {\n        return _queue.tail == _queue.head;\n    }\n\n    /// @notice Add the priority operation to the end of the priority queue\n    function pushBack(Queue storage _queue, PriorityOperation memory _operation) internal {\n        // Save value into the stack to avoid double reading from the storage\n        uint256 tail = _queue.tail;\n\n        _queue.data[tail] = _operation;\n        _queue.tail = tail + 1;\n    }\n\n    /// @return The first unprocessed priority operation from the queue\n    function front(Queue storage _queue) internal view returns (PriorityOperation memory) {\n        require(!_queue.isEmpty(), \"D\"); // priority queue is empty\n\n        return _queue.data[_queue.head];\n    }\n\n    /// @notice Remove the first unprocessed priority operation from the queue\n    /// @return priorityOperation that was popped from the priority queue\n    function popFront(Queue storage _queue) internal returns (PriorityOperation memory priorityOperation) {\n        require(!_queue.isEmpty(), \"s\"); // priority queue is empty\n\n        // Save value into the stack to avoid double reading from the storage\n        uint256 head = _queue.head;\n\n        priorityOperation = _queue.data[head];\n        delete _queue.data[head];\n        _queue.head = head + 1;\n    }\n}\n"},"cache/solpp-generated-contracts/zksync/facets/Executor.sol":{"content":"pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n\n\nimport \"./Base.sol\";\nimport \"../Config.sol\";\nimport \"../interfaces/IExecutor.sol\";\nimport \"../libraries/PairingsBn254.sol\";\nimport \"../libraries/PriorityQueue.sol\";\nimport \"../../common/libraries/UncheckedMath.sol\";\nimport \"../../common/libraries/UnsafeBytes.sol\";\nimport \"../../common/libraries/L2ContractHelper.sol\";\nimport \"../../common/L2ContractAddresses.sol\";\n\n/// @title zkSync Executor contract capable of processing events emitted in the zkSync protocol.\n/// @author Matter Labs\ncontract ExecutorFacet is Base, IExecutor {\n    using UncheckedMath for uint256;\n    using PriorityQueue for PriorityQueue.Queue;\n\n    /// @dev Process one block commit using the previous block StoredBlockInfo\n    /// @dev returns new block StoredBlockInfo\n    /// @notice Does not change storage\n    function _commitOneBlock(StoredBlockInfo memory _previousBlock, CommitBlockInfo calldata _newBlock)\n        internal\n        view\n        returns (StoredBlockInfo memory)\n    {\n        require(_newBlock.blockNumber == _previousBlock.blockNumber + 1, \"f\"); // only commit next block\n\n        // Check that block contain all meta information for L2 logs.\n        // Get the chained hash of priority transaction hashes.\n        (\n            uint256 expectedNumberOfLayer1Txs,\n            bytes32 expectedPriorityOperationsHash,\n            bytes32 previousBlockHash,\n            uint256 l2BlockTimestamp\n        ) = _processL2Logs(_newBlock);\n\n        require(_previousBlock.blockHash == previousBlockHash, \"l\");\n        // Check that the priority operation hash in the L2 logs is as expected\n        require(expectedPriorityOperationsHash == _newBlock.priorityOperationsHash, \"t\");\n        // Check that the number of processed priority operations is as expected\n        require(expectedNumberOfLayer1Txs == _newBlock.numberOfLayer1Txs, \"ta\");\n        // Check that the timestamp that came from the Bootloader is expected\n        require(l2BlockTimestamp == _newBlock.timestamp, \"tb\");\n\n        // Preventing \"stack too deep error\"\n        {\n            // Check the timestamp of the new block\n            bool timestampNotTooSmall = block.timestamp - COMMIT_TIMESTAMP_NOT_OLDER <= l2BlockTimestamp;\n            bool timestampNotTooBig = l2BlockTimestamp <= block.timestamp + COMMIT_TIMESTAMP_APPROXIMATION_DELTA;\n            require(timestampNotTooSmall, \"h\"); // New block timestamp is too small\n            require(timestampNotTooBig, \"h1\"); // New block timestamp is too big\n\n            // Check the index of repeated storage writes\n            uint256 newStorageChangesIndexes = uint256(uint32(bytes4(_newBlock.initialStorageChanges[:4])));\n            require(\n                _previousBlock.indexRepeatedStorageChanges + newStorageChangesIndexes ==\n                    _newBlock.indexRepeatedStorageChanges,\n                \"yq\"\n            );\n\n            // NOTE: We don't check that _newBlock.timestamp > _previousBlock.timestamp, it is checked inside the L2\n        }\n\n        // Create block commitment for the proof verification\n        bytes32 commitment = _createBlockCommitment(_newBlock);\n\n        return\n            StoredBlockInfo(\n                _newBlock.blockNumber,\n                _newBlock.newStateRoot,\n                _newBlock.indexRepeatedStorageChanges,\n                _newBlock.numberOfLayer1Txs,\n                _newBlock.priorityOperationsHash,\n                _newBlock.l2LogsTreeRoot,\n                _newBlock.timestamp,\n                commitment\n            );\n    }\n\n    /// @dev Check that L2 logs are proper and block contain all meta information for them\n    function _processL2Logs(CommitBlockInfo calldata _newBlock)\n        internal\n        pure\n        returns (\n            uint256 numberOfLayer1Txs,\n            bytes32 chainedPriorityTxsHash,\n            bytes32 previousBlockHash,\n            uint256 blockTimestamp\n        )\n    {\n        // Copy L2 to L1 logs into memory.\n        bytes memory emittedL2Logs = _newBlock.l2Logs[4:];\n        bytes[] calldata l2Messages = _newBlock.l2ArbitraryLengthMessages;\n        uint256 currentMessage;\n        // Auxiliary variable that is needed to enforce that `previousBlockHash` and `blockTimestamp` was read exactly one time\n        bool isSystemContextLogProcessed;\n        bytes[] calldata factoryDeps = _newBlock.factoryDeps;\n        uint256 currentBytecode;\n\n        chainedPriorityTxsHash = EMPTY_STRING_KECCAK;\n\n        // linear traversal of the logs\n        for (uint256 i = 0; i < emittedL2Logs.length; i = i.uncheckedAdd(L2_TO_L1_LOG_SERIALIZE_SIZE)) {\n            (address logSender, ) = UnsafeBytes.readAddress(emittedL2Logs, i + 4);\n\n            // show preimage for hashed message stored in log\n            if (logSender == L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR) {\n                (bytes32 hashedMessage, ) = UnsafeBytes.readBytes32(emittedL2Logs, i + 56);\n                require(keccak256(l2Messages[currentMessage]) == hashedMessage, \"k2\");\n\n                currentMessage = currentMessage.uncheckedInc();\n            } else if (logSender == L2_BOOTLOADER_ADDRESS) {\n                (bytes32 canonicalTxHash, ) = UnsafeBytes.readBytes32(emittedL2Logs, i + 24);\n                chainedPriorityTxsHash = keccak256(abi.encode(chainedPriorityTxsHash, canonicalTxHash));\n\n                // Overflow is not realistic\n                numberOfLayer1Txs = numberOfLayer1Txs.uncheckedInc();\n            } else if (logSender == L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR) {\n                // Make sure that the system context log wasn't processed yet, to\n                // avoid accident double reading `blockTimestamp` and `previousBlockHash`\n                require(!isSystemContextLogProcessed, \"fx\");\n                (blockTimestamp, ) = UnsafeBytes.readUint256(emittedL2Logs, i + 24);\n                (previousBlockHash, ) = UnsafeBytes.readBytes32(emittedL2Logs, i + 56);\n                // Mark system context log as processed\n                isSystemContextLogProcessed = true;\n            } else if (logSender == L2_KNOWN_CODE_STORAGE_SYSTEM_CONTRACT_ADDR) {\n                (bytes32 bytecodeHash, ) = UnsafeBytes.readBytes32(emittedL2Logs, i + 24);\n                require(bytecodeHash == L2ContractHelper.hashL2Bytecode(factoryDeps[currentBytecode]), \"k3\");\n\n                currentBytecode = currentBytecode.uncheckedInc();\n            }\n        }\n        // To check that only relevant preimages have been included in the calldata\n        require(currentBytecode == factoryDeps.length, \"ym\");\n        require(currentMessage == l2Messages.length, \"pl\");\n        // `blockTimestamp` and `previousBlockHash` wasn't read from L2 logs\n        require(isSystemContextLogProcessed, \"by\");\n    }\n\n    /// @notice Commit block\n    /// @notice 1. Checks timestamp.\n    /// @notice 2. Process L2 logs.\n    /// @notice 3. Store block commitments.\n    function commitBlocks(StoredBlockInfo memory _lastCommittedBlockData, CommitBlockInfo[] calldata _newBlocksData)\n        external\n        override\n        nonReentrant\n        onlyValidator\n    {\n        // Check that we commit blocks after last committed block\n        require(s.storedBlockHashes[s.totalBlocksCommitted] == _hashStoredBlockInfo(_lastCommittedBlockData), \"i\"); // incorrect previous block data\n\n        uint256 blocksLength = _newBlocksData.length;\n        for (uint256 i = 0; i < blocksLength; i = i.uncheckedInc()) {\n            _lastCommittedBlockData = _commitOneBlock(_lastCommittedBlockData, _newBlocksData[i]);\n            s.storedBlockHashes[_lastCommittedBlockData.blockNumber] = _hashStoredBlockInfo(_lastCommittedBlockData);\n\n            emit BlockCommit(\n                _lastCommittedBlockData.blockNumber,\n                _lastCommittedBlockData.blockHash,\n                _lastCommittedBlockData.commitment\n            );\n        }\n\n        s.totalBlocksCommitted = s.totalBlocksCommitted + blocksLength;\n    }\n\n    /// @dev Pops the priority operations from the priority queue and returns a rolling hash of operations\n    function _collectOperationsFromPriorityQueue(uint256 _nPriorityOps) internal returns (bytes32 concatHash) {\n        concatHash = EMPTY_STRING_KECCAK;\n\n        for (uint256 i = 0; i < _nPriorityOps; i = i.uncheckedInc()) {\n            PriorityOperation memory priorityOp = s.priorityQueue.popFront();\n            concatHash = keccak256(abi.encode(concatHash, priorityOp.canonicalTxHash));\n        }\n    }\n\n    /// @dev Executes one block\n    /// @dev 1. Processes all pending operations (Complete priority requests)\n    /// @dev 2. Finalizes block on Ethereum\n    /// @dev _executedBlockIdx is an index in the array of the blocks that we want to execute together\n    function _executeOneBlock(StoredBlockInfo memory _storedBlock, uint256 _executedBlockIdx) internal {\n        uint256 currentBlockNumber = _storedBlock.blockNumber;\n        require(currentBlockNumber == s.totalBlocksExecuted + _executedBlockIdx + 1, \"k\"); // Execute blocks in order\n        require(\n            _hashStoredBlockInfo(_storedBlock) == s.storedBlockHashes[currentBlockNumber],\n            \"exe10\" // executing block should be committed\n        );\n\n        bytes32 priorityOperationsHash = _collectOperationsFromPriorityQueue(_storedBlock.numberOfLayer1Txs);\n        require(priorityOperationsHash == _storedBlock.priorityOperationsHash, \"x\"); // priority operations hash does not match to expected\n\n        // Save root hash of L2 -> L1 logs tree\n        s.l2LogsRootHashes[currentBlockNumber] = _storedBlock.l2LogsTreeRoot;\n    }\n\n    /// @notice Execute blocks, complete priority operations and process withdrawals.\n    /// @notice 1. Processes all pending operations (Complete priority requests)\n    /// @notice 2. Finalizes block on Ethereum\n    function executeBlocks(StoredBlockInfo[] calldata _blocksData) external nonReentrant onlyValidator {\n        uint256 nBlocks = _blocksData.length;\n        for (uint256 i = 0; i < nBlocks; i = i.uncheckedInc()) {\n            _executeOneBlock(_blocksData[i], i);\n            emit BlockExecution(_blocksData[i].blockNumber, _blocksData[i].blockHash, _blocksData[i].commitment);\n        }\n\n        s.totalBlocksExecuted = s.totalBlocksExecuted + nBlocks;\n        require(s.totalBlocksExecuted <= s.totalBlocksVerified, \"n\"); // Can't execute blocks more than committed and proven currently.\n    }\n\n    /// @notice Blocks commitment verification.\n    /// @notice Only verifies block commitments without any other processing\n    function proveBlocks(\n        StoredBlockInfo calldata _prevBlock,\n        StoredBlockInfo[] calldata _committedBlocks,\n        ProofInput calldata _proof\n    ) external nonReentrant onlyValidator {\n        // Save the variables into the stack to save gas on reading them later\n        uint256 currentTotalBlocksVerified = s.totalBlocksVerified;\n        uint256 committedBlocksLength = _committedBlocks.length;\n\n        // Save the variable from the storage to memory to save gas\n        VerifierParams memory verifierParams = s.verifierParams;\n\n        // Initialize the array, that will be used as public input to the ZKP\n        uint256[] memory proofPublicInput = new uint256[](committedBlocksLength);\n\n        // Check that the block passed by the validator is indeed the first unverified block\n        require(_hashStoredBlockInfo(_prevBlock) == s.storedBlockHashes[currentTotalBlocksVerified], \"t1\");\n\n        bytes32 prevBlockCommitment = _prevBlock.commitment;\n        for (uint256 i = 0; i < committedBlocksLength; i = i.uncheckedInc()) {\n            currentTotalBlocksVerified = currentTotalBlocksVerified.uncheckedInc();\n            require(_hashStoredBlockInfo(_committedBlocks[i]) == s.storedBlockHashes[currentTotalBlocksVerified], \"o1\");\n\n            bytes32 currentBlockCommitment = _committedBlocks[i].commitment;\n            proofPublicInput[i] = _getBlockProofPublicInput(\n                prevBlockCommitment,\n                currentBlockCommitment,\n                _proof,\n                verifierParams\n            );\n\n            prevBlockCommitment = currentBlockCommitment;\n        }\n        require(currentTotalBlocksVerified <= s.totalBlocksCommitted, \"q\");\n\n        bool successVerifyProof = s.verifier.verify_serialized_proof(proofPublicInput, _proof.serializedProof);\n        require(successVerifyProof, \"p\"); // Proof verification fail\n\n        // Verify the recursive part that was given to us through the public input\n        bool successProofAggregation = _verifyRecursivePartOfProof(_proof.recursiveAggregationInput);\n        require(successProofAggregation, \"hh\"); // Proof aggregation must be valid\n\n        emit BlocksVerification(s.totalBlocksVerified, currentTotalBlocksVerified);\n        s.totalBlocksVerified = currentTotalBlocksVerified;\n    }\n\n    /// @dev Gets zk proof public input\n    function _getBlockProofPublicInput(\n        bytes32 _prevBlockCommitment,\n        bytes32 _currentBlockCommitment,\n        ProofInput calldata _proof,\n        VerifierParams memory _verifierParams\n    ) internal pure returns (uint256) {\n        return\n            uint256(\n                keccak256(\n                    abi.encodePacked(\n                        _prevBlockCommitment,\n                        _currentBlockCommitment,\n                        _verifierParams.recursionNodeLevelVkHash,\n                        _verifierParams.recursionLeafLevelVkHash,\n                        _verifierParams.recursionCircuitsSetVksHash,\n                        _proof.recursiveAggregationInput\n                    )\n                )\n            ) & INPUT_MASK;\n    }\n\n    /// @dev Verify a part of the zkp, that is responsible for the aggregation\n    function _verifyRecursivePartOfProof(uint256[] calldata _recursiveAggregationInput) internal view returns (bool) {\n        require(_recursiveAggregationInput.length == 4, \"vr\");\n\n        PairingsBn254.G1Point memory pairWithGen = PairingsBn254.new_g1_checked(\n            _recursiveAggregationInput[0],\n            _recursiveAggregationInput[1]\n        );\n        PairingsBn254.G1Point memory pairWithX = PairingsBn254.new_g1_checked(\n            _recursiveAggregationInput[2],\n            _recursiveAggregationInput[3]\n        );\n\n        PairingsBn254.G2Point memory g2Gen = PairingsBn254.new_g2(\n            [\n                0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\n                0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed\n            ],\n            [\n                0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\n                0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\n            ]\n        );\n        PairingsBn254.G2Point memory g2X = PairingsBn254.new_g2(\n            [\n                0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1,\n                0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0\n            ],\n            [\n                0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4,\n                0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55\n            ]\n        );\n\n        return PairingsBn254.pairingProd2(pairWithGen, g2Gen, pairWithX, g2X);\n    }\n\n    /// @notice Reverts unexecuted blocks\n    /// @param _newLastBlock block number after which blocks should be reverted\n    /// NOTE: Doesn't delete the stored data about blocks, but only decreases\n    /// counters that are responsible for the number of blocks\n    function revertBlocks(uint256 _newLastBlock) external nonReentrant onlyValidator {\n        require(s.totalBlocksCommitted > _newLastBlock, \"v1\"); // The last committed block is less than new last block\n        uint256 newTotalBlocksCommitted = _maxU256(_newLastBlock, s.totalBlocksExecuted);\n\n        if (newTotalBlocksCommitted < s.totalBlocksVerified) {\n            s.totalBlocksVerified = newTotalBlocksCommitted;\n        }\n        s.totalBlocksCommitted = newTotalBlocksCommitted;\n\n        emit BlocksRevert(s.totalBlocksCommitted, s.totalBlocksVerified, s.totalBlocksExecuted);\n    }\n\n    /// @notice Returns larger of two values\n    function _maxU256(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? b : a;\n    }\n\n    /// @dev Creates block commitment from its data\n    function _createBlockCommitment(CommitBlockInfo calldata _newBlockData) internal view returns (bytes32) {\n        bytes32 passThroughDataHash = keccak256(_blockPassThroughData(_newBlockData));\n        bytes32 metadataHash = keccak256(_blockMetaParameters());\n        bytes32 auxiliaryOutputHash = keccak256(_blockAuxiliaryOutput(_newBlockData));\n\n        return keccak256(abi.encode(passThroughDataHash, metadataHash, auxiliaryOutputHash));\n    }\n\n    function _blockPassThroughData(CommitBlockInfo calldata _block) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _block.indexRepeatedStorageChanges,\n                _block.newStateRoot,\n                uint64(0), // index repeated storage changes in zkPorter\n                bytes32(0) // zkPorter block hash\n            );\n    }\n\n    function _blockMetaParameters() internal view returns (bytes memory) {\n        return abi.encodePacked(s.zkPorterIsAvailable, s.l2BootloaderBytecodeHash, s.l2DefaultAccountBytecodeHash);\n    }\n\n    function _blockAuxiliaryOutput(CommitBlockInfo calldata _block) internal pure returns (bytes memory) {\n        require(_block.initialStorageChanges.length <= MAX_INITIAL_STORAGE_CHANGES_COMMITMENT_BYTES, \"pf\");\n        require(_block.repeatedStorageChanges.length <= MAX_REPEATED_STORAGE_CHANGES_COMMITMENT_BYTES, \"py\");\n        require(_block.l2Logs.length <= MAX_L2_TO_L1_LOGS_COMMITMENT_BYTES, \"pu\");\n\n        bytes32 initialStorageChangesHash = keccak256(_block.initialStorageChanges);\n        bytes32 repeatedStorageChangesHash = keccak256(_block.repeatedStorageChanges);\n        bytes32 l2ToL1LogsHash = keccak256(_block.l2Logs);\n\n        return abi.encode(_block.l2LogsTreeRoot, l2ToL1LogsHash, initialStorageChangesHash, repeatedStorageChangesHash);\n    }\n\n    /// @notice Returns the keccak hash of the ABI-encoded StoredBlockInfo\n    function _hashStoredBlockInfo(StoredBlockInfo memory _storedBlockInfo) internal pure returns (bytes32) {\n        return keccak256(abi.encode(_storedBlockInfo));\n    }\n}\n"},"cache/solpp-generated-contracts/common/libraries/UncheckedMath.sol":{"content":"pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n\n\nlibrary UncheckedMath {\n    function uncheckedInc(uint256 _number) internal pure returns (uint256) {\n        unchecked {\n            return _number + 1;\n        }\n    }\n\n    function uncheckedAdd(uint256 _lhs, uint256 _rhs) internal pure returns (uint256) {\n        unchecked {\n            return _lhs + _rhs;\n        }\n    }\n}\n"},"cache/solpp-generated-contracts/common/interfaces/IAllowList.sol":{"content":"pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n\n\ninterface IAllowList {\n    /*//////////////////////////////////////////////////////////////\n                            EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Access mode of target contract is changed\n    event UpdateAccessMode(address indexed target, AccessMode previousMode, AccessMode newMode);\n\n    /// @notice Permission to call is changed\n    event UpdateCallPermission(address indexed caller, address indexed target, bytes4 indexed functionSig, bool status);\n\n    /// @notice Type of access to a specific contract includes three different modes\n    /// @param Closed No one has access to the contract\n    /// @param SpecialAccessOnly Any address with granted special access can interact with a contract (see `hasSpecialAccessToCall`)\n    /// @param Public Everyone can interact with a contract\n    enum AccessMode {\n        Closed,\n        SpecialAccessOnly,\n        Public\n    }\n\n    /// @dev A struct that contains deposit limit data of a token\n    /// @param depositLimitation Whether any deposit limitation is placed or not\n    /// @param depositCap The maximum amount that can be deposited.\n    struct Deposit {\n        bool depositLimitation;\n        uint256 depositCap;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            GETTERS\n    //////////////////////////////////////////////////////////////*/\n\n    function getAccessMode(address _target) external view returns (AccessMode);\n\n    function hasSpecialAccessToCall(\n        address _caller,\n        address _target,\n        bytes4 _functionSig\n    ) external view returns (bool);\n\n    function canCall(\n        address _caller,\n        address _target,\n        bytes4 _functionSig\n    ) external view returns (bool);\n\n    function getTokenDepositLimitData(address _l1Token) external view returns (Deposit memory);\n\n    /*//////////////////////////////////////////////////////////////\n                           ALLOW LIST LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setBatchAccessMode(address[] calldata _targets, AccessMode[] calldata _accessMode) external;\n\n    function setAccessMode(address _target, AccessMode _accessMode) external;\n\n    function setBatchPermissionToCall(\n        address[] calldata _callers,\n        address[] calldata _targets,\n        bytes4[] calldata _functionSigs,\n        bool[] calldata _enables\n    ) external;\n\n    function setPermissionToCall(\n        address _caller,\n        address _target,\n        bytes4 _functionSig,\n        bool _enable\n    ) external;\n\n    /*//////////////////////////////////////////////////////////////\n                           DEPOSIT LIMIT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function setDepositLimit(\n        address _l1Token,\n        bool _depositLimitation,\n        uint256 _depositCap\n    ) external;\n}\n"},"cache/solpp-generated-contracts/common/libraries/L2ContractHelper.sol":{"content":"pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n\n\n/**\n * @author Matter Labs\n * @notice Helper library for working with L2 contracts on L1.\n */\nlibrary L2ContractHelper {\n    /// @dev The prefix used to create CREATE2 addresses.\n    bytes32 constant CREATE2_PREFIX = keccak256(\"zksyncCreate2\");\n\n    /// @notice Validate the bytecode format and calculate its hash.\n    /// @param _bytecode The bytecode to hash.\n    /// @return hashedBytecode The 32-byte hash of the bytecode.\n    /// Note: The function reverts the execution if the bytecode has non expected format:\n    /// - Bytecode bytes length is not a multiple of 32\n    /// - Bytecode bytes length is not less than 2^21 bytes (2^16 words)\n    /// - Bytecode words length is not odd\n    function hashL2Bytecode(bytes memory _bytecode) internal pure returns (bytes32 hashedBytecode) {\n        // Note that the length of the bytecode must be provided in 32-byte words.\n        require(_bytecode.length % 32 == 0, \"po\");\n\n        uint256 bytecodeLenInWords = _bytecode.length / 32;\n        require(bytecodeLenInWords < 2**16, \"pp\"); // bytecode length must be less than 2^16 words\n        require(bytecodeLenInWords % 2 == 1, \"pr\"); // bytecode length in words must be odd\n        hashedBytecode = sha256(_bytecode) & 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        // Setting the version of the hash\n        hashedBytecode = (hashedBytecode | bytes32(uint256(1 << 248)));\n        // Setting the length\n        hashedBytecode = hashedBytecode | bytes32(bytecodeLenInWords << 224);\n    }\n\n    /// @notice Validates the format of the given bytecode hash.\n    /// @dev Due to the specification of the L2 bytecode hash, not every 32 bytes could be a legit bytecode hash.\n    /// @dev The function reverts on invalid bytecode hash formam.\n    /// @param _bytecodeHash The hash of the bytecode to validate.\n    function validateBytecodeHash(bytes32 _bytecodeHash) internal pure {\n        uint8 version = uint8(_bytecodeHash[0]);\n        require(version == 1 && _bytecodeHash[1] == bytes1(0), \"zf\"); // Incorrectly formatted bytecodeHash\n\n        require(_bytecodeLen(_bytecodeHash) % 2 == 1, \"uy\"); // Code length in words must be odd\n    }\n\n    /// @notice Returns the length of the bytecode associated with the given hash.\n    /// @param _bytecodeHash The hash of the bytecode.\n    /// @return codeLengthInWords The length of the bytecode in words.\n    function _bytecodeLen(bytes32 _bytecodeHash) private pure returns (uint256 codeLengthInWords) {\n        codeLengthInWords = uint256(uint8(_bytecodeHash[2])) * 256 + uint256(uint8(_bytecodeHash[3]));\n    }\n\n    /// @notice Computes the create2 address for a Layer 2 contract.\n    /// @param _sender The address of the sender.\n    /// @param _salt The salt value to use in the create2 address computation.\n    /// @param _bytecodeHash The contract bytecode hash.\n    /// @param _constructorInputHash The hash of the constructor input data.\n    /// @return The create2 address of the contract.\n    /// NOTE: L2 create2 derivation is different from L1 derivation!\n    function computeCreate2Address(\n        address _sender,\n        bytes32 _salt,\n        bytes32 _bytecodeHash,\n        bytes32 _constructorInputHash\n    ) internal pure returns (address) {\n        bytes32 senderBytes = bytes32(uint256(uint160(_sender)));\n        bytes32 data = keccak256(\n            bytes.concat(CREATE2_PREFIX, senderBytes, _salt, _bytecodeHash, _constructorInputHash)\n        );\n\n        return address(uint160(uint256(data)));\n    }\n}\n"},"cache/solpp-generated-contracts/zksync/Storage.sol":{"content":"pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n\n\nimport \"./Verifier.sol\";\nimport \"../common/interfaces/IAllowList.sol\";\nimport \"./libraries/PriorityQueue.sol\";\n\n/// @notice Indicates whether an upgrade is initiated and if yes what type\n/// @param None Upgrade is NOT initiated\n/// @param Transparent Fully transparent upgrade is initiated, upgrade data is publicly known\n/// @param Shadow Shadow upgrade is initiated, upgrade data is hidden\nenum UpgradeState {\n    None,\n    Transparent,\n    Shadow\n}\n\n/// @dev Logically separated part of the storage structure, which is responsible for everything related to proxy upgrades and diamond cuts\n/// @param proposedUpgradeHash The hash of the current upgrade proposal, zero if there is no active proposal\n/// @param state Indicates whether an upgrade is initiated and if yes what type\n/// @param securityCouncil Address which has the permission to approve instant upgrades (expected to be a Gnosis multisig)\n/// @param approvedBySecurityCouncil Indicates whether the security council has approved the upgrade\n/// @param proposedUpgradeTimestamp The timestamp when the upgrade was proposed, zero if there are no active proposals\n/// @param currentProposalId The serial number of proposed upgrades, increments when proposing a new one\nstruct UpgradeStorage {\n    bytes32 proposedUpgradeHash;\n    UpgradeState state;\n    address securityCouncil;\n    bool approvedBySecurityCouncil;\n    uint40 proposedUpgradeTimestamp;\n    uint40 currentProposalId;\n}\n\n/// @dev The log passed from L2\n/// @param l2ShardId The shard identifier, 0 - rollup, 1 - porter. All other values are not used but are reserved for the future\n/// @param isService A boolean flag that is part of the log along with `key`, `value`, and `sender` address.\n/// This field is required formally but does not have any special meaning.\n/// @param txNumberInBlock The L2 transaction number in a block, in which the log was sent\n/// @param sender The L2 address which sent the log\n/// @param key The 32 bytes of information that was sent in the log\n/// @param value The 32 bytes of information that was sent in the log\n// Both `key` and `value` are arbitrary 32-bytes selected by the log sender\nstruct L2Log {\n    uint8 l2ShardId;\n    bool isService;\n    uint16 txNumberInBlock;\n    address sender;\n    bytes32 key;\n    bytes32 value;\n}\n\n/// @dev An arbitrary length message passed from L2\n/// @notice Under the hood it is `L2Log` sent from the special system L2 contract\n/// @param txNumberInBlock The L2 transaction number in a block, in which the message was sent\n/// @param sender The address of the L2 account from which the message was passed\n/// @param data An arbitrary length message\nstruct L2Message {\n    uint16 txNumberInBlock;\n    address sender;\n    bytes data;\n}\n\n/// @notice Part of the configuration parameters of ZKP circuits\nstruct VerifierParams {\n    bytes32 recursionNodeLevelVkHash;\n    bytes32 recursionLeafLevelVkHash;\n    bytes32 recursionCircuitsSetVksHash;\n}\n\n/// @dev storing all storage variables for zkSync facets\n/// NOTE: It is used in a proxy, so it is possible to add new variables to the end\n/// NOTE: but NOT to modify already existing variables or change their order\n/// NOTE: DiamondCutStorage is unused, but it must remain a member of AppStorage to not have storage collision\n/// NOTE: instead UpgradeStorage is used that is appended to the end of the AppStorage struct\nstruct AppStorage {\n    /// @dev Storage of variables needed for deprecated diamond cut facet\n    uint256[7] __DEPRECATED_diamondCutStorage;\n    /// @notice Address which will exercise governance over the network i.e. change validator set, conduct upgrades\n    address governor;\n    /// @notice Address that the governor proposed as one that will replace it\n    address pendingGovernor;\n    /// @notice List of permitted validators\n    mapping(address => bool) validators;\n    /// @dev Verifier contract. Used to verify aggregated proof for blocks\n    Verifier verifier;\n    /// @notice Total number of executed blocks i.e. blocks[totalBlocksExecuted] points at the latest executed block (block 0 is genesis)\n    uint256 totalBlocksExecuted;\n    /// @notice Total number of proved blocks i.e. blocks[totalBlocksProved] points at the latest proved block\n    uint256 totalBlocksVerified;\n    /// @notice Total number of committed blocks i.e. blocks[totalBlocksCommitted] points at the latest committed block\n    uint256 totalBlocksCommitted;\n    /// @dev Stored hashed StoredBlock for block number\n    mapping(uint256 => bytes32) storedBlockHashes;\n    /// @dev Stored root hashes of L2 -> L1 logs\n    mapping(uint256 => bytes32) l2LogsRootHashes;\n    /// @dev Container that stores transactions requested from L1\n    PriorityQueue.Queue priorityQueue;\n    /// @dev The smart contract that manages the list with permission to call contract functions\n    IAllowList allowList;\n    /// @notice Part of the configuration parameters of ZKP circuits. Used as an input for the verifier smart contract\n    VerifierParams verifierParams;\n    /// @notice Bytecode hash of bootloader program.\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2BootloaderBytecodeHash;\n    /// @notice Bytecode hash of default account (bytecode for EOA).\n    /// @dev Used as an input to zkp-circuit.\n    bytes32 l2DefaultAccountBytecodeHash;\n    /// @dev Indicates that the porter may be touched on L2 transactions.\n    /// @dev Used as an input to zkp-circuit.\n    bool zkPorterIsAvailable;\n    /// @dev The maximum number of the L2 gas that a user can request for L1 -> L2 transactions\n    /// @dev This is the maximum number of L2 gas that is available for the \"body\" of the transaction, i.e.\n    /// without overhead for proving the block.\n    uint256 priorityTxMaxGasLimit;\n    /// @dev Storage of variables needed for upgrade facet\n    UpgradeStorage upgrades;\n    /// @dev A mapping L2 block number => message number => flag.\n    /// @dev The L2 -> L1 log is sent for every withdrawal, so this mapping is serving as\n    /// a flag to indicate that the message was already processed.\n    /// @dev Used to indicate that eth withdrawal was already processed\n    mapping(uint256 => mapping(uint256 => bool)) isEthWithdrawalFinalized;\n    /// @dev The most recent withdrawal time and amount reset\n    uint256 __DEPRECATED_lastWithdrawalLimitReset;\n    /// @dev The accumulated withdrawn amount during the withdrawal limit window\n    uint256 __DEPRECATED_withdrawnAmountInWindow;\n    /// @dev A mapping user address => the total deposited amount by the user\n    mapping(address => uint256) totalDepositedAmountPerUser;\n}\n"},"cache/solpp-generated-contracts/zksync/Plonk4VerifierWithAccessToDNext.sol":{"content":"pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n\n\nimport \"./libraries/PairingsBn254.sol\";\nimport \"./libraries/TranscriptLib.sol\";\nimport \"../common/libraries/UncheckedMath.sol\";\n\nuint256 constant STATE_WIDTH = 4;\nuint256 constant NUM_G2_ELS = 2;\n\nstruct VerificationKey {\n    uint256 domain_size;\n    uint256 num_inputs;\n    PairingsBn254.Fr omega;\n    PairingsBn254.G1Point[2] gate_selectors_commitments;\n    PairingsBn254.G1Point[8] gate_setup_commitments;\n    PairingsBn254.G1Point[STATE_WIDTH] permutation_commitments;\n    PairingsBn254.G1Point lookup_selector_commitment;\n    PairingsBn254.G1Point[4] lookup_tables_commitments;\n    PairingsBn254.G1Point lookup_table_type_commitment;\n    PairingsBn254.Fr[STATE_WIDTH - 1] non_residues;\n    PairingsBn254.G2Point[NUM_G2_ELS] g2_elements;\n}\n\ncontract Plonk4VerifierWithAccessToDNext {\n    using PairingsBn254 for PairingsBn254.G1Point;\n    using PairingsBn254 for PairingsBn254.G2Point;\n    using PairingsBn254 for PairingsBn254.Fr;\n\n    using TranscriptLib for TranscriptLib.Transcript;\n\n    using UncheckedMath for uint256;\n\n    struct Proof {\n        uint256[] input_values;\n        // commitments\n        PairingsBn254.G1Point[STATE_WIDTH] state_polys_commitments;\n        PairingsBn254.G1Point copy_permutation_grand_product_commitment;\n        PairingsBn254.G1Point[STATE_WIDTH] quotient_poly_parts_commitments;\n        // openings\n        PairingsBn254.Fr[STATE_WIDTH] state_polys_openings_at_z;\n        PairingsBn254.Fr[1] state_polys_openings_at_z_omega;\n        PairingsBn254.Fr[1] gate_selectors_openings_at_z;\n        PairingsBn254.Fr[STATE_WIDTH - 1] copy_permutation_polys_openings_at_z;\n        PairingsBn254.Fr copy_permutation_grand_product_opening_at_z_omega;\n        PairingsBn254.Fr quotient_poly_opening_at_z;\n        PairingsBn254.Fr linearization_poly_opening_at_z;\n        // lookup commitments\n        PairingsBn254.G1Point lookup_s_poly_commitment;\n        PairingsBn254.G1Point lookup_grand_product_commitment;\n        // lookup openings\n        PairingsBn254.Fr lookup_s_poly_opening_at_z_omega;\n        PairingsBn254.Fr lookup_grand_product_opening_at_z_omega;\n        PairingsBn254.Fr lookup_t_poly_opening_at_z;\n        PairingsBn254.Fr lookup_t_poly_opening_at_z_omega;\n        PairingsBn254.Fr lookup_selector_poly_opening_at_z;\n        PairingsBn254.Fr lookup_table_type_poly_opening_at_z;\n        PairingsBn254.G1Point opening_proof_at_z;\n        PairingsBn254.G1Point opening_proof_at_z_omega;\n    }\n\n    struct PartialVerifierState {\n        PairingsBn254.Fr zero;\n        PairingsBn254.Fr alpha;\n        PairingsBn254.Fr beta;\n        PairingsBn254.Fr gamma;\n        PairingsBn254.Fr[9] alpha_values;\n        PairingsBn254.Fr eta;\n        PairingsBn254.Fr beta_lookup;\n        PairingsBn254.Fr gamma_lookup;\n        PairingsBn254.Fr beta_plus_one;\n        PairingsBn254.Fr beta_gamma;\n        PairingsBn254.Fr v;\n        PairingsBn254.Fr u;\n        PairingsBn254.Fr z;\n        PairingsBn254.Fr z_omega;\n        PairingsBn254.Fr z_minus_last_omega;\n        PairingsBn254.Fr l_0_at_z;\n        PairingsBn254.Fr l_n_minus_one_at_z;\n        PairingsBn254.Fr t;\n        PairingsBn254.G1Point tp;\n    }\n\n    function evaluate_l0_at_point(uint256 domain_size, PairingsBn254.Fr memory at)\n        internal\n        view\n        returns (PairingsBn254.Fr memory num)\n    {\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\n\n        PairingsBn254.Fr memory size_fe = PairingsBn254.new_fr(domain_size);\n        PairingsBn254.Fr memory den = at.copy();\n        den.sub_assign(one);\n        den.mul_assign(size_fe);\n\n        den = den.inverse();\n\n        num = at.pow(domain_size);\n        num.sub_assign(one);\n        num.mul_assign(den);\n    }\n\n    function evaluate_lagrange_poly_out_of_domain(\n        uint256 poly_num,\n        uint256 domain_size,\n        PairingsBn254.Fr memory omega,\n        PairingsBn254.Fr memory at\n    ) internal view returns (PairingsBn254.Fr memory res) {\n        // (omega^i / N) / (X - omega^i) * (X^N - 1)\n        require(poly_num < domain_size);\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\n        PairingsBn254.Fr memory omega_power = omega.pow(poly_num);\n        res = at.pow(domain_size);\n        res.sub_assign(one);\n        require(res.value != 0); // Vanishing polynomial can not be zero at point `at`\n        res.mul_assign(omega_power);\n\n        PairingsBn254.Fr memory den = PairingsBn254.copy(at);\n        den.sub_assign(omega_power);\n        den.mul_assign(PairingsBn254.new_fr(domain_size));\n\n        den = den.inverse();\n\n        res.mul_assign(den);\n    }\n\n    function evaluate_vanishing(uint256 domain_size, PairingsBn254.Fr memory at)\n        internal\n        view\n        returns (PairingsBn254.Fr memory res)\n    {\n        res = at.pow(domain_size);\n        res.sub_assign(PairingsBn254.new_fr(1));\n    }\n\n    function initialize_transcript(Proof memory proof, VerificationKey memory vk)\n        internal\n        pure\n        returns (PartialVerifierState memory state)\n    {\n        TranscriptLib.Transcript memory transcript = TranscriptLib.new_transcript();\n\n        for (uint256 i = 0; i < vk.num_inputs; i = i.uncheckedInc()) {\n            transcript.update_with_u256(proof.input_values[i]);\n        }\n\n        for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()) {\n            transcript.update_with_g1(proof.state_polys_commitments[i]);\n        }\n\n        state.eta = transcript.get_challenge();\n        transcript.update_with_g1(proof.lookup_s_poly_commitment);\n\n        state.beta = transcript.get_challenge();\n        state.gamma = transcript.get_challenge();\n\n        transcript.update_with_g1(proof.copy_permutation_grand_product_commitment);\n        state.beta_lookup = transcript.get_challenge();\n        state.gamma_lookup = transcript.get_challenge();\n        transcript.update_with_g1(proof.lookup_grand_product_commitment);\n        state.alpha = transcript.get_challenge();\n\n        for (uint256 i = 0; i < proof.quotient_poly_parts_commitments.length; i = i.uncheckedInc()) {\n            transcript.update_with_g1(proof.quotient_poly_parts_commitments[i]);\n        }\n        state.z = transcript.get_challenge();\n\n        transcript.update_with_fr(proof.quotient_poly_opening_at_z);\n\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z.length; i = i.uncheckedInc()) {\n            transcript.update_with_fr(proof.state_polys_openings_at_z[i]);\n        }\n\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z_omega.length; i = i.uncheckedInc()) {\n            transcript.update_with_fr(proof.state_polys_openings_at_z_omega[i]);\n        }\n        for (uint256 i = 0; i < proof.gate_selectors_openings_at_z.length; i = i.uncheckedInc()) {\n            transcript.update_with_fr(proof.gate_selectors_openings_at_z[i]);\n        }\n        for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z.length; i = i.uncheckedInc()) {\n            transcript.update_with_fr(proof.copy_permutation_polys_openings_at_z[i]);\n        }\n\n        state.z_omega = state.z.copy();\n        state.z_omega.mul_assign(vk.omega);\n\n        transcript.update_with_fr(proof.copy_permutation_grand_product_opening_at_z_omega);\n\n        transcript.update_with_fr(proof.lookup_t_poly_opening_at_z);\n        transcript.update_with_fr(proof.lookup_selector_poly_opening_at_z);\n        transcript.update_with_fr(proof.lookup_table_type_poly_opening_at_z);\n        transcript.update_with_fr(proof.lookup_s_poly_opening_at_z_omega);\n        transcript.update_with_fr(proof.lookup_grand_product_opening_at_z_omega);\n        transcript.update_with_fr(proof.lookup_t_poly_opening_at_z_omega);\n        transcript.update_with_fr(proof.linearization_poly_opening_at_z);\n\n        state.v = transcript.get_challenge();\n\n        transcript.update_with_g1(proof.opening_proof_at_z);\n        transcript.update_with_g1(proof.opening_proof_at_z_omega);\n\n        state.u = transcript.get_challenge();\n    }\n\n    // compute some powers of challenge alpha([alpha^1, .. alpha^8])\n    function compute_powers_of_alpha(PartialVerifierState memory state) public pure {\n        require(state.alpha.value != 0);\n        state.alpha_values[0] = PairingsBn254.new_fr(1);\n        state.alpha_values[1] = state.alpha.copy();\n        PairingsBn254.Fr memory current_alpha = state.alpha.copy();\n        for (uint256 i = 2; i < state.alpha_values.length; i = i.uncheckedInc()) {\n            current_alpha.mul_assign(state.alpha);\n            state.alpha_values[i] = current_alpha.copy();\n        }\n    }\n\n    function verify(Proof memory proof, VerificationKey memory vk) internal view returns (bool) {\n        // we initialize all challenges beforehand, we can draw each challenge in its own place\n        PartialVerifierState memory state = initialize_transcript(proof, vk);\n        if (verify_quotient_evaluation(vk, proof, state) == false) {\n            return false;\n        }\n        require(proof.state_polys_openings_at_z_omega.length == 1);\n\n        PairingsBn254.G1Point memory quotient_result = proof.quotient_poly_parts_commitments[0].copy_g1();\n        {\n            // block scope\n            PairingsBn254.Fr memory z_in_domain_size = state.z.pow(vk.domain_size);\n            PairingsBn254.Fr memory current_z = z_in_domain_size.copy();\n            PairingsBn254.G1Point memory tp;\n            // start from i =1\n            for (uint256 i = 1; i < proof.quotient_poly_parts_commitments.length; i = i.uncheckedInc()) {\n                tp = proof.quotient_poly_parts_commitments[i].copy_g1();\n                tp.point_mul_assign(current_z);\n                quotient_result.point_add_assign(tp);\n\n                current_z.mul_assign(z_in_domain_size);\n            }\n        }\n\n        Queries memory queries = prepare_queries(vk, proof, state);\n        queries.commitments_at_z[0] = quotient_result;\n        queries.values_at_z[0] = proof.quotient_poly_opening_at_z;\n        queries.commitments_at_z[1] = aggregated_linearization_commitment(vk, proof, state);\n        queries.values_at_z[1] = proof.linearization_poly_opening_at_z;\n\n        require(queries.commitments_at_z.length == queries.values_at_z.length);\n\n        PairingsBn254.G1Point memory aggregated_commitment_at_z = queries.commitments_at_z[0];\n\n        PairingsBn254.Fr memory aggregated_opening_at_z = queries.values_at_z[0];\n        PairingsBn254.Fr memory aggregation_challenge = PairingsBn254.new_fr(1);\n        PairingsBn254.G1Point memory scaled;\n        for (uint256 i = 1; i < queries.commitments_at_z.length; i = i.uncheckedInc()) {\n            aggregation_challenge.mul_assign(state.v);\n            scaled = queries.commitments_at_z[i].point_mul(aggregation_challenge);\n            aggregated_commitment_at_z.point_add_assign(scaled);\n\n            state.t = queries.values_at_z[i];\n            state.t.mul_assign(aggregation_challenge);\n            aggregated_opening_at_z.add_assign(state.t);\n        }\n\n        aggregation_challenge.mul_assign(state.v);\n\n        PairingsBn254.G1Point memory aggregated_commitment_at_z_omega = queries.commitments_at_z_omega[0].point_mul(\n            aggregation_challenge\n        );\n        PairingsBn254.Fr memory aggregated_opening_at_z_omega = queries.values_at_z_omega[0];\n        aggregated_opening_at_z_omega.mul_assign(aggregation_challenge);\n        for (uint256 i = 1; i < queries.commitments_at_z_omega.length; i = i.uncheckedInc()) {\n            aggregation_challenge.mul_assign(state.v);\n\n            scaled = queries.commitments_at_z_omega[i].point_mul(aggregation_challenge);\n            aggregated_commitment_at_z_omega.point_add_assign(scaled);\n\n            state.t = queries.values_at_z_omega[i];\n            state.t.mul_assign(aggregation_challenge);\n            aggregated_opening_at_z_omega.add_assign(state.t);\n        }\n\n        return\n            final_pairing(\n                vk.g2_elements,\n                proof,\n                state,\n                aggregated_commitment_at_z,\n                aggregated_commitment_at_z_omega,\n                aggregated_opening_at_z,\n                aggregated_opening_at_z_omega\n            );\n    }\n\n    function verify_quotient_evaluation(\n        VerificationKey memory vk,\n        Proof memory proof,\n        PartialVerifierState memory state\n    ) internal view returns (bool) {\n        uint256[] memory lagrange_poly_numbers = new uint256[](vk.num_inputs);\n        for (uint256 i = 0; i < lagrange_poly_numbers.length; i = i.uncheckedInc()) {\n            lagrange_poly_numbers[i] = i;\n        }\n        require(vk.num_inputs > 0);\n\n        PairingsBn254.Fr memory inputs_term = PairingsBn254.new_fr(0);\n        for (uint256 i = 0; i < vk.num_inputs; i = i.uncheckedInc()) {\n            state.t = evaluate_lagrange_poly_out_of_domain(i, vk.domain_size, vk.omega, state.z);\n            state.t.mul_assign(PairingsBn254.new_fr(proof.input_values[i]));\n            inputs_term.add_assign(state.t);\n        }\n        inputs_term.mul_assign(proof.gate_selectors_openings_at_z[0]);\n        PairingsBn254.Fr memory result = proof.linearization_poly_opening_at_z.copy();\n        result.add_assign(inputs_term);\n\n        // compute powers of alpha\n        compute_powers_of_alpha(state);\n        PairingsBn254.Fr memory factor = state.alpha_values[4].copy();\n        factor.mul_assign(proof.copy_permutation_grand_product_opening_at_z_omega);\n\n        // - alpha_0 * (a + perm(z) * beta + gamma)*()*(d + gamma) * z(z*omega)\n        require(proof.copy_permutation_polys_openings_at_z.length == STATE_WIDTH - 1);\n        PairingsBn254.Fr memory t; // TMP;\n        for (uint256 i = 0; i < proof.copy_permutation_polys_openings_at_z.length; i = i.uncheckedInc()) {\n            t = proof.copy_permutation_polys_openings_at_z[i].copy();\n            t.mul_assign(state.beta);\n            t.add_assign(proof.state_polys_openings_at_z[i]);\n            t.add_assign(state.gamma);\n\n            factor.mul_assign(t);\n        }\n\n        t = proof.state_polys_openings_at_z[3].copy();\n        t.add_assign(state.gamma);\n        factor.mul_assign(t);\n        result.sub_assign(factor);\n\n        // - L_0(z) * alpha_1\n        PairingsBn254.Fr memory l_0_at_z = evaluate_l0_at_point(vk.domain_size, state.z);\n        l_0_at_z.mul_assign(state.alpha_values[4 + 1]);\n        result.sub_assign(l_0_at_z);\n\n        PairingsBn254.Fr memory lookup_quotient_contrib = lookup_quotient_contribution(vk, proof, state);\n        result.add_assign(lookup_quotient_contrib);\n\n        PairingsBn254.Fr memory lhs = proof.quotient_poly_opening_at_z.copy();\n        lhs.mul_assign(evaluate_vanishing(vk.domain_size, state.z));\n        return lhs.value == result.value;\n    }\n\n    function lookup_quotient_contribution(\n        VerificationKey memory vk,\n        Proof memory proof,\n        PartialVerifierState memory state\n    ) internal view returns (PairingsBn254.Fr memory result) {\n        PairingsBn254.Fr memory t;\n\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\n        state.beta_plus_one = state.beta_lookup.copy();\n        state.beta_plus_one.add_assign(one);\n        state.beta_gamma = state.beta_plus_one.copy();\n        state.beta_gamma.mul_assign(state.gamma_lookup);\n\n        // (s'*beta + gamma)*(zw')*alpha\n        t = proof.lookup_s_poly_opening_at_z_omega.copy();\n        t.mul_assign(state.beta_lookup);\n        t.add_assign(state.beta_gamma);\n        t.mul_assign(proof.lookup_grand_product_opening_at_z_omega);\n        t.mul_assign(state.alpha_values[6]);\n\n        // (z - omega^{n-1}) for this part\n        PairingsBn254.Fr memory last_omega = vk.omega.pow(vk.domain_size - 1);\n        state.z_minus_last_omega = state.z.copy();\n        state.z_minus_last_omega.sub_assign(last_omega);\n        t.mul_assign(state.z_minus_last_omega);\n        result.add_assign(t);\n\n        // - alpha_1 * L_{0}(z)\n        state.l_0_at_z = evaluate_lagrange_poly_out_of_domain(0, vk.domain_size, vk.omega, state.z);\n        t = state.l_0_at_z.copy();\n        t.mul_assign(state.alpha_values[6 + 1]);\n        result.sub_assign(t);\n\n        // - alpha_2 * beta_gamma_powered L_{n-1}(z)\n        PairingsBn254.Fr memory beta_gamma_powered = state.beta_gamma.pow(vk.domain_size - 1);\n        state.l_n_minus_one_at_z = evaluate_lagrange_poly_out_of_domain(\n            vk.domain_size - 1,\n            vk.domain_size,\n            vk.omega,\n            state.z\n        );\n        t = state.l_n_minus_one_at_z.copy();\n        t.mul_assign(beta_gamma_powered);\n        t.mul_assign(state.alpha_values[6 + 2]);\n\n        result.sub_assign(t);\n    }\n\n    function aggregated_linearization_commitment(\n        VerificationKey memory vk,\n        Proof memory proof,\n        PartialVerifierState memory state\n    ) internal view returns (PairingsBn254.G1Point memory result) {\n        // qMain*(Q_a * A + Q_b * B + Q_c * C + Q_d * D + Q_m * A*B + Q_const + Q_dNext * D_next)\n        result = PairingsBn254.new_g1(0, 0);\n        // Q_a * A\n        PairingsBn254.G1Point memory scaled = vk.gate_setup_commitments[0].point_mul(\n            proof.state_polys_openings_at_z[0]\n        );\n        result.point_add_assign(scaled);\n        // Q_b * B\n        scaled = vk.gate_setup_commitments[1].point_mul(proof.state_polys_openings_at_z[1]);\n        result.point_add_assign(scaled);\n        // Q_c * C\n        scaled = vk.gate_setup_commitments[2].point_mul(proof.state_polys_openings_at_z[2]);\n        result.point_add_assign(scaled);\n        // Q_d * D\n        scaled = vk.gate_setup_commitments[3].point_mul(proof.state_polys_openings_at_z[3]);\n        result.point_add_assign(scaled);\n        // Q_m* A*B or Q_ab*A*B\n        PairingsBn254.Fr memory t = proof.state_polys_openings_at_z[0].copy();\n        t.mul_assign(proof.state_polys_openings_at_z[1]);\n        scaled = vk.gate_setup_commitments[4].point_mul(t);\n        result.point_add_assign(scaled);\n        // Q_AC* A*C\n        t = proof.state_polys_openings_at_z[0].copy();\n        t.mul_assign(proof.state_polys_openings_at_z[2]);\n        scaled = vk.gate_setup_commitments[5].point_mul(t);\n        result.point_add_assign(scaled);\n        // Q_const\n        result.point_add_assign(vk.gate_setup_commitments[6]);\n        // Q_dNext * D_next\n        scaled = vk.gate_setup_commitments[7].point_mul(proof.state_polys_openings_at_z_omega[0]);\n        result.point_add_assign(scaled);\n        result.point_mul_assign(proof.gate_selectors_openings_at_z[0]);\n\n        PairingsBn254.G1Point\n            memory rescue_custom_gate_linearization_contrib = rescue_custom_gate_linearization_contribution(\n                vk,\n                proof,\n                state\n            );\n        result.point_add_assign(rescue_custom_gate_linearization_contrib);\n        require(vk.non_residues.length == STATE_WIDTH - 1);\n\n        PairingsBn254.Fr memory one = PairingsBn254.new_fr(1);\n        PairingsBn254.Fr memory factor = state.alpha_values[4].copy();\n        for (uint256 i = 0; i < proof.state_polys_openings_at_z.length; ) {\n            t = state.z.copy();\n            if (i == 0) {\n                t.mul_assign(one);\n            } else {\n                t.mul_assign(vk.non_residues[i - 1]);\n            }\n            t.mul_assign(state.beta);\n            t.add_assign(state.gamma);\n            t.add_assign(proof.state_polys_openings_at_z[i]);\n\n            factor.mul_assign(t);\n            unchecked {\n                ++i;\n            }\n        }\n\n        scaled = proof.copy_permutation_grand_product_commitment.point_mul(factor);\n        result.point_add_assign(scaled);\n\n        // - (a(z) + beta*perm_a + gamma)*()*()*z(z*omega) * beta * perm_d(X)\n        factor = state.alpha_values[4].copy();\n        factor.mul_assign(state.beta);\n        factor.mul_assign(proof.copy_permutation_grand_product_opening_at_z_omega);\n        for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc()) {\n            t = proof.copy_permutation_polys_openings_at_z[i].copy();\n            t.mul_assign(state.beta);\n            t.add_assign(state.gamma);\n            t.add_assign(proof.state_polys_openings_at_z[i]);\n\n            factor.mul_assign(t);\n        }\n        scaled = vk.permutation_commitments[3].point_mul(factor);\n        result.point_sub_assign(scaled);\n\n        // + L_0(z) * Z(x)\n        state.l_0_at_z = evaluate_lagrange_poly_out_of_domain(0, vk.domain_size, vk.omega, state.z);\n        require(state.l_0_at_z.value != 0);\n        factor = state.l_0_at_z.copy();\n        factor.mul_assign(state.alpha_values[4 + 1]);\n        scaled = proof.copy_permutation_grand_product_commitment.point_mul(factor);\n        result.point_add_assign(scaled);\n\n        PairingsBn254.G1Point memory lookup_linearization_contrib = lookup_linearization_contribution(proof, state);\n        result.point_add_assign(lookup_linearization_contrib);\n    }\n\n    function rescue_custom_gate_linearization_contribution(\n        VerificationKey memory vk,\n        Proof memory proof,\n        PartialVerifierState memory state\n    ) public view returns (PairingsBn254.G1Point memory result) {\n        PairingsBn254.Fr memory t;\n        PairingsBn254.Fr memory intermediate_result;\n\n        // a^2 - b = 0\n        t = proof.state_polys_openings_at_z[0].copy();\n        t.mul_assign(t);\n        t.sub_assign(proof.state_polys_openings_at_z[1]);\n        // t.mul_assign(challenge1);\n        t.mul_assign(state.alpha_values[1]);\n        intermediate_result.add_assign(t);\n\n        // b^2 - c = 0\n        t = proof.state_polys_openings_at_z[1].copy();\n        t.mul_assign(t);\n        t.sub_assign(proof.state_polys_openings_at_z[2]);\n        t.mul_assign(state.alpha_values[1 + 1]);\n        intermediate_result.add_assign(t);\n\n        // c*a - d = 0;\n        t = proof.state_polys_openings_at_z[2].copy();\n        t.mul_assign(proof.state_polys_openings_at_z[0]);\n        t.sub_assign(proof.state_polys_openings_at_z[3]);\n        t.mul_assign(state.alpha_values[1 + 2]);\n        intermediate_result.add_assign(t);\n\n        result = vk.gate_selectors_commitments[1].point_mul(intermediate_result);\n    }\n\n    function lookup_linearization_contribution(Proof memory proof, PartialVerifierState memory state)\n        internal\n        view\n        returns (PairingsBn254.G1Point memory result)\n    {\n        PairingsBn254.Fr memory zero = PairingsBn254.new_fr(0);\n\n        PairingsBn254.Fr memory t;\n        PairingsBn254.Fr memory factor;\n        // s(x) from the Z(x*omega)*(\\gamma*(1 + \\beta) + s(x) + \\beta * s(x*omega)))\n        factor = proof.lookup_grand_product_opening_at_z_omega.copy();\n        factor.mul_assign(state.alpha_values[6]);\n        factor.mul_assign(state.z_minus_last_omega);\n\n        PairingsBn254.G1Point memory scaled = proof.lookup_s_poly_commitment.point_mul(factor);\n        result.point_add_assign(scaled);\n\n        // Z(x) from - alpha_0 * Z(x) * (\\beta + 1) * (\\gamma + f(x)) * (\\gamma(1 + \\beta) + t(x) + \\beta * t(x*omega))\n        // + alpha_1 * Z(x) * L_{0}(z) + alpha_2 * Z(x) * L_{n-1}(z)\n\n        // accumulate coefficient\n        factor = proof.lookup_t_poly_opening_at_z_omega.copy();\n        factor.mul_assign(state.beta_lookup);\n        factor.add_assign(proof.lookup_t_poly_opening_at_z);\n        factor.add_assign(state.beta_gamma);\n\n        // (\\gamma + f(x))\n        PairingsBn254.Fr memory f_reconstructed;\n        PairingsBn254.Fr memory current = PairingsBn254.new_fr(1);\n        PairingsBn254.Fr memory tmp0;\n        for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc()) {\n            tmp0 = proof.state_polys_openings_at_z[i].copy();\n            tmp0.mul_assign(current);\n            f_reconstructed.add_assign(tmp0);\n\n            current.mul_assign(state.eta);\n        }\n\n        // add type of table\n        t = proof.lookup_table_type_poly_opening_at_z.copy();\n        t.mul_assign(current);\n        f_reconstructed.add_assign(t);\n\n        f_reconstructed.mul_assign(proof.lookup_selector_poly_opening_at_z);\n        f_reconstructed.add_assign(state.gamma_lookup);\n\n        // end of (\\gamma + f(x)) part\n        factor.mul_assign(f_reconstructed);\n        factor.mul_assign(state.beta_plus_one);\n        t = zero.copy();\n        t.sub_assign(factor);\n        factor = t;\n        factor.mul_assign(state.alpha_values[6]);\n\n        // Multiply by (z - omega^{n-1})\n        factor.mul_assign(state.z_minus_last_omega);\n\n        // L_{0}(z) in front of Z(x)\n        t = state.l_0_at_z.copy();\n        t.mul_assign(state.alpha_values[6 + 1]);\n        factor.add_assign(t);\n\n        // L_{n-1}(z) in front of Z(x)\n        t = state.l_n_minus_one_at_z.copy();\n        t.mul_assign(state.alpha_values[6 + 2]);\n        factor.add_assign(t);\n\n        scaled = proof.lookup_grand_product_commitment.point_mul(factor);\n        result.point_add_assign(scaled);\n    }\n\n    struct Queries {\n        PairingsBn254.G1Point[13] commitments_at_z;\n        PairingsBn254.Fr[13] values_at_z;\n        PairingsBn254.G1Point[6] commitments_at_z_omega;\n        PairingsBn254.Fr[6] values_at_z_omega;\n    }\n\n    function prepare_queries(\n        VerificationKey memory vk,\n        Proof memory proof,\n        PartialVerifierState memory state\n    ) public view returns (Queries memory queries) {\n        // we set first two items in calee side so start idx from 2\n        uint256 idx = 2;\n        for (uint256 i = 0; i < STATE_WIDTH; i = i.uncheckedInc()) {\n            queries.commitments_at_z[idx] = proof.state_polys_commitments[i];\n            queries.values_at_z[idx] = proof.state_polys_openings_at_z[i];\n            idx = idx.uncheckedInc();\n        }\n        require(proof.gate_selectors_openings_at_z.length == 1);\n        queries.commitments_at_z[idx] = vk.gate_selectors_commitments[0];\n        queries.values_at_z[idx] = proof.gate_selectors_openings_at_z[0];\n        idx = idx.uncheckedInc();\n        for (uint256 i = 0; i < STATE_WIDTH - 1; i = i.uncheckedInc()) {\n            queries.commitments_at_z[idx] = vk.permutation_commitments[i];\n            queries.values_at_z[idx] = proof.copy_permutation_polys_openings_at_z[i];\n            idx = idx.uncheckedInc();\n        }\n\n        queries.commitments_at_z_omega[0] = proof.copy_permutation_grand_product_commitment;\n        queries.commitments_at_z_omega[1] = proof.state_polys_commitments[STATE_WIDTH - 1];\n\n        queries.values_at_z_omega[0] = proof.copy_permutation_grand_product_opening_at_z_omega;\n        queries.values_at_z_omega[1] = proof.state_polys_openings_at_z_omega[0];\n\n        PairingsBn254.G1Point memory lookup_t_poly_commitment_aggregated = vk.lookup_tables_commitments[0];\n        PairingsBn254.Fr memory current_eta = state.eta.copy();\n        for (uint256 i = 1; i < vk.lookup_tables_commitments.length; i = i.uncheckedInc()) {\n            state.tp = vk.lookup_tables_commitments[i].point_mul(current_eta);\n            lookup_t_poly_commitment_aggregated.point_add_assign(state.tp);\n\n            current_eta.mul_assign(state.eta);\n        }\n        queries.commitments_at_z[idx] = lookup_t_poly_commitment_aggregated;\n        queries.values_at_z[idx] = proof.lookup_t_poly_opening_at_z;\n        idx = idx.uncheckedInc();\n        queries.commitments_at_z[idx] = vk.lookup_selector_commitment;\n        queries.values_at_z[idx] = proof.lookup_selector_poly_opening_at_z;\n        idx = idx.uncheckedInc();\n        queries.commitments_at_z[idx] = vk.lookup_table_type_commitment;\n        queries.values_at_z[idx] = proof.lookup_table_type_poly_opening_at_z;\n        queries.commitments_at_z_omega[2] = proof.lookup_s_poly_commitment;\n        queries.values_at_z_omega[2] = proof.lookup_s_poly_opening_at_z_omega;\n        queries.commitments_at_z_omega[3] = proof.lookup_grand_product_commitment;\n        queries.values_at_z_omega[3] = proof.lookup_grand_product_opening_at_z_omega;\n        queries.commitments_at_z_omega[4] = lookup_t_poly_commitment_aggregated;\n        queries.values_at_z_omega[4] = proof.lookup_t_poly_opening_at_z_omega;\n    }\n\n    function final_pairing(\n        // VerificationKey memory vk,\n        PairingsBn254.G2Point[NUM_G2_ELS] memory g2_elements,\n        Proof memory proof,\n        PartialVerifierState memory state,\n        PairingsBn254.G1Point memory aggregated_commitment_at_z,\n        PairingsBn254.G1Point memory aggregated_commitment_at_z_omega,\n        PairingsBn254.Fr memory aggregated_opening_at_z,\n        PairingsBn254.Fr memory aggregated_opening_at_z_omega\n    ) internal view returns (bool) {\n        // q(x) = f(x) - f(z) / (x - z)\n        // q(x) * (x-z)  = f(x) - f(z)\n\n        // f(x)\n        PairingsBn254.G1Point memory pair_with_generator = aggregated_commitment_at_z.copy_g1();\n        aggregated_commitment_at_z_omega.point_mul_assign(state.u);\n        pair_with_generator.point_add_assign(aggregated_commitment_at_z_omega);\n\n        // - f(z)*g\n        PairingsBn254.Fr memory aggregated_value = aggregated_opening_at_z_omega.copy();\n        aggregated_value.mul_assign(state.u);\n        aggregated_value.add_assign(aggregated_opening_at_z);\n        PairingsBn254.G1Point memory tp = PairingsBn254.P1().point_mul(aggregated_value);\n        pair_with_generator.point_sub_assign(tp);\n\n        // +z * q(x)\n        tp = proof.opening_proof_at_z.point_mul(state.z);\n        PairingsBn254.Fr memory t = state.z_omega.copy();\n        t.mul_assign(state.u);\n        PairingsBn254.G1Point memory t1 = proof.opening_proof_at_z_omega.point_mul(t);\n        tp.point_add_assign(t1);\n        pair_with_generator.point_add_assign(tp);\n\n        // rhs\n        PairingsBn254.G1Point memory pair_with_x = proof.opening_proof_at_z_omega.point_mul(state.u);\n        pair_with_x.point_add_assign(proof.opening_proof_at_z);\n        pair_with_x.negate();\n        // Pairing precompile expects points to be in a `i*x[1] + x[0]` form instead of `x[0] + i*x[1]`\n        // so we handle it in code generation step\n        PairingsBn254.G2Point memory first_g2 = g2_elements[0];\n        PairingsBn254.G2Point memory second_g2 = g2_elements[1];\n\n        return PairingsBn254.pairingProd2(pair_with_generator, first_g2, pair_with_x, second_g2);\n    }\n}\n"},"cache/solpp-generated-contracts/zksync/interfaces/IExecutor.sol":{"content":"pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n\n\ninterface IExecutor {\n    /// @notice Rollup block stored data\n    /// @param blockNumber Rollup block number\n    /// @param blockHash Hash of L2 block\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\n    /// @param priorityOperationsHash Hash of all priority operations from this block\n    /// @param l2LogsTreeRoot Root hash of tree that contains L2 -> L1 messages from this block\n    /// @param timestamp Rollup block timestamp, have the same format as Ethereum block constant\n    /// @param commitment Verified input for the zkSync circuit\n    struct StoredBlockInfo {\n        uint64 blockNumber;\n        bytes32 blockHash;\n        uint64 indexRepeatedStorageChanges;\n        uint256 numberOfLayer1Txs;\n        bytes32 priorityOperationsHash;\n        bytes32 l2LogsTreeRoot;\n        uint256 timestamp;\n        bytes32 commitment;\n    }\n\n    /// @notice Data needed to commit new block\n    /// @param blockNumber Number of the committed block\n    /// @param timestamp Unix timestamp denoting the start of the block execution\n    /// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more\n    /// @param newStateRoot The state root of the full state tree\n    /// @param numberOfLayer1Txs Number of priority operations to be processed\n    /// @param l2LogsTreeRoot The root hash of the tree that contains all L2 -> L1 logs in the block\n    /// @param priorityOperationsHash Hash of all priority operations from this block\n    /// @param initialStorageChanges Storage write access as a concatenation key-value\n    /// @param repeatedStorageChanges Storage write access as a concatenation index-value\n    /// @param l2Logs concatenation of all L2 -> L1 logs in the block\n    /// @param l2ArbitraryLengthMessages array of hash preimages that were sent as value of L2 logs by special system L2 contract\n    /// @param factoryDeps array of l2 bytecodes that were marked as known on L2\n    struct CommitBlockInfo {\n        uint64 blockNumber;\n        uint64 timestamp;\n        uint64 indexRepeatedStorageChanges;\n        bytes32 newStateRoot;\n        uint256 numberOfLayer1Txs;\n        bytes32 l2LogsTreeRoot;\n        bytes32 priorityOperationsHash;\n        bytes initialStorageChanges;\n        bytes repeatedStorageChanges;\n        bytes l2Logs;\n        bytes[] l2ArbitraryLengthMessages;\n        bytes[] factoryDeps;\n    }\n\n    /// @notice Recursive proof input data (individual commitments are constructed onchain)\n    struct ProofInput {\n        uint256[] recursiveAggregationInput;\n        uint256[] serializedProof;\n    }\n\n    function commitBlocks(StoredBlockInfo calldata _lastCommittedBlockData, CommitBlockInfo[] calldata _newBlocksData)\n        external;\n\n    function proveBlocks(\n        StoredBlockInfo calldata _prevBlock,\n        StoredBlockInfo[] calldata _committedBlocks,\n        ProofInput calldata _proof\n    ) external;\n\n    function executeBlocks(StoredBlockInfo[] calldata _blocksData) external;\n\n    function revertBlocks(uint256 _newLastBlock) external;\n\n    /// @notice Event emitted when a block is committed\n    event BlockCommit(uint256 indexed blockNumber, bytes32 indexed blockHash, bytes32 indexed commitment);\n\n    /// @notice Event emitted when blocks are verified\n    event BlocksVerification(uint256 indexed previousLastVerifiedBlock, uint256 indexed currentLastVerifiedBlock);\n\n    /// @notice Event emitted when a block is executed\n    event BlockExecution(uint256 indexed blockNumber, bytes32 indexed blockHash, bytes32 indexed commitment);\n\n    /// @notice Event emitted when blocks are reverted\n    event BlocksRevert(uint256 totalBlocksCommitted, uint256 totalBlocksVerified, uint256 totalBlocksExecuted);\n}\n"},"cache/solpp-generated-contracts/zksync/Config.sol":{"content":"pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n\n\n/// @dev `keccak256(\"\")`\nbytes32 constant EMPTY_STRING_KECCAK = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n/// @dev Bytes in raw L2 log\n/// @dev Equal to the bytes size of the tuple - (uint8 ShardId, bool isService, uint16 txNumberInBlock, address sender, bytes32 key, bytes32 value)\nuint256 constant L2_TO_L1_LOG_SERIALIZE_SIZE = 88;\n\n/// @dev The maximum length of the bytes array with L2 -> L1 logs\nuint256 constant MAX_L2_TO_L1_LOGS_COMMITMENT_BYTES = 4 + L2_TO_L1_LOG_SERIALIZE_SIZE * 512;\n\n/// @dev L2 -> L1 logs Merkle tree height\nuint256 constant L2_TO_L1_LOG_MERKLE_TREE_HEIGHT = 9;\n\n/// @dev The value of default leaf hash for L2 -> L1 logs Merkle tree\n/// @dev An incomplete fixed-size tree is filled with this value to be a full binary tree\n/// @dev Actually equal to the `keccak256(new bytes(L2_TO_L1_LOG_SERIALIZE_SIZE))`\nbytes32 constant L2_L1_LOGS_TREE_DEFAULT_LEAF_HASH = 0x72abee45b59e344af8a6e520241c4744aff26ed411f4c4b00f8af09adada43ba;\n\n/// @dev Number of bytes in a one initial storage change\n/// @dev Equal to the bytes size of the tuple - (bytes32 key, bytes32 value)\nuint256 constant INITIAL_STORAGE_CHANGE_SERIALIZE_SIZE = 64;\n\n/// @dev The maximum length of the bytes array with initial storage changes\nuint256 constant MAX_INITIAL_STORAGE_CHANGES_COMMITMENT_BYTES = 4 + INITIAL_STORAGE_CHANGE_SERIALIZE_SIZE * 4765;\n\n/// @dev Number of bytes in a one repeated storage change\n/// @dev Equal to the bytes size of the tuple - (bytes8 key, bytes32 value)\nuint256 constant REPEATED_STORAGE_CHANGE_SERIALIZE_SIZE = 40;\n\n/// @dev The maximum length of the bytes array with repeated storage changes\nuint256 constant MAX_REPEATED_STORAGE_CHANGES_COMMITMENT_BYTES = 4 + REPEATED_STORAGE_CHANGE_SERIALIZE_SIZE * 7564;\n\n// TODO: change constant to the real root hash of empty Merkle tree (SMA-184)\nbytes32 constant DEFAULT_L2_LOGS_TREE_ROOT_HASH = bytes32(0);\n\n/// @dev Denotes the first byte of the zkSync transaction that came from L1.\nuint256 constant PRIORITY_OPERATION_L2_TX_TYPE = 255;\n\n/// @dev The amount of time in seconds the validator has to process the priority transaction\n/// NOTE: The constant is set to zero for the Alpha release period\nuint256 constant PRIORITY_EXPIRATION = 0 days;\n\n/// @dev Notice period before activation preparation status of upgrade mode (in seconds)\n/// @dev NOTE: we must reserve for users enough time to send full exit operation, wait maximum time for processing this operation and withdraw funds from it.\nuint256 constant UPGRADE_NOTICE_PERIOD = 0;\n\n/// @dev Timestamp - seconds since unix epoch\nuint256 constant COMMIT_TIMESTAMP_NOT_OLDER = 365 days;\n\n/// @dev Maximum available error between real commit block timestamp and analog used in the verifier (in seconds)\n/// @dev Must be used cause miner's `block.timestamp` value can differ on some small value (as we know - 15 seconds)\nuint256 constant COMMIT_TIMESTAMP_APPROXIMATION_DELTA = 365 days;\n\n/// @dev Bit mask to apply for verifier public input before verifying.\nuint256 constant INPUT_MASK = 452312848583266388373324160190187140051835877600158453279131187530910662655;\n\n/// @dev The maximum number of L2 gas that a user can request for an L2 transaction\nuint256 constant L2_TX_MAX_GAS_LIMIT = 80000000;\n\n/// @dev The maximum number of the pubdata an L2 operation should be allowed to use.\nuint256 constant MAX_PUBDATA_PER_BLOCK = 110000;\n\n/// @dev The maximum number of the pubdata an priority operation should be allowed to use.\n/// For now, it is somewhat lower than the maximum number of pubdata allowed for an L2 transaction,\n/// to ensure that the transaction is definitely processable on L2 despite any potential overhead.\nuint256 constant PRIORITY_TX_MAX_PUBDATA = 99000;\n\n/// @dev The default price per L2 gas to be used for L1->L2 transactions\nuint256 constant FAIR_L2_GAS_PRICE = 500000000;\n\n/// @dev Even though the price for 1 byte of pubdata is 16 L1 gas, we have a slightly increased\n/// value.\nuint256 constant L1_GAS_PER_PUBDATA_BYTE = 17;\n\n/// @dev The computational overhead of processing an L2 block.\nuint256 constant BLOCK_OVERHEAD_L2_GAS = 1200000;\n\n/// @dev The overhead in L1 gas of interacting with the L1\nuint256 constant BLOCK_OVERHEAD_L1_GAS = 1000000;\n\n/// @dev The equivalent in L1 pubdata of L1 gas used for working with L1\nuint256 constant BLOCK_OVERHEAD_PUBDATA = BLOCK_OVERHEAD_L1_GAS / L1_GAS_PER_PUBDATA_BYTE;\n\n/// @dev The maximum number of transactions in L2 block:\nuint256 constant MAX_TRANSACTIONS_IN_BLOCK = 1024;\n\n/// @dev The size of the bootloader memory dedicated to the encodings of transactions\nuint256 constant BOOTLOADER_TX_ENCODING_SPACE = 485225;\n\n/// @dev The intrinsic cost of the L1->l2 transaction in computational L2 gas\nuint256 constant L1_TX_INTRINSIC_L2_GAS = 167157;\n\n/// @dev The intrinsic cost of the L1->l2 transaction in pubdata\nuint256 constant L1_TX_INTRINSIC_PUBDATA = 88;\n\n/// @dev The minimal base price for L1 transaction\nuint256 constant L1_TX_MIN_L2_GAS_BASE = 173484;\n\n/// @dev The number of L2 gas the transaction starts costing more with each 544 bytes of encoding\nuint256 constant L1_TX_DELTA_544_ENCODING_BYTES = 1656;\n\n/// @dev The number of L2 gas an L1->L2 transaction gains with each new factory dependency\nuint256 constant L1_TX_DELTA_FACTORY_DEPS_L2_GAS = 2473;\n\n/// @dev The number of L2 gas an L1->L2 transaction gains with each new factory dependency\nuint256 constant L1_TX_DELTA_FACTORY_DEPS_PUBDATA = 64;\n\n/// @dev The number of pubdata an L1->L2 transaction requires with each new factory dependency\nuint256 constant MAX_NEW_FACTORY_DEPS = 32;\n\n/// @dev The L2 gasPricePerPubdata required to be used in bridges.\nuint256 constant REQUIRED_L2_GAS_PRICE_PER_PUBDATA = 800;\n"},"cache/solpp-generated-contracts/common/L2ContractAddresses.sol":{"content":"pragma solidity ^0.8.0;\n\n// SPDX-License-Identifier: MIT\n\n\n\n/// @dev The address of the L2 deployer system contract.\naddress constant L2_DEPLOYER_SYSTEM_CONTRACT_ADDR = address(0x8006);\n\n/// @dev The special reserved L2 address. It is located in the system contracts space but doesn't have deployed bytecode.\n/// @dev The L2 deployer system contract allows changing bytecodes on any address if the `msg.sender` is this address.\n/// @dev So, whenever the governor wants to redeploy system contracts, it just initiates the L1 upgrade call deployer system contract\n/// via the L1 -> L2 transaction with `sender == L2_FORCE_DEPLOYER_ADDR`. For more details see the `diamond-initializers` contracts.\naddress constant L2_FORCE_DEPLOYER_ADDR = address(0x8007);\n\n/// @dev The address of the special smart contract that can send arbitrary length message as an L2 log\naddress constant L2_TO_L1_MESSENGER_SYSTEM_CONTRACT_ADDR = address(0x8008);\n\n/// @dev The formal address of the initial program of the system: the bootloader\naddress constant L2_BOOTLOADER_ADDRESS = address(0x8001);\n\n/// @dev The address of the eth token system contract\naddress constant L2_ETH_TOKEN_SYSTEM_CONTRACT_ADDR = address(0x800a);\n\n/// @dev The address of the known code storage system contract\naddress constant L2_KNOWN_CODE_STORAGE_SYSTEM_CONTRACT_ADDR = address(0x8004);\n\n/// @dev The address of the context system contract\naddress constant L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR = address(0x800b);\n"},"cache/solpp-generated-contracts/zksync/libraries/TranscriptLib.sol":{"content":"pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n\n\nimport \"./PairingsBn254.sol\";\n\nlibrary TranscriptLib {\n    // flip                    0xe000000000000000000000000000000000000000000000000000000000000000;\n    uint256 constant FR_MASK = 0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    uint32 constant DST_0 = 0;\n    uint32 constant DST_1 = 1;\n    uint32 constant DST_CHALLENGE = 2;\n\n    struct Transcript {\n        bytes32 state_0;\n        bytes32 state_1;\n        uint32 challenge_counter;\n    }\n\n    function new_transcript() internal pure returns (Transcript memory t) {\n        t.state_0 = bytes32(0);\n        t.state_1 = bytes32(0);\n        t.challenge_counter = 0;\n    }\n\n    function update_with_u256(Transcript memory self, uint256 value) internal pure {\n        bytes32 old_state_0 = self.state_0;\n        self.state_0 = keccak256(abi.encodePacked(DST_0, old_state_0, self.state_1, value));\n        self.state_1 = keccak256(abi.encodePacked(DST_1, old_state_0, self.state_1, value));\n    }\n\n    function update_with_fr(Transcript memory self, PairingsBn254.Fr memory value) internal pure {\n        update_with_u256(self, value.value);\n    }\n\n    function update_with_g1(Transcript memory self, PairingsBn254.G1Point memory p) internal pure {\n        update_with_u256(self, p.X);\n        update_with_u256(self, p.Y);\n    }\n\n    function get_challenge(Transcript memory self) internal pure returns (PairingsBn254.Fr memory challenge) {\n        bytes32 query = keccak256(abi.encodePacked(DST_CHALLENGE, self.state_0, self.state_1, self.challenge_counter));\n        self.challenge_counter += 1;\n        challenge = PairingsBn254.Fr({value: uint256(query) & FR_MASK});\n    }\n}\n"},"cache/solpp-generated-contracts/zksync/libraries/PairingsBn254.sol":{"content":"pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n\n\nlibrary PairingsBn254 {\n    uint256 constant q_mod = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\n    uint256 constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    uint256 constant bn254_b_coeff = 3;\n\n    struct G1Point {\n        uint256 X;\n        uint256 Y;\n    }\n\n    struct Fr {\n        uint256 value;\n    }\n\n    function new_fr(uint256 fr) internal pure returns (Fr memory) {\n        require(fr < r_mod);\n        return Fr({value: fr});\n    }\n\n    function copy(Fr memory self) internal pure returns (Fr memory n) {\n        n.value = self.value;\n    }\n\n    function assign(Fr memory self, Fr memory other) internal pure {\n        self.value = other.value;\n    }\n\n    function inverse(Fr memory fr) internal view returns (Fr memory) {\n        require(fr.value != 0);\n        return pow(fr, r_mod - 2);\n    }\n\n    function add_assign(Fr memory self, Fr memory other) internal pure {\n        self.value = addmod(self.value, other.value, r_mod);\n    }\n\n    function sub_assign(Fr memory self, Fr memory other) internal pure {\n        self.value = addmod(self.value, r_mod - other.value, r_mod);\n    }\n\n    function mul_assign(Fr memory self, Fr memory other) internal pure {\n        self.value = mulmod(self.value, other.value, r_mod);\n    }\n\n    function pow(Fr memory self, uint256 power) internal view returns (Fr memory) {\n        uint256[6] memory input = [32, 32, 32, self.value, power, r_mod];\n        uint256[1] memory result;\n        bool success;\n        assembly {\n            success := staticcall(gas(), 0x05, input, 0xc0, result, 0x20)\n        }\n        require(success);\n        return Fr({value: result[0]});\n    }\n\n    // Encoding of field elements is: X[0] * z + X[1]\n    struct G2Point {\n        uint256[2] X;\n        uint256[2] Y;\n    }\n\n    function P1() internal pure returns (G1Point memory) {\n        return G1Point(1, 2);\n    }\n\n    function new_g1(uint256 x, uint256 y) internal pure returns (G1Point memory) {\n        return G1Point(x, y);\n    }\n\n    // function new_g1_checked(uint256 x, uint256 y) internal pure returns (G1Point memory) {\n    function new_g1_checked(uint256 x, uint256 y) internal pure returns (G1Point memory) {\n        if (x == 0 && y == 0) {\n            // point of infinity is (0,0)\n            return G1Point(x, y);\n        }\n\n        // check encoding\n        require(x < q_mod, \"x axis isn't valid\");\n        require(y < q_mod, \"y axis isn't valid\");\n        // check on curve\n        uint256 lhs = mulmod(y, y, q_mod); // y^2\n\n        uint256 rhs = mulmod(x, x, q_mod); // x^2\n        rhs = mulmod(rhs, x, q_mod); // x^3\n        rhs = addmod(rhs, bn254_b_coeff, q_mod); // x^3 + b\n        require(lhs == rhs, \"is not on curve\");\n\n        return G1Point(x, y);\n    }\n\n    function new_g2(uint256[2] memory x, uint256[2] memory y) internal pure returns (G2Point memory) {\n        return G2Point(x, y);\n    }\n\n    function copy_g1(G1Point memory self) internal pure returns (G1Point memory result) {\n        result.X = self.X;\n        result.Y = self.Y;\n    }\n\n    function P2() internal pure returns (G2Point memory) {\n        // for some reason ethereum expects to have c1*v + c0 form\n\n        return\n            G2Point(\n                [\n                    0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\n                    0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed\n                ],\n                [\n                    0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\n                    0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\n                ]\n            );\n    }\n\n    function negate(G1Point memory self) internal pure {\n        // The prime q in the base field F_q for G1\n        if (self.Y == 0) {\n            require(self.X == 0);\n            return;\n        }\n\n        self.Y = q_mod - self.Y;\n    }\n\n    function point_add(G1Point memory p1, G1Point memory p2) internal view returns (G1Point memory r) {\n        point_add_into_dest(p1, p2, r);\n        return r;\n    }\n\n    function point_add_assign(G1Point memory p1, G1Point memory p2) internal view {\n        point_add_into_dest(p1, p2, p1);\n    }\n\n    function point_add_into_dest(\n        G1Point memory p1,\n        G1Point memory p2,\n        G1Point memory dest\n    ) internal view {\n        if (p2.X == 0 && p2.Y == 0) {\n            // we add zero, nothing happens\n            dest.X = p1.X;\n            dest.Y = p1.Y;\n            return;\n        } else if (p1.X == 0 && p1.Y == 0) {\n            // we add into zero, and we add non-zero point\n            dest.X = p2.X;\n            dest.Y = p2.Y;\n            return;\n        } else {\n            uint256[4] memory input;\n\n            input[0] = p1.X;\n            input[1] = p1.Y;\n            input[2] = p2.X;\n            input[3] = p2.Y;\n\n            bool success;\n            assembly {\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\n            }\n            require(success);\n        }\n    }\n\n    function point_sub_assign(G1Point memory p1, G1Point memory p2) internal view {\n        point_sub_into_dest(p1, p2, p1);\n    }\n\n    function point_sub_into_dest(\n        G1Point memory p1,\n        G1Point memory p2,\n        G1Point memory dest\n    ) internal view {\n        if (p2.X == 0 && p2.Y == 0) {\n            // we subtracted zero, nothing happens\n            dest.X = p1.X;\n            dest.Y = p1.Y;\n            return;\n        } else if (p1.X == 0 && p1.Y == 0) {\n            // we subtract from zero, and we subtract non-zero point\n            dest.X = p2.X;\n            dest.Y = q_mod - p2.Y;\n            return;\n        } else {\n            uint256[4] memory input;\n\n            input[0] = p1.X;\n            input[1] = p1.Y;\n            input[2] = p2.X;\n            input[3] = q_mod - p2.Y;\n\n            bool success = false;\n            assembly {\n                success := staticcall(gas(), 6, input, 0x80, dest, 0x40)\n            }\n            require(success);\n        }\n    }\n\n    function point_mul(G1Point memory p, Fr memory s) internal view returns (G1Point memory r) {\n        // https://eips.ethereum.org/EIPS/eip-197\n        // Elliptic curve points are encoded as a Jacobian pair (X, Y) where the point at infinity is encoded as (0, 0)\n        if (p.X == 0 && p.Y == 1) {\n            p.Y = 0;\n        }\n        point_mul_into_dest(p, s, r);\n        return r;\n    }\n\n    function point_mul_assign(G1Point memory p, Fr memory s) internal view {\n        point_mul_into_dest(p, s, p);\n    }\n\n    function point_mul_into_dest(\n        G1Point memory p,\n        Fr memory s,\n        G1Point memory dest\n    ) internal view {\n        uint256[3] memory input;\n        input[0] = p.X;\n        input[1] = p.Y;\n        input[2] = s.value;\n        bool success;\n        assembly {\n            success := staticcall(gas(), 7, input, 0x60, dest, 0x40)\n        }\n        require(success);\n    }\n\n    function pairing(G1Point[] memory p1, G2Point[] memory p2) internal view returns (bool) {\n        require(p1.length == p2.length);\n        uint256 elements = p1.length;\n        uint256 inputSize = elements * 6;\n        uint256[] memory input = new uint256[](inputSize);\n        for (uint256 i = 0; i < elements; ) {\n            input[i * 6 + 0] = p1[i].X;\n            input[i * 6 + 1] = p1[i].Y;\n            input[i * 6 + 2] = p2[i].X[0];\n            input[i * 6 + 3] = p2[i].X[1];\n            input[i * 6 + 4] = p2[i].Y[0];\n            input[i * 6 + 5] = p2[i].Y[1];\n            unchecked {\n                ++i;\n            }\n        }\n        uint256[1] memory out;\n        bool success;\n        assembly {\n            success := staticcall(gas(), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n        }\n        require(success);\n        return out[0] != 0;\n    }\n\n    /// Convenience method for a pairing check for two pairs.\n    function pairingProd2(\n        G1Point memory a1,\n        G2Point memory a2,\n        G1Point memory b1,\n        G2Point memory b2\n    ) internal view returns (bool) {\n        G1Point[] memory p1 = new G1Point[](2);\n        G2Point[] memory p2 = new G2Point[](2);\n        p1[0] = a1;\n        p1[1] = b1;\n        p2[0] = a2;\n        p2[1] = b2;\n        return pairing(p1, p2);\n    }\n}\n"},"cache/solpp-generated-contracts/common/ReentrancyGuard.sol":{"content":"pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\n * metering changes introduced in the Istanbul hardfork.\n */\nabstract contract ReentrancyGuard {\n    /// @dev Address of lock flag variable.\n    /// @dev Flag is placed at random memory location to not interfere with Storage contract.\n    uint256 private constant LOCK_FLAG_ADDRESS = 0x8e94fed44239eb2314ab7a406345e6c5a8f0ccedf3b600de3d004e672c33abf4; // keccak256(\"ReentrancyGuard\") - 1;\n\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/566a774222707e424896c0c390a84dc3c13bdcb2/contracts/security/ReentrancyGuard.sol\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    modifier reentrancyGuardInitializer() {\n        _initializeReentrancyGuard();\n        _;\n    }\n\n    function _initializeReentrancyGuard() private {\n        uint256 lockSlotOldValue;\n\n        // Storing an initial non-zero value makes deployment a bit more\n        // expensive but in exchange every call to nonReentrant\n        // will be cheaper.\n        assembly {\n            lockSlotOldValue := sload(LOCK_FLAG_ADDRESS)\n            sstore(LOCK_FLAG_ADDRESS, _NOT_ENTERED)\n        }\n\n        // Check that storage slot for reentrancy guard is empty to rule out possibility of slot conflict\n        require(lockSlotOldValue == 0, \"1B\");\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        uint256 _status;\n        assembly {\n            _status := sload(LOCK_FLAG_ADDRESS)\n        }\n\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status == _NOT_ENTERED, \"r1\");\n\n        // Any calls to nonReentrant after this point will fail\n        assembly {\n            sstore(LOCK_FLAG_ADDRESS, _ENTERED)\n        }\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        assembly {\n            sstore(LOCK_FLAG_ADDRESS, _NOT_ENTERED)\n        }\n    }\n}\n"},"cache/solpp-generated-contracts/common/AllowListed.sol":{"content":"pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n\n\nimport \"./interfaces/IAllowList.sol\";\n\n/// @author Matter Labs\nabstract contract AllowListed {\n    modifier senderCanCallFunction(IAllowList _allowList) {\n        // Preventing the stack too deep error\n        {\n            require(_allowList.canCall(msg.sender, address(this), msg.sig), \"nr\");\n        }\n        _;\n    }\n}\n"},"cache/solpp-generated-contracts/zksync/facets/Base.sol":{"content":"pragma solidity ^0.8.13;\n\n// SPDX-License-Identifier: MIT\n\n\n\nimport \"../Storage.sol\";\nimport \"../../common/ReentrancyGuard.sol\";\nimport \"../../common/AllowListed.sol\";\n\n/// @title Base contract containing functions accessible to the other facets.\n/// @author Matter Labs\ncontract Base is ReentrancyGuard, AllowListed {\n    AppStorage internal s;\n\n    /// @notice Checks that the message sender is an active governor\n    modifier onlyGovernor() {\n        require(msg.sender == s.governor, \"1g\"); // only by governor\n        _;\n    }\n\n    /// @notice Checks if validator is active\n    modifier onlyValidator() {\n        require(s.validators[msg.sender], \"1h\"); // validator is not active\n        _;\n    }\n\n    modifier onlySecurityCouncil() {\n        require(msg.sender == s.upgrades.securityCouncil, \"a9\"); // not a security council\n        _;\n    }\n}\n"}},"settings":{"libraries":{},"optimizer":{"enabled":true,"runs":200},"outputSelection":{"*":{"*":["evm.bytecode","evm.deployedBytecode","devdoc","userdoc","metadata","abi"]}}}},"ABI":"[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"name\":\"BlockCommit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"name\":\"BlockExecution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBlocksCommitted\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBlocksVerified\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBlocksExecuted\",\"type\":\"uint256\"}],\"name\":\"BlocksRevert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"previousLastVerifiedBlock\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"currentLastVerifiedBlock\",\"type\":\"uint256\"}],\"name\":\"BlocksVerification\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"indexRepeatedStorageChanges\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"numberOfLayer1Txs\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"priorityOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"l2LogsTreeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct IExecutor.StoredBlockInfo\",\"name\":\"_lastCommittedBlockData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"indexRepeatedStorageChanges\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"newStateRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"numberOfLayer1Txs\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"l2LogsTreeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"priorityOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"initialStorageChanges\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"repeatedStorageChanges\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"l2Logs\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"l2ArbitraryLengthMessages\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes[]\",\"name\":\"factoryDeps\",\"type\":\"bytes[]\"}],\"internalType\":\"struct IExecutor.CommitBlockInfo[]\",\"name\":\"_newBlocksData\",\"type\":\"tuple[]\"}],\"name\":\"commitBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"indexRepeatedStorageChanges\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"numberOfLayer1Txs\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"priorityOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"l2LogsTreeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct IExecutor.StoredBlockInfo[]\",\"name\":\"_blocksData\",\"type\":\"tuple[]\"}],\"name\":\"executeBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"indexRepeatedStorageChanges\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"numberOfLayer1Txs\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"priorityOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"l2LogsTreeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct IExecutor.StoredBlockInfo\",\"name\":\"_prevBlock\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"indexRepeatedStorageChanges\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"numberOfLayer1Txs\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"priorityOperationsHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"l2LogsTreeRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"commitment\",\"type\":\"bytes32\"}],\"internalType\":\"struct IExecutor.StoredBlockInfo[]\",\"name\":\"_committedBlocks\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"recursiveAggregationInput\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"serializedProof\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IExecutor.ProofInput\",\"name\":\"_proof\",\"type\":\"tuple\"}],\"name\":\"proveBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLastBlock\",\"type\":\"uint256\"}],\"name\":\"revertBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"ExecutorFacet","CompilerVersion":"v0.8.17+commit.8df45f5f","OptimizationUsed":1,"Runs":200,"ConstructorArguments":"0x","EVMVersion":"Default","Library":"","LicenseType":"","Proxy":0,"SwarmSource":""}]}